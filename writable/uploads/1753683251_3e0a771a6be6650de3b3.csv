  /*!--------------------------------------------------------
  * Copyright (C) Microsoft Corporation. All rights reserved.
  *--------------------------------------------------------*/
 (function () {
    try {
      var e = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
      var n = new e.Error().stack;
      if (n) {
        e._sentryDebugIds = e._sentryDebugIds || {};
        e._sentryDebugIds[n] = "61209153-73c8-5a0b-b208-7e2f4a87ff8d";
      }
    } catch (e) {}
  })();
  function Lf(t, e) {
    Lf = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (i, s) {
      i.__proto__ = s;
    } || function (i, s) {
      for (var r in s) {
        if (Object.prototype.hasOwnProperty.call(s, r)) {
          i[r] = s[r];
        }
      }
    };
    return Lf(t, e);
  }
  export function __extends(t, e) {
    if (typeof e != "function" && e !== null) {
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    }
    Lf(t, e);
    function i() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  }
  export function __assign() {
    __assign = Object.assign || function (e) {
      var i;
      for (var s = 1, r = arguments.length; s < r; s++) {
        i = arguments[s];
        for (var n in i) {
          if (Object.prototype.hasOwnProperty.call(i, n)) {
            e[n] = i[n];
          }
        }
      }
      return e;
    };
    return __assign.apply(this, arguments);
  }
  export function __rest(t, e) {
    var i = {};
    for (var s in t) {
      if (Object.prototype.hasOwnProperty.call(t, s) && e.indexOf(s) < 0) {
        i[s] = t[s];
      }
    }
    if (t != null && typeof Object.getOwnPropertySymbols == "function") {
      for (var r = 0, s = Object.getOwnPropertySymbols(t); r < s.length; r++) {
        if (e.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, s[r])) {
          i[s[r]] = t[s[r]];
        }
      }
    }
    return i;
  }
  export function __decorate(t, e, i, s) {
    var r = arguments.length;
    var n = r < 3 ? e : s === null ? s = Object.getOwnPropertyDescriptor(e, i) : s;
    var o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") {
      n = Reflect.decorate(t, e, i, s);
    } else {
      for (var a = t.length - 1; a >= 0; a--) {
        if (o = t[a]) {
          n = (r < 3 ? o(n) : r > 3 ? o(e, i, n) : o(e, i)) || n;
        }
      }
    }
    if (r > 3 && n) {
      Object.defineProperty(e, i, n);
    }
    return n;
  }
  export function __param(t, e) {
    return function (i, s) {
      e(i, s, t);
    };
  }
  export function __esDecorate(t, e, i, s, r, n) {
    function o(b) {
      if (b !== undefined && typeof b != "function") {
        throw new TypeError("Function expected");
      }
      return b;
    }
    var a = s.kind;
    var c = a === "getter" ? "get" : a === "setter" ? "set" : "value";
    var l = !e && t ? s.static ? t : t.prototype : null;
    var u = e || (l ? Object.getOwnPropertyDescriptor(l, s.name) : {});
    var d;
    var f = false;
    for (var p = i.length - 1; p >= 0; p--) {
      var w = {};
      for (var m in s) {
        w[m] = m === "access" ? {} : s[m];
      }
      for (var m in s.access) {
        w.access[m] = s.access[m];
      }
      w.addInitializer = function (b) {
        if (f) {
          throw new TypeError("Cannot add initializers after decoration has completed");
        }
        n.push(o(b || null));
      };
      var y = (0, i[p])(a === "accessor" ? {
        get: u.get,
        set: u.set
      } : u[c], w);
      if (a === "accessor") {
        if (y === undefined) {
          continue;
        }
        if (y === null || typeof y != "object") {
          throw new TypeError("Object expected");
        }
        if (d = o(y.get)) {
          u.get = d;
        }
        if (d = o(y.set)) {
          u.set = d;
        }
        if (d = o(y.init)) {
          r.unshift(d);
        }
      } else if (d = o(y)) {
        if (a === "field") {
          r.unshift(d);
        } else {
          u[c] = d;
        }
      }
    }
    if (l) {
      Object.defineProperty(l, s.name, u);
    }
    f = true;
  }
  export function __runInitializers(t, e, i) {
    var s = arguments.length > 2;
    for (var r = 0; r < e.length; r++) {
      i = s ? e[r].call(t, i) : e[r].call(t);
    }
    if (s) {
      return i;
    } else {
      return undefined;
    }
  }
  export function __propKey(t) {
    if (typeof t == "symbol") {
      return t;
    } else {
      return `${t}`;
    }
  }
  export function __setFunctionName(t, e, i) {
    if (typeof e == "symbol") {
      e = e.description ? `[${e.description}]` : "";
    }
    return Object.defineProperty(t, "name", {
      configurable: true,
      value: i ? `${i} ${e}` : e
    });
  }
  export function __metadata(t, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function") {
      return Reflect.metadata(t, e);
    }
  }
  export function __awaiter(t, e, i, s) {
    function r(n) {
      if (n instanceof i) {
        return n;
      } else {
        return new i(function (o) {
          o(n);
        });
      }
    }
    return new (i ||= Promise)(function (n, o) {
      function a(u) {
        try {
          l(s.next(u));
        } catch (d) {
          o(d);
        }
      }
      function c(u) {
        try {
          l(s.throw(u));
        } catch (d) {
          o(d);
        }
      }
      function l(u) {
        if (u.done) {
          n(u.value);
        } else {
          r(u.value).then(a, c);
        }
      }
      l((s = s.apply(t, e || [])).next());
    });
  }
  export function __generator(t, e) {
    var i = {
      label: 0,
      sent: function () {
        if (n[0] & 1) {
          throw n[1];
        }
        return n[1];
      },
      trys: [],
      ops: []
    };
    var s;
    var r;
    var n;
    var o;
    o = {
      next: a(0),
      throw: a(1),
      return: a(2)
    };
    if (typeof Symbol == "function") {
      o[Symbol.iterator] = function () {
        return this;
      };
    }
    return o;
    function a(l) {
      return function (u) {
        return c([l, u]);
      };
    }
    function c(l) {
      if (s) {
        throw new TypeError("Generator is already executing.");
      }
      while (o && (o = 0, l[0] && (i = 0)), i) {
        try {
          s = 1;
          if (r && (n = l[0] & 2 ? r.return : l[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, l[1])).done) {
            return n;
          }
          r = 0;
          if (n) {
            l = [l[0] & 2, n.value];
          }
          switch (l[0]) {
            case 0:
            case 1:
              n = l;
              break;
            case 4:
              i.label++;
              return {
                value: l[1],
                done: false
              };
            case 5:
              i.label++;
              r = l[1];
              l = [0];
              continue;
            case 7:
              l = i.ops.pop();
              i.trys.pop();
              continue;
            default:
              n = i.trys;
              if (!(n = n.length > 0 && n[n.length - 1]) && (l[0] === 6 || l[0] === 2)) {
                i = 0;
                continue;
              }
              if (l[0] === 3 && (!n || l[1] > n[0] && l[1] < n[3])) {
                i.label = l[1];
                break;
              }
              if (l[0] === 6 && i.label < n[1]) {
                i.label = n[1];
                n = l;
                break;
              }
              if (n && i.label < n[2]) {
                i.label = n[2];
                i.ops.push(l);
                break;
              }
              if (n[2]) {
                i.ops.pop();
              }
              i.trys.pop();
              continue;
          }
          l = e.call(t, i);
        } catch (u) {
          l = [6, u];
          r = 0;
        } finally {
          s = n = 0;
        }
      }
      if (l[0] & 5) {
        throw l[1];
      }
      return {
        value: l[0] ? l[1] : undefined,
        done: true
      };
    }
  }
  export var __createBinding = Object.create ? function (t, e, i, s = i) {
    var r = Object.getOwnPropertyDescriptor(e, i);
    if (!r || ("get" in r ? !e.__esModule : r.writable || r.configurable)) {
      r = {
        enumerable: true,
        get: function () {
          return e[i];
        }
      };
    }
    Object.defineProperty(t, s, r);
  } : function (t, e, i, s = i) {
    t[s] = e[i];
  };
  export function __exportStar(t, e) {
    for (var i in t) {
      if (i !== "default" && !Object.prototype.hasOwnProperty.call(e, i)) {
        __createBinding(e, t, i);
      }
    }
  }
  export function __values(t) {
    var e = typeof Symbol == "function" && Symbol.iterator;
    var i = e && t[e];
    var s = 0;
    if (i) {
      return i.call(t);
    }
    if (t && typeof t.length == "number") {
      return {
        next: function () {
          if (t && s >= t.length) {
            t = undefined;
          }
          return {
            value: t && t[s++],
            done: !t
          };
        }
      };
    }
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  export function __read(t, e) {
    var i = typeof Symbol == "function" && t[Symbol.iterator];
    if (!i) {
      return t;
    }
    var s = i.call(t);
    var r;
    var n = [];
    var o;
    try {
      while ((e === undefined || e-- > 0) && !(r = s.next()).done) {
        n.push(r.value);
      }
    } catch (a) {
      o = {
        error: a
      };
    } finally {
      try {
        if (r && !r.done && (i = s.return)) {
          i.call(s);
        }
      } finally {
        if (o) {
          throw o.error;
        }
      }
    }
    return n;
  }
  export function __spread() {
    var t = [];
    for (var e = 0; e < arguments.length; e++) {
      t = t.concat(__read(arguments[e]));
    }
    return t;
  }
  export function __spreadArrays() {
    var t = 0;
    for (var e = 0, i = arguments.length; e < i; e++) {
      t += arguments[e].length;
    }
    var s = Array(t);
    var r = 0;
    for (var e = 0; e < i; e++) {
      var n = arguments[e];
      for (var o = 0, a = n.length; o < a; o++, r++) {
        s[r] = n[o];
      }
    }
    return s;
  }
  export function __spreadArray(t, e, i) {
    if (i || arguments.length === 2) {
      for (var s = 0, r = e.length, n; s < r; s++) {
        if (n || !(s in e)) {
          n ||= Array.prototype.slice.call(e, 0, s);
          n[s] = e[s];
        }
      }
    }
    return t.concat(n || Array.prototype.slice.call(e));
  }
  export function __await(t) {
    if (this instanceof __await) {
      this.v = t;
      return this;
    } else {
      return new __await(t);
    }
  }
  export function __asyncGenerator(t, e, i) {
    if (!Symbol.asyncIterator) {
      throw new TypeError("Symbol.asyncIterator is not defined.");
    }
    var s = i.apply(t, e || []);
    var r;
    var n = [];
    r = {};
    a("next");
    a("throw");
    a("return", o);
    r[Symbol.asyncIterator] = function () {
      return this;
    };
    return r;
    function o(p) {
      return function (w) {
        return Promise.resolve(w).then(p, d);
      };
    }
    function a(p, w) {
      if (s[p]) {
        r[p] = function (m) {
          return new Promise(function (y, b) {
            if (!(n.push([p, m, y, b]) > 1)) {
              c(p, m);
            }
          });
        };
        if (w) {
          r[p] = w(r[p]);
        }
      }
    }
    function c(p, w) {
      try {
        l(s[p](w));
      } catch (m) {
        f(n[0][3], m);
      }
    }
    function l(p) {
      if (p.value instanceof __await) {
        Promise.resolve(p.value.v).then(u, d);
      } else {
        f(n[0][2], p);
      }
    }
    function u(p) {
      c("next", p);
    }
    function d(p) {
      c("throw", p);
    }
    function f(p, w) {
      p(w);
      n.shift();
      if (n.length) {
        c(n[0][0], n[0][1]);
      }
    }
  }
  export function __asyncDelegator(t) {
    var e;
    var i;
    e = {};
    s("next");
    s("throw", function (r) {
      throw r;
    });
    s("return");
    e[Symbol.iterator] = function () {
      return this;
    };
    return e;
    function s(r, n) {
      e[r] = t[r] ? function (o) {
        if (i = !i) {
          return {
            value: __await(t[r](o)),
            done: false
          };
        } else if (n) {
          return n(o);
        } else {
          return o;
        }
      } : n;
    }
  }
  export function __asyncValues(t) {
    if (!Symbol.asyncIterator) {
      throw new TypeError("Symbol.asyncIterator is not defined.");
    }
    var e = t[Symbol.asyncIterator];
    var i;
    if (e) {
      return e.call(t);
    } else {
      t = typeof __values == "function" ? __values(t) : t[Symbol.iterator]();
      i = {};
      s("next");
      s("throw");
      s("return");
      i[Symbol.asyncIterator] = function () {
        return this;
      };
      return i;
    }
    function s(n) {
      i[n] = t[n] && function (o) {
        return new Promise(function (a, c) {
          o = t[n](o);
          r(a, c, o.done, o.value);
        });
      };
    }
    function r(n, o, a, c) {
      Promise.resolve(c).then(function (l) {
        n({
          value: l,
          done: a
        });
      }, o);
    }
  }
  export function __makeTemplateObject(t, e) {
    if (Object.defineProperty) {
      Object.defineProperty(t, "raw", {
        value: e
      });
    } else {
      t.raw = e;
    }
    return t;
  }
  var mS = Object.create ? function (t, e) {
    Object.defineProperty(t, "default", {
      enumerable: true,
      value: e
    });
  } : function (t, e) {
    t.default = e;
  };
  export function __importStar(t) {
    if (t && t.__esModule) {
      return t;
    }
    var e = {};
    if (t != null) {
      for (var i in t) {
        if (i !== "default" && Object.prototype.hasOwnProperty.call(t, i)) {
          __createBinding(e, t, i);
        }
      }
    }
    mS(e, t);
    return e;
  }
  export function __importDefault(t) {
    if (t && t.__esModule) {
      return t;
    } else {
      return {
        default: t
      };
    }
  }
  export function __classPrivateFieldGet(t, e, i, s) {
    if (i === "a" && !s) {
      throw new TypeError("Private accessor was defined without a getter");
    }
    if (typeof e == "function" ? t !== e || !s : !e.has(t)) {
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    }
    if (i === "m") {
      return s;
    } else if (i === "a") {
      return s.call(t);
    } else if (s) {
      return s.value;
    } else {
      return e.get(t);
    }
  }
  export function __classPrivateFieldSet(t, e, i, s, r) {
    if (s === "m") {
      throw new TypeError("Private method is not writable");
    }
    if (s === "a" && !r) {
      throw new TypeError("Private accessor was defined without a setter");
    }
    if (typeof e == "function" ? t !== e || !r : !e.has(t)) {
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    }
    if (s === "a") {
      r.call(t, i);
    } else if (r) {
      r.value = i;
    } else {
      e.set(t, i);
    }
    return i;
  }
  export function __classPrivateFieldIn(t, e) {
    if (e === null || typeof e != "object" && typeof e != "function") {
      throw new TypeError("Cannot use 'in' operator on non-object");
    }
    if (typeof t == "function") {
      return e === t;
    } else {
      return t.has(e);
    }
  }
  export function __addDisposableResource(t, e, i) {
    if (e != null) {
      if (typeof e != "object" && typeof e != "function") {
        throw new TypeError("Object expected.");
      }
      var s;
      var r;
      if (i) {
        if (!Symbol.asyncDispose) {
          throw new TypeError("Symbol.asyncDispose is not defined.");
        }
        s = e[Symbol.asyncDispose];
      }
      if (s === undefined) {
        if (!Symbol.dispose) {
          throw new TypeError("Symbol.dispose is not defined.");
        }
        s = e[Symbol.dispose];
        if (i) {
          r = s;
        }
      }
      if (typeof s != "function") {
        throw new TypeError("Object not disposable.");
      }
      if (r) {
        s = function () {
          try {
            r.call(this);
          } catch (n) {
            return Promise.reject(n);
          }
        };
      }
      t.stack.push({
        value: e,
        dispose: s,
        async: i
      });
    } else if (i) {
      t.stack.push({
        async: true
      });
    }
    return e;
  }
  var wS = typeof SuppressedError == "function" ? SuppressedError : function (t, e, i) {
    var s = new Error(i);
    s.name = "SuppressedError";
    s.error = t;
    s.suppressed = e;
    return s;
  };
  export function __disposeResources(t) {
    function e(s) {
      t.error = t.hasError ? new wS(s, t.error, "An error was suppressed during disposal.") : s;
      t.hasError = true;
    }
    function i() {
      while (t.stack.length) {
        var s = t.stack.pop();
        try {
          var r = s.dispose && s.dispose.call(s.value);
          if (s.async) {
            return Promise.resolve(r).then(i, function (n) {
              e(n);
              return i();
            });
          }
        } catch (n) {
          e(n);
        }
      }
      if (t.hasError) {
        throw t.error;
      }
    }
    return i();
  }
  export default {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __createBinding,
    __exportStar,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources
  };
  var vS = Object.create;
  var _0 = Object.defineProperty;
  var bS = Object.getOwnPropertyDescriptor;
  var Mf = Object.getOwnPropertyNames;
  var yS = Object.getPrototypeOf;
  var SS = Object.prototype.hasOwnProperty;
  var g = (t, e) => function () {
    if (t) {
      e = (0, t[Mf(t)[0]])(t = 0);
    }
    return e;
  };
  var ES = (t, e) => function () {
    if (!e) {
      (0, t[Mf(t)[0]])((e = {
        exports: {}
      }).exports, e);
    }
    return e.exports;
  };
  var kS = (t, e, i, s) => {
    if (e && typeof e == "object" || typeof e == "function") {
      for (let r of Mf(e)) {
        if (!SS.call(t, r) && r !== i) {
          _0(t, r, {
            get: () => e[r],
            enumerable: !(s = bS(e, r)) || s.enumerable
          });
        }
      }
    }
    return t;
  };
  var R0 = (t, e, i) => {
    i = t != null ? vS(yS(t)) : {};
    return kS(e || !t || !t.__esModule ? _0(i, "default", {
      value: t,
      enumerable: true
    }) : i, t);
  };
  function Ff(t) {
    const e = [];
    if (typeof t == "number") {
      e.push("code/timeOrigin", t);
    }
    function i(r, n) {
      e.push(r, n?.startTime ?? Date.now());
    }
    function s() {
      const r = [];
      for (let n = 0; n < e.length; n += 2) {
        r.push({
          name: e[n],
          startTime: e[n + 1]
        });
      }
      return r;
    }
    return {
      mark: i,
      getMarks: s
    };
  }
  function xS() {
    if (typeof performance == "object" && typeof performance.mark == "function" && !performance.nodeTiming) {
      if (typeof performance.timeOrigin != "number" && !performance.timing) {
        return Ff();
      } else {
        return {
          mark(t, e) {
            performance.mark(t, e);
          },
          getMarks() {
            let t = performance.timeOrigin;
            if (typeof t != "number") {
              t = performance.timing.navigationStart || performance.timing.redirectStart || performance.timing.fetchStart;
            }
            const e = [{
              name: "code/timeOrigin",
              startTime: Math.round(t)
            }];
            for (const i of performance.getEntriesByType("mark")) {
              e.push({
                name: i.name,
                startTime: Math.round(t + i.startTime)
              });
            }
            return e;
          }
        };
      }
    }
    if (typeof process == "object") {
      const t = performance?.timeOrigin;
      return Ff(t);
    } else {
      console.trace("perf-util loaded in UNKNOWN environment");
      return Ff();
    }
  }
  function DS(t) {
    t.MonacoPerformanceMarks ||= xS();
    return t.MonacoPerformanceMarks;
  }
  var Nf;
  var Ne;
  var Wf;
  var Hs = g({
    "out-build/vs/base/common/performance.js"() {
      "use strict";
  
      Nf = DS(globalThis);
      Ne = Nf.mark;
      Wf = Nf.getMarks;
    }
  });
  var O0 = ES({
    "node_modules/minimist/index.js"(t, e) {
      e.exports = function (n, o) {
        o ||= {};
        var a = {
          bools: {},
          strings: {},
          unknownFn: null
        };
        if (typeof o.unknown == "function") {
          a.unknownFn = o.unknown;
        }
        if (typeof o.boolean == "boolean" && o.boolean) {
          a.allBools = true;
        } else {
          [].concat(o.boolean).filter(Boolean).forEach(function (W) {
            a.bools[W] = true;
          });
        }
        var c = {};
        Object.keys(o.alias || {}).forEach(function (W) {
          c[W] = [].concat(o.alias[W]);
          c[W].forEach(function (Ee) {
            c[Ee] = [W].concat(c[W].filter(function (Ye) {
              return Ee !== Ye;
            }));
          });
        });
        [].concat(o.string).filter(Boolean).forEach(function (W) {
          a.strings[W] = true;
          if (c[W]) {
            a.strings[c[W]] = true;
          }
        });
        var l = o.default || {};
        var u = {
          _: []
        };
        Object.keys(a.bools).forEach(function (W) {
          p(W, l[W] === undefined ? false : l[W]);
        });
        var d = [];
        if (n.indexOf("--") !== -1) {
          d = n.slice(n.indexOf("--") + 1);
          n = n.slice(0, n.indexOf("--"));
        }
        function f(W, Ee) {
          return a.allBools && /^--[^=]+$/.test(Ee) || a.strings[W] || a.bools[W] || c[W];
        }
        function p(W, Ee, Ye) {
          if (!Ye || !a.unknownFn || !!f(W, Ye) || a.unknownFn(Ye) !== false) {
            var re = !a.strings[W] && s(Ee) ? Number(Ee) : Ee;
            w(u, W.split("."), re);
            (c[W] || []).forEach(function (St) {
              w(u, St.split("."), re);
            });
          }
        }
        function w(W, Ee, Ye) {
          var re = W;
          for (var St = 0; St < Ee.length - 1; St++) {
            var L = Ee[St];
            if (r(re, L)) {
              return;
            }
            if (re[L] === undefined) {
              re[L] = {};
            }
            if (re[L] === Object.prototype || re[L] === Number.prototype || re[L] === String.prototype) {
              re[L] = {};
            }
            if (re[L] === Array.prototype) {
              re[L] = [];
            }
            re = re[L];
          }
          var L = Ee[Ee.length - 1];
          if (!r(re, L)) {
            if (re === Object.prototype || re === Number.prototype || re === String.prototype) {
              re = {};
            }
            if (re === Array.prototype) {
              re = [];
            }
            if (re[L] === undefined || a.bools[L] || typeof re[L] == "boolean") {
              re[L] = Ye;
            } else if (Array.isArray(re[L])) {
              re[L].push(Ye);
            } else {
              re[L] = [re[L], Ye];
            }
          }
        }
        function m(W) {
          return c[W].some(function (Ee) {
            return a.bools[Ee];
          });
        }
        for (var y = 0; y < n.length; y++) {
          var b = n[y];
          if (/^--.+=/.test(b)) {
            var k = b.match(/^--([^=]+)=([\s\S]*)$/);
            var A = k[1];
            var C = k[2];
            if (a.bools[A]) {
              C = C !== "false";
            }
            p(A, C, b);
          } else if (/^--no-.+/.test(b)) {
            var A = b.match(/^--no-(.+)/)[1];
            p(A, false, b);
          } else if (/^--.+/.test(b)) {
            var A = b.match(/^--(.+)/)[1];
            var _ = n[y + 1];
            if (_ !== undefined && !/^-/.test(_) && !a.bools[A] && !a.allBools && (!c[A] || !m(A))) {
              p(A, _, b);
              y++;
            } else if (/^(true|false)$/.test(_)) {
              p(A, _ === "true", b);
              y++;
            } else {
              p(A, a.strings[A] ? "" : true, b);
            }
          } else if (/^-[^-]+/.test(b)) {
            for (var Z = b.slice(1, -1).split(""), ie = false, me = 0; me < Z.length; me++) {
              var _ = b.slice(me + 2);
              if (_ === "-") {
                p(Z[me], _, b);
                continue;
              }
              if (/[A-Za-z]/.test(Z[me]) && /=/.test(_)) {
                p(Z[me], _.split("=")[1], b);
                ie = true;
                break;
              }
              if (/[A-Za-z]/.test(Z[me]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(_)) {
                p(Z[me], _, b);
                ie = true;
                break;
              }
              if (Z[me + 1] && Z[me + 1].match(/\W/)) {
                p(Z[me], b.slice(me + 2), b);
                ie = true;
                break;
              } else {
                p(Z[me], a.strings[Z[me]] ? "" : true, b);
              }
            }
            var A = b.slice(-1)[0];
            if (!ie && A !== "-") {
              if (n[y + 1] && !/^(-|--)[^-]/.test(n[y + 1]) && !a.bools[A] && (!c[A] || !m(A))) {
                p(A, n[y + 1], b);
                y++;
              } else if (n[y + 1] && /^(true|false)$/.test(n[y + 1])) {
                p(A, n[y + 1] === "true", b);
                y++;
              } else {
                p(A, a.strings[A] ? "" : true, b);
              }
            }
          } else {
            if (!a.unknownFn || a.unknownFn(b) !== false) {
              u._.push(a.strings._ || !s(b) ? b : Number(b));
            }
            if (o.stopEarly) {
              u._.push.apply(u._, n.slice(y + 1));
              break;
            }
          }
        }
        Object.keys(l).forEach(function (W) {
          if (!i(u, W.split("."))) {
            w(u, W.split("."), l[W]);
            (c[W] || []).forEach(function (Ee) {
              w(u, Ee.split("."), l[W]);
            });
          }
        });
        if (o["--"]) {
          u["--"] = new Array();
          d.forEach(function (W) {
            u["--"].push(W);
          });
        } else {
          d.forEach(function (W) {
            u._.push(W);
          });
        }
        return u;
      };
      function i(n, o) {
        var a = n;
        o.slice(0, -1).forEach(function (l) {
          a = a[l] || {};
        });
        var c = o[o.length - 1];
        return c in a;
      }
      function s(n) {
        if (typeof n == "number" || /^0x[0-9a-f]+$/i.test(n)) {
          return true;
        } else {
          return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(n);
        }
      }
      function r(n, o) {
        return o === "constructor" && typeof n[o] == "function" || o === "__proto__";
      }
    }
  });
  function PS(t) {
    return t.replace(M0, function (e, i, s, r, n, o) {
      if (r) {
        return "";
      }
      if (n) {
        const a = n.length;
        if (n[a - 1] === `
  `) {
          if (n[a - 2] === "\r") {
            return `\r
  `;
          } else {
            return `
  `;
          }
        } else {
          return "";
        }
      } else if (o) {
        return e.substring(1);
      } else {
        return e;
      }
    });
  }
  function L0(t) {
    const e = PS(t);
    try {
      return JSON.parse(e);
    } catch {
      const s = e.replace(/,\s*([}\]])/g, "$1");
      return JSON.parse(s);
    }
  }
  var M0;
  var F0 = g({
    "out-build/vs/base/common/jsonc.js"() {
      "use strict";
  
      M0 = /("[^"\\]*(?:\\.[^"\\]*)*")|('[^'\\]*(?:\\.[^'\\]*)*')|(\/\*[^\/\*]*(?:(?:\*|\/)[^\/\*]*)*?\*\/)|(\/{2,}.*?(?:(?:\r?\n)|$))|(,\s*[}\]])/g;
    }
  });
  import * as N0 from "os";
  import * as dr from "path";
  function W0(t, e) {
    const i = $S(t, e);
    const s = [i];
    if (!dr.isAbsolute(i)) {
      s.unshift(T0);
    }
    return dr.resolve(...s);
  }
  function $S(t, e) {
    if (process.env.VSCODE_DEV) {
      e = "code-oss-dev";
    }
    const i = process.env.VSCODE_PORTABLE;
    if (i) {
      return dr.join(i, "user-data");
    }
    let s = process.env.VSCODE_APPDATA;
    if (s) {
      return dr.join(s, e);
    }
    const r = t["user-data-dir"];
    if (r) {
      return r;
    }
    switch (process.platform) {
      case "win32":
        s = process.env.APPDATA;
        if (!s) {
          const n = process.env.USERPROFILE;
          if (typeof n != "string") {
            throw new Error("Windows: Unexpected undefined %USERPROFILE% environment variable");
          }
          s = dr.join(n, "AppData", "Roaming");
        }
        break;
      case "darwin":
        s = dr.join(N0.homedir(), "Library", "Application Support");
        break;
      case "linux":
        s = process.env.XDG_CONFIG_HOME || dr.join(N0.homedir(), ".config");
        break;
      default:
        throw new Error("Platform not supported");
    }
    return dr.join(s, e);
  }
  var T0;
  var j0 = g({
    "out-build/vs/platform/environment/node/userDataPath.js"() {
      "use strict";
  
      T0 = process.env.VSCODE_CWD || process.cwd();
    }
  });
  function IS() {
    const t = U0();
    if (t) {
      return Array.from(t);
    } else {
      return [];
    }
  }
  function U0() {
    return process.uncHostAllowlist;
  }
  function ma(t) {
    if (process.platform !== "win32") {
      return;
    }
    const e = U0();
    if (e) {
      if (typeof t == "string") {
        e.add(t.toLowerCase());
      } else {
        for (const i of AS(t)) {
          ma(i);
        }
      }
    }
  }
  function AS(t) {
    const e = new Set();
    if (Array.isArray(t)) {
      for (const i of t) {
        if (typeof i == "string") {
          e.add(i);
        }
      }
    }
    return Array.from(e);
  }
  function B0(t) {
    if (typeof t != "string") {
      return;
    }
    const e = ["\\\\.\\UNC\\", "\\\\?\\UNC\\", "\\\\"];
    let i;
    for (const s of e) {
      if (t.indexOf(s) !== 0) {
        continue;
      }
      const n = t.indexOf("\\", s.length);
      if (n === -1) {
        continue;
      }
      const o = t.substring(s.length, n);
      if (o) {
        i = o;
        break;
      }
    }
    return i;
  }
  function CS() {
    if (process.platform === "win32") {
      process.restrictUNCAccess = false;
    }
  }
  function _S() {
    if (process.platform !== "win32") {
      return true;
    } else {
      return process.restrictUNCAccess === false;
    }
  }
  var wa = g({
    "out-build/vs/base/node/unc.js"() {
      "use strict";
    }
  });
  function qt() {
    return globalThis._CURSOR_SENTRY;
  }
  function RS() {
    return {
      send: function (e) {
        const i = qt().buffer;
        if (i.length < 64) {
          i.push(e);
        }
        return Promise.resolve({
          statusCode: 200
        });
      },
      flush: function (e) {
        return Promise.resolve(true);
      }
    };
  }
  function OS() {
    return {
      send: function (t) {
        if (qt().enabled) {
          return qt().transport.send(t);
        } else {
          return Promise.resolve({
            statusCode: 200
          });
        }
      },
      flush: function (t) {
        return qt().transport.flush(t);
      }
    };
  }
  function LS() {
    return function (t) {
      if (t.attributes?.["sentry.sample_rate"] === undefined) {
        return 0;
      } else {
        return 1;
      }
    };
  }
  function MS() {
    return {
      defaultIntegrations: [],
      dsn: q0,
      parentSpanIsAlwaysRootSpan: true,
      tracesSampler: LS(),
      transport: OS
    };
  }
  var q0;
  var va = g({
    "out-build/vs/platform/tracing/common/global.js"() {
      "use strict";
  
      q0 = "https://80ec2259ebfad12d8aa2afe6eb4f6dd5@metrics.cursor.sh/4508016051945472";
      if (globalThis._CURSOR_SENTRY === undefined) {
        globalThis._CURSOR_SENTRY = {
          buffer: [],
          enabled: true,
          loggerSampleRate: 1,
          sentry: undefined,
          tracesSampleRate: 0.01,
          profilesSampleRate: 0,
          jsonStringifySampleRate: 0,
          transport: RS()
        };
      }
    }
  });
  function Tf() {
    return globalThis._VSCODE_NLS_MESSAGES;
  }
  function Ll() {
    return globalThis._VSCODE_NLS_LANGUAGE;
  }
  var z0 = g({
    "out-build/vs/nls.messages.js"() {
      "use strict";
    }
  });
  function Ml(t, e) {
    let i;
    if (e.length === 0) {
      i = t;
    } else {
      i = t.replace(/\{(\d+)\}/g, (s, r) => {
        const n = r[0];
        const o = e[n];
        let a = s;
        if (typeof o == "string") {
          a = o;
        } else if (typeof o == "number" || typeof o == "boolean" || o === undefined || o === null) {
          a = String(o);
        }
        return a;
      });
    }
    if (G0) {
      i = "［" + i.replace(/[aouei]/g, "$&$&") + "］";
    }
    return i;
  }
  function v(t, e, ...i) {
    return Ml(typeof t == "number" ? H0(t, e) : e, i);
  }
  function H0(t, e) {
    const i = Tf()?.[t];
    if (typeof i != "string") {
      if (typeof e == "string") {
        return e;
      }
      throw new Error(`!!! NLS MISSING: ${t} !!!`);
    }
    return i;
  }
  function V0(t, e, ...i) {
    let s;
    if (typeof t == "number") {
      s = H0(t, e);
    } else {
      s = e;
    }
    const r = Ml(s, i);
    return {
      value: r,
      original: e === s ? r : Ml(e, i)
    };
  }
  var G0;
  var be = g({
    "out-build/vs/nls.js"() {
      "use strict";
  
      z0();
      z0();
      G0 = Ll() === "pseudo" || typeof document !== "undefined" && document.location && typeof document.location.hash == "string" && document.location.hash.indexOf("pseudo=true") >= 0;
    }
  });
  function J0(t) {
    switch (t) {
      case 0:
        return "Web";
      case 1:
        return "Mac";
      case 2:
        return "Linux";
      case 3:
        return "Windows";
    }
  }
  function FS(t) {
    return parseFloat(t) >= 20;
  }
  var Hr;
  var Hn;
  var Vn;
  var Gn;
  var jf;
  var Uf;
  var Fl;
  var K0;
  var Bf;
  var qf;
  var Z0;
  var ba;
  var ya;
  var zf;
  var Hf;
  var ws;
  var vs;
  var Xt;
  var Vf;
  var Y0;
  var X0;
  var Sa;
  var j;
  var N;
  var Se;
  var Gf;
  var Jf;
  var fr;
  var Q0;
  var ew;
  var tw;
  var Ea;
  var is;
  var Hi;
  var iw;
  var Kf;
  var sw;
  var rw;
  var nw;
  var Wi;
  var Zf;
  var ow;
  var aw;
  var cw;
  var NS;
  var WS;
  var TS;
  var H = g({
    "out-build/vs/base/common/platform.js"() {
      "use strict";
  
      be();
      Hr = "en";
      Hn = false;
      Vn = false;
      Gn = false;
      jf = false;
      Uf = false;
      Fl = false;
      K0 = false;
      Bf = false;
      qf = false;
      Z0 = false;
      ba = undefined;
      ya = Hr;
      zf = Hr;
      Hf = undefined;
      ws = undefined;
      vs = globalThis;
      Xt = undefined;
      if (typeof vs.vscode !== "undefined" && typeof vs.vscode.process !== "undefined") {
        Xt = vs.vscode.process;
      } else if (typeof process !== "undefined" && typeof process?.versions?.node == "string") {
        Xt = process;
      }
      Vf = typeof Xt?.versions?.electron == "string";
      Y0 = Vf && Xt?.type === "renderer";
      if (typeof Xt == "object") {
        Hn = Xt.platform === "win32";
        Vn = Xt.platform === "darwin";
        Gn = Xt.platform === "linux";
        jf = Gn && !!Xt.env.SNAP && !!Xt.env.SNAP_REVISION;
        K0 = Vf;
        qf = !!Xt.env.CI || !!Xt.env.BUILD_ARTIFACTSTAGINGDIRECTORY;
        ba = Hr;
        ya = Hr;
        const t = Xt.env.VSCODE_NLS_CONFIG;
        if (t) {
          try {
            const e = JSON.parse(t);
            ba = e.userLocale;
            zf = e.osLocale;
            ya = e.resolvedLanguage || Hr;
            Hf = e.languagePack?.translationsConfigFile;
          } catch {}
        }
        Uf = true;
      } else if (typeof navigator == "object" && !Y0) {
        ws = navigator.userAgent;
        Hn = ws.indexOf("Windows") >= 0;
        Vn = ws.indexOf("Macintosh") >= 0;
        Bf = (ws.indexOf("Macintosh") >= 0 || ws.indexOf("iPad") >= 0 || ws.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
        Gn = ws.indexOf("Linux") >= 0;
        Z0 = ws?.indexOf("Mobi") >= 0;
        Fl = true;
        ya = Ll() || Hr;
        ba = navigator.language.toLowerCase();
        zf = ba;
      } else {
        console.error("Unable to resolve platform.");
      }
      (function (t) {
        t[t.Web = 0] = "Web";
        t[t.Mac = 1] = "Mac";
        t[t.Linux = 2] = "Linux";
        t[t.Windows = 3] = "Windows";
      })(X0 ||= {});
      Sa = 0;
      if (Vn) {
        Sa = 1;
      } else if (Hn) {
        Sa = 3;
      } else if (Gn) {
        Sa = 2;
      }
      j = Hn;
      N = Vn;
      Se = Gn;
      Gf = jf;
      Jf = Uf;
      fr = Fl;
      Q0 = Fl && typeof vs.importScripts == "function";
      ew = Q0 ? vs.origin : undefined;
      tw = qf;
      Ea = Sa;
      is = ws;
      Hi = ya;
      (function (t) {
        function e() {
          return Hi;
        }
        t.value = e;
        function i() {
          if (Hi.length === 2) {
            return Hi === "en";
          } else if (Hi.length >= 3) {
            return Hi[0] === "e" && Hi[1] === "n" && Hi[2] === "-";
          } else {
            return false;
          }
        }
        t.isDefaultVariant = i;
        function s() {
          return Hi === "en";
        }
        t.isDefault = s;
      })(iw ||= {});
      Kf = Hf;
      sw = typeof vs.postMessage == "function" && !vs.importScripts;
      rw = (() => {
        if (sw) {
          const t = [];
          vs.addEventListener("message", i => {
            if (i.data && i.data.vscodeScheduleAsyncWork) {
              for (let s = 0, r = t.length; s < r; s++) {
                const n = t[s];
                if (n.id === i.data.vscodeScheduleAsyncWork) {
                  t.splice(s, 1);
                  n.callback();
                  return;
                }
              }
            }
          });
          let e = 0;
          return i => {
            const s = ++e;
            t.push({
              id: s,
              callback: i
            });
            vs.postMessage({
              vscodeScheduleAsyncWork: s
            }, "*");
          };
        }
        return t => setTimeout(t);
      })();
      (function (t) {
        t[t.Windows = 1] = "Windows";
        t[t.Macintosh = 2] = "Macintosh";
        t[t.Linux = 3] = "Linux";
      })(nw ||= {});
      Wi = Vn || Bf ? 2 : Hn ? 1 : 3;
      Zf = !!is && !!(is.indexOf("Chrome") >= 0);
      ow = !!is && !!(is.indexOf("Firefox") >= 0);
      aw = !Zf && !!is && !!(is.indexOf("Safari") >= 0);
      cw = !!is && !!(is.indexOf("Edg/") >= 0);
      NS = !!is && !!(is.indexOf("Android") >= 0);
      WS = Xt?.arch;
      TS = Xt?.platform;
    }
  });
  function jS(t, e, i = 0, s = t.length) {
    let r = i;
    let n = s;
    while (r < n) {
      const o = Math.floor((r + n) / 2);
      if (e(t[o])) {
        r = o + 1;
      } else {
        n = o;
      }
    }
    return r - 1;
  }
  function US(t, e, i = 0, s = t.length) {
    let r = i;
    let n = s;
    while (r < n) {
      const o = Math.floor((r + n) / 2);
      if (e(t[o])) {
        n = o;
      } else {
        r = o + 1;
      }
    }
    return r;
  }
  var BS;
  var qS = g({
    "out-build/vs/base/common/arraysFind.js"() {
      "use strict";
  
      BS = class R3 {
        static {
          this.assertInvariants = false;
        }
        constructor(e) {
          this.e = e;
          this.c = 0;
        }
        findLastMonotonous(e) {
          if (R3.assertInvariants) {
            if (this.d) {
              for (const s of this.e) {
                if (this.d(s) && !e(s)) {
                  throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
                }
              }
            }
            this.d = e;
          }
          const i = jS(this.e, e, this.c);
          this.c = i + 1;
          if (i === -1) {
            return undefined;
          } else {
            return this.e[i];
          }
        }
      };
    }
  });
  function lw(t) {
    Wl.setUnexpectedErrorHandler(t);
  }
  function zS(t) {
    if (!t || typeof t != "object") {
      return false;
    }
    const e = t;
    return e.code === "EPIPE" && e.syscall?.toUpperCase() === "WRITE";
  }
  function Ft(t) {
    if (!Nl(t)) {
      Wl.onUnexpectedError(t);
    }
  }
  function Nl(t) {
    if (t instanceof hi) {
      return true;
    } else {
      return t instanceof Error && t.name === ka && t.message === ka;
    }
  }
  function Jn() {
    const t = new Error(ka);
    t.name = t.message;
    return t;
  }
  function uw(t) {
    if (t) {
      return new Error(`Illegal state: ${t}`);
    } else {
      return new Error("Illegal state");
    }
  }
  function Vi(t) {
    if (t) {
      if (t.message) {
        return t.message;
      } else if (t.stack) {
        return t.stack.split(`
  `)[0];
      } else {
        return String(t);
      }
    } else {
      return "Error";
    }
  }
  var hw;
  var Wl;
  var ka;
  var hi;
  var Tl;
  var Vs;
  var $e = g({
    "out-build/vs/base/common/errors.js"() {
      "use strict";
  
      hw = class {
        constructor() {
          this.b = [];
          this.a = function (t) {
            setTimeout(() => {
              throw t.stack ? Vs.isErrorNoTelemetry(t) ? new Vs(`${t.message}
  
  ${t.stack}`) : new Error(`${t.message}
  
  ${t.stack}`) : t;
            }, 0);
          };
        }
        addListener(t) {
          this.b.push(t);
          return () => {
            this.d(t);
          };
        }
        c(t) {
          this.b.forEach(e => {
            e(t);
          });
        }
        d(t) {
          this.b.splice(this.b.indexOf(t), 1);
        }
        setUnexpectedErrorHandler(t) {
          this.a = t;
        }
        getUnexpectedErrorHandler() {
          return this.a;
        }
        onUnexpectedError(t) {
          this.a(t);
          this.c(t);
        }
        onUnexpectedExternalError(t) {
          this.a(t);
        }
      };
      Wl = new hw();
      ka = "Canceled";
      hi = class extends Error {
        constructor() {
          super(ka);
          this.name = this.message;
        }
      };
      Tl = class extends Error {
        constructor() {
          super(...arguments);
          this.isExpected = true;
        }
      };
      Vs = class b0 extends Error {
        constructor(e) {
          super(e);
          this.name = "CodeExpectedError";
        }
        static fromError(e) {
          if (e instanceof b0) {
            return e;
          }
          const i = new b0();
          i.message = e.message;
          i.stack = e.stack;
          return i;
        }
        static isErrorNoTelemetry(e) {
          return e.name === "CodeExpectedError";
        }
      };
    }
  });
  function xa(t, e, i = (s, r) => s === r) {
    if (t === e) {
      return true;
    }
    if (!t || !e || t.length !== e.length) {
      return false;
    }
    for (let s = 0, r = t.length; s < r; s++) {
      if (!i(t[s], e[s])) {
        return false;
      }
    }
    return true;
  }
  function HS(t, e, i) {
    if (i === 0) {
      return [];
    }
    const s = t.slice(0, i).sort(e);
    VS(t, e, s, i, t.length);
    return s;
  }
  function VS(t, e, i, s, r) {
    for (const n = i.length; s < r; s++) {
      const o = t[s];
      if (e(o, i[n - 1]) < 0) {
        i.pop();
        const a = US(i, c => e(o, c) < 0);
        i.splice(a, 0, o);
      }
    }
  }
  function $t(t) {
    return t.filter(e => !!e);
  }
  function ss(t, e = i => i) {
    const i = new Set();
    return t.filter(s => {
      const r = e(s);
      if (i.has(r)) {
        return false;
      } else {
        i.add(r);
        return true;
      }
    });
  }
  function dw(t, e) {
    t.push(e);
    return () => GS(t, e);
  }
  function GS(t, e) {
    const i = t.indexOf(e);
    if (i > -1) {
      t.splice(i, 1);
      return e;
    }
  }
  function fw(t, e) {
    let i;
    if (typeof e == "number") {
      let s = e;
      i = () => {
        const r = Math.sin(s++) * 179426549;
        return r - Math.floor(r);
      };
    } else {
      i = Math.random;
    }
    for (let s = t.length - 1; s > 0; s -= 1) {
      const r = Math.floor(i() * (s + 1));
      const n = t[s];
      t[s] = t[r];
      t[r] = n;
    }
  }
  function JS(t) {
    return t[Math.floor(Math.random() * t.length)];
  }
  function KS(t, e) {
    return (i, s) => e(t(i), t(s));
  }
  var Yf;
  var pw;
  var ZS;
  var zt = g({
    "out-build/vs/base/common/arrays.js"() {
      "use strict";
  
      qS();
      $e();
      (function (t) {
        function e(n) {
          return n < 0;
        }
        t.isLessThan = e;
        function i(n) {
          return n <= 0;
        }
        t.isLessThanOrEqual = i;
        function s(n) {
          return n > 0;
        }
        t.isGreaterThan = s;
        function r(n) {
          return n === 0;
        }
        t.isNeitherLessOrGreaterThan = r;
        t.greaterThan = 1;
        t.lessThan = -1;
        t.neitherLessOrGreaterThan = 0;
      })(Yf ||= {});
      pw = (t, e) => t - e;
      ZS = class bf {
        static {
          this.empty = new bf(e => {});
        }
        constructor(e) {
          this.iterate = e;
        }
        forEach(e) {
          this.iterate(i => {
            e(i);
            return true;
          });
        }
        toArray() {
          const e = [];
          this.iterate(i => {
            e.push(i);
            return true;
          });
          return e;
        }
        filter(e) {
          return new bf(i => this.iterate(s => e(s) ? i(s) : true));
        }
        map(e) {
          return new bf(i => this.iterate(s => i(e(s))));
        }
        some(e) {
          let i = false;
          this.iterate(s => {
            i = e(s);
            return !i;
          });
          return i;
        }
        findFirst(e) {
          let i;
          this.iterate(s => e(s) ? (i = s, false) : true);
          return i;
        }
        findLast(e) {
          let i;
          this.iterate(s => {
            if (e(s)) {
              i = s;
            }
            return true;
          });
          return i;
        }
        findLastMaxBy(e) {
          let i;
          let s = true;
          this.iterate(r => {
            if (s || Yf.isGreaterThan(e(r, i))) {
              s = false;
              i = r;
            }
            return true;
          });
          return i;
        }
      };
    }
  });
  function YS(t, e) {
    const i = Object.create(null);
    for (const s of t) {
      const r = e(s);
      let n = i[r];
      n ||= i[r] = [];
      n.push(s);
    }
    return i;
  }
  var gw;
  var XS;
  var mw = g({
    "out-build/vs/base/common/collections.js"() {
      "use strict";
  
      XS = class {
        static {
          gw = Symbol.toStringTag;
        }
        constructor(t, e) {
          this.b = e;
          this.a = new Map();
          this[gw] = "SetWithKey";
          for (const i of t) {
            this.add(i);
          }
        }
        get size() {
          return this.a.size;
        }
        add(t) {
          const e = this.b(t);
          this.a.set(e, t);
          return this;
        }
        delete(t) {
          return this.a.delete(this.b(t));
        }
        has(t) {
          return this.a.has(this.b(t));
        }
        *entries() {
          for (const t of this.a.values()) {
            yield [t, t];
          }
        }
        keys() {
          return this.values();
        }
        *values() {
          for (const t of this.a.values()) {
            yield t;
          }
        }
        clear() {
          this.a.clear();
        }
        forEach(t, e) {
          this.a.forEach(i => t.call(e, i, i, this));
        }
        [Symbol.iterator]() {
          return this.values();
        }
      };
    }
  });
  function jl(t, e) {
    const i = this;
    let s = false;
    let r;
    return function () {
      if (s) {
        return r;
      }
      s = true;
      if (e) {
        try {
          r = t.apply(i, arguments);
        } finally {
          e();
        }
      } else {
        r = t.apply(i, arguments);
      }
      return r;
    };
  }
  var Ul = g({
    "out-build/vs/base/common/functional.js"() {
      "use strict";
    }
  });
  function QS(t) {
    const e = [];
    t.forEach((i, s) => {
      e.push(`${s} => ${i}`);
    });
    return `Map(${t.size}) {${e.join(", ")}}`;
  }
  function eE(t) {
    const e = [];
    t.forEach(i => {
      e.push(i);
    });
    return `Set(${t.size}) {${e.join(", ")}}`;
  }
  function tE(t) {
    return Array.isArray(t);
  }
  var ww;
  var vw;
  var bw;
  var yw;
  var Ht;
  var Sw;
  var Ew;
  var kw;
  var xw;
  var Da;
  var Dw;
  var $i = g({
    "out-build/vs/base/common/map.js"() {
      "use strict";
  
      yw = class {
        constructor(t, e) {
          this.uri = t;
          this.value = e;
        }
      };
      Ht = class yl {
        static {
          this.c = e => e.toString();
        }
        constructor(e, i) {
          this[ww] = "ResourceMap";
          if (e instanceof yl) {
            this.d = new Map(e.d);
            this.e = i ?? yl.c;
          } else if (tE(e)) {
            this.d = new Map();
            this.e = i ?? yl.c;
            for (const [s, r] of e) {
              this.set(s, r);
            }
          } else {
            this.d = new Map();
            this.e = e ?? yl.c;
          }
        }
        set(e, i) {
          this.d.set(this.e(e), new yw(e, i));
          return this;
        }
        get(e) {
          return this.d.get(this.e(e))?.value;
        }
        has(e) {
          return this.d.has(this.e(e));
        }
        get size() {
          return this.d.size;
        }
        clear() {
          this.d.clear();
        }
        delete(e) {
          return this.d.delete(this.e(e));
        }
        forEach(e, i) {
          if (typeof i !== "undefined") {
            e = e.bind(i);
          }
          for (const [s, r] of this.d) {
            e(r.value, r.uri, this);
          }
        }
        *values() {
          for (const e of this.d.values()) {
            yield e.value;
          }
        }
        *keys() {
          for (const e of this.d.values()) {
            yield e.uri;
          }
        }
        *entries() {
          for (const e of this.d.values()) {
            yield [e.uri, e.value];
          }
        }
        *[(ww = Symbol.toStringTag, Symbol.iterator)]() {
          for (const [, e] of this.d) {
            yield [e.uri, e.value];
          }
        }
      };
      Sw = class {
        constructor(t, e) {
          this[vw] = "ResourceSet";
          if (!t || typeof t == "function") {
            this.c = new Ht(t);
          } else {
            this.c = new Ht(e);
            t.forEach(this.add, this);
          }
        }
        get size() {
          return this.c.size;
        }
        add(t) {
          this.c.set(t, t);
          return this;
        }
        clear() {
          this.c.clear();
        }
        delete(t) {
          return this.c.delete(t);
        }
        forEach(t, e) {
          this.c.forEach((i, s) => t.call(e, s, s, this));
        }
        has(t) {
          return this.c.has(t);
        }
        entries() {
          return this.c.entries();
        }
        keys() {
          return this.c.keys();
        }
        values() {
          return this.c.keys();
        }
        [(vw = Symbol.toStringTag, Symbol.iterator)]() {
          return this.keys();
        }
      };
      (function (t) {
        t[t.None = 0] = "None";
        t[t.AsOld = 1] = "AsOld";
        t[t.AsNew = 2] = "AsNew";
      })(Ew ||= {});
      kw = class {
        constructor() {
          this[bw] = "LinkedMap";
          this.c = new Map();
          this.d = undefined;
          this.e = undefined;
          this.f = 0;
          this.g = 0;
        }
        clear() {
          this.c.clear();
          this.d = undefined;
          this.e = undefined;
          this.f = 0;
          this.g++;
        }
        isEmpty() {
          return !this.d && !this.e;
        }
        get size() {
          return this.f;
        }
        get first() {
          return this.d?.value;
        }
        get last() {
          return this.e?.value;
        }
        has(t) {
          return this.c.has(t);
        }
        get(t, e = 0) {
          const i = this.c.get(t);
          if (i) {
            if (e !== 0) {
              this.m(i, e);
            }
            return i.value;
          }
        }
        set(t, e, i = 0) {
          let s = this.c.get(t);
          if (s) {
            s.value = e;
            if (i !== 0) {
              this.m(s, i);
            }
          } else {
            s = {
              key: t,
              value: e,
              next: undefined,
              previous: undefined
            };
            switch (i) {
              case 0:
                this.k(s);
                break;
              case 1:
                this.j(s);
                break;
              case 2:
                this.k(s);
                break;
              default:
                this.k(s);
                break;
            }
            this.c.set(t, s);
            this.f++;
          }
          return this;
        }
        delete(t) {
          return !!this.remove(t);
        }
        remove(t) {
          const e = this.c.get(t);
          if (e) {
            this.c.delete(t);
            this.l(e);
            this.f--;
            return e.value;
          }
        }
        shift() {
          if (!this.d && !this.e) {
            return;
          }
          if (!this.d || !this.e) {
            throw new Error("Invalid list");
          }
          const t = this.d;
          this.c.delete(t.key);
          this.l(t);
          this.f--;
          return t.value;
        }
        forEach(t, e) {
          const i = this.g;
          let s = this.d;
          while (s) {
            if (e) {
              t.bind(e)(s.value, s.key, this);
            } else {
              t(s.value, s.key, this);
            }
            if (this.g !== i) {
              throw new Error("LinkedMap got modified during iteration.");
            }
            s = s.next;
          }
        }
        keys() {
          const t = this;
          const e = this.g;
          let i = this.d;
          const s = {
            [Symbol.iterator]() {
              return s;
            },
            next() {
              if (t.g !== e) {
                throw new Error("LinkedMap got modified during iteration.");
              }
              if (i) {
                const r = {
                  value: i.key,
                  done: false
                };
                i = i.next;
                return r;
              } else {
                return {
                  value: undefined,
                  done: true
                };
              }
            }
          };
          return s;
        }
        values() {
          const t = this;
          const e = this.g;
          let i = this.d;
          const s = {
            [Symbol.iterator]() {
              return s;
            },
            next() {
              if (t.g !== e) {
                throw new Error("LinkedMap got modified during iteration.");
              }
              if (i) {
                const r = {
                  value: i.value,
                  done: false
                };
                i = i.next;
                return r;
              } else {
                return {
                  value: undefined,
                  done: true
                };
              }
            }
          };
          return s;
        }
        entries() {
          const t = this;
          const e = this.g;
          let i = this.d;
          const s = {
            [Symbol.iterator]() {
              return s;
            },
            next() {
              if (t.g !== e) {
                throw new Error("LinkedMap got modified during iteration.");
              }
              if (i) {
                const r = {
                  value: [i.key, i.value],
                  done: false
                };
                i = i.next;
                return r;
              } else {
                return {
                  value: undefined,
                  done: true
                };
              }
            }
          };
          return s;
        }
        [(bw = Symbol.toStringTag, Symbol.iterator)]() {
          return this.entries();
        }
        h(t) {
          if (t >= this.size) {
            return;
          }
          if (t === 0) {
            this.clear();
            return;
          }
          let e = this.d;
          let i = this.size;
          while (e && i > t) {
            this.c.delete(e.key);
            e = e.next;
            i--;
          }
          this.d = e;
          this.f = i;
          if (e) {
            e.previous = undefined;
          }
          this.g++;
        }
        i(t) {
          if (t >= this.size) {
            return;
          }
          if (t === 0) {
            this.clear();
            return;
          }
          let e = this.e;
          let i = this.size;
          while (e && i > t) {
            this.c.delete(e.key);
            e = e.previous;
            i--;
          }
          this.e = e;
          this.f = i;
          if (e) {
            e.next = undefined;
          }
          this.g++;
        }
        j(t) {
          if (!this.d && !this.e) {
            this.e = t;
          } else if (this.d) {
            t.next = this.d;
            this.d.previous = t;
          } else {
            throw new Error("Invalid list");
          }
          this.d = t;
          this.g++;
        }
        k(t) {
          if (!this.d && !this.e) {
            this.d = t;
          } else if (this.e) {
            t.previous = this.e;
            this.e.next = t;
          } else {
            throw new Error("Invalid list");
          }
          this.e = t;
          this.g++;
        }
        l(t) {
          if (t === this.d && t === this.e) {
            this.d = undefined;
            this.e = undefined;
          } else if (t === this.d) {
            if (!t.next) {
              throw new Error("Invalid list");
            }
            t.next.previous = undefined;
            this.d = t.next;
          } else if (t === this.e) {
            if (!t.previous) {
              throw new Error("Invalid list");
            }
            t.previous.next = undefined;
            this.e = t.previous;
          } else {
            const e = t.next;
            const i = t.previous;
            if (!e || !i) {
              throw new Error("Invalid list");
            }
            e.previous = i;
            i.next = e;
          }
          t.next = undefined;
          t.previous = undefined;
          this.g++;
        }
        m(t, e) {
          if (!this.d || !this.e) {
            throw new Error("Invalid list");
          }
          if (e === 1 || e === 2) {
            if (e === 1) {
              if (t === this.d) {
                return;
              }
              const i = t.next;
              const s = t.previous;
              if (t === this.e) {
                s.next = undefined;
                this.e = s;
              } else {
                i.previous = s;
                s.next = i;
              }
              t.previous = undefined;
              t.next = this.d;
              this.d.previous = t;
              this.d = t;
              this.g++;
            } else if (e === 2) {
              if (t === this.e) {
                return;
              }
              const i = t.next;
              const s = t.previous;
              if (t === this.d) {
                i.previous = undefined;
                this.d = i;
              } else {
                i.previous = s;
                s.next = i;
              }
              t.next = undefined;
              t.previous = this.e;
              this.e.next = t;
              this.e = t;
              this.g++;
            }
          }
        }
        toJSON() {
          const t = [];
          this.forEach((e, i) => {
            t.push([i, e]);
          });
          return t;
        }
        fromJSON(t) {
          this.clear();
          for (const [e, i] of t) {
            this.set(e, i);
          }
        }
      };
      xw = class extends kw {
        constructor(t, e = 1) {
          super();
          this.n = t;
          this.o = Math.min(Math.max(0, e), 1);
        }
        get limit() {
          return this.n;
        }
        set limit(t) {
          this.n = t;
          this.p();
        }
        get ratio() {
          return this.o;
        }
        set ratio(t) {
          this.o = Math.min(Math.max(0, t), 1);
          this.p();
        }
        get(t, e = 2) {
          return super.get(t, e);
        }
        peek(t) {
          return super.get(t, 0);
        }
        set(t, e) {
          super.set(t, e, 2);
          return this;
        }
        p() {
          if (this.size > this.n) {
            this.q(Math.round(this.n * this.o));
          }
        }
      };
      Da = class extends xw {
        constructor(t, e = 1) {
          super(t, e);
        }
        q(t) {
          this.h(t);
        }
        set(t, e) {
          super.set(t, e);
          this.p();
          return this;
        }
      };
      Dw = class {
        constructor() {
          this.c = new Map();
        }
        add(t, e) {
          let i = this.c.get(t);
          if (!i) {
            i = new Set();
            this.c.set(t, i);
          }
          i.add(e);
        }
        delete(t, e) {
          const i = this.c.get(t);
          if (i) {
            i.delete(e);
            if (i.size === 0) {
              this.c.delete(t);
            }
          }
        }
        forEach(t, e) {
          const i = this.c.get(t);
          if (i) {
            i.forEach(e);
          }
        }
        get(t) {
          const e = this.c.get(t);
          return e || new Set();
        }
      };
    }
  });
  var Vr;
  var Bl = g({
    "out-build/vs/base/common/iterator.js"() {
      "use strict";
  
      (function (t) {
        function e(C) {
          return C && typeof C == "object" && typeof C[Symbol.iterator] == "function";
        }
        t.is = e;
        const i = Object.freeze([]);
        function s() {
          return i;
        }
        t.empty = s;
        function* r(C) {
          yield C;
        }
        t.single = r;
        function n(C) {
          if (e(C)) {
            return C;
          } else {
            return r(C);
          }
        }
        t.wrap = n;
        function o(C) {
          return C || i;
        }
        t.from = o;
        function* a(C) {
          for (let _ = C.length - 1; _ >= 0; _--) {
            yield C[_];
          }
        }
        t.reverse = a;
        function c(C) {
          return !C || C[Symbol.iterator]().next().done === true;
        }
        t.isEmpty = c;
        function l(C) {
          return C[Symbol.iterator]().next().value;
        }
        t.first = l;
        function u(C, _) {
          let Z = 0;
          for (const ie of C) {
            if (_(ie, Z++)) {
              return true;
            }
          }
          return false;
        }
        t.some = u;
        function d(C, _) {
          for (const Z of C) {
            if (_(Z)) {
              return Z;
            }
          }
        }
        t.find = d;
        function* f(C, _) {
          for (const Z of C) {
            if (_(Z)) {
              yield Z;
            }
          }
        }
        t.filter = f;
        function* p(C, _) {
          let Z = 0;
          for (const ie of C) {
            yield _(ie, Z++);
          }
        }
        t.map = p;
        function* w(C, _) {
          let Z = 0;
          for (const ie of C) {
            yield* _(ie, Z++);
          }
        }
        t.flatMap = w;
        function* m(...C) {
          for (const _ of C) {
            yield* _;
          }
        }
        t.concat = m;
        function y(C, _, Z) {
          let ie = Z;
          for (const me of C) {
            ie = _(ie, me);
          }
          return ie;
        }
        t.reduce = y;
        function* b(C, _, Z = C.length) {
          if (_ < -C.length) {
            _ = 0;
          }
          if (_ < 0) {
            _ += C.length;
          }
          if (Z < 0) {
            Z += C.length;
          } else if (Z > C.length) {
            Z = C.length;
          }
          for (; _ < Z; _++) {
            yield C[_];
          }
        }
        t.slice = b;
        function k(C, _ = Number.POSITIVE_INFINITY) {
          const Z = [];
          if (_ === 0) {
            return [Z, C];
          }
          const ie = C[Symbol.iterator]();
          for (let me = 0; me < _; me++) {
            const W = ie.next();
            if (W.done) {
              return [Z, t.empty()];
            }
            Z.push(W.value);
          }
          return [Z, {
            [Symbol.iterator]() {
              return ie;
            }
          }];
        }
        t.consume = k;
        async function A(C) {
          const _ = [];
          for await (const Z of C) {
            _.push(Z);
          }
          return Promise.resolve(_);
        }
        t.asyncToArray = A;
      })(Vr ||= {});
    }
  });
  function iE(t) {
    Gr = t;
  }
  function Pa(t) {
    Gr?.trackDisposable(t);
    return t;
  }
  function $a(t) {
    Gr?.markAsDisposed(t);
  }
  function Ia(t, e) {
    Gr?.setParent(t, e);
  }
  function sE(t, e) {
    if (Gr) {
      for (const i of t) {
        Gr.setParent(i, e);
      }
    }
  }
  function rE(t) {
    return typeof t == "object" && t !== null && typeof t.dispose == "function" && t.dispose.length === 0;
  }
  function Et(t) {
    if (Vr.is(t)) {
      const e = [];
      for (const i of t) {
        if (i) {
          try {
            i.dispose();
          } catch (s) {
            e.push(s);
          }
        }
      }
      if (e.length === 1) {
        throw e[0];
      }
      if (e.length > 1) {
        throw new AggregateError(e, "Encountered errors while disposing of store");
      }
      if (Array.isArray(t)) {
        return [];
      } else {
        return t;
      }
    } else if (t) {
      t.dispose();
      return t;
    }
  }
  function nE(...t) {
    const e = xe(() => Et(t));
    sE(t, e);
    return e;
  }
  function xe(t) {
    const e = Pa({
      dispose: jl(() => {
        $a(e);
        t();
      })
    });
    return e;
  }
  var Pw;
  var Gr;
  var oE;
  var De;
  var T;
  var pr;
  var Xf;
  var M = g({
    "out-build/vs/base/common/lifecycle.js"() {
      "use strict";
  
      zt();
      mw();
      $i();
      Ul();
      Bl();
      Pw = false;
      Gr = null;
      oE = class O3 {
        constructor() {
          this.b = new Map();
        }
        static {
          this.a = 0;
        }
        c(e) {
          let i = this.b.get(e);
          if (!i) {
            i = {
              parent: null,
              source: null,
              isSingleton: false,
              value: e,
              idx: O3.a++
            };
            this.b.set(e, i);
          }
          return i;
        }
        trackDisposable(e) {
          const i = this.c(e);
          i.source ||= new Error().stack;
        }
        setParent(e, i) {
          const s = this.c(e);
          s.parent = i;
        }
        markAsDisposed(e) {
          this.b.delete(e);
        }
        markAsSingleton(e) {
          this.c(e).isSingleton = true;
        }
        f(e, i) {
          const s = i.get(e);
          if (s) {
            return s;
          }
          const r = e.parent ? this.f(this.c(e.parent), i) : e;
          i.set(e, r);
          return r;
        }
        getTrackedDisposables() {
          const e = new Map();
          return [...this.b.entries()].filter(([, s]) => s.source !== null && !this.f(s, e).isSingleton).flatMap(([s]) => s);
        }
        computeLeakingDisposables(e = 10, i) {
          let s;
          if (i) {
            s = i;
          } else {
            const c = new Map();
            const l = [...this.b.values()].filter(d => d.source !== null && !this.f(d, c).isSingleton);
            if (l.length === 0) {
              return;
            }
            const u = new Set(l.map(d => d.value));
            s = l.filter(d => !d.parent || !u.has(d.parent));
            if (s.length === 0) {
              throw new Error("There are cyclic diposable chains!");
            }
          }
          if (!s) {
            return;
          }
          function r(c) {
            function l(d, f) {
              while (d.length > 0 && f.some(p => typeof p == "string" ? p === d[0] : d[0].match(p))) {
                d.shift();
              }
            }
            const u = c.source.split(`
  `).map(d => d.trim().replace("at ", "")).filter(d => d !== "");
            l(u, ["Error", /^trackDisposable \(.*\)$/, /^DisposableTracker.trackDisposable \(.*\)$/]);
            return u.reverse();
          }
          const n = new Dw();
          for (const c of s) {
            const l = r(c);
            for (let u = 0; u <= l.length; u++) {
              n.add(l.slice(0, u).join(`
  `), c);
            }
          }
          s.sort(KS(c => c.idx, pw));
          let o = "";
          let a = 0;
          for (const c of s.slice(0, e)) {
            a++;
            const l = r(c);
            const u = [];
            for (let d = 0; d < l.length; d++) {
              let f = l[d];
              f = `(shared with ${n.get(l.slice(0, d + 1).join(`
  `)).size}/${s.length} leaks) at ${f}`;
              const w = n.get(l.slice(0, d).join(`
  `));
              const m = YS([...w].map(y => r(y)[d]), y => y);
              delete m[l[d]];
              for (const [y, b] of Object.entries(m)) {
                u.unshift(`    - stacktraces of ${b.length} other leaks continue with ${y}`);
              }
              u.unshift(f);
            }
            o += `
  
  
  ==================== Leaking disposable ${a}/${s.length}: ${c.value.constructor.name} ====================
  ${u.join(`
  `)}
  ============================================================
  
  `;
          }
          if (s.length > e) {
            o += `
  
  
  ... and ${s.length - e} more leaking disposables
  
  `;
          }
          return {
            leaks: s,
            details: o
          };
        }
      };
      if (Pw) {
        const t = "__is_disposable_tracked__";
        iE(new class {
          trackDisposable(e) {
            const i = new Error("Potentially leaked disposable").stack;
            setTimeout(() => {
              if (!e[t]) {
                console.log(i);
              }
            }, 3000);
          }
          setParent(e, i) {
            if (e && e !== T.None) {
              try {
                e[t] = true;
              } catch {}
            }
          }
          markAsDisposed(e) {
            if (e && e !== T.None) {
              try {
                e[t] = true;
              } catch {}
            }
          }
          markAsSingleton(e) {}
        }());
      }
      De = class L3 {
        static {
          this.DISABLE_DISPOSED_WARNING = false;
        }
        constructor() {
          this.f = new Set();
          this.g = false;
          Pa(this);
        }
        dispose() {
          if (!this.g) {
            $a(this);
            this.g = true;
            this.clear();
          }
        }
        get isDisposed() {
          return this.g;
        }
        clear() {
          if (this.f.size !== 0) {
            try {
              Et(this.f);
            } finally {
              this.f.clear();
            }
          }
        }
        add(e) {
          if (!e) {
            return e;
          }
          if (e === this) {
            throw new Error("Cannot register a disposable on itself!");
          }
          Ia(e, this);
          if (this.g) {
            if (!L3.DISABLE_DISPOSED_WARNING) {
              console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
            }
          } else {
            this.f.add(e);
          }
          return e;
        }
        delete(e) {
          if (e) {
            if (e === this) {
              throw new Error("Cannot dispose a disposable on itself!");
            }
            this.f.delete(e);
            e.dispose();
          }
        }
        deleteAndLeak(e) {
          if (e && this.f.has(e)) {
            this.f.delete(e);
            Ia(e, null);
          }
        }
      };
      T = class {
        static {
          this.None = Object.freeze({
            dispose() {}
          });
        }
        constructor() {
          this.B = new De();
          Pa(this);
          Ia(this.B, this);
        }
        dispose() {
          $a(this);
          this.B.dispose();
        }
        D(t) {
          if (t === this) {
            throw new Error("Cannot register a disposable on itself!");
          }
          return this.B.add(t);
        }
      };
      pr = class {
        constructor() {
          this.b = false;
          Pa(this);
        }
        get value() {
          if (this.b) {
            return undefined;
          } else {
            return this.a;
          }
        }
        set value(t) {
          if (!this.b && t !== this.a) {
            this.a?.dispose();
            if (t) {
              Ia(t, this);
            }
            this.a = t;
          }
        }
        clear() {
          this.value = undefined;
        }
        dispose() {
          this.b = true;
          $a(this);
          this.a?.dispose();
          this.a = undefined;
        }
        clearAndLeak() {
          const t = this.a;
          this.a = undefined;
          if (t) {
            Ia(t, null);
          }
          return t;
        }
      };
      Xf = class {
        constructor() {
          this.a = new Map();
          this.b = false;
          Pa(this);
        }
        dispose() {
          $a(this);
          this.b = true;
          this.clearAndDisposeAll();
        }
        clearAndDisposeAll() {
          if (this.a.size) {
            try {
              Et(this.a.values());
            } finally {
              this.a.clear();
            }
          }
        }
        has(t) {
          return this.a.has(t);
        }
        get size() {
          return this.a.size;
        }
        get(t) {
          return this.a.get(t);
        }
        set(t, e, i = false) {
          if (this.b) {
            console.warn(new Error("Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!").stack);
          }
          if (!i) {
            this.a.get(t)?.dispose();
          }
          this.a.set(t, e);
        }
        deleteAndDispose(t) {
          this.a.get(t)?.dispose();
          this.a.delete(t);
        }
        deleteAndLeak(t) {
          const e = this.a.get(t);
          this.a.delete(t);
          return e;
        }
        keys() {
          return this.a.keys();
        }
        values() {
          return this.a.values();
        }
        [Symbol.iterator]() {
          return this.a[Symbol.iterator]();
        }
      };
    }
  });
  var et;
  var Qf;
  var $w = g({
    "out-build/vs/base/common/linkedList.js"() {
      "use strict";
  
      et = class yf {
        static {
          this.Undefined = new yf(undefined);
        }
        constructor(e) {
          this.element = e;
          this.next = yf.Undefined;
          this.prev = yf.Undefined;
        }
      };
      Qf = class {
        constructor() {
          this.a = et.Undefined;
          this.b = et.Undefined;
          this.c = 0;
        }
        get size() {
          return this.c;
        }
        get first() {
          return this.a;
        }
        isEmpty() {
          return this.a === et.Undefined;
        }
        clear() {
          let t = this.a;
          while (t !== et.Undefined) {
            const e = t.next;
            t.prev = et.Undefined;
            t.next = et.Undefined;
            t = e;
          }
          this.a = et.Undefined;
          this.b = et.Undefined;
          this.c = 0;
        }
        unshift(t) {
          return this.d(t, false);
        }
        push(t) {
          return this.d(t, true);
        }
        d(t, e) {
          const i = new et(t);
          if (this.a === et.Undefined) {
            this.a = i;
            this.b = i;
          } else if (e) {
            const r = this.b;
            this.b = i;
            i.prev = r;
            r.next = i;
          } else {
            const r = this.a;
            this.a = i;
            i.next = r;
            r.prev = i;
          }
          this.c += 1;
          let s = false;
          return () => {
            if (!s) {
              s = true;
              this.e(i);
            }
          };
        }
        shift() {
          if (this.a !== et.Undefined) {
            const t = this.a.element;
            this.e(this.a);
            return t;
          }
        }
        pop() {
          if (this.b !== et.Undefined) {
            const t = this.b.element;
            this.e(this.b);
            return t;
          }
        }
        remove(t) {
          this.e(t);
        }
        e(t) {
          if (t.prev !== et.Undefined && t.next !== et.Undefined) {
            const e = t.prev;
            e.next = t.next;
            t.next.prev = e;
          } else if (t.prev === et.Undefined && t.next === et.Undefined) {
            this.a = et.Undefined;
            this.b = et.Undefined;
          } else if (t.next === et.Undefined) {
            this.b = this.b.prev;
            this.b.next = et.Undefined;
          } else if (t.prev === et.Undefined) {
            this.a = this.a.next;
            this.a.prev = et.Undefined;
          }
          this.c -= 1;
        }
        *[Symbol.iterator]() {
          let t = this.a;
          while (t !== et.Undefined) {
            yield t.element;
            t = t.next;
          }
        }
      };
    }
  });
  var Iw;
  var Jr;
  var Kn = g({
    "out-build/vs/base/common/stopwatch.js"() {
      "use strict";
  
      Iw = globalThis.performance && typeof globalThis.performance.now == "function";
      Jr = class M3 {
        static create(e) {
          return new M3(e);
        }
        constructor(e) {
          this.c = Iw && e === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);
          this.a = this.c();
          this.b = -1;
        }
        stop() {
          this.b = this.c();
        }
        reset() {
          this.a = this.c();
          this.b = -1;
        }
        elapsed() {
          if (this.b !== -1) {
            return this.b - this.a;
          } else {
            return this.c() - this.a;
          }
        }
      };
    }
  });
  var ep;
  var Aw;
  var x;
  var Cw;
  var tp;
  var _w;
  var ql;
  var Rw;
  var Ow;
  var Lw;
  var Aa;
  var Mw;
  var Fw;
  var $;
  var Nw;
  var zl;
  var Ww;
  var ip;
  var B = g({
    "out-build/vs/base/common/event.js"() {
      "use strict";
  
      mw();
      $e();
      Ul();
      M();
      $w();
      Kn();
      ep = false;
      Aw = false;
      (function (t) {
        t.None = () => T.None;
        function e(L) {
          if (Aw) {
            const {
              onDidAddListener: O
            } = L;
            const G = ql.create();
            let U = 0;
            L.onDidAddListener = () => {
              if (++U === 2) {
                console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here");
                G.print();
              }
              O?.();
            };
          }
        }
        function i(L, O) {
          return p(L, () => {}, 0, undefined, true, undefined, O);
        }
        t.defer = i;
        function s(L) {
          return (O, G = null, U) => {
            let te = false;
            let pe;
            pe = L(Ce => {
              if (!te) {
                if (pe) {
                  pe.dispose();
                } else {
                  te = true;
                }
                return O.call(G, Ce);
              }
            }, null, U);
            if (te) {
              pe.dispose();
            }
            return pe;
          };
        }
        t.once = s;
        function r(L, O) {
          return t.once(t.filter(L, O));
        }
        t.onceIf = r;
        function n(L, O, G) {
          return d((U, te = null, pe) => L(Ce => U.call(te, O(Ce)), null, pe), G);
        }
        t.map = n;
        function o(L, O, G) {
          return d((U, te = null, pe) => L(Ce => {
            O(Ce);
            U.call(te, Ce);
          }, null, pe), G);
        }
        t.forEach = o;
        function a(L, O, G) {
          return d((U, te = null, pe) => L(Ce => O(Ce) && U.call(te, Ce), null, pe), G);
        }
        t.filter = a;
        function c(L) {
          return L;
        }
        t.signal = c;
        function l(...L) {
          return (O, G = null, U) => {
            const te = nE(...L.map(pe => pe(Ce => O.call(G, Ce))));
            return f(te, U);
          };
        }
        t.any = l;
        function u(L, O, G, U) {
          let te = G;
          return n(L, pe => {
            te = O(te, pe);
            return te;
          }, U);
        }
        t.reduce = u;
        function d(L, O) {
          let G;
          const U = {
            onWillAddFirstListener() {
              G = L(te.fire, te);
            },
            onDidRemoveLastListener() {
              G?.dispose();
            }
          };
          if (!O) {
            e(U);
          }
          const te = new $(U);
          O?.add(te);
          return te.event;
        }
        function f(L, O) {
          if (O instanceof Array) {
            O.push(L);
          } else if (O) {
            O.add(L);
          }
          return L;
        }
        function p(L, O, G = 100, U = false, te = false, pe, Ce) {
          let rt;
          let pt;
          let Bs;
          let Br = 0;
          let qs;
          const qn = {
            leakWarningThreshold: pe,
            onWillAddFirstListener() {
              rt = L(Il => {
                Br++;
                pt = O(pt, Il);
                if (U && !Bs) {
                  gs.fire(pt);
                  pt = undefined;
                }
                qs = () => {
                  const Al = pt;
                  pt = undefined;
                  Bs = undefined;
                  if (!U || Br > 1) {
                    gs.fire(Al);
                  }
                  Br = 0;
                };
                if (typeof G == "number") {
                  clearTimeout(Bs);
                  Bs = setTimeout(qs, G);
                } else if (Bs === undefined) {
                  Bs = 0;
                  queueMicrotask(qs);
                }
              });
            },
            onWillRemoveListener() {
              if (te && Br > 0) {
                qs?.();
              }
            },
            onDidRemoveLastListener() {
              qs = undefined;
              rt.dispose();
            }
          };
          if (!Ce) {
            e(qn);
          }
          const gs = new $(qn);
          Ce?.add(gs);
          return gs.event;
        }
        t.debounce = p;
        function w(L, O = 0, G) {
          return t.debounce(L, (U, te) => U ? (U.push(te), U) : [te], O, undefined, true, undefined, G);
        }
        t.accumulate = w;
        function m(L, O = (U, te) => U === te, G) {
          let U = true;
          let te;
          return a(L, pe => {
            const Ce = U || !O(pe, te);
            U = false;
            te = pe;
            return Ce;
          }, G);
        }
        t.latch = m;
        function y(L, O, G) {
          return [t.filter(L, O, G), t.filter(L, U => !O(U), G)];
        }
        t.split = y;
        function b(L, O = false, G = [], U) {
          let te = G.slice();
          let pe = L(pt => {
            if (te) {
              te.push(pt);
            } else {
              rt.fire(pt);
            }
          });
          if (U) {
            U.add(pe);
          }
          const Ce = () => {
            te?.forEach(pt => rt.fire(pt));
            te = null;
          };
          const rt = new $({
            onWillAddFirstListener() {
              if (!pe) {
                pe = L(pt => rt.fire(pt));
                if (U) {
                  U.add(pe);
                }
              }
            },
            onDidAddFirstListener() {
              if (te) {
                if (O) {
                  setTimeout(Ce);
                } else {
                  Ce();
                }
              }
            },
            onDidRemoveLastListener() {
              if (pe) {
                pe.dispose();
              }
              pe = null;
            }
          });
          if (U) {
            U.add(rt);
          }
          return rt.event;
        }
        t.buffer = b;
        function k(L, O) {
          return (U, te, pe) => {
            const Ce = O(new C());
            return L(function (rt) {
              const pt = Ce.evaluate(rt);
              if (pt !== A) {
                U.call(te, pt);
              }
            }, undefined, pe);
          };
        }
        t.chain = k;
        const A = Symbol("HaltChainable");
        class C {
          constructor() {
            this.f = [];
          }
          map(O) {
            this.f.push(O);
            return this;
          }
          forEach(O) {
            this.f.push(G => {
              O(G);
              return G;
            });
            return this;
          }
          filter(O) {
            this.f.push(G => O(G) ? G : A);
            return this;
          }
          reduce(O, G) {
            let U = G;
            this.f.push(te => {
              U = O(U, te);
              return U;
            });
            return this;
          }
          latch(O = (G, U) => G === U) {
            let G = true;
            let U;
            this.f.push(te => {
              const pe = G || !O(te, U);
              G = false;
              U = te;
              if (pe) {
                return te;
              } else {
                return A;
              }
            });
            return this;
          }
          evaluate(O) {
            for (const G of this.f) {
              O = G(O);
              if (O === A) {
                break;
              }
            }
            return O;
          }
        }
        function _(L, O, G = U => U) {
          const U = (...rt) => Ce.fire(G(...rt));
          const te = () => L.on(O, U);
          const pe = () => L.removeListener(O, U);
          const Ce = new $({
            onWillAddFirstListener: te,
            onDidRemoveLastListener: pe
          });
          return Ce.event;
        }
        t.fromNodeEventEmitter = _;
        function Z(L, O, G = U => U) {
          const U = (...rt) => Ce.fire(G(...rt));
          const te = () => L.addEventListener(O, U);
          const pe = () => L.removeEventListener(O, U);
          const Ce = new $({
            onWillAddFirstListener: te,
            onDidRemoveLastListener: pe
          });
          return Ce.event;
        }
        t.fromDOMEventEmitter = Z;
        function ie(L) {
          return new Promise(O => s(L)(O));
        }
        t.toPromise = ie;
        function me(L) {
          const O = new $();
          L.then(G => {
            O.fire(G);
          }, () => {
            O.fire(undefined);
          }).finally(() => {
            O.dispose();
          });
          return O.event;
        }
        t.fromPromise = me;
        function W(L, O) {
          return L(G => O.fire(G));
        }
        t.forward = W;
        function Ee(L, O, G) {
          O(G);
          return L(U => O(U));
        }
        t.runAndSubscribe = Ee;
        class Ye {
          constructor(O, G) {
            this._observable = O;
            this.f = 0;
            this.g = false;
            const U = {
              onWillAddFirstListener: () => {
                O.addObserver(this);
                this._observable.reportChanges();
              },
              onDidRemoveLastListener: () => {
                O.removeObserver(this);
              }
            };
            if (!G) {
              e(U);
            }
            this.emitter = new $(U);
            if (G) {
              G.add(this.emitter);
            }
          }
          beginUpdate(O) {
            this.f++;
          }
          handlePossibleChange(O) {}
          handleChange(O, G) {
            this.g = true;
          }
          endUpdate(O) {
            this.f--;
            if (this.f === 0) {
              this._observable.reportChanges();
              if (this.g) {
                this.g = false;
                this.emitter.fire(this._observable.get());
              }
            }
          }
        }
        function re(L, O) {
          return new Ye(L, O).emitter.event;
        }
        t.fromObservable = re;
        function St(L) {
          return (O, G, U) => {
            let te = 0;
            let pe = false;
            const Ce = {
              beginUpdate() {
                te++;
              },
              endUpdate() {
                te--;
                if (te === 0) {
                  L.reportChanges();
                  if (pe) {
                    pe = false;
                    O.call(G);
                  }
                }
              },
              handlePossibleChange() {},
              handleChange() {
                pe = true;
              }
            };
            L.addObserver(Ce);
            L.reportChanges();
            const rt = {
              dispose() {
                L.removeObserver(Ce);
              }
            };
            if (U instanceof De) {
              U.add(rt);
            } else if (Array.isArray(U)) {
              U.push(rt);
            }
            return rt;
          };
        }
        t.fromObservableLight = St;
      })(x ||= {});
      Cw = class y0 {
        static {
          this.all = new Set();
        }
        static {
          this.f = 0;
        }
        constructor(e) {
          this.listenerCount = 0;
          this.invocationCount = 0;
          this.elapsedOverall = 0;
          this.durations = [];
          this.name = `${e}_${y0.f++}`;
          y0.all.add(this);
        }
        start(e) {
          this.g = new Jr();
          this.listenerCount = e;
        }
        stop() {
          if (this.g) {
            const e = this.g.elapsed();
            this.durations.push(e);
            this.elapsedOverall += e;
            this.invocationCount += 1;
            this.g = undefined;
          }
        }
      };
      tp = -1;
      _w = class F3 {
        static {
          this.f = 1;
        }
        constructor(e, i, s = (F3.f++).toString(16).padStart(3, "0")) {
          this.j = e;
          this.threshold = i;
          this.name = s;
          this.h = 0;
        }
        dispose() {
          this.g?.clear();
        }
        check(e, i) {
          const s = this.threshold;
          if (s <= 0 || i < s) {
            return;
          }
          this.g ||= new Map();
          const r = this.g.get(e.value) || 0;
          this.g.set(e.value, r + 1);
          this.h -= 1;
          if (this.h <= 0) {
            this.h = s * 0.5;
            const [n, o] = this.getMostFrequentStack();
            const a = `[${this.name}] potential listener LEAK detected, having ${i} listeners already. MOST frequent listener (${o}):`;
            console.warn(a);
            console.warn(n);
            const c = new Rw(a, n);
            this.j(c);
          }
          return () => {
            const n = this.g.get(e.value) || 0;
            this.g.set(e.value, n - 1);
          };
        }
        getMostFrequentStack() {
          if (!this.g) {
            return;
          }
          let e;
          let i = 0;
          for (const [s, r] of this.g) {
            if (!e || i < r) {
              e = [s, r];
              i = r;
            }
          }
          return e;
        }
      };
      ql = class N3 {
        static create() {
          const e = new Error();
          return new N3(e.stack ?? "");
        }
        constructor(e) {
          this.value = e;
        }
        print() {
          console.warn(this.value.split(`
  `).slice(2).join(`
  `));
        }
      };
      Rw = class extends Error {
        constructor(t, e) {
          super(t);
          this.name = "ListenerLeakError";
          this.stack = e;
        }
      };
      Ow = class extends Error {
        constructor(t, e) {
          super(t);
          this.name = "ListenerRefusalError";
          this.stack = e;
        }
      };
      Lw = 0;
      Aa = class {
        constructor(t) {
          this.value = t;
          this.id = Lw++;
        }
      };
      Mw = 2;
      Fw = (t, e) => {
        if (t instanceof Aa) {
          e(t);
        } else {
          for (let i = 0; i < t.length; i++) {
            const s = t[i];
            if (s) {
              e(s);
            }
          }
        }
      };
      $ = class {
        constructor(t) {
          this.z = 0;
          this.f = t;
          this.g = tp > 0 || this.f?.leakWarningThreshold ? new _w(t?.onListenerError ?? Ft, this.f?.leakWarningThreshold ?? tp) : undefined;
          this.j = this.f?._profName ? new Cw(this.f._profName) : undefined;
          this.w = this.f?.deliveryQueue;
        }
        dispose() {
          if (!this.m) {
            this.m = true;
            if (this.w?.current === this) {
              this.w.reset();
            }
            if (this.u) {
              if (ep) {
                const t = this.u;
                queueMicrotask(() => {
                  Fw(t, e => e.stack?.print());
                });
              }
              this.u = undefined;
              this.z = 0;
            }
            this.f?.onDidRemoveLastListener?.();
            this.g?.dispose();
          }
        }
        get event() {
          this.q ??= (t, e, i) => {
            if (this.g && this.z > this.g.threshold ** 2) {
              const a = `[${this.g.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this.z} vs ${this.g.threshold})`;
              console.warn(a);
              const c = this.g.getMostFrequentStack() ?? ["UNKNOWN stack", -1];
              const l = new Ow(`${a}. HINT: Stack shows most frequent listener (${c[1]}-times)`, c[0]);
              (this.f?.onListenerError || Ft)(l);
              return T.None;
            }
            if (this.m) {
              return T.None;
            }
            if (e) {
              t = t.bind(e);
            }
            const s = new Aa(t);
            let r;
            let n;
            if (this.g && this.z >= Math.ceil(this.g.threshold * 0.2)) {
              s.stack = ql.create();
              r = this.g.check(s.stack, this.z + 1);
            }
            if (ep) {
              s.stack = n ?? ql.create();
            }
            if (this.u) {
              if (this.u instanceof Aa) {
                this.w ??= new Nw();
                this.u = [this.u, s];
              } else {
                this.u.push(s);
              }
            } else {
              this.f?.onWillAddFirstListener?.(this);
              this.u = s;
              this.f?.onDidAddFirstListener?.(this);
            }
            this.f?.onDidAddListener?.(this);
            this.z++;
            const o = xe(() => {
              r?.();
              this.A(s);
            });
            if (i instanceof De) {
              i.add(o);
            } else if (Array.isArray(i)) {
              i.push(o);
            }
            return o;
          };
          return this.q;
        }
        A(t) {
          this.f?.onWillRemoveListener?.(this);
          if (!this.u) {
            return;
          }
          if (this.z === 1) {
            this.u = undefined;
            this.f?.onDidRemoveLastListener?.(this);
            this.z = 0;
            return;
          }
          const e = this.u;
          const i = e.indexOf(t);
          if (i === -1) {
            console.log("disposed?", this.m);
            console.log("size?", this.z);
            console.log("arr?", JSON.stringify(this.u));
            throw new Error("Attempted to dispose unknown listener");
          }
          this.z--;
          e[i] = undefined;
          const s = this.w.current === this;
          if (this.z * Mw <= e.length) {
            let r = 0;
            for (let n = 0; n < e.length; n++) {
              if (e[n]) {
                e[r++] = e[n];
              } else if (s && r < this.w.end) {
                this.w.end--;
                if (r < this.w.i) {
                  this.w.i--;
                }
              }
            }
            e.length = r;
          }
        }
        B(t, e) {
          if (!t) {
            return;
          }
          const i = this.f?.onListenerError || Ft;
          if (!i) {
            t.value(e);
            return;
          }
          try {
            t.value(e);
          } catch (s) {
            i(s);
          }
        }
        C(t) {
          const e = t.current.u;
          while (t.i < t.end) {
            this.B(e[t.i++], t.value);
          }
          t.reset();
        }
        fire(t) {
          if (this.w?.current) {
            this.C(this.w);
            this.j?.stop();
          }
          this.j?.start(this.z);
          if (this.u) {
            if (this.u instanceof Aa) {
              this.B(this.u, t);
            } else {
              const e = this.w;
              e.enqueue(this, t, this.u.length);
              this.C(e);
            }
          }
          this.j?.stop();
        }
        hasListeners() {
          return this.z > 0;
        }
      };
      Nw = class {
        constructor() {
          this.i = -1;
          this.end = 0;
        }
        enqueue(t, e, i) {
          this.i = 0;
          this.end = i;
          this.current = t;
          this.value = e;
        }
        reset() {
          this.i = this.end;
          this.current = undefined;
          this.value = undefined;
        }
      };
      zl = class extends $ {
        get isPaused() {
          return this.h !== 0;
        }
        constructor(t) {
          super(t);
          this.h = 0;
          this.s = new Qf();
          this.t = t?.merge;
        }
        pause() {
          this.h++;
        }
        resume() {
          if (this.h !== 0 && --this.h === 0) {
            if (this.t) {
              if (this.s.size > 0) {
                const t = Array.from(this.s);
                this.s.clear();
                super.fire(this.t(t));
              }
            } else {
              while (!this.h && this.s.size !== 0) {
                super.fire(this.s.shift());
              }
            }
          }
        }
        fire(t) {
          if (this.z) {
            if (this.h !== 0) {
              this.s.push(t);
            } else {
              super.fire(t);
            }
          }
        }
      };
      Ww = class {
        constructor() {
          this.g = false;
          this.h = [];
          this.f = new $({
            onWillAddFirstListener: () => this.j(),
            onDidRemoveLastListener: () => this.k()
          });
        }
        get event() {
          return this.f.event;
        }
        add(t) {
          const e = {
            event: t,
            listener: null
          };
          this.h.push(e);
          if (this.g) {
            this.m(e);
          }
          return xe(jl(() => {
            if (this.g) {
              this.o(e);
            }
            const s = this.h.indexOf(e);
            this.h.splice(s, 1);
          }));
        }
        j() {
          this.g = true;
          this.h.forEach(t => this.m(t));
        }
        k() {
          this.g = false;
          this.h.forEach(t => this.o(t));
        }
        m(t) {
          t.listener = t.event(e => this.f.fire(e));
        }
        o(t) {
          t.listener?.dispose();
          t.listener = null;
        }
        dispose() {
          this.f.dispose();
          for (const t of this.h) {
            t.listener?.dispose();
          }
          this.h = [];
        }
      };
      ip = class {
        constructor() {
          this.f = false;
          this.g = x.None;
          this.h = T.None;
          this.j = new $({
            onDidAddFirstListener: () => {
              this.f = true;
              this.h = this.g(this.j.fire, this.j);
            },
            onDidRemoveLastListener: () => {
              this.f = false;
              this.h.dispose();
            }
          });
          this.event = this.j.event;
        }
        set input(t) {
          this.g = t;
          if (this.f) {
            this.h.dispose();
            this.h = t(this.j.fire, this.j);
          }
        }
        dispose() {
          this.h.dispose();
          this.j.dispose();
        }
      };
    }
  });
  function wt(t) {
    return typeof t == "string";
  }
  function Nt(t) {
    return typeof t == "object" && t !== null && !Array.isArray(t) && !(t instanceof RegExp) && !(t instanceof Date);
  }
  function aE(t) {
    const e = Object.getPrototypeOf(Uint8Array);
    return typeof t == "object" && t instanceof e;
  }
  function Hl(t) {
    return typeof t == "number" && !isNaN(t);
  }
  function Tw(t) {
    return t === true || t === false;
  }
  function Gs(t) {
    return typeof t === "undefined";
  }
  function Qt(t) {
    return Gs(t) || t === null;
  }
  function cE(t, e) {
    if (!t) {
      throw new Error(e ? `Unexpected type, expected '${e}'` : "Unexpected type");
    }
  }
  function Vl(t) {
    if (Qt(t)) {
      throw new Error("Assertion Failed: argument is undefined or null");
    }
    return t;
  }
  function sp(t) {
    if (!Nt(t)) {
      return false;
    }
    for (const e in t) {
      if (Uw.call(t, e)) {
        return false;
      }
    }
    return true;
  }
  function jw(t) {
    return typeof t == "function";
  }
  function hN(t) {
    return t;
  }
  var Uw;
  var _e = g({
    "out-build/vs/base/common/types.js"() {
      "use strict";
  
      Uw = Object.prototype.hasOwnProperty;
    }
  });
  var Kr;
  var Gl;
  var bs;
  var Ii;
  var rp;
  var Bw;
  var ys = g({
    "out-build/vs/base/common/process.js"() {
      "use strict";
  
      H();
      Gl = globalThis.vscode;
      if (typeof Gl !== "undefined" && typeof Gl.process !== "undefined") {
        const t = Gl.process;
        Kr = {
          get platform() {
            return t.platform;
          },
          get arch() {
            return t.arch;
          },
          get env() {
            return t.env;
          },
          cwd() {
            return t.cwd();
          }
        };
      } else if (typeof process !== "undefined" && typeof process?.versions?.node == "string") {
        Kr = {
          get platform() {
            return process.platform;
          },
          get arch() {
            return process.arch;
          },
          get env() {
            return process.env;
          },
          cwd() {
            return process.env.VSCODE_CWD || process.cwd();
          }
        };
      } else {
        Kr = {
          get platform() {
            if (j) {
              return "win32";
            } else if (N) {
              return "darwin";
            } else {
              return "linux";
            }
          },
          get arch() {},
          get env() {
            return {};
          },
          cwd() {
            return "/";
          }
        };
      }
      bs = Kr.cwd;
      Ii = Kr.env;
      rp = Kr.platform;
      Bw = Kr.arch;
    }
  });
  function lE(t, e) {
    if (t === null || typeof t != "object") {
      throw new op(e, "Object", t);
    }
  }
  function ut(t, e) {
    if (typeof t != "string") {
      throw new op(e, "string", t);
    }
  }
  function ge(t) {
    return t === It || t === di;
  }
  function np(t) {
    return t === It;
  }
  function gr(t) {
    return t >= zw && t <= Vw || t >= Hw && t <= Gw;
  }
  function Jl(t, e, i, s) {
    let r = "";
    let n = 0;
    let o = -1;
    let a = 0;
    let c = 0;
    for (let l = 0; l <= t.length; ++l) {
      if (l < t.length) {
        c = t.charCodeAt(l);
      } else {
        if (s(c)) {
          break;
        }
        c = It;
      }
      if (s(c)) {
        if (o !== l - 1 && a !== 1) {
          if (a === 2) {
            if (r.length < 2 || n !== 2 || r.charCodeAt(r.length - 1) !== Js || r.charCodeAt(r.length - 2) !== Js) {
              if (r.length > 2) {
                const u = r.lastIndexOf(i);
                if (u === -1) {
                  r = "";
                  n = 0;
                } else {
                  r = r.slice(0, u);
                  n = r.length - 1 - r.lastIndexOf(i);
                }
                o = l;
                a = 0;
                continue;
              } else if (r.length !== 0) {
                r = "";
                n = 0;
                o = l;
                a = 0;
                continue;
              }
            }
            if (e) {
              r += r.length > 0 ? `${i}..` : "..";
              n = 2;
            }
          } else {
            if (r.length > 0) {
              r += `${i}${t.slice(o + 1, l)}`;
            } else {
              r = t.slice(o + 1, l);
            }
            n = l - o - 1;
          }
        }
        o = l;
        a = 0;
      } else if (c === Js && a !== -1) {
        ++a;
      } else {
        a = -1;
      }
    }
    return r;
  }
  function uE(t) {
    if (t) {
      return `${t[0] === "." ? "" : "."}${t}`;
    } else {
      return "";
    }
  }
  function qw(t, e) {
    lE(e, "pathObject");
    const i = e.dir || e.root;
    const s = e.base || `${e.name || ""}${uE(e.ext)}`;
    if (i) {
      if (i === e.root) {
        return `${i}${s}`;
      } else {
        return `${i}${t}${s}`;
      }
    } else {
      return s;
    }
  }
  var zw;
  var Hw;
  var Vw;
  var Gw;
  var Js;
  var It;
  var di;
  var Ks;
  var Jw;
  var op;
  var fi;
  var Ge;
  var Kw;
  var ae;
  var pi;
  var Zr;
  var F;
  var Gi;
  var Zw;
  var Xe;
  var Ue;
  var Kl;
  var hE;
  var dE;
  var fE;
  var Vt;
  var Zl;
  var we = g({
    "out-build/vs/base/common/path.js"() {
      "use strict";
  
      ys();
      zw = 65;
      Hw = 97;
      Vw = 90;
      Gw = 122;
      Js = 46;
      It = 47;
      di = 92;
      Ks = 58;
      Jw = 63;
      op = class extends Error {
        constructor(t, e, i) {
          let s;
          if (typeof e == "string" && e.indexOf("not ") === 0) {
            s = "must not be";
            e = e.replace(/^not /, "");
          } else {
            s = "must be";
          }
          const r = t.indexOf(".") !== -1 ? "property" : "argument";
          let n = `The "${t}" ${r} ${s} of type ${e}`;
          n += `. Received type ${typeof i}`;
          super(n);
          this.code = "ERR_INVALID_ARG_TYPE";
        }
      };
      fi = rp === "win32";
      Ge = {
        resolve(...t) {
          let e = "";
          let i = "";
          let s = false;
          for (let r = t.length - 1; r >= -1; r--) {
            let n;
            if (r >= 0) {
              n = t[r];
              ut(n, `paths[${r}]`);
              if (n.length === 0) {
                continue;
              }
            } else if (e.length === 0) {
              n = bs();
            } else {
              n = Ii[`=${e}`] || bs();
              if (n === undefined || n.slice(0, 2).toLowerCase() !== e.toLowerCase() && n.charCodeAt(2) === di) {
                n = `${e}\\`;
              }
            }
            const o = n.length;
            let a = 0;
            let c = "";
            let l = false;
            const u = n.charCodeAt(0);
            if (o === 1) {
              if (ge(u)) {
                a = 1;
                l = true;
              }
            } else if (ge(u)) {
              l = true;
              if (ge(n.charCodeAt(1))) {
                let d = 2;
                let f = d;
                while (d < o && !ge(n.charCodeAt(d))) {
                  d++;
                }
                if (d < o && d !== f) {
                  const p = n.slice(f, d);
                  for (f = d; d < o && ge(n.charCodeAt(d));) {
                    d++;
                  }
                  if (d < o && d !== f) {
                    for (f = d; d < o && !ge(n.charCodeAt(d));) {
                      d++;
                    }
                    if (d === o || d !== f) {
                      c = `\\\\${p}\\${n.slice(f, d)}`;
                      a = d;
                    }
                  }
                }
              } else {
                a = 1;
              }
            } else if (gr(u) && n.charCodeAt(1) === Ks) {
              c = n.slice(0, 2);
              a = 2;
              if (o > 2 && ge(n.charCodeAt(2))) {
                l = true;
                a = 3;
              }
            }
            if (c.length > 0) {
              if (e.length > 0) {
                if (c.toLowerCase() !== e.toLowerCase()) {
                  continue;
                }
              } else {
                e = c;
              }
            }
            if (s) {
              if (e.length > 0) {
                break;
              }
            } else {
              i = `${n.slice(a)}\\${i}`;
              s = l;
              if (l && e.length > 0) {
                break;
              }
            }
          }
          i = Jl(i, !s, "\\", ge);
          if (s) {
            return `${e}\\${i}`;
          } else {
            return `${e}${i}` || ".";
          }
        },
        normalize(t) {
          ut(t, "path");
          const e = t.length;
          if (e === 0) {
            return ".";
          }
          let i = 0;
          let s;
          let r = false;
          const n = t.charCodeAt(0);
          if (e === 1) {
            if (np(n)) {
              return "\\";
            } else {
              return t;
            }
          }
          if (ge(n)) {
            r = true;
            if (ge(t.charCodeAt(1))) {
              let a = 2;
              let c = a;
              while (a < e && !ge(t.charCodeAt(a))) {
                a++;
              }
              if (a < e && a !== c) {
                const l = t.slice(c, a);
                for (c = a; a < e && ge(t.charCodeAt(a));) {
                  a++;
                }
                if (a < e && a !== c) {
                  for (c = a; a < e && !ge(t.charCodeAt(a));) {
                    a++;
                  }
                  if (a === e) {
                    return `\\\\${l}\\${t.slice(c)}\\`;
                  }
                  if (a !== c) {
                    s = `\\\\${l}\\${t.slice(c, a)}`;
                    i = a;
                  }
                }
              }
            } else {
              i = 1;
            }
          } else if (gr(n) && t.charCodeAt(1) === Ks) {
            s = t.slice(0, 2);
            i = 2;
            if (e > 2 && ge(t.charCodeAt(2))) {
              r = true;
              i = 3;
            }
          }
          let o = i < e ? Jl(t.slice(i), !r, "\\", ge) : "";
          if (o.length === 0 && !r) {
            o = ".";
          }
          if (o.length > 0 && ge(t.charCodeAt(e - 1))) {
            o += "\\";
          }
          if (s === undefined) {
            if (r) {
              return `\\${o}`;
            } else {
              return o;
            }
          } else if (r) {
            return `${s}\\${o}`;
          } else {
            return `${s}${o}`;
          }
        },
        isAbsolute(t) {
          ut(t, "path");
          const e = t.length;
          if (e === 0) {
            return false;
          }
          const i = t.charCodeAt(0);
          return ge(i) || e > 2 && gr(i) && t.charCodeAt(1) === Ks && ge(t.charCodeAt(2));
        },
        join(...t) {
          if (t.length === 0) {
            return ".";
          }
          let e;
          let i;
          for (let n = 0; n < t.length; ++n) {
            const o = t[n];
            ut(o, "path");
            if (o.length > 0) {
              if (e === undefined) {
                e = i = o;
              } else {
                e += `\\${o}`;
              }
            }
          }
          if (e === undefined) {
            return ".";
          }
          let s = true;
          let r = 0;
          if (typeof i == "string" && ge(i.charCodeAt(0))) {
            ++r;
            const n = i.length;
            if (n > 1 && ge(i.charCodeAt(1))) {
              ++r;
              if (n > 2) {
                if (ge(i.charCodeAt(2))) {
                  ++r;
                } else {
                  s = false;
                }
              }
            }
          }
          if (s) {
            while (r < e.length && ge(e.charCodeAt(r))) {
              r++;
            }
            if (r >= 2) {
              e = `\\${e.slice(r)}`;
            }
          }
          return Ge.normalize(e);
        },
        relative(t, e) {
          ut(t, "from");
          ut(e, "to");
          if (t === e) {
            return "";
          }
          const i = Ge.resolve(t);
          const s = Ge.resolve(e);
          if (i === s || (t = i.toLowerCase(), e = s.toLowerCase(), t === e)) {
            return "";
          }
          let r = 0;
          while (r < t.length && t.charCodeAt(r) === di) {
            r++;
          }
          let n = t.length;
          while (n - 1 > r && t.charCodeAt(n - 1) === di) {
            n--;
          }
          const o = n - r;
          let a = 0;
          while (a < e.length && e.charCodeAt(a) === di) {
            a++;
          }
          let c = e.length;
          while (c - 1 > a && e.charCodeAt(c - 1) === di) {
            c--;
          }
          const l = c - a;
          const u = o < l ? o : l;
          let d = -1;
          let f = 0;
          for (; f < u; f++) {
            const w = t.charCodeAt(r + f);
            if (w !== e.charCodeAt(a + f)) {
              break;
            }
            if (w === di) {
              d = f;
            }
          }
          if (f !== u) {
            if (d === -1) {
              return s;
            }
          } else {
            if (l > u) {
              if (e.charCodeAt(a + f) === di) {
                return s.slice(a + f + 1);
              }
              if (f === 2) {
                return s.slice(a + f);
              }
            }
            if (o > u) {
              if (t.charCodeAt(r + f) === di) {
                d = f;
              } else if (f === 2) {
                d = 3;
              }
            }
            if (d === -1) {
              d = 0;
            }
          }
          let p = "";
          for (f = r + d + 1; f <= n; ++f) {
            if (f === n || t.charCodeAt(f) === di) {
              p += p.length === 0 ? ".." : "\\..";
            }
          }
          a += d;
          if (p.length > 0) {
            return `${p}${s.slice(a, c)}`;
          } else {
            if (s.charCodeAt(a) === di) {
              ++a;
            }
            return s.slice(a, c);
          }
        },
        toNamespacedPath(t) {
          if (typeof t != "string" || t.length === 0) {
            return t;
          }
          const e = Ge.resolve(t);
          if (e.length <= 2) {
            return t;
          }
          if (e.charCodeAt(0) === di) {
            if (e.charCodeAt(1) === di) {
              const i = e.charCodeAt(2);
              if (i !== Jw && i !== Js) {
                return `\\\\?\\UNC\\${e.slice(2)}`;
              }
            }
          } else if (gr(e.charCodeAt(0)) && e.charCodeAt(1) === Ks && e.charCodeAt(2) === di) {
            return `\\\\?\\${e}`;
          }
          return t;
        },
        dirname(t) {
          ut(t, "path");
          const e = t.length;
          if (e === 0) {
            return ".";
          }
          let i = -1;
          let s = 0;
          const r = t.charCodeAt(0);
          if (e === 1) {
            if (ge(r)) {
              return t;
            } else {
              return ".";
            }
          }
          if (ge(r)) {
            i = s = 1;
            if (ge(t.charCodeAt(1))) {
              let a = 2;
              let c = a;
              while (a < e && !ge(t.charCodeAt(a))) {
                a++;
              }
              if (a < e && a !== c) {
                for (c = a; a < e && ge(t.charCodeAt(a));) {
                  a++;
                }
                if (a < e && a !== c) {
                  for (c = a; a < e && !ge(t.charCodeAt(a));) {
                    a++;
                  }
                  if (a === e) {
                    return t;
                  }
                  if (a !== c) {
                    i = s = a + 1;
                  }
                }
              }
            }
          } else if (gr(r) && t.charCodeAt(1) === Ks) {
            i = e > 2 && ge(t.charCodeAt(2)) ? 3 : 2;
            s = i;
          }
          let n = -1;
          let o = true;
          for (let a = e - 1; a >= s; --a) {
            if (ge(t.charCodeAt(a))) {
              if (!o) {
                n = a;
                break;
              }
            } else {
              o = false;
            }
          }
          if (n === -1) {
            if (i === -1) {
              return ".";
            }
            n = i;
          }
          return t.slice(0, n);
        },
        basename(t, e) {
          if (e !== undefined) {
            ut(e, "suffix");
          }
          ut(t, "path");
          let i = 0;
          let s = -1;
          let r = true;
          let n;
          if (t.length >= 2 && gr(t.charCodeAt(0)) && t.charCodeAt(1) === Ks) {
            i = 2;
          }
          if (e !== undefined && e.length > 0 && e.length <= t.length) {
            if (e === t) {
              return "";
            }
            let o = e.length - 1;
            let a = -1;
            for (n = t.length - 1; n >= i; --n) {
              const c = t.charCodeAt(n);
              if (ge(c)) {
                if (!r) {
                  i = n + 1;
                  break;
                }
              } else {
                if (a === -1) {
                  r = false;
                  a = n + 1;
                }
                if (o >= 0) {
                  if (c === e.charCodeAt(o)) {
                    if (--o === -1) {
                      s = n;
                    }
                  } else {
                    o = -1;
                    s = a;
                  }
                }
              }
            }
            if (i === s) {
              s = a;
            } else if (s === -1) {
              s = t.length;
            }
            return t.slice(i, s);
          }
          for (n = t.length - 1; n >= i; --n) {
            if (ge(t.charCodeAt(n))) {
              if (!r) {
                i = n + 1;
                break;
              }
            } else if (s === -1) {
              r = false;
              s = n + 1;
            }
          }
          if (s === -1) {
            return "";
          } else {
            return t.slice(i, s);
          }
        },
        extname(t) {
          ut(t, "path");
          let e = 0;
          let i = -1;
          let s = 0;
          let r = -1;
          let n = true;
          let o = 0;
          if (t.length >= 2 && t.charCodeAt(1) === Ks && gr(t.charCodeAt(0))) {
            e = s = 2;
          }
          for (let a = t.length - 1; a >= e; --a) {
            const c = t.charCodeAt(a);
            if (ge(c)) {
              if (!n) {
                s = a + 1;
                break;
              }
              continue;
            }
            if (r === -1) {
              n = false;
              r = a + 1;
            }
            if (c === Js) {
              if (i === -1) {
                i = a;
              } else if (o !== 1) {
                o = 1;
              }
            } else if (i !== -1) {
              o = -1;
            }
          }
          if (i === -1 || r === -1 || o === 0 || o === 1 && i === r - 1 && i === s + 1) {
            return "";
          } else {
            return t.slice(i, r);
          }
        },
        format: qw.bind(null, "\\"),
        parse(t) {
          ut(t, "path");
          const e = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
          };
          if (t.length === 0) {
            return e;
          }
          const i = t.length;
          let s = 0;
          let r = t.charCodeAt(0);
          if (i === 1) {
            if (ge(r)) {
              e.root = e.dir = t;
              return e;
            } else {
              e.base = e.name = t;
              return e;
            }
          }
          if (ge(r)) {
            s = 1;
            if (ge(t.charCodeAt(1))) {
              let d = 2;
              let f = d;
              while (d < i && !ge(t.charCodeAt(d))) {
                d++;
              }
              if (d < i && d !== f) {
                for (f = d; d < i && ge(t.charCodeAt(d));) {
                  d++;
                }
                if (d < i && d !== f) {
                  for (f = d; d < i && !ge(t.charCodeAt(d));) {
                    d++;
                  }
                  if (d === i) {
                    s = d;
                  } else if (d !== f) {
                    s = d + 1;
                  }
                }
              }
            }
          } else if (gr(r) && t.charCodeAt(1) === Ks) {
            if (i <= 2) {
              e.root = e.dir = t;
              return e;
            }
            s = 2;
            if (ge(t.charCodeAt(2))) {
              if (i === 3) {
                e.root = e.dir = t;
                return e;
              }
              s = 3;
            }
          }
          if (s > 0) {
            e.root = t.slice(0, s);
          }
          let n = -1;
          let o = s;
          let a = -1;
          let c = true;
          let l = t.length - 1;
          let u = 0;
          for (; l >= s; --l) {
            r = t.charCodeAt(l);
            if (ge(r)) {
              if (!c) {
                o = l + 1;
                break;
              }
              continue;
            }
            if (a === -1) {
              c = false;
              a = l + 1;
            }
            if (r === Js) {
              if (n === -1) {
                n = l;
              } else if (u !== 1) {
                u = 1;
              }
            } else if (n !== -1) {
              u = -1;
            }
          }
          if (a !== -1) {
            if (n === -1 || u === 0 || u === 1 && n === a - 1 && n === o + 1) {
              e.base = e.name = t.slice(o, a);
            } else {
              e.name = t.slice(o, n);
              e.base = t.slice(o, a);
              e.ext = t.slice(n, a);
            }
          }
          if (o > 0 && o !== s) {
            e.dir = t.slice(0, o - 1);
          } else {
            e.dir = e.root;
          }
          return e;
        },
        sep: "\\",
        delimiter: ";",
        win32: null,
        posix: null
      };
      Kw = (() => {
        if (fi) {
          const t = /\\/g;
          return () => {
            const e = bs().replace(t, "/");
            return e.slice(e.indexOf("/"));
          };
        }
        return () => bs();
      })();
      ae = {
        resolve(...t) {
          let e = "";
          let i = false;
          for (let s = t.length - 1; s >= -1 && !i; s--) {
            const r = s >= 0 ? t[s] : Kw();
            ut(r, `paths[${s}]`);
            if (r.length !== 0) {
              e = `${r}/${e}`;
              i = r.charCodeAt(0) === It;
            }
          }
          e = Jl(e, !i, "/", np);
          if (i) {
            return `/${e}`;
          } else if (e.length > 0) {
            return e;
          } else {
            return ".";
          }
        },
        normalize(t) {
          ut(t, "path");
          if (t.length === 0) {
            return ".";
          }
          const e = t.charCodeAt(0) === It;
          const i = t.charCodeAt(t.length - 1) === It;
          t = Jl(t, !e, "/", np);
          if (t.length === 0) {
            if (e) {
              return "/";
            } else if (i) {
              return "./";
            } else {
              return ".";
            }
          } else {
            if (i) {
              t += "/";
            }
            if (e) {
              return `/${t}`;
            } else {
              return t;
            }
          }
        },
        isAbsolute(t) {
          ut(t, "path");
          return t.length > 0 && t.charCodeAt(0) === It;
        },
        join(...t) {
          if (t.length === 0) {
            return ".";
          }
          let e;
          for (let i = 0; i < t.length; ++i) {
            const s = t[i];
            ut(s, "path");
            if (s.length > 0) {
              if (e === undefined) {
                e = s;
              } else {
                e += `/${s}`;
              }
            }
          }
          if (e === undefined) {
            return ".";
          } else {
            return ae.normalize(e);
          }
        },
        relative(t, e) {
          ut(t, "from");
          ut(e, "to");
          if (t === e || (t = ae.resolve(t), e = ae.resolve(e), t === e)) {
            return "";
          }
          const i = 1;
          const s = t.length;
          const r = s - i;
          const n = 1;
          const o = e.length - n;
          const a = r < o ? r : o;
          let c = -1;
          let l = 0;
          for (; l < a; l++) {
            const d = t.charCodeAt(i + l);
            if (d !== e.charCodeAt(n + l)) {
              break;
            }
            if (d === It) {
              c = l;
            }
          }
          if (l === a) {
            if (o > a) {
              if (e.charCodeAt(n + l) === It) {
                return e.slice(n + l + 1);
              }
              if (l === 0) {
                return e.slice(n + l);
              }
            } else if (r > a) {
              if (t.charCodeAt(i + l) === It) {
                c = l;
              } else if (l === 0) {
                c = 0;
              }
            }
          }
          let u = "";
          for (l = i + c + 1; l <= s; ++l) {
            if (l === s || t.charCodeAt(l) === It) {
              u += u.length === 0 ? ".." : "/..";
            }
          }
          return `${u}${e.slice(n + c)}`;
        },
        toNamespacedPath(t) {
          return t;
        },
        dirname(t) {
          ut(t, "path");
          if (t.length === 0) {
            return ".";
          }
          const e = t.charCodeAt(0) === It;
          let i = -1;
          let s = true;
          for (let r = t.length - 1; r >= 1; --r) {
            if (t.charCodeAt(r) === It) {
              if (!s) {
                i = r;
                break;
              }
            } else {
              s = false;
            }
          }
          if (i === -1) {
            if (e) {
              return "/";
            } else {
              return ".";
            }
          } else if (e && i === 1) {
            return "//";
          } else {
            return t.slice(0, i);
          }
        },
        basename(t, e) {
          if (e !== undefined) {
            ut(e, "ext");
          }
          ut(t, "path");
          let i = 0;
          let s = -1;
          let r = true;
          let n;
          if (e !== undefined && e.length > 0 && e.length <= t.length) {
            if (e === t) {
              return "";
            }
            let o = e.length - 1;
            let a = -1;
            for (n = t.length - 1; n >= 0; --n) {
              const c = t.charCodeAt(n);
              if (c === It) {
                if (!r) {
                  i = n + 1;
                  break;
                }
              } else {
                if (a === -1) {
                  r = false;
                  a = n + 1;
                }
                if (o >= 0) {
                  if (c === e.charCodeAt(o)) {
                    if (--o === -1) {
                      s = n;
                    }
                  } else {
                    o = -1;
                    s = a;
                  }
                }
              }
            }
            if (i === s) {
              s = a;
            } else if (s === -1) {
              s = t.length;
            }
            return t.slice(i, s);
          }
          for (n = t.length - 1; n >= 0; --n) {
            if (t.charCodeAt(n) === It) {
              if (!r) {
                i = n + 1;
                break;
              }
            } else if (s === -1) {
              r = false;
              s = n + 1;
            }
          }
          if (s === -1) {
            return "";
          } else {
            return t.slice(i, s);
          }
        },
        extname(t) {
          ut(t, "path");
          let e = -1;
          let i = 0;
          let s = -1;
          let r = true;
          let n = 0;
          for (let o = t.length - 1; o >= 0; --o) {
            const a = t.charCodeAt(o);
            if (a === It) {
              if (!r) {
                i = o + 1;
                break;
              }
              continue;
            }
            if (s === -1) {
              r = false;
              s = o + 1;
            }
            if (a === Js) {
              if (e === -1) {
                e = o;
              } else if (n !== 1) {
                n = 1;
              }
            } else if (e !== -1) {
              n = -1;
            }
          }
          if (e === -1 || s === -1 || n === 0 || n === 1 && e === s - 1 && e === i + 1) {
            return "";
          } else {
            return t.slice(e, s);
          }
        },
        format: qw.bind(null, "/"),
        parse(t) {
          ut(t, "path");
          const e = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
          };
          if (t.length === 0) {
            return e;
          }
          const i = t.charCodeAt(0) === It;
          let s;
          if (i) {
            e.root = "/";
            s = 1;
          } else {
            s = 0;
          }
          let r = -1;
          let n = 0;
          let o = -1;
          let a = true;
          let c = t.length - 1;
          let l = 0;
          for (; c >= s; --c) {
            const u = t.charCodeAt(c);
            if (u === It) {
              if (!a) {
                n = c + 1;
                break;
              }
              continue;
            }
            if (o === -1) {
              a = false;
              o = c + 1;
            }
            if (u === Js) {
              if (r === -1) {
                r = c;
              } else if (l !== 1) {
                l = 1;
              }
            } else if (r !== -1) {
              l = -1;
            }
          }
          if (o !== -1) {
            const u = n === 0 && i ? 1 : n;
            if (r === -1 || l === 0 || l === 1 && r === o - 1 && r === n + 1) {
              e.base = e.name = t.slice(u, o);
            } else {
              e.name = t.slice(u, r);
              e.base = t.slice(u, o);
              e.ext = t.slice(r, o);
            }
          }
          if (n > 0) {
            e.dir = t.slice(0, n - 1);
          } else if (i) {
            e.dir = "/";
          }
          return e;
        },
        sep: "/",
        delimiter: ":",
        win32: null,
        posix: null
      };
      ae.win32 = Ge.win32 = Ge;
      ae.posix = Ge.posix = ae;
      pi = fi ? Ge.normalize : ae.normalize;
      Zr = fi ? Ge.isAbsolute : ae.isAbsolute;
      F = fi ? Ge.join : ae.join;
      Gi = fi ? Ge.resolve : ae.resolve;
      Zw = fi ? Ge.relative : ae.relative;
      Xe = fi ? Ge.dirname : ae.dirname;
      Ue = fi ? Ge.basename : ae.basename;
      Kl = fi ? Ge.extname : ae.extname;
      hE = fi ? Ge.format : ae.format;
      dE = fi ? Ge.parse : ae.parse;
      fE = fi ? Ge.toNamespacedPath : ae.toNamespacedPath;
      Vt = fi ? Ge.sep : ae.sep;
      Zl = fi ? Ge.delimiter : ae.delimiter;
    }
  });
  function pE(t, e) {
    if (!t.scheme && e) {
      throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t.authority}", path: "${t.path}", query: "${t.query}", fragment: "${t.fragment}"}`);
    }
    if (t.scheme && !Qw.test(t.scheme)) {
      throw new Error("[UriError]: Scheme contains illegal characters.");
    }
    if (t.path) {
      if (t.authority) {
        if (!ev.test(t.path)) {
          throw new Error("[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character");
        }
      } else if (tv.test(t.path)) {
        throw new Error("[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")");
      }
    }
  }
  function gE(t, e) {
    if (!t && !e) {
      return "file";
    } else {
      return t;
    }
  }
  function mE(t, e) {
    switch (t) {
      case "https":
      case "http":
      case "file":
        if (e) {
          if (e[0] !== Ji) {
            e = Ji + e;
          }
        } else {
          e = Ji;
        }
        break;
    }
    return e;
  }
  function Yw(t, e, i) {
    let s;
    let r = -1;
    for (let n = 0; n < t.length; n++) {
      const o = t.charCodeAt(n);
      if (o >= 97 && o <= 122 || o >= 65 && o <= 90 || o >= 48 && o <= 57 || o === 45 || o === 46 || o === 95 || o === 126 || e && o === 47 || i && o === 91 || i && o === 93 || i && o === 58) {
        if (r !== -1) {
          s += encodeURIComponent(t.substring(r, n));
          r = -1;
        }
        if (s !== undefined) {
          s += t.charAt(n);
        }
      } else {
        if (s === undefined) {
          s = t.substr(0, n);
        }
        const a = lp[o];
        if (a !== undefined) {
          if (r !== -1) {
            s += encodeURIComponent(t.substring(r, n));
            r = -1;
          }
          s += a;
        } else if (r === -1) {
          r = n;
        }
      }
    }
    if (r !== -1) {
      s += encodeURIComponent(t.substring(r));
    }
    if (s !== undefined) {
      return s;
    } else {
      return t;
    }
  }
  function wE(t) {
    let e;
    for (let i = 0; i < t.length; i++) {
      const s = t.charCodeAt(i);
      if (s === 35 || s === 63) {
        if (e === undefined) {
          e = t.substr(0, i);
        }
        e += lp[s];
      } else if (e !== undefined) {
        e += t[i];
      }
    }
    if (e !== undefined) {
      return e;
    } else {
      return t;
    }
  }
  function Yl(t, e) {
    let i;
    if (t.authority && t.path.length > 1 && t.scheme === "file") {
      i = `//${t.authority}${t.path}`;
    } else if (t.path.charCodeAt(0) === 47 && (t.path.charCodeAt(1) >= 65 && t.path.charCodeAt(1) <= 90 || t.path.charCodeAt(1) >= 97 && t.path.charCodeAt(1) <= 122) && t.path.charCodeAt(2) === 58) {
      if (e) {
        i = t.path.substr(1);
      } else {
        i = t.path[1].toLowerCase() + t.path.substr(2);
      }
    } else {
      i = t.path;
    }
    if (j) {
      i = i.replace(/\//g, "\\");
    }
    return i;
  }
  function ap(t, e) {
    const i = e ? wE : Yw;
    let s = "";
    let {
      scheme: r,
      authority: n,
      path: o,
      query: a,
      fragment: c
    } = t;
    if (r) {
      s += r;
      s += ":";
    }
    if (n || r === "file") {
      s += Ji;
      s += Ji;
    }
    if (n) {
      let l = n.indexOf("@");
      if (l !== -1) {
        const u = n.substr(0, l);
        n = n.substr(l + 1);
        l = u.lastIndexOf(":");
        if (l === -1) {
          s += i(u, false, false);
        } else {
          s += i(u.substr(0, l), false, false);
          s += ":";
          s += i(u.substr(l + 1), false, true);
        }
        s += "@";
      }
      n = n.toLowerCase();
      l = n.lastIndexOf(":");
      if (l === -1) {
        s += i(n, false, true);
      } else {
        s += i(n.substr(0, l), false, true);
        s += n.substr(l);
      }
    }
    if (o) {
      if (o.length >= 3 && o.charCodeAt(0) === 47 && o.charCodeAt(2) === 58) {
        const l = o.charCodeAt(1);
        if (l >= 65 && l <= 90) {
          o = `/${String.fromCharCode(l + 32)}:${o.substr(3)}`;
        }
      } else if (o.length >= 2 && o.charCodeAt(1) === 58) {
        const l = o.charCodeAt(0);
        if (l >= 65 && l <= 90) {
          o = `${String.fromCharCode(l + 32)}:${o.substr(2)}`;
        }
      }
      s += i(o, true, false);
    }
    if (a) {
      s += "?";
      s += i(a, false, false);
    }
    if (c) {
      s += "#";
      s += e ? c : Yw(c, false, false);
    }
    return s;
  }
  function Xw(t) {
    try {
      return decodeURIComponent(t);
    } catch {
      if (t.length > 3) {
        return t.substr(0, 3) + Xw(t.substr(3));
      } else {
        return t;
      }
    }
  }
  function Xl(t) {
    if (t.match(up)) {
      return t.replace(up, e => Xw(e));
    } else {
      return t;
    }
  }
  var Qw;
  var ev;
  var tv;
  var Be;
  var Ji;
  var iv;
  var P;
  var cp;
  var Yr;
  var lp;
  var up;
  var se = g({
    "out-build/vs/base/common/uri.js"() {
      "use strict";
  
      we();
      H();
      Qw = /^\w[\w\d+.-]*$/;
      ev = /^\//;
      tv = /^\/\//;
      Be = "";
      Ji = "/";
      iv = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
      P = class Sf {
        static isUri(e) {
          if (e instanceof Sf) {
            return true;
          } else if (e) {
            return typeof e.authority == "string" && typeof e.fragment == "string" && typeof e.path == "string" && typeof e.query == "string" && typeof e.scheme == "string" && typeof e.fsPath == "string" && typeof e.with == "function" && typeof e.toString == "function";
          } else {
            return false;
          }
        }
        constructor(e, i, s, r, n, o = false) {
          if (typeof e == "object") {
            this.scheme = e.scheme || Be;
            this.authority = e.authority || Be;
            this.path = e.path || Be;
            this.query = e.query || Be;
            this.fragment = e.fragment || Be;
          } else {
            this.scheme = gE(e, o);
            this.authority = i || Be;
            this.path = mE(this.scheme, s || Be);
            this.query = r || Be;
            this.fragment = n || Be;
            pE(this, o);
          }
        }
        get fsPath() {
          return Yl(this, false);
        }
        with(e) {
          if (!e) {
            return this;
          }
          let {
            scheme: i,
            authority: s,
            path: r,
            query: n,
            fragment: o
          } = e;
          if (i === undefined) {
            i = this.scheme;
          } else if (i === null) {
            i = Be;
          }
          if (s === undefined) {
            s = this.authority;
          } else if (s === null) {
            s = Be;
          }
          if (r === undefined) {
            r = this.path;
          } else if (r === null) {
            r = Be;
          }
          if (n === undefined) {
            n = this.query;
          } else if (n === null) {
            n = Be;
          }
          if (o === undefined) {
            o = this.fragment;
          } else if (o === null) {
            o = Be;
          }
          if (i === this.scheme && s === this.authority && r === this.path && n === this.query && o === this.fragment) {
            return this;
          } else {
            return new Yr(i, s, r, n, o);
          }
        }
        static parse(e, i = false) {
          const s = iv.exec(e);
          if (s) {
            return new Yr(s[2] || Be, Xl(s[4] || Be), Xl(s[5] || Be), Xl(s[7] || Be), Xl(s[9] || Be), i);
          } else {
            return new Yr(Be, Be, Be, Be, Be);
          }
        }
        static file(e) {
          let i = Be;
          if (j) {
            e = e.replace(/\\/g, Ji);
          }
          if (e[0] === Ji && e[1] === Ji) {
            const s = e.indexOf(Ji, 2);
            if (s === -1) {
              i = e.substring(2);
              e = Ji;
            } else {
              i = e.substring(2, s);
              e = e.substring(s) || Ji;
            }
          }
          return new Yr("file", i, e, Be, Be);
        }
        static from(e, i) {
          return new Yr(e.scheme, e.authority, e.path, e.query, e.fragment, i);
        }
        static joinPath(e, ...i) {
          if (!e.path) {
            throw new Error("[UriError]: cannot call joinPath on URI without path");
          }
          let s;
          if (j && e.scheme === "file") {
            s = Sf.file(Ge.join(Yl(e, true), ...i)).path;
          } else {
            s = ae.join(e.path, ...i);
          }
          return e.with({
            path: s
          });
        }
        toString(e = false) {
          return ap(this, e);
        }
        toJSON() {
          return this;
        }
        static revive(e) {
          if (e) {
            if (e instanceof Sf) {
              return e;
            }
            {
              const i = new Yr(e);
              i._formatted = e.external ?? null;
              i._fsPath = e._sep === cp ? e.fsPath ?? null : null;
              return i;
            }
          } else {
            return e;
          }
        }
        [Symbol.for("debug.description")]() {
          return `URI(${this.toString()})`;
        }
      };
      cp = j ? 1 : undefined;
      Yr = class extends P {
        constructor() {
          super(...arguments);
          this._formatted = null;
          this._fsPath = null;
        }
        get fsPath() {
          this._fsPath ||= Yl(this, false);
          return this._fsPath;
        }
        toString(t = false) {
          if (t) {
            return ap(this, true);
          } else {
            this._formatted ||= ap(this, false);
            return this._formatted;
          }
        }
        toJSON() {
          const t = {
            $mid: 1
          };
          if (this._fsPath) {
            t.fsPath = this._fsPath;
            t._sep = cp;
          }
          if (this._formatted) {
            t.external = this._formatted;
          }
          if (this.path) {
            t.path = this.path;
          }
          if (this.scheme) {
            t.scheme = this.scheme;
          }
          if (this.authority) {
            t.authority = this.authority;
          }
          if (this.query) {
            t.query = this.query;
          }
          if (this.fragment) {
            t.fragment = this.fragment;
          }
          return t;
        }
      };
      lp = {
        58: "%3A",
        47: "%2F",
        63: "%3F",
        35: "%23",
        91: "%5B",
        93: "%5D",
        64: "%40",
        33: "%21",
        36: "%24",
        38: "%26",
        39: "%27",
        40: "%28",
        41: "%29",
        42: "%2A",
        43: "%2B",
        44: "%2C",
        59: "%3B",
        61: "%3D",
        32: "%20"
      };
      up = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
    }
  });
  function vE(t, e, i) {
    if (e[rs.DI_TARGET] === e) {
      e[rs.DI_DEPENDENCIES].push({
        id: t,
        index: i
      });
    } else {
      e[rs.DI_DEPENDENCIES] = [{
        id: t,
        index: i
      }];
      e[rs.DI_TARGET] = e;
    }
  }
  function q(t) {
    if (rs.serviceIds.has(t)) {
      return rs.serviceIds.get(t);
    }
    const e = function (i, s, r) {
      if (arguments.length !== 3) {
        throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
      }
      vE(e, i, r);
    };
    e.toString = () => t;
    rs.serviceIds.set(t, e);
    return e;
  }
  function dN(t) {
    return t;
  }
  var rs;
  var Ss;
  var Y = g({
    "out-build/vs/platform/instantiation/common/instantiation.js"() {
      "use strict";
  
      (function (t) {
        t.serviceIds = new Map();
        t.DI_TARGET = "$di$target";
        t.DI_DEPENDENCIES = "$di$dependencies";
        function e(i) {
          return i[t.DI_DEPENDENCIES] || [];
        }
        t.getServiceDependencies = e;
      })(rs ||= {});
      Ss = q("instantiationService");
    }
  });
  function hp(t) {
    return t && typeof t == "object" && (!t.overrideIdentifier || typeof t.overrideIdentifier == "string") && (!t.resource || t.resource instanceof P);
  }
  function bE(t) {
    return t && typeof t == "object" && (!t.overrideIdentifiers || Array.isArray(t.overrideIdentifiers)) && !t.overrideIdentifier && (!t.resource || t.resource instanceof P);
  }
  function dp(t, e) {
    const i = Object.create(null);
    for (const s in t) {
      sv(i, s, t[s], e);
    }
    return i;
  }
  function sv(t, e, i, s) {
    const r = e.split(".");
    const n = r.pop();
    let o = t;
    for (let a = 0; a < r.length; a++) {
      const c = r[a];
      let l = o[c];
      switch (typeof l) {
        case "undefined":
          l = o[c] = Object.create(null);
          break;
        case "object":
          if (l === null) {
            s(`Ignoring ${e} as ${r.slice(0, a + 1).join(".")} is null`);
            return;
          }
          break;
        default:
          s(`Ignoring ${e} as ${r.slice(0, a + 1).join(".")} is ${JSON.stringify(l)}`);
          return;
      }
      o = l;
    }
    if (typeof o == "object" && o !== null) {
      try {
        o[n] = i;
      } catch {
        s(`Ignoring ${e} as ${r.join(".")} is ${JSON.stringify(o)}`);
      }
    } else {
      s(`Ignoring ${e} as ${r.join(".")} is ${JSON.stringify(o)}`);
    }
  }
  function yE(t, e) {
    const i = e.split(".");
    rv(t, i);
  }
  function rv(t, e) {
    const i = e.shift();
    if (e.length === 0) {
      delete t[i];
      return;
    }
    if (Object.keys(t).indexOf(i) !== -1) {
      const s = t[i];
      if (typeof s == "object" && !Array.isArray(s)) {
        rv(s, e);
        if (Object.keys(s).length === 0) {
          delete t[i];
        }
      }
    }
  }
  function Ql(t, e, i) {
    function s(o, a) {
      let c = o;
      for (const l of a) {
        if (typeof c != "object" || c === null) {
          return;
        }
        c = c[l];
      }
      return c;
    }
    const r = e.split(".");
    const n = s(t, r);
    if (typeof n === "undefined") {
      return i;
    } else {
      return n;
    }
  }
  function SE(t) {
    return t.replace(/[\[\]]/g, "");
  }
  var Je;
  var nv;
  var Ke = g({
    "out-build/vs/platform/configuration/common/configuration.js"() {
      "use strict";
  
      _e();
      se();
      Y();
      Je = q("configurationService");
      (function (t) {
        t[t.APPLICATION = 1] = "APPLICATION";
        t[t.USER = 2] = "USER";
        t[t.USER_LOCAL = 3] = "USER_LOCAL";
        t[t.USER_REMOTE = 4] = "USER_REMOTE";
        t[t.WORKSPACE = 5] = "WORKSPACE";
        t[t.WORKSPACE_FOLDER = 6] = "WORKSPACE_FOLDER";
        t[t.DEFAULT = 7] = "DEFAULT";
        t[t.MEMORY = 8] = "MEMORY";
      })(nv ||= {});
    }
  });
  function EE(t) {
    let e = false;
    const i = new Map();
    const s = new Map();
    kE(t, u => {
      if (t === u) {
        return true;
      }
      const d = JSON.stringify(u);
      if (d.length < 30) {
        return true;
      }
      const f = i.get(d);
      if (!f) {
        const p = {
          schemas: [u]
        };
        i.set(d, p);
        s.set(u, p);
        return true;
      }
      f.schemas.push(u);
      s.set(u, f);
      e = true;
      return false;
    });
    i.clear();
    if (!e) {
      return JSON.stringify(t);
    }
    let n = "$defs";
    while (t.hasOwnProperty(n)) {
      n += "_";
    }
    const o = [];
    function a(u) {
      return JSON.stringify(u, (d, f) => {
        if (f !== u) {
          const p = s.get(f);
          if (p && p.schemas.length > 1) {
            if (!p.id) {
              p.id = `_${o.length}`;
              o.push(p.schemas[0]);
            }
            return {
              $ref: `#/${n}/${p.id}`
            };
          }
        }
        return f;
      });
    }
    const c = a(t);
    const l = [];
    for (let u = 0; u < o.length; u++) {
      l.push(`"_${u}":${a(o[u])}`);
    }
    if (l.length) {
      return `${c.substring(0, c.length - 1)},"${n}":{${l.join(",")}}}`;
    } else {
      return c;
    }
  }
  function Zn(t) {
    return typeof t == "object" && t !== null;
  }
  function kE(t, e) {
    if (!t || typeof t != "object") {
      return;
    }
    const i = (...c) => {
      for (const l of c) {
        if (Zn(l)) {
          o.push(l);
        }
      }
    };
    const s = (...c) => {
      for (const l of c) {
        if (Zn(l)) {
          for (const u in l) {
            const d = l[u];
            if (Zn(d)) {
              o.push(d);
            }
          }
        }
      }
    };
    const r = (...c) => {
      for (const l of c) {
        if (Array.isArray(l)) {
          for (const u of l) {
            if (Zn(u)) {
              o.push(u);
            }
          }
        }
      }
    };
    const n = c => {
      if (Array.isArray(c)) {
        for (const l of c) {
          if (Zn(l)) {
            o.push(l);
          }
        }
      } else if (Zn(c)) {
        o.push(c);
      }
    };
    const o = [t];
    let a = o.pop();
    while (a) {
      if (e(a)) {
        i(a.additionalItems, a.additionalProperties, a.not, a.contains, a.propertyNames, a.if, a.then, a.else, a.unevaluatedItems, a.unevaluatedProperties);
        s(a.definitions, a.$defs, a.properties, a.patternProperties, a.dependencies, a.dependentSchemas);
        r(a.anyOf, a.allOf, a.oneOf, a.prefixItems);
        n(a.items);
      }
      a = o.pop();
    }
  }
  var xE = g({
    "out-build/vs/base/common/jsonSchema.js"() {
      "use strict";
    }
  });
  function fp(t, e) {
    if (!t) {
      throw new Error(e ? `Assertion failed (${e})` : "Assertion Failed");
    }
  }
  var DE = g({
    "out-build/vs/base/common/assert.js"() {
      "use strict";
  
      $e();
    }
  });
  var ov;
  var Gt;
  var Zs = g({
    "out-build/vs/platform/registry/common/platform.js"() {
      "use strict";
  
      DE();
      _e();
      ov = class {
        constructor() {
          this.a = new Map();
        }
        add(t, e) {
          fp(wt(t));
          fp(Nt(e));
          fp(!this.a.has(t), "There is already an extension with this id");
          this.a.set(t, e);
        }
        knows(t) {
          return this.a.has(t);
        }
        as(t) {
          return this.a.get(t) || null;
        }
      };
      Gt = new ov();
    }
  });
  function PE(t) {
    if (t.length > 0 && t.charAt(t.length - 1) === "#") {
      return t.substring(0, t.length - 1);
    } else {
      return t;
    }
  }
  var pp;
  var av;
  var cv;
  var $E = g({
    "out-build/vs/platform/jsonschemas/common/jsonContributionRegistry.js"() {
      "use strict";
  
      B();
      xE();
      Zs();
      pp = {
        JSONContribution: "base.contributions.json"
      };
      av = class {
        constructor() {
          this.b = new $();
          this.onDidChangeSchema = this.b.event;
          this.a = {};
        }
        registerSchema(t, e) {
          this.a[PE(t)] = e;
          this.b.fire(t);
        }
        notifySchemaChanged(t) {
          this.b.fire(t);
        }
        getSchemaContributions() {
          return {
            schemas: this.a
          };
        }
        getSchemaContent(t) {
          const e = this.a[t];
          if (e) {
            return EE(e);
          } else {
            return undefined;
          }
        }
        hasSchemaContent(t) {
          return !!this.a[t];
        }
      };
      cv = new av();
      Gt.add(pp.JSONContribution, cv);
    }
  });
  function Ca(t) {
    const e = [];
    if (Es.test(t)) {
      let i = mp.exec(t);
      while (i?.length) {
        const s = i[1].trim();
        if (s) {
          e.push(s);
        }
        i = mp.exec(t);
      }
    }
    return ss(e);
  }
  function IE(t) {
    return t.reduce((e, i) => `${e}[${i}]`, "");
  }
  function AE(t) {
    switch (Array.isArray(t) ? t[0] : t) {
      case "boolean":
        return false;
      case "integer":
      case "number":
        return 0;
      case "string":
        return "";
      case "array":
        return [];
      case "object":
        return {};
      default:
        return null;
    }
  }
  function CE(t, e) {
    if (t.trim()) {
      if (Es.test(t)) {
        return v(1704, null, t);
      } else if (Na.getConfigurationProperties()[t] !== undefined) {
        return v(1705, null, t);
      } else if (e.policy?.name && Na.getPolicyConfigurations().get(e.policy?.name) !== undefined) {
        return v(1706, null, t, e.policy?.name, Na.getPolicyConfigurations().get(e.policy?.name));
      } else {
        return null;
      }
    } else {
      return v(1703, null);
    }
  }
  var lv;
  var Ai;
  var uv;
  var _a;
  var Ra;
  var Oa;
  var La;
  var Ma;
  var Yn;
  var mr;
  var Fa;
  var hv;
  var gp;
  var mp;
  var wr;
  var Es;
  var Na;
  var Xr = g({
    "out-build/vs/platform/configuration/common/configurationRegistry.js"() {
      "use strict";
  
      zt();
      B();
      _e();
      be();
      Ke();
      $E();
      Zs();
      (function (t) {
        t.Multiline = "multilineText";
        t.Singleline = "singlelineText";
      })(lv ||= {});
      Ai = {
        Configuration: "base.contributions.configuration"
      };
      (function (t) {
        t[t.APPLICATION = 1] = "APPLICATION";
        t[t.MACHINE = 2] = "MACHINE";
        t[t.WINDOW = 3] = "WINDOW";
        t[t.RESOURCE = 4] = "RESOURCE";
        t[t.LANGUAGE_OVERRIDABLE = 5] = "LANGUAGE_OVERRIDABLE";
        t[t.MACHINE_OVERRIDABLE = 6] = "MACHINE_OVERRIDABLE";
      })(uv ||= {});
      _a = {
        properties: {},
        patternProperties: {}
      };
      Ra = {
        properties: {},
        patternProperties: {}
      };
      Oa = {
        properties: {},
        patternProperties: {}
      };
      La = {
        properties: {},
        patternProperties: {}
      };
      Ma = {
        properties: {},
        patternProperties: {}
      };
      Yn = {
        properties: {},
        patternProperties: {}
      };
      mr = "vscode://schemas/settings/resourceLanguage";
      Fa = Gt.as(pp.JSONContribution);
      hv = class {
        constructor() {
          this.a = [];
          this.i = new Set();
          this.j = new $();
          this.onDidSchemaChange = this.j.event;
          this.k = new $();
          this.onDidUpdateConfiguration = this.k.event;
          this.b = new Map();
          this.c = {
            id: "defaultOverrides",
            title: v(1697, null),
            properties: {}
          };
          this.d = [this.c];
          this.h = {
            properties: {},
            patternProperties: {},
            additionalProperties: true,
            allowTrailingCommas: true,
            allowComments: true
          };
          this.e = {};
          this.f = new Map();
          this.g = {};
          Fa.registerSchema(mr, this.h);
          this.z();
        }
        registerConfiguration(t, e = true) {
          this.registerConfigurations([t], e);
        }
        registerConfigurations(t, e = true) {
          const i = new Set();
          this.r(t, e, i);
          Fa.registerSchema(mr, this.h);
          this.j.fire();
          this.k.fire({
            properties: i
          });
        }
        deregisterConfigurations(t) {
          const e = new Set();
          this.s(t, e);
          Fa.registerSchema(mr, this.h);
          this.j.fire();
          this.k.fire({
            properties: e
          });
        }
        updateConfigurations({
          add: t,
          remove: e
        }) {
          const i = new Set();
          this.s(e, i);
          this.r(t, false, i);
          Fa.registerSchema(mr, this.h);
          this.j.fire();
          this.k.fire({
            properties: i
          });
        }
        registerDefaultConfigurations(t) {
          const e = new Set();
          this.l(t, e);
          this.j.fire();
          this.k.fire({
            properties: e,
            defaultsOverrides: true
          });
        }
        l(t, e) {
          this.a.push(...t);
          const i = [];
          for (const {
            overrides: s,
            source: r
          } of t) {
            for (const n in s) {
              e.add(n);
              const o = this.b.get(n) ?? this.b.set(n, {
                configurationDefaultOverrides: []
              }).get(n);
              const a = s[n];
              o.configurationDefaultOverrides.push({
                value: a,
                source: r
              });
              if (Es.test(n)) {
                const c = this.o(n, a, r, o.configurationDefaultOverrideValue);
                if (!c) {
                  continue;
                }
                o.configurationDefaultOverrideValue = c;
                this.n(n, c, r);
                i.push(...Ca(n));
              } else {
                const c = this.p(n, a, r, o.configurationDefaultOverrideValue);
                if (!c) {
                  continue;
                }
                o.configurationDefaultOverrideValue = c;
                const l = this.e[n];
                if (l) {
                  this.A(n, l);
                  this.w(n, l);
                }
              }
            }
          }
          this.q(i);
        }
        deregisterDefaultConfigurations(t) {
          const e = new Set();
          this.m(t, e);
          this.j.fire();
          this.k.fire({
            properties: e,
            defaultsOverrides: true
          });
        }
        m(t, e) {
          for (const i of t) {
            const s = this.a.indexOf(i);
            if (s !== -1) {
              this.a.splice(s, 1);
            }
          }
          for (const {
            overrides: i,
            source: s
          } of t) {
            for (const r in i) {
              const n = this.b.get(r);
              if (!n) {
                continue;
              }
              const o = n.configurationDefaultOverrides.findIndex(a => s ? a.source?.id === s.id : a.value === i[r]);
              if (o !== -1) {
                n.configurationDefaultOverrides.splice(o, 1);
                if (n.configurationDefaultOverrides.length === 0) {
                  this.b.delete(r);
                }
                if (Es.test(r)) {
                  let a;
                  for (const c of n.configurationDefaultOverrides) {
                    a = this.o(r, c.value, c.source, a);
                  }
                  if (a && !sp(a.value)) {
                    n.configurationDefaultOverrideValue = a;
                    this.n(r, a, s);
                  } else {
                    this.b.delete(r);
                    delete this.e[r];
                    delete this.c.properties[r];
                  }
                } else {
                  let a;
                  for (const l of n.configurationDefaultOverrides) {
                    a = this.p(r, l.value, l.source, a);
                  }
                  n.configurationDefaultOverrideValue = a;
                  const c = this.e[r];
                  if (c) {
                    this.A(r, c);
                    this.w(r, c);
                  }
                }
                e.add(r);
              }
            }
          }
          this.y();
        }
        n(t, e, i) {
          const s = {
            type: "object",
            default: e.value,
            description: v(1698, null, SE(t)),
            $ref: mr,
            defaultDefaultValue: e.value,
            source: i,
            defaultValueSource: i
          };
          this.e[t] = s;
          this.c.properties[t] = s;
        }
        o(t, e, i, s) {
          const r = s?.value || {};
          const n = s?.source ?? new Map();
          if (!(n instanceof Map)) {
            console.error("objectConfigurationSources is not a Map");
            return;
          }
          for (const o of Object.keys(e)) {
            const a = e[o];
            if (Nt(a) && (Gs(r[o]) || Nt(r[o]))) {
              r[o] = {
                ...(r[o] ?? {}),
                ...a
              };
              if (i) {
                for (const l in a) {
                  n.set(`${o}.${l}`, i);
                }
              }
            } else {
              r[o] = a;
              if (i) {
                n.set(o, i);
              } else {
                n.delete(o);
              }
            }
          }
          return {
            value: r,
            source: n
          };
        }
        p(t, e, i, s) {
          const r = this.e[t];
          const n = s?.value ?? r?.defaultDefaultValue;
          let o = i;
          if (Nt(e) && (r !== undefined && r.type === "object" || r === undefined && (Gs(n) || Nt(n)))) {
            o = s?.source ?? new Map();
            if (!(o instanceof Map)) {
              console.error("defaultValueSource is not a Map");
              return;
            }
            for (const c in e) {
              if (i) {
                o.set(`${t}.${c}`, i);
              }
            }
            e = {
              ...(Nt(n) ? n : {}),
              ...e
            };
          }
          return {
            value: e,
            source: o
          };
        }
        deltaConfiguration(t) {
          let e = false;
          const i = new Set();
          if (t.removedDefaults) {
            this.m(t.removedDefaults, i);
            e = true;
          }
          if (t.addedDefaults) {
            this.l(t.addedDefaults, i);
            e = true;
          }
          if (t.removedConfigurations) {
            this.s(t.removedConfigurations, i);
          }
          if (t.addedConfigurations) {
            this.r(t.addedConfigurations, false, i);
          }
          this.j.fire();
          this.k.fire({
            properties: i,
            defaultsOverrides: e
          });
        }
        notifyConfigurationSchemaUpdated(...t) {
          this.j.fire();
        }
        registerOverrideIdentifiers(t) {
          this.q(t);
          this.j.fire();
        }
        q(t) {
          for (const e of t) {
            this.i.add(e);
          }
          this.y();
        }
        r(t, e, i) {
          t.forEach(s => {
            this.u(s, e, s.extensionInfo, s.restrictedProperties, undefined, i);
            this.d.push(s);
            this.v(s);
          });
        }
        s(t, e) {
          const i = s => {
            if (s.properties) {
              for (const r in s.properties) {
                e.add(r);
                const n = this.e[r];
                if (n?.policy?.name) {
                  this.f.delete(n.policy.name);
                }
                delete this.e[r];
                this.x(r, s.properties[r]);
              }
            }
            s.allOf?.forEach(r => i(r));
          };
          for (const s of t) {
            i(s);
            const r = this.d.indexOf(s);
            if (r !== -1) {
              this.d.splice(r, 1);
            }
          }
        }
        u(t, e = true, i, s, r = 3, n) {
          r = Qt(t.scope) ? r : t.scope;
          const o = t.properties;
          if (o) {
            for (const c in o) {
              const l = o[c];
              if (e && CE(c, l)) {
                delete o[c];
                continue;
              }
              l.source = i;
              l.defaultDefaultValue = o[c].default;
              this.A(c, l);
              if (Es.test(c)) {
                l.scope = undefined;
              } else {
                l.scope = Qt(l.scope) ? r : l.scope;
                l.restricted = Qt(l.restricted) ? !!s?.includes(c) : l.restricted;
              }
              if (o[c].hasOwnProperty("included") && !o[c].included) {
                this.g[c] = o[c];
                delete o[c];
                continue;
              } else {
                this.e[c] = o[c];
                if (o[c].policy?.name) {
                  this.f.set(o[c].policy.name, c);
                }
              }
              if (!o[c].deprecationMessage && o[c].markdownDeprecationMessage) {
                o[c].deprecationMessage = o[c].markdownDeprecationMessage;
              }
              n.add(c);
            }
          }
          const a = t.allOf;
          if (a) {
            for (const c of a) {
              this.u(c, e, i, s, r, n);
            }
          }
        }
        getConfigurations() {
          return this.d;
        }
        getConfigurationProperties() {
          return this.e;
        }
        getPolicyConfigurations() {
          return this.f;
        }
        getExcludedConfigurationProperties() {
          return this.g;
        }
        getRegisteredDefaultConfigurations() {
          return [...this.a];
        }
        getConfigurationDefaultsOverrides() {
          const t = new Map();
          for (const [e, i] of this.b) {
            if (i.configurationDefaultOverrideValue) {
              t.set(e, i.configurationDefaultOverrideValue);
            }
          }
          return t;
        }
        v(t) {
          const e = i => {
            const s = i.properties;
            if (s) {
              for (const n in s) {
                this.w(n, s[n]);
              }
            }
            i.allOf?.forEach(e);
          };
          e(t);
        }
        w(t, e) {
          _a.properties[t] = e;
          switch (e.scope) {
            case 1:
              Ra.properties[t] = e;
              break;
            case 2:
              Oa.properties[t] = e;
              break;
            case 6:
              La.properties[t] = e;
              break;
            case 3:
              Ma.properties[t] = e;
              break;
            case 4:
              Yn.properties[t] = e;
              break;
            case 5:
              Yn.properties[t] = e;
              this.h.properties[t] = e;
              break;
          }
        }
        x(t, e) {
          delete _a.properties[t];
          switch (e.scope) {
            case 1:
              delete Ra.properties[t];
              break;
            case 2:
              delete Oa.properties[t];
              break;
            case 6:
              delete La.properties[t];
              break;
            case 3:
              delete Ma.properties[t];
              break;
            case 4:
            case 5:
              delete Yn.properties[t];
              delete this.h.properties[t];
              break;
          }
        }
        y() {
          for (const t of this.i.values()) {
            const e = `[${t}]`;
            const i = {
              type: "object",
              description: v(1699, null),
              errorMessage: v(1700, null),
              $ref: mr
            };
            this.A(e, i);
            _a.properties[e] = i;
            Ra.properties[e] = i;
            Oa.properties[e] = i;
            La.properties[e] = i;
            Ma.properties[e] = i;
            Yn.properties[e] = i;
          }
        }
        z() {
          const t = {
            type: "object",
            description: v(1701, null),
            errorMessage: v(1702, null),
            $ref: mr
          };
          _a.patternProperties[wr] = t;
          Ra.patternProperties[wr] = t;
          Oa.patternProperties[wr] = t;
          La.patternProperties[wr] = t;
          Ma.patternProperties[wr] = t;
          Yn.patternProperties[wr] = t;
          this.j.fire();
        }
        A(t, e) {
          const i = this.b.get(t)?.configurationDefaultOverrideValue;
          let s;
          let r;
          if (i && (!e.disallowConfigurationDefault || !i.source)) {
            s = i.value;
            r = i.source;
          }
          if (Gs(s)) {
            s = e.defaultDefaultValue;
            r = undefined;
          }
          if (Gs(s)) {
            s = AE(e.type);
          }
          e.default = s;
          e.defaultValueSource = r;
        }
      };
      gp = "\\[([^\\]]+)\\]";
      mp = new RegExp(gp, "g");
      wr = `^(${gp})+$`;
      Es = new RegExp(wr);
      Na = new hv();
      Gt.add(Ai.Configuration, Na);
    }
  });
  var dv;
  var _E = g({
    "out-build/vs/platform/update/common/update.config.contribution.js"() {
      "use strict";
  
      H();
      be();
      Xr();
      Zs();
      dv = Gt.as(Ai.Configuration);
      dv.registerConfiguration({
        id: "update",
        order: 15,
        title: v(2474, null),
        type: "object",
        properties: {
          "update.mode": {
            type: "string",
            enum: ["none", "manual", "start", "default"],
            default: "default",
            scope: 1,
            description: v(2475, null),
            tags: ["usesOnlineServices"],
            enumDescriptions: [v(2476, null), v(2477, null), v(2478, null), v(2479, null)],
            policy: {
              name: "UpdateMode",
              minimumVersion: "1.67"
            }
          },
          "update.channel": {
            type: "string",
            default: "default",
            scope: 1,
            description: v(2480, null),
            deprecationMessage: v(2481, null, "update.mode")
          },
          "update.enableWindowsBackgroundUpdates": {
            type: "boolean",
            default: true,
            scope: 1,
            title: v(2482, null),
            description: v(2483, null),
            included: j && !fr
          },
          "update.showReleaseNotes": {
            type: "boolean",
            default: true,
            scope: 1,
            description: v(2484, null),
            tags: ["usesOnlineServices"]
          },
          "update.releaseTrack": {
            type: "string",
            default: "stable",
            scope: 1,
            description: v(2485, null)
          }
        }
      });
    }
  });
  var wp;
  var We;
  var Wa;
  var ns;
  var At = g({
    "out-build/vs/base/common/cancellation.js"() {
      "use strict";
  
      B();
      wp = Object.freeze(function (t, e) {
        const i = setTimeout(t.bind(e), 0);
        return {
          dispose() {
            clearTimeout(i);
          }
        };
      });
      (function (t) {
        function e(i) {
          if (i === t.None || i === t.Cancelled || i instanceof Wa) {
            return true;
          } else if (!i || typeof i != "object") {
            return false;
          } else {
            return typeof i.isCancellationRequested == "boolean" && typeof i.onCancellationRequested == "function";
          }
        }
        t.isCancellationToken = e;
        t.None = Object.freeze({
          isCancellationRequested: false,
          onCancellationRequested: x.None
        });
        t.Cancelled = Object.freeze({
          isCancellationRequested: true,
          onCancellationRequested: wp
        });
      })(We ||= {});
      Wa = class {
        constructor() {
          this.a = false;
          this.b = null;
        }
        cancel() {
          if (!this.a) {
            this.a = true;
            if (this.b) {
              this.b.fire(undefined);
              this.dispose();
            }
          }
        }
        get isCancellationRequested() {
          return this.a;
        }
        get onCancellationRequested() {
          if (this.a) {
            return wp;
          } else {
            this.b ||= new $();
            return this.b.event;
          }
        }
        dispose() {
          if (this.b) {
            this.b.dispose();
            this.b = null;
          }
        }
      };
      ns = class {
        constructor(t) {
          this.f = undefined;
          this.g = undefined;
          this.g = t && t.onCancellationRequested(this.cancel, this);
        }
        get token() {
          this.f ||= new Wa();
          return this.f;
        }
        cancel() {
          if (this.f) {
            if (this.f instanceof Wa) {
              this.f.cancel();
            }
          } else {
            this.f = We.Cancelled;
          }
        }
        dispose(t = false) {
          if (t) {
            this.cancel();
          }
          this.g?.dispose();
          if (this.f) {
            if (this.f instanceof Wa) {
              this.f.dispose();
            }
          } else {
            this.f = We.None;
          }
        }
      };
    }
  });
  function RE(t) {
    return t;
  }
  var fv;
  var OE = g({
    "out-build/vs/base/common/cache.js"() {
      "use strict";
  
      At();
      fv = class {
        constructor(t, e) {
          this.a = undefined;
          this.b = undefined;
          if (typeof t == "function") {
            this.c = t;
            this.d = RE;
          } else {
            this.c = e;
            this.d = t.getCacheKey;
          }
        }
        get(t) {
          const e = this.d(t);
          if (this.b !== e) {
            this.b = e;
            this.a = this.c(t);
          }
          return this.a;
        }
      };
    }
  });
  var vr;
  var Ta = g({
    "out-build/vs/base/common/lazy.js"() {
      "use strict";
  
      vr = class {
        constructor(t) {
          this.d = t;
          this.a = false;
        }
        get hasValue() {
          return this.a;
        }
        get value() {
          if (!this.a) {
            try {
              this.b = this.d();
            } catch (t) {
              this.c = t;
            } finally {
              this.a = true;
            }
          }
          if (this.c) {
            throw this.c;
          }
          return this.b;
        }
        get rawValue() {
          return this.b;
        }
      };
    }
  });
  function LE(t) {
    if (!t || typeof t != "string") {
      return true;
    } else {
      return t.trim().length === 0;
    }
  }
  function ja(t) {
    return t.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
  }
  function pv(t, e = " ") {
    const i = gv(t, e);
    return Qr(i, e);
  }
  function gv(t, e) {
    if (!t || !e) {
      return t;
    }
    const i = e.length;
    if (i === 0 || t.length === 0) {
      return t;
    }
    let s = 0;
    while (t.indexOf(e, s) === s) {
      s = s + i;
    }
    return t.substring(s);
  }
  function Qr(t, e) {
    if (!t || !e) {
      return t;
    }
    const i = e.length;
    const s = t.length;
    if (i === 0 || s === 0) {
      return t;
    }
    let r = s;
    let n = -1;
    while (n = t.lastIndexOf(e, r - 1), n !== -1 && n + i === r) {
      if (n === 0) {
        return "";
      }
      r = n;
    }
    return t.substring(0, r);
  }
  function vp(t, e) {
    if (t < e) {
      return -1;
    } else if (t > e) {
      return 1;
    } else {
      return 0;
    }
  }
  function bp(t, e, i = 0, s = t.length, r = 0, n = e.length) {
    for (; i < s && r < n; i++, r++) {
      const c = t.charCodeAt(i);
      const l = e.charCodeAt(r);
      if (c < l) {
        return -1;
      }
      if (c > l) {
        return 1;
      }
    }
    const o = s - i;
    const a = n - r;
    if (o < a) {
      return -1;
    } else if (o > a) {
      return 1;
    } else {
      return 0;
    }
  }
  function yp(t, e) {
    return Ua(t, e, 0, t.length, 0, e.length);
  }
  function Ua(t, e, i = 0, s = t.length, r = 0, n = e.length) {
    for (; i < s && r < n; i++, r++) {
      let c = t.charCodeAt(i);
      let l = e.charCodeAt(r);
      if (c === l) {
        continue;
      }
      if (c >= 128 || l >= 128) {
        return bp(t.toLowerCase(), e.toLowerCase(), i, s, r, n);
      }
      if (mv(c)) {
        c -= 32;
      }
      if (mv(l)) {
        l -= 32;
      }
      const u = c - l;
      if (u !== 0) {
        return u;
      }
    }
    const o = s - i;
    const a = n - r;
    if (o < a) {
      return -1;
    } else if (o > a) {
      return 1;
    } else {
      return 0;
    }
  }
  function mv(t) {
    return t >= 97 && t <= 122;
  }
  function wv(t) {
    return t >= 65 && t <= 90;
  }
  function br(t, e) {
    return t.length === e.length && Ua(t, e) === 0;
  }
  function eu(t, e) {
    const i = e.length;
    if (e.length > t.length) {
      return false;
    } else {
      return Ua(t, e, 0, i) === 0;
    }
  }
  function ME(t) {
    return t >= 55296 && t <= 56319;
  }
  function vv(t) {
    return t >= 56320 && t <= 57343;
  }
  function FE(t, e) {
    return (t - 55296 << 10) + (e - 56320) + 65536;
  }
  function NE() {
    return [0, 0, 0, 51229, 51255, 12, 44061, 44087, 12, 127462, 127487, 6, 7083, 7085, 5, 47645, 47671, 12, 54813, 54839, 12, 128678, 128678, 14, 3270, 3270, 5, 9919, 9923, 14, 45853, 45879, 12, 49437, 49463, 12, 53021, 53047, 12, 71216, 71218, 7, 128398, 128399, 14, 129360, 129374, 14, 2519, 2519, 5, 4448, 4519, 9, 9742, 9742, 14, 12336, 12336, 14, 44957, 44983, 12, 46749, 46775, 12, 48541, 48567, 12, 50333, 50359, 12, 52125, 52151, 12, 53917, 53943, 12, 69888, 69890, 5, 73018, 73018, 5, 127990, 127990, 14, 128558, 128559, 14, 128759, 128760, 14, 129653, 129655, 14, 2027, 2035, 5, 2891, 2892, 7, 3761, 3761, 5, 6683, 6683, 5, 8293, 8293, 4, 9825, 9826, 14, 9999, 9999, 14, 43452, 43453, 5, 44509, 44535, 12, 45405, 45431, 12, 46301, 46327, 12, 47197, 47223, 12, 48093, 48119, 12, 48989, 49015, 12, 49885, 49911, 12, 50781, 50807, 12, 51677, 51703, 12, 52573, 52599, 12, 53469, 53495, 12, 54365, 54391, 12, 65279, 65279, 4, 70471, 70472, 7, 72145, 72147, 7, 119173, 119179, 5, 127799, 127818, 14, 128240, 128244, 14, 128512, 128512, 14, 128652, 128652, 14, 128721, 128722, 14, 129292, 129292, 14, 129445, 129450, 14, 129734, 129743, 14, 1476, 1477, 5, 2366, 2368, 7, 2750, 2752, 7, 3076, 3076, 5, 3415, 3415, 5, 4141, 4144, 5, 6109, 6109, 5, 6964, 6964, 5, 7394, 7400, 5, 9197, 9198, 14, 9770, 9770, 14, 9877, 9877, 14, 9968, 9969, 14, 10084, 10084, 14, 43052, 43052, 5, 43713, 43713, 5, 44285, 44311, 12, 44733, 44759, 12, 45181, 45207, 12, 45629, 45655, 12, 46077, 46103, 12, 46525, 46551, 12, 46973, 46999, 12, 47421, 47447, 12, 47869, 47895, 12, 48317, 48343, 12, 48765, 48791, 12, 49213, 49239, 12, 49661, 49687, 12, 50109, 50135, 12, 50557, 50583, 12, 51005, 51031, 12, 51453, 51479, 12, 51901, 51927, 12, 52349, 52375, 12, 52797, 52823, 12, 53245, 53271, 12, 53693, 53719, 12, 54141, 54167, 12, 54589, 54615, 12, 55037, 55063, 12, 69506, 69509, 5, 70191, 70193, 5, 70841, 70841, 7, 71463, 71467, 5, 72330, 72342, 5, 94031, 94031, 5, 123628, 123631, 5, 127763, 127765, 14, 127941, 127941, 14, 128043, 128062, 14, 128302, 128317, 14, 128465, 128467, 14, 128539, 128539, 14, 128640, 128640, 14, 128662, 128662, 14, 128703, 128703, 14, 128745, 128745, 14, 129004, 129007, 14, 129329, 129330, 14, 129402, 129402, 14, 129483, 129483, 14, 129686, 129704, 14, 130048, 131069, 14, 173, 173, 4, 1757, 1757, 1, 2200, 2207, 5, 2434, 2435, 7, 2631, 2632, 5, 2817, 2817, 5, 3008, 3008, 5, 3201, 3201, 5, 3387, 3388, 5, 3542, 3542, 5, 3902, 3903, 7, 4190, 4192, 5, 6002, 6003, 5, 6439, 6440, 5, 6765, 6770, 7, 7019, 7027, 5, 7154, 7155, 7, 8205, 8205, 13, 8505, 8505, 14, 9654, 9654, 14, 9757, 9757, 14, 9792, 9792, 14, 9852, 9853, 14, 9890, 9894, 14, 9937, 9937, 14, 9981, 9981, 14, 10035, 10036, 14, 11035, 11036, 14, 42654, 42655, 5, 43346, 43347, 7, 43587, 43587, 5, 44006, 44007, 7, 44173, 44199, 12, 44397, 44423, 12, 44621, 44647, 12, 44845, 44871, 12, 45069, 45095, 12, 45293, 45319, 12, 45517, 45543, 12, 45741, 45767, 12, 45965, 45991, 12, 46189, 46215, 12, 46413, 46439, 12, 46637, 46663, 12, 46861, 46887, 12, 47085, 47111, 12, 47309, 47335, 12, 47533, 47559, 12, 47757, 47783, 12, 47981, 48007, 12, 48205, 48231, 12, 48429, 48455, 12, 48653, 48679, 12, 48877, 48903, 12, 49101, 49127, 12, 49325, 49351, 12, 49549, 49575, 12, 49773, 49799, 12, 49997, 50023, 12, 50221, 50247, 12, 50445, 50471, 12, 50669, 50695, 12, 50893, 50919, 12, 51117, 51143, 12, 51341, 51367, 12, 51565, 51591, 12, 51789, 51815, 12, 52013, 52039, 12, 52237, 52263, 12, 52461, 52487, 12, 52685, 52711, 12, 52909, 52935, 12, 53133, 53159, 12, 53357, 53383, 12, 53581, 53607, 12, 53805, 53831, 12, 54029, 54055, 12, 54253, 54279, 12, 54477, 54503, 12, 54701, 54727, 12, 54925, 54951, 12, 55149, 55175, 12, 68101, 68102, 5, 69762, 69762, 7, 70067, 70069, 7, 70371, 70378, 5, 70720, 70721, 7, 71087, 71087, 5, 71341, 71341, 5, 71995, 71996, 5, 72249, 72249, 7, 72850, 72871, 5, 73109, 73109, 5, 118576, 118598, 5, 121505, 121519, 5, 127245, 127247, 14, 127568, 127569, 14, 127777, 127777, 14, 127872, 127891, 14, 127956, 127967, 14, 128015, 128016, 14, 128110, 128172, 14, 128259, 128259, 14, 128367, 128368, 14, 128424, 128424, 14, 128488, 128488, 14, 128530, 128532, 14, 128550, 128551, 14, 128566, 128566, 14, 128647, 128647, 14, 128656, 128656, 14, 128667, 128673, 14, 128691, 128693, 14, 128715, 128715, 14, 128728, 128732, 14, 128752, 128752, 14, 128765, 128767, 14, 129096, 129103, 14, 129311, 129311, 14, 129344, 129349, 14, 129394, 129394, 14, 129413, 129425, 14, 129466, 129471, 14, 129511, 129535, 14, 129664, 129666, 14, 129719, 129722, 14, 129760, 129767, 14, 917536, 917631, 5, 13, 13, 2, 1160, 1161, 5, 1564, 1564, 4, 1807, 1807, 1, 2085, 2087, 5, 2307, 2307, 7, 2382, 2383, 7, 2497, 2500, 5, 2563, 2563, 7, 2677, 2677, 5, 2763, 2764, 7, 2879, 2879, 5, 2914, 2915, 5, 3021, 3021, 5, 3142, 3144, 5, 3263, 3263, 5, 3285, 3286, 5, 3398, 3400, 7, 3530, 3530, 5, 3633, 3633, 5, 3864, 3865, 5, 3974, 3975, 5, 4155, 4156, 7, 4229, 4230, 5, 5909, 5909, 7, 6078, 6085, 7, 6277, 6278, 5, 6451, 6456, 7, 6744, 6750, 5, 6846, 6846, 5, 6972, 6972, 5, 7074, 7077, 5, 7146, 7148, 7, 7222, 7223, 5, 7416, 7417, 5, 8234, 8238, 4, 8417, 8417, 5, 9000, 9000, 14, 9203, 9203, 14, 9730, 9731, 14, 9748, 9749, 14, 9762, 9763, 14, 9776, 9783, 14, 9800, 9811, 14, 9831, 9831, 14, 9872, 9873, 14, 9882, 9882, 14, 9900, 9903, 14, 9929, 9933, 14, 9941, 9960, 14, 9974, 9974, 14, 9989, 9989, 14, 10006, 10006, 14, 10062, 10062, 14, 10160, 10160, 14, 11647, 11647, 5, 12953, 12953, 14, 43019, 43019, 5, 43232, 43249, 5, 43443, 43443, 5, 43567, 43568, 7, 43696, 43696, 5, 43765, 43765, 7, 44013, 44013, 5, 44117, 44143, 12, 44229, 44255, 12, 44341, 44367, 12, 44453, 44479, 12, 44565, 44591, 12, 44677, 44703, 12, 44789, 44815, 12, 44901, 44927, 12, 45013, 45039, 12, 45125, 45151, 12, 45237, 45263, 12, 45349, 45375, 12, 45461, 45487, 12, 45573, 45599, 12, 45685, 45711, 12, 45797, 45823, 12, 45909, 45935, 12, 46021, 46047, 12, 46133, 46159, 12, 46245, 46271, 12, 46357, 46383, 12, 46469, 46495, 12, 46581, 46607, 12, 46693, 46719, 12, 46805, 46831, 12, 46917, 46943, 12, 47029, 47055, 12, 47141, 47167, 12, 47253, 47279, 12, 47365, 47391, 12, 47477, 47503, 12, 47589, 47615, 12, 47701, 47727, 12, 47813, 47839, 12, 47925, 47951, 12, 48037, 48063, 12, 48149, 48175, 12, 48261, 48287, 12, 48373, 48399, 12, 48485, 48511, 12, 48597, 48623, 12, 48709, 48735, 12, 48821, 48847, 12, 48933, 48959, 12, 49045, 49071, 12, 49157, 49183, 12, 49269, 49295, 12, 49381, 49407, 12, 49493, 49519, 12, 49605, 49631, 12, 49717, 49743, 12, 49829, 49855, 12, 49941, 49967, 12, 50053, 50079, 12, 50165, 50191, 12, 50277, 50303, 12, 50389, 50415, 12, 50501, 50527, 12, 50613, 50639, 12, 50725, 50751, 12, 50837, 50863, 12, 50949, 50975, 12, 51061, 51087, 12, 51173, 51199, 12, 51285, 51311, 12, 51397, 51423, 12, 51509, 51535, 12, 51621, 51647, 12, 51733, 51759, 12, 51845, 51871, 12, 51957, 51983, 12, 52069, 52095, 12, 52181, 52207, 12, 52293, 52319, 12, 52405, 52431, 12, 52517, 52543, 12, 52629, 52655, 12, 52741, 52767, 12, 52853, 52879, 12, 52965, 52991, 12, 53077, 53103, 12, 53189, 53215, 12, 53301, 53327, 12, 53413, 53439, 12, 53525, 53551, 12, 53637, 53663, 12, 53749, 53775, 12, 53861, 53887, 12, 53973, 53999, 12, 54085, 54111, 12, 54197, 54223, 12, 54309, 54335, 12, 54421, 54447, 12, 54533, 54559, 12, 54645, 54671, 12, 54757, 54783, 12, 54869, 54895, 12, 54981, 55007, 12, 55093, 55119, 12, 55243, 55291, 10, 66045, 66045, 5, 68325, 68326, 5, 69688, 69702, 5, 69817, 69818, 5, 69957, 69958, 7, 70089, 70092, 5, 70198, 70199, 5, 70462, 70462, 5, 70502, 70508, 5, 70750, 70750, 5, 70846, 70846, 7, 71100, 71101, 5, 71230, 71230, 7, 71351, 71351, 5, 71737, 71738, 5, 72000, 72000, 7, 72160, 72160, 5, 72273, 72278, 5, 72752, 72758, 5, 72882, 72883, 5, 73031, 73031, 5, 73461, 73462, 7, 94192, 94193, 7, 119149, 119149, 7, 121403, 121452, 5, 122915, 122916, 5, 126980, 126980, 14, 127358, 127359, 14, 127535, 127535, 14, 127759, 127759, 14, 127771, 127771, 14, 127792, 127793, 14, 127825, 127867, 14, 127897, 127899, 14, 127945, 127945, 14, 127985, 127986, 14, 128000, 128007, 14, 128021, 128021, 14, 128066, 128100, 14, 128184, 128235, 14, 128249, 128252, 14, 128266, 128276, 14, 128335, 128335, 14, 128379, 128390, 14, 128407, 128419, 14, 128444, 128444, 14, 128481, 128481, 14, 128499, 128499, 14, 128526, 128526, 14, 128536, 128536, 14, 128543, 128543, 14, 128556, 128556, 14, 128564, 128564, 14, 128577, 128580, 14, 128643, 128645, 14, 128649, 128649, 14, 128654, 128654, 14, 128660, 128660, 14, 128664, 128664, 14, 128675, 128675, 14, 128686, 128689, 14, 128695, 128696, 14, 128705, 128709, 14, 128717, 128719, 14, 128725, 128725, 14, 128736, 128741, 14, 128747, 128748, 14, 128755, 128755, 14, 128762, 128762, 14, 128981, 128991, 14, 129009, 129023, 14, 129160, 129167, 14, 129296, 129304, 14, 129320, 129327, 14, 129340, 129342, 14, 129356, 129356, 14, 129388, 129392, 14, 129399, 129400, 14, 129404, 129407, 14, 129432, 129442, 14, 129454, 129455, 14, 129473, 129474, 14, 129485, 129487, 14, 129648, 129651, 14, 129659, 129660, 14, 129671, 129679, 14, 129709, 129711, 14, 129728, 129730, 14, 129751, 129753, 14, 129776, 129782, 14, 917505, 917505, 4, 917760, 917999, 5, 10, 10, 3, 127, 159, 4, 768, 879, 5, 1471, 1471, 5, 1536, 1541, 1, 1648, 1648, 5, 1767, 1768, 5, 1840, 1866, 5, 2070, 2073, 5, 2137, 2139, 5, 2274, 2274, 1, 2363, 2363, 7, 2377, 2380, 7, 2402, 2403, 5, 2494, 2494, 5, 2507, 2508, 7, 2558, 2558, 5, 2622, 2624, 7, 2641, 2641, 5, 2691, 2691, 7, 2759, 2760, 5, 2786, 2787, 5, 2876, 2876, 5, 2881, 2884, 5, 2901, 2902, 5, 3006, 3006, 5, 3014, 3016, 7, 3072, 3072, 5, 3134, 3136, 5, 3157, 3158, 5, 3260, 3260, 5, 3266, 3266, 5, 3274, 3275, 7, 3328, 3329, 5, 3391, 3392, 7, 3405, 3405, 5, 3457, 3457, 5, 3536, 3537, 7, 3551, 3551, 5, 3636, 3642, 5, 3764, 3772, 5, 3895, 3895, 5, 3967, 3967, 7, 3993, 4028, 5, 4146, 4151, 5, 4182, 4183, 7, 4226, 4226, 5, 4253, 4253, 5, 4957, 4959, 5, 5940, 5940, 7, 6070, 6070, 7, 6087, 6088, 7, 6158, 6158, 4, 6432, 6434, 5, 6448, 6449, 7, 6679, 6680, 5, 6742, 6742, 5, 6754, 6754, 5, 6783, 6783, 5, 6912, 6915, 5, 6966, 6970, 5, 6978, 6978, 5, 7042, 7042, 7, 7080, 7081, 5, 7143, 7143, 7, 7150, 7150, 7, 7212, 7219, 5, 7380, 7392, 5, 7412, 7412, 5, 8203, 8203, 4, 8232, 8232, 4, 8265, 8265, 14, 8400, 8412, 5, 8421, 8432, 5, 8617, 8618, 14, 9167, 9167, 14, 9200, 9200, 14, 9410, 9410, 14, 9723, 9726, 14, 9733, 9733, 14, 9745, 9745, 14, 9752, 9752, 14, 9760, 9760, 14, 9766, 9766, 14, 9774, 9774, 14, 9786, 9786, 14, 9794, 9794, 14, 9823, 9823, 14, 9828, 9828, 14, 9833, 9850, 14, 9855, 9855, 14, 9875, 9875, 14, 9880, 9880, 14, 9885, 9887, 14, 9896, 9897, 14, 9906, 9916, 14, 9926, 9927, 14, 9935, 9935, 14, 9939, 9939, 14, 9962, 9962, 14, 9972, 9972, 14, 9978, 9978, 14, 9986, 9986, 14, 9997, 9997, 14, 10002, 10002, 14, 10017, 10017, 14, 10055, 10055, 14, 10071, 10071, 14, 10133, 10135, 14, 10548, 10549, 14, 11093, 11093, 14, 12330, 12333, 5, 12441, 12442, 5, 42608, 42610, 5, 43010, 43010, 5, 43045, 43046, 5, 43188, 43203, 7, 43302, 43309, 5, 43392, 43394, 5, 43446, 43449, 5, 43493, 43493, 5, 43571, 43572, 7, 43597, 43597, 7, 43703, 43704, 5, 43756, 43757, 5, 44003, 44004, 7, 44009, 44010, 7, 44033, 44059, 12, 44089, 44115, 12, 44145, 44171, 12, 44201, 44227, 12, 44257, 44283, 12, 44313, 44339, 12, 44369, 44395, 12, 44425, 44451, 12, 44481, 44507, 12, 44537, 44563, 12, 44593, 44619, 12, 44649, 44675, 12, 44705, 44731, 12, 44761, 44787, 12, 44817, 44843, 12, 44873, 44899, 12, 44929, 44955, 12, 44985, 45011, 12, 45041, 45067, 12, 45097, 45123, 12, 45153, 45179, 12, 45209, 45235, 12, 45265, 45291, 12, 45321, 45347, 12, 45377, 45403, 12, 45433, 45459, 12, 45489, 45515, 12, 45545, 45571, 12, 45601, 45627, 12, 45657, 45683, 12, 45713, 45739, 12, 45769, 45795, 12, 45825, 45851, 12, 45881, 45907, 12, 45937, 45963, 12, 45993, 46019, 12, 46049, 46075, 12, 46105, 46131, 12, 46161, 46187, 12, 46217, 46243, 12, 46273, 46299, 12, 46329, 46355, 12, 46385, 46411, 12, 46441, 46467, 12, 46497, 46523, 12, 46553, 46579, 12, 46609, 46635, 12, 46665, 46691, 12, 46721, 46747, 12, 46777, 46803, 12, 46833, 46859, 12, 46889, 46915, 12, 46945, 46971, 12, 47001, 47027, 12, 47057, 47083, 12, 47113, 47139, 12, 47169, 47195, 12, 47225, 47251, 12, 47281, 47307, 12, 47337, 47363, 12, 47393, 47419, 12, 47449, 47475, 12, 47505, 47531, 12, 47561, 47587, 12, 47617, 47643, 12, 47673, 47699, 12, 47729, 47755, 12, 47785, 47811, 12, 47841, 47867, 12, 47897, 47923, 12, 47953, 47979, 12, 48009, 48035, 12, 48065, 48091, 12, 48121, 48147, 12, 48177, 48203, 12, 48233, 48259, 12, 48289, 48315, 12, 48345, 48371, 12, 48401, 48427, 12, 48457, 48483, 12, 48513, 48539, 12, 48569, 48595, 12, 48625, 48651, 12, 48681, 48707, 12, 48737, 48763, 12, 48793, 48819, 12, 48849, 48875, 12, 48905, 48931, 12, 48961, 48987, 12, 49017, 49043, 12, 49073, 49099, 12, 49129, 49155, 12, 49185, 49211, 12, 49241, 49267, 12, 49297, 49323, 12, 49353, 49379, 12, 49409, 49435, 12, 49465, 49491, 12, 49521, 49547, 12, 49577, 49603, 12, 49633, 49659, 12, 49689, 49715, 12, 49745, 49771, 12, 49801, 49827, 12, 49857, 49883, 12, 49913, 49939, 12, 49969, 49995, 12, 50025, 50051, 12, 50081, 50107, 12, 50137, 50163, 12, 50193, 50219, 12, 50249, 50275, 12, 50305, 50331, 12, 50361, 50387, 12, 50417, 50443, 12, 50473, 50499, 12, 50529, 50555, 12, 50585, 50611, 12, 50641, 50667, 12, 50697, 50723, 12, 50753, 50779, 12, 50809, 50835, 12, 50865, 50891, 12, 50921, 50947, 12, 50977, 51003, 12, 51033, 51059, 12, 51089, 51115, 12, 51145, 51171, 12, 51201, 51227, 12, 51257, 51283, 12, 51313, 51339, 12, 51369, 51395, 12, 51425, 51451, 12, 51481, 51507, 12, 51537, 51563, 12, 51593, 51619, 12, 51649, 51675, 12, 51705, 51731, 12, 51761, 51787, 12, 51817, 51843, 12, 51873, 51899, 12, 51929, 51955, 12, 51985, 52011, 12, 52041, 52067, 12, 52097, 52123, 12, 52153, 52179, 12, 52209, 52235, 12, 52265, 52291, 12, 52321, 52347, 12, 52377, 52403, 12, 52433, 52459, 12, 52489, 52515, 12, 52545, 52571, 12, 52601, 52627, 12, 52657, 52683, 12, 52713, 52739, 12, 52769, 52795, 12, 52825, 52851, 12, 52881, 52907, 12, 52937, 52963, 12, 52993, 53019, 12, 53049, 53075, 12, 53105, 53131, 12, 53161, 53187, 12, 53217, 53243, 12, 53273, 53299, 12, 53329, 53355, 12, 53385, 53411, 12, 53441, 53467, 12, 53497, 53523, 12, 53553, 53579, 12, 53609, 53635, 12, 53665, 53691, 12, 53721, 53747, 12, 53777, 53803, 12, 53833, 53859, 12, 53889, 53915, 12, 53945, 53971, 12, 54001, 54027, 12, 54057, 54083, 12, 54113, 54139, 12, 54169, 54195, 12, 54225, 54251, 12, 54281, 54307, 12, 54337, 54363, 12, 54393, 54419, 12, 54449, 54475, 12, 54505, 54531, 12, 54561, 54587, 12, 54617, 54643, 12, 54673, 54699, 12, 54729, 54755, 12, 54785, 54811, 12, 54841, 54867, 12, 54897, 54923, 12, 54953, 54979, 12, 55009, 55035, 12, 55065, 55091, 12, 55121, 55147, 12, 55177, 55203, 12, 65024, 65039, 5, 65520, 65528, 4, 66422, 66426, 5, 68152, 68154, 5, 69291, 69292, 5, 69633, 69633, 5, 69747, 69748, 5, 69811, 69814, 5, 69826, 69826, 5, 69932, 69932, 7, 70016, 70017, 5, 70079, 70080, 7, 70095, 70095, 5, 70196, 70196, 5, 70367, 70367, 5, 70402, 70403, 7, 70464, 70464, 5, 70487, 70487, 5, 70709, 70711, 7, 70725, 70725, 7, 70833, 70834, 7, 70843, 70844, 7, 70849, 70849, 7, 71090, 71093, 5, 71103, 71104, 5, 71227, 71228, 7, 71339, 71339, 5, 71344, 71349, 5, 71458, 71461, 5, 71727, 71735, 5, 71985, 71989, 7, 71998, 71998, 5, 72002, 72002, 7, 72154, 72155, 5, 72193, 72202, 5, 72251, 72254, 5, 72281, 72283, 5, 72344, 72345, 5, 72766, 72766, 7, 72874, 72880, 5, 72885, 72886, 5, 73023, 73029, 5, 73104, 73105, 5, 73111, 73111, 5, 92912, 92916, 5, 94095, 94098, 5, 113824, 113827, 4, 119142, 119142, 7, 119155, 119162, 4, 119362, 119364, 5, 121476, 121476, 5, 122888, 122904, 5, 123184, 123190, 5, 125252, 125258, 5, 127183, 127183, 14, 127340, 127343, 14, 127377, 127386, 14, 127491, 127503, 14, 127548, 127551, 14, 127744, 127756, 14, 127761, 127761, 14, 127769, 127769, 14, 127773, 127774, 14, 127780, 127788, 14, 127796, 127797, 14, 127820, 127823, 14, 127869, 127869, 14, 127894, 127895, 14, 127902, 127903, 14, 127943, 127943, 14, 127947, 127950, 14, 127972, 127972, 14, 127988, 127988, 14, 127992, 127994, 14, 128009, 128011, 14, 128019, 128019, 14, 128023, 128041, 14, 128064, 128064, 14, 128102, 128107, 14, 128174, 128181, 14, 128238, 128238, 14, 128246, 128247, 14, 128254, 128254, 14, 128264, 128264, 14, 128278, 128299, 14, 128329, 128330, 14, 128348, 128359, 14, 128371, 128377, 14, 128392, 128393, 14, 128401, 128404, 14, 128421, 128421, 14, 128433, 128434, 14, 128450, 128452, 14, 128476, 128478, 14, 128483, 128483, 14, 128495, 128495, 14, 128506, 128506, 14, 128519, 128520, 14, 128528, 128528, 14, 128534, 128534, 14, 128538, 128538, 14, 128540, 128542, 14, 128544, 128549, 14, 128552, 128555, 14, 128557, 128557, 14, 128560, 128563, 14, 128565, 128565, 14, 128567, 128576, 14, 128581, 128591, 14, 128641, 128642, 14, 128646, 128646, 14, 128648, 128648, 14, 128650, 128651, 14, 128653, 128653, 14, 128655, 128655, 14, 128657, 128659, 14, 128661, 128661, 14, 128663, 128663, 14, 128665, 128666, 14, 128674, 128674, 14, 128676, 128677, 14, 128679, 128685, 14, 128690, 128690, 14, 128694, 128694, 14, 128697, 128702, 14, 128704, 128704, 14, 128710, 128714, 14, 128716, 128716, 14, 128720, 128720, 14, 128723, 128724, 14, 128726, 128727, 14, 128733, 128735, 14, 128742, 128744, 14, 128746, 128746, 14, 128749, 128751, 14, 128753, 128754, 14, 128756, 128758, 14, 128761, 128761, 14, 128763, 128764, 14, 128884, 128895, 14, 128992, 129003, 14, 129008, 129008, 14, 129036, 129039, 14, 129114, 129119, 14, 129198, 129279, 14, 129293, 129295, 14, 129305, 129310, 14, 129312, 129319, 14, 129328, 129328, 14, 129331, 129338, 14, 129343, 129343, 14, 129351, 129355, 14, 129357, 129359, 14, 129375, 129387, 14, 129393, 129393, 14, 129395, 129398, 14, 129401, 129401, 14, 129403, 129403, 14, 129408, 129412, 14, 129426, 129431, 14, 129443, 129444, 14, 129451, 129453, 14, 129456, 129465, 14, 129472, 129472, 14, 129475, 129482, 14, 129484, 129484, 14, 129488, 129510, 14, 129536, 129647, 14, 129652, 129652, 14, 129656, 129658, 14, 129661, 129663, 14, 129667, 129670, 14, 129680, 129685, 14, 129705, 129708, 14, 129712, 129718, 14, 129723, 129727, 14, 129731, 129733, 14, 129744, 129750, 14, 129754, 129759, 14, 129768, 129775, 14, 129783, 129791, 14, 917504, 917504, 4, 917506, 917535, 4, 917632, 917759, 4, 918000, 921599, 4, 0, 9, 4, 11, 12, 4, 14, 31, 4, 169, 169, 14, 174, 174, 14, 1155, 1159, 5, 1425, 1469, 5, 1473, 1474, 5, 1479, 1479, 5, 1552, 1562, 5, 1611, 1631, 5, 1750, 1756, 5, 1759, 1764, 5, 1770, 1773, 5, 1809, 1809, 5, 1958, 1968, 5, 2045, 2045, 5, 2075, 2083, 5, 2089, 2093, 5, 2192, 2193, 1, 2250, 2273, 5, 2275, 2306, 5, 2362, 2362, 5, 2364, 2364, 5, 2369, 2376, 5, 2381, 2381, 5, 2385, 2391, 5, 2433, 2433, 5, 2492, 2492, 5, 2495, 2496, 7, 2503, 2504, 7, 2509, 2509, 5, 2530, 2531, 5, 2561, 2562, 5, 2620, 2620, 5, 2625, 2626, 5, 2635, 2637, 5, 2672, 2673, 5, 2689, 2690, 5, 2748, 2748, 5, 2753, 2757, 5, 2761, 2761, 7, 2765, 2765, 5, 2810, 2815, 5, 2818, 2819, 7, 2878, 2878, 5, 2880, 2880, 7, 2887, 2888, 7, 2893, 2893, 5, 2903, 2903, 5, 2946, 2946, 5, 3007, 3007, 7, 3009, 3010, 7, 3018, 3020, 7, 3031, 3031, 5, 3073, 3075, 7, 3132, 3132, 5, 3137, 3140, 7, 3146, 3149, 5, 3170, 3171, 5, 3202, 3203, 7, 3262, 3262, 7, 3264, 3265, 7, 3267, 3268, 7, 3271, 3272, 7, 3276, 3277, 5, 3298, 3299, 5, 3330, 3331, 7, 3390, 3390, 5, 3393, 3396, 5, 3402, 3404, 7, 3406, 3406, 1, 3426, 3427, 5, 3458, 3459, 7, 3535, 3535, 5, 3538, 3540, 5, 3544, 3550, 7, 3570, 3571, 7, 3635, 3635, 7, 3655, 3662, 5, 3763, 3763, 7, 3784, 3789, 5, 3893, 3893, 5, 3897, 3897, 5, 3953, 3966, 5, 3968, 3972, 5, 3981, 3991, 5, 4038, 4038, 5, 4145, 4145, 7, 4153, 4154, 5, 4157, 4158, 5, 4184, 4185, 5, 4209, 4212, 5, 4228, 4228, 7, 4237, 4237, 5, 4352, 4447, 8, 4520, 4607, 10, 5906, 5908, 5, 5938, 5939, 5, 5970, 5971, 5, 6068, 6069, 5, 6071, 6077, 5, 6086, 6086, 5, 6089, 6099, 5, 6155, 6157, 5, 6159, 6159, 5, 6313, 6313, 5, 6435, 6438, 7, 6441, 6443, 7, 6450, 6450, 5, 6457, 6459, 5, 6681, 6682, 7, 6741, 6741, 7, 6743, 6743, 7, 6752, 6752, 5, 6757, 6764, 5, 6771, 6780, 5, 6832, 6845, 5, 6847, 6862, 5, 6916, 6916, 7, 6965, 6965, 5, 6971, 6971, 7, 6973, 6977, 7, 6979, 6980, 7, 7040, 7041, 5, 7073, 7073, 7, 7078, 7079, 7, 7082, 7082, 7, 7142, 7142, 5, 7144, 7145, 5, 7149, 7149, 5, 7151, 7153, 5, 7204, 7211, 7, 7220, 7221, 7, 7376, 7378, 5, 7393, 7393, 7, 7405, 7405, 5, 7415, 7415, 7, 7616, 7679, 5, 8204, 8204, 5, 8206, 8207, 4, 8233, 8233, 4, 8252, 8252, 14, 8288, 8292, 4, 8294, 8303, 4, 8413, 8416, 5, 8418, 8420, 5, 8482, 8482, 14, 8596, 8601, 14, 8986, 8987, 14, 9096, 9096, 14, 9193, 9196, 14, 9199, 9199, 14, 9201, 9202, 14, 9208, 9210, 14, 9642, 9643, 14, 9664, 9664, 14, 9728, 9729, 14, 9732, 9732, 14, 9735, 9741, 14, 9743, 9744, 14, 9746, 9746, 14, 9750, 9751, 14, 9753, 9756, 14, 9758, 9759, 14, 9761, 9761, 14, 9764, 9765, 14, 9767, 9769, 14, 9771, 9773, 14, 9775, 9775, 14, 9784, 9785, 14, 9787, 9791, 14, 9793, 9793, 14, 9795, 9799, 14, 9812, 9822, 14, 9824, 9824, 14, 9827, 9827, 14, 9829, 9830, 14, 9832, 9832, 14, 9851, 9851, 14, 9854, 9854, 14, 9856, 9861, 14, 9874, 9874, 14, 9876, 9876, 14, 9878, 9879, 14, 9881, 9881, 14, 9883, 9884, 14, 9888, 9889, 14, 9895, 9895, 14, 9898, 9899, 14, 9904, 9905, 14, 9917, 9918, 14, 9924, 9925, 14, 9928, 9928, 14, 9934, 9934, 14, 9936, 9936, 14, 9938, 9938, 14, 9940, 9940, 14, 9961, 9961, 14, 9963, 9967, 14, 9970, 9971, 14, 9973, 9973, 14, 9975, 9977, 14, 9979, 9980, 14, 9982, 9985, 14, 9987, 9988, 14, 9992, 9996, 14, 9998, 9998, 14, 10000, 10001, 14, 10004, 10004, 14, 10013, 10013, 14, 10024, 10024, 14, 10052, 10052, 14, 10060, 10060, 14, 10067, 10069, 14, 10083, 10083, 14, 10085, 10087, 14, 10145, 10145, 14, 10175, 10175, 14, 11013, 11015, 14, 11088, 11088, 14, 11503, 11505, 5, 11744, 11775, 5, 12334, 12335, 5, 12349, 12349, 14, 12951, 12951, 14, 42607, 42607, 5, 42612, 42621, 5, 42736, 42737, 5, 43014, 43014, 5, 43043, 43044, 7, 43047, 43047, 7, 43136, 43137, 7, 43204, 43205, 5, 43263, 43263, 5, 43335, 43345, 5, 43360, 43388, 8, 43395, 43395, 7, 43444, 43445, 7, 43450, 43451, 7, 43454, 43456, 7, 43561, 43566, 5, 43569, 43570, 5, 43573, 43574, 5, 43596, 43596, 5, 43644, 43644, 5, 43698, 43700, 5, 43710, 43711, 5, 43755, 43755, 7, 43758, 43759, 7, 43766, 43766, 5, 44005, 44005, 5, 44008, 44008, 5, 44012, 44012, 7, 44032, 44032, 11, 44060, 44060, 11, 44088, 44088, 11, 44116, 44116, 11, 44144, 44144, 11, 44172, 44172, 11, 44200, 44200, 11, 44228, 44228, 11, 44256, 44256, 11, 44284, 44284, 11, 44312, 44312, 11, 44340, 44340, 11, 44368, 44368, 11, 44396, 44396, 11, 44424, 44424, 11, 44452, 44452, 11, 44480, 44480, 11, 44508, 44508, 11, 44536, 44536, 11, 44564, 44564, 11, 44592, 44592, 11, 44620, 44620, 11, 44648, 44648, 11, 44676, 44676, 11, 44704, 44704, 11, 44732, 44732, 11, 44760, 44760, 11, 44788, 44788, 11, 44816, 44816, 11, 44844, 44844, 11, 44872, 44872, 11, 44900, 44900, 11, 44928, 44928, 11, 44956, 44956, 11, 44984, 44984, 11, 45012, 45012, 11, 45040, 45040, 11, 45068, 45068, 11, 45096, 45096, 11, 45124, 45124, 11, 45152, 45152, 11, 45180, 45180, 11, 45208, 45208, 11, 45236, 45236, 11, 45264, 45264, 11, 45292, 45292, 11, 45320, 45320, 11, 45348, 45348, 11, 45376, 45376, 11, 45404, 45404, 11, 45432, 45432, 11, 45460, 45460, 11, 45488, 45488, 11, 45516, 45516, 11, 45544, 45544, 11, 45572, 45572, 11, 45600, 45600, 11, 45628, 45628, 11, 45656, 45656, 11, 45684, 45684, 11, 45712, 45712, 11, 45740, 45740, 11, 45768, 45768, 11, 45796, 45796, 11, 45824, 45824, 11, 45852, 45852, 11, 45880, 45880, 11, 45908, 45908, 11, 45936, 45936, 11, 45964, 45964, 11, 45992, 45992, 11, 46020, 46020, 11, 46048, 46048, 11, 46076, 46076, 11, 46104, 46104, 11, 46132, 46132, 11, 46160, 46160, 11, 46188, 46188, 11, 46216, 46216, 11, 46244, 46244, 11, 46272, 46272, 11, 46300, 46300, 11, 46328, 46328, 11, 46356, 46356, 11, 46384, 46384, 11, 46412, 46412, 11, 46440, 46440, 11, 46468, 46468, 11, 46496, 46496, 11, 46524, 46524, 11, 46552, 46552, 11, 46580, 46580, 11, 46608, 46608, 11, 46636, 46636, 11, 46664, 46664, 11, 46692, 46692, 11, 46720, 46720, 11, 46748, 46748, 11, 46776, 46776, 11, 46804, 46804, 11, 46832, 46832, 11, 46860, 46860, 11, 46888, 46888, 11, 46916, 46916, 11, 46944, 46944, 11, 46972, 46972, 11, 47000, 47000, 11, 47028, 47028, 11, 47056, 47056, 11, 47084, 47084, 11, 47112, 47112, 11, 47140, 47140, 11, 47168, 47168, 11, 47196, 47196, 11, 47224, 47224, 11, 47252, 47252, 11, 47280, 47280, 11, 47308, 47308, 11, 47336, 47336, 11, 47364, 47364, 11, 47392, 47392, 11, 47420, 47420, 11, 47448, 47448, 11, 47476, 47476, 11, 47504, 47504, 11, 47532, 47532, 11, 47560, 47560, 11, 47588, 47588, 11, 47616, 47616, 11, 47644, 47644, 11, 47672, 47672, 11, 47700, 47700, 11, 47728, 47728, 11, 47756, 47756, 11, 47784, 47784, 11, 47812, 47812, 11, 47840, 47840, 11, 47868, 47868, 11, 47896, 47896, 11, 47924, 47924, 11, 47952, 47952, 11, 47980, 47980, 11, 48008, 48008, 11, 48036, 48036, 11, 48064, 48064, 11, 48092, 48092, 11, 48120, 48120, 11, 48148, 48148, 11, 48176, 48176, 11, 48204, 48204, 11, 48232, 48232, 11, 48260, 48260, 11, 48288, 48288, 11, 48316, 48316, 11, 48344, 48344, 11, 48372, 48372, 11, 48400, 48400, 11, 48428, 48428, 11, 48456, 48456, 11, 48484, 48484, 11, 48512, 48512, 11, 48540, 48540, 11, 48568, 48568, 11, 48596, 48596, 11, 48624, 48624, 11, 48652, 48652, 11, 48680, 48680, 11, 48708, 48708, 11, 48736, 48736, 11, 48764, 48764, 11, 48792, 48792, 11, 48820, 48820, 11, 48848, 48848, 11, 48876, 48876, 11, 48904, 48904, 11, 48932, 48932, 11, 48960, 48960, 11, 48988, 48988, 11, 49016, 49016, 11, 49044, 49044, 11, 49072, 49072, 11, 49100, 49100, 11, 49128, 49128, 11, 49156, 49156, 11, 49184, 49184, 11, 49212, 49212, 11, 49240, 49240, 11, 49268, 49268, 11, 49296, 49296, 11, 49324, 49324, 11, 49352, 49352, 11, 49380, 49380, 11, 49408, 49408, 11, 49436, 49436, 11, 49464, 49464, 11, 49492, 49492, 11, 49520, 49520, 11, 49548, 49548, 11, 49576, 49576, 11, 49604, 49604, 11, 49632, 49632, 11, 49660, 49660, 11, 49688, 49688, 11, 49716, 49716, 11, 49744, 49744, 11, 49772, 49772, 11, 49800, 49800, 11, 49828, 49828, 11, 49856, 49856, 11, 49884, 49884, 11, 49912, 49912, 11, 49940, 49940, 11, 49968, 49968, 11, 49996, 49996, 11, 50024, 50024, 11, 50052, 50052, 11, 50080, 50080, 11, 50108, 50108, 11, 50136, 50136, 11, 50164, 50164, 11, 50192, 50192, 11, 50220, 50220, 11, 50248, 50248, 11, 50276, 50276, 11, 50304, 50304, 11, 50332, 50332, 11, 50360, 50360, 11, 50388, 50388, 11, 50416, 50416, 11, 50444, 50444, 11, 50472, 50472, 11, 50500, 50500, 11, 50528, 50528, 11, 50556, 50556, 11, 50584, 50584, 11, 50612, 50612, 11, 50640, 50640, 11, 50668, 50668, 11, 50696, 50696, 11, 50724, 50724, 11, 50752, 50752, 11, 50780, 50780, 11, 50808, 50808, 11, 50836, 50836, 11, 50864, 50864, 11, 50892, 50892, 11, 50920, 50920, 11, 50948, 50948, 11, 50976, 50976, 11, 51004, 51004, 11, 51032, 51032, 11, 51060, 51060, 11, 51088, 51088, 11, 51116, 51116, 11, 51144, 51144, 11, 51172, 51172, 11, 51200, 51200, 11, 51228, 51228, 11, 51256, 51256, 11, 51284, 51284, 11, 51312, 51312, 11, 51340, 51340, 11, 51368, 51368, 11, 51396, 51396, 11, 51424, 51424, 11, 51452, 51452, 11, 51480, 51480, 11, 51508, 51508, 11, 51536, 51536, 11, 51564, 51564, 11, 51592, 51592, 11, 51620, 51620, 11, 51648, 51648, 11, 51676, 51676, 11, 51704, 51704, 11, 51732, 51732, 11, 51760, 51760, 11, 51788, 51788, 11, 51816, 51816, 11, 51844, 51844, 11, 51872, 51872, 11, 51900, 51900, 11, 51928, 51928, 11, 51956, 51956, 11, 51984, 51984, 11, 52012, 52012, 11, 52040, 52040, 11, 52068, 52068, 11, 52096, 52096, 11, 52124, 52124, 11, 52152, 52152, 11, 52180, 52180, 11, 52208, 52208, 11, 52236, 52236, 11, 52264, 52264, 11, 52292, 52292, 11, 52320, 52320, 11, 52348, 52348, 11, 52376, 52376, 11, 52404, 52404, 11, 52432, 52432, 11, 52460, 52460, 11, 52488, 52488, 11, 52516, 52516, 11, 52544, 52544, 11, 52572, 52572, 11, 52600, 52600, 11, 52628, 52628, 11, 52656, 52656, 11, 52684, 52684, 11, 52712, 52712, 11, 52740, 52740, 11, 52768, 52768, 11, 52796, 52796, 11, 52824, 52824, 11, 52852, 52852, 11, 52880, 52880, 11, 52908, 52908, 11, 52936, 52936, 11, 52964, 52964, 11, 52992, 52992, 11, 53020, 53020, 11, 53048, 53048, 11, 53076, 53076, 11, 53104, 53104, 11, 53132, 53132, 11, 53160, 53160, 11, 53188, 53188, 11, 53216, 53216, 11, 53244, 53244, 11, 53272, 53272, 11, 53300, 53300, 11, 53328, 53328, 11, 53356, 53356, 11, 53384, 53384, 11, 53412, 53412, 11, 53440, 53440, 11, 53468, 53468, 11, 53496, 53496, 11, 53524, 53524, 11, 53552, 53552, 11, 53580, 53580, 11, 53608, 53608, 11, 53636, 53636, 11, 53664, 53664, 11, 53692, 53692, 11, 53720, 53720, 11, 53748, 53748, 11, 53776, 53776, 11, 53804, 53804, 11, 53832, 53832, 11, 53860, 53860, 11, 53888, 53888, 11, 53916, 53916, 11, 53944, 53944, 11, 53972, 53972, 11, 54000, 54000, 11, 54028, 54028, 11, 54056, 54056, 11, 54084, 54084, 11, 54112, 54112, 11, 54140, 54140, 11, 54168, 54168, 11, 54196, 54196, 11, 54224, 54224, 11, 54252, 54252, 11, 54280, 54280, 11, 54308, 54308, 11, 54336, 54336, 11, 54364, 54364, 11, 54392, 54392, 11, 54420, 54420, 11, 54448, 54448, 11, 54476, 54476, 11, 54504, 54504, 11, 54532, 54532, 11, 54560, 54560, 11, 54588, 54588, 11, 54616, 54616, 11, 54644, 54644, 11, 54672, 54672, 11, 54700, 54700, 11, 54728, 54728, 11, 54756, 54756, 11, 54784, 54784, 11, 54812, 54812, 11, 54840, 54840, 11, 54868, 54868, 11, 54896, 54896, 11, 54924, 54924, 11, 54952, 54952, 11, 54980, 54980, 11, 55008, 55008, 11, 55036, 55036, 11, 55064, 55064, 11, 55092, 55092, 11, 55120, 55120, 11, 55148, 55148, 11, 55176, 55176, 11, 55216, 55238, 9, 64286, 64286, 5, 65056, 65071, 5, 65438, 65439, 5, 65529, 65531, 4, 66272, 66272, 5, 68097, 68099, 5, 68108, 68111, 5, 68159, 68159, 5, 68900, 68903, 5, 69446, 69456, 5, 69632, 69632, 7, 69634, 69634, 7, 69744, 69744, 5, 69759, 69761, 5, 69808, 69810, 7, 69815, 69816, 7, 69821, 69821, 1, 69837, 69837, 1, 69927, 69931, 5, 69933, 69940, 5, 70003, 70003, 5, 70018, 70018, 7, 70070, 70078, 5, 70082, 70083, 1, 70094, 70094, 7, 70188, 70190, 7, 70194, 70195, 7, 70197, 70197, 7, 70206, 70206, 5, 70368, 70370, 7, 70400, 70401, 5, 70459, 70460, 5, 70463, 70463, 7, 70465, 70468, 7, 70475, 70477, 7, 70498, 70499, 7, 70512, 70516, 5, 70712, 70719, 5, 70722, 70724, 5, 70726, 70726, 5, 70832, 70832, 5, 70835, 70840, 5, 70842, 70842, 5, 70845, 70845, 5, 70847, 70848, 5, 70850, 70851, 5, 71088, 71089, 7, 71096, 71099, 7, 71102, 71102, 7, 71132, 71133, 5, 71219, 71226, 5, 71229, 71229, 5, 71231, 71232, 5, 71340, 71340, 7, 71342, 71343, 7, 71350, 71350, 7, 71453, 71455, 5, 71462, 71462, 7, 71724, 71726, 7, 71736, 71736, 7, 71984, 71984, 5, 71991, 71992, 7, 71997, 71997, 7, 71999, 71999, 1, 72001, 72001, 1, 72003, 72003, 5, 72148, 72151, 5, 72156, 72159, 7, 72164, 72164, 7, 72243, 72248, 5, 72250, 72250, 1, 72263, 72263, 5, 72279, 72280, 7, 72324, 72329, 1, 72343, 72343, 7, 72751, 72751, 7, 72760, 72765, 5, 72767, 72767, 5, 72873, 72873, 7, 72881, 72881, 7, 72884, 72884, 7, 73009, 73014, 5, 73020, 73021, 5, 73030, 73030, 1, 73098, 73102, 7, 73107, 73108, 7, 73110, 73110, 7, 73459, 73460, 5, 78896, 78904, 4, 92976, 92982, 5, 94033, 94087, 7, 94180, 94180, 5, 113821, 113822, 5, 118528, 118573, 5, 119141, 119141, 5, 119143, 119145, 5, 119150, 119154, 5, 119163, 119170, 5, 119210, 119213, 5, 121344, 121398, 5, 121461, 121461, 5, 121499, 121503, 5, 122880, 122886, 5, 122907, 122913, 5, 122918, 122922, 5, 123566, 123566, 5, 125136, 125142, 5, 126976, 126979, 14, 126981, 127182, 14, 127184, 127231, 14, 127279, 127279, 14, 127344, 127345, 14, 127374, 127374, 14, 127405, 127461, 14, 127489, 127490, 14, 127514, 127514, 14, 127538, 127546, 14, 127561, 127567, 14, 127570, 127743, 14, 127757, 127758, 14, 127760, 127760, 14, 127762, 127762, 14, 127766, 127768, 14, 127770, 127770, 14, 127772, 127772, 14, 127775, 127776, 14, 127778, 127779, 14, 127789, 127791, 14, 127794, 127795, 14, 127798, 127798, 14, 127819, 127819, 14, 127824, 127824, 14, 127868, 127868, 14, 127870, 127871, 14, 127892, 127893, 14, 127896, 127896, 14, 127900, 127901, 14, 127904, 127940, 14, 127942, 127942, 14, 127944, 127944, 14, 127946, 127946, 14, 127951, 127955, 14, 127968, 127971, 14, 127973, 127984, 14, 127987, 127987, 14, 127989, 127989, 14, 127991, 127991, 14, 127995, 127999, 5, 128008, 128008, 14, 128012, 128014, 14, 128017, 128018, 14, 128020, 128020, 14, 128022, 128022, 14, 128042, 128042, 14, 128063, 128063, 14, 128065, 128065, 14, 128101, 128101, 14, 128108, 128109, 14, 128173, 128173, 14, 128182, 128183, 14, 128236, 128237, 14, 128239, 128239, 14, 128245, 128245, 14, 128248, 128248, 14, 128253, 128253, 14, 128255, 128258, 14, 128260, 128263, 14, 128265, 128265, 14, 128277, 128277, 14, 128300, 128301, 14, 128326, 128328, 14, 128331, 128334, 14, 128336, 128347, 14, 128360, 128366, 14, 128369, 128370, 14, 128378, 128378, 14, 128391, 128391, 14, 128394, 128397, 14, 128400, 128400, 14, 128405, 128406, 14, 128420, 128420, 14, 128422, 128423, 14, 128425, 128432, 14, 128435, 128443, 14, 128445, 128449, 14, 128453, 128464, 14, 128468, 128475, 14, 128479, 128480, 14, 128482, 128482, 14, 128484, 128487, 14, 128489, 128494, 14, 128496, 128498, 14, 128500, 128505, 14, 128507, 128511, 14, 128513, 128518, 14, 128521, 128525, 14, 128527, 128527, 14, 128529, 128529, 14, 128533, 128533, 14, 128535, 128535, 14, 128537, 128537, 14];
  }
  var WE;
  var bv;
  var TE;
  var yv;
  var jE;
  var UE;
  var Wt = g({
    "out-build/vs/base/common/strings.js"() {
      "use strict";
  
      OE();
      Ta();
      WE = "﻿";
      (function (t) {
        t[t.Other = 0] = "Other";
        t[t.Prepend = 1] = "Prepend";
        t[t.CR = 2] = "CR";
        t[t.LF = 3] = "LF";
        t[t.Control = 4] = "Control";
        t[t.Extend = 5] = "Extend";
        t[t.Regional_Indicator = 6] = "Regional_Indicator";
        t[t.SpacingMark = 7] = "SpacingMark";
        t[t.L = 8] = "L";
        t[t.V = 9] = "V";
        t[t.T = 10] = "T";
        t[t.LV = 11] = "LV";
        t[t.LVT = 12] = "LVT";
        t[t.ZWJ = 13] = "ZWJ";
        t[t.Extended_Pictographic = 14] = "Extended_Pictographic";
      })(bv ||= {});
      TE = class Sl {
        static {
          this.c = null;
        }
        static getInstance() {
          Sl.c ||= new Sl();
          return Sl.c;
        }
        constructor() {
          this.d = NE();
        }
        getGraphemeBreakType(e) {
          if (e < 32) {
            if (e === 10) {
              return 3;
            } else if (e === 13) {
              return 2;
            } else {
              return 4;
            }
          }
          if (e < 127) {
            return 0;
          }
          const i = this.d;
          const s = i.length / 3;
          let r = 1;
          while (r <= s) {
            if (e < i[r * 3]) {
              r = r * 2;
            } else if (e > i[r * 3 + 1]) {
              r = r * 2 + 1;
            } else {
              return i[r * 3 + 2];
            }
          }
          return 0;
        }
      };
      (function (t) {
        t[t.zwj = 8205] = "zwj";
        t[t.emojiVariantSelector = 65039] = "emojiVariantSelector";
        t[t.enclosingKeyCap = 8419] = "enclosingKeyCap";
      })(yv ||= {});
      jE = class El {
        static {
          this.c = new vr(() => ({
            _common: [8232, 32, 8233, 32, 5760, 32, 8192, 32, 8193, 32, 8194, 32, 8195, 32, 8196, 32, 8197, 32, 8198, 32, 8200, 32, 8201, 32, 8202, 32, 8287, 32, 8199, 32, 8239, 32, 2042, 95, 65101, 95, 65102, 95, 65103, 95, 8208, 45, 8209, 45, 8210, 45, 65112, 45, 1748, 45, 8259, 45, 727, 45, 8722, 45, 10134, 45, 11450, 45, 1549, 44, 1643, 44, 8218, 44, 184, 44, 42233, 44, 894, 59, 2307, 58, 2691, 58, 1417, 58, 1795, 58, 1796, 58, 5868, 58, 65072, 58, 6147, 58, 6153, 58, 8282, 58, 1475, 58, 760, 58, 42889, 58, 8758, 58, 720, 58, 42237, 58, 451, 33, 11601, 33, 660, 63, 577, 63, 2429, 63, 5038, 63, 42731, 63, 119149, 46, 8228, 46, 1793, 46, 1794, 46, 42510, 46, 68176, 46, 1632, 46, 1776, 46, 42232, 46, 1373, 96, 65287, 96, 8219, 96, 8242, 96, 1370, 96, 1523, 96, 8175, 96, 65344, 96, 900, 96, 8189, 96, 8125, 96, 8127, 96, 8190, 96, 697, 96, 884, 96, 712, 96, 714, 96, 715, 96, 756, 96, 699, 96, 701, 96, 700, 96, 702, 96, 42892, 96, 1497, 96, 2036, 96, 2037, 96, 5194, 96, 5836, 96, 94033, 96, 94034, 96, 65339, 91, 10088, 40, 10098, 40, 12308, 40, 64830, 40, 65341, 93, 10089, 41, 10099, 41, 12309, 41, 64831, 41, 10100, 123, 119060, 123, 10101, 125, 65342, 94, 8270, 42, 1645, 42, 8727, 42, 66335, 42, 5941, 47, 8257, 47, 8725, 47, 8260, 47, 9585, 47, 10187, 47, 10744, 47, 119354, 47, 12755, 47, 12339, 47, 11462, 47, 20031, 47, 12035, 47, 65340, 92, 65128, 92, 8726, 92, 10189, 92, 10741, 92, 10745, 92, 119311, 92, 119355, 92, 12756, 92, 20022, 92, 12034, 92, 42872, 38, 708, 94, 710, 94, 5869, 43, 10133, 43, 66203, 43, 8249, 60, 10094, 60, 706, 60, 119350, 60, 5176, 60, 5810, 60, 5120, 61, 11840, 61, 12448, 61, 42239, 61, 8250, 62, 10095, 62, 707, 62, 119351, 62, 5171, 62, 94015, 62, 8275, 126, 732, 126, 8128, 126, 8764, 126, 65372, 124, 65293, 45, 120784, 50, 120794, 50, 120804, 50, 120814, 50, 120824, 50, 130034, 50, 42842, 50, 423, 50, 1000, 50, 42564, 50, 5311, 50, 42735, 50, 119302, 51, 120785, 51, 120795, 51, 120805, 51, 120815, 51, 120825, 51, 130035, 51, 42923, 51, 540, 51, 439, 51, 42858, 51, 11468, 51, 1248, 51, 94011, 51, 71882, 51, 120786, 52, 120796, 52, 120806, 52, 120816, 52, 120826, 52, 130036, 52, 5070, 52, 71855, 52, 120787, 53, 120797, 53, 120807, 53, 120817, 53, 120827, 53, 130037, 53, 444, 53, 71867, 53, 120788, 54, 120798, 54, 120808, 54, 120818, 54, 120828, 54, 130038, 54, 11474, 54, 5102, 54, 71893, 54, 119314, 55, 120789, 55, 120799, 55, 120809, 55, 120819, 55, 120829, 55, 130039, 55, 66770, 55, 71878, 55, 2819, 56, 2538, 56, 2666, 56, 125131, 56, 120790, 56, 120800, 56, 120810, 56, 120820, 56, 120830, 56, 130040, 56, 547, 56, 546, 56, 66330, 56, 2663, 57, 2920, 57, 2541, 57, 3437, 57, 120791, 57, 120801, 57, 120811, 57, 120821, 57, 120831, 57, 130041, 57, 42862, 57, 11466, 57, 71884, 57, 71852, 57, 71894, 57, 9082, 97, 65345, 97, 119834, 97, 119886, 97, 119938, 97, 119990, 97, 120042, 97, 120094, 97, 120146, 97, 120198, 97, 120250, 97, 120302, 97, 120354, 97, 120406, 97, 120458, 97, 593, 97, 945, 97, 120514, 97, 120572, 97, 120630, 97, 120688, 97, 120746, 97, 65313, 65, 119808, 65, 119860, 65, 119912, 65, 119964, 65, 120016, 65, 120068, 65, 120120, 65, 120172, 65, 120224, 65, 120276, 65, 120328, 65, 120380, 65, 120432, 65, 913, 65, 120488, 65, 120546, 65, 120604, 65, 120662, 65, 120720, 65, 5034, 65, 5573, 65, 42222, 65, 94016, 65, 66208, 65, 119835, 98, 119887, 98, 119939, 98, 119991, 98, 120043, 98, 120095, 98, 120147, 98, 120199, 98, 120251, 98, 120303, 98, 120355, 98, 120407, 98, 120459, 98, 388, 98, 5071, 98, 5234, 98, 5551, 98, 65314, 66, 8492, 66, 119809, 66, 119861, 66, 119913, 66, 120017, 66, 120069, 66, 120121, 66, 120173, 66, 120225, 66, 120277, 66, 120329, 66, 120381, 66, 120433, 66, 42932, 66, 914, 66, 120489, 66, 120547, 66, 120605, 66, 120663, 66, 120721, 66, 5108, 66, 5623, 66, 42192, 66, 66178, 66, 66209, 66, 66305, 66, 65347, 99, 8573, 99, 119836, 99, 119888, 99, 119940, 99, 119992, 99, 120044, 99, 120096, 99, 120148, 99, 120200, 99, 120252, 99, 120304, 99, 120356, 99, 120408, 99, 120460, 99, 7428, 99, 1010, 99, 11429, 99, 43951, 99, 66621, 99, 128844, 67, 71922, 67, 71913, 67, 65315, 67, 8557, 67, 8450, 67, 8493, 67, 119810, 67, 119862, 67, 119914, 67, 119966, 67, 120018, 67, 120174, 67, 120226, 67, 120278, 67, 120330, 67, 120382, 67, 120434, 67, 1017, 67, 11428, 67, 5087, 67, 42202, 67, 66210, 67, 66306, 67, 66581, 67, 66844, 67, 8574, 100, 8518, 100, 119837, 100, 119889, 100, 119941, 100, 119993, 100, 120045, 100, 120097, 100, 120149, 100, 120201, 100, 120253, 100, 120305, 100, 120357, 100, 120409, 100, 120461, 100, 1281, 100, 5095, 100, 5231, 100, 42194, 100, 8558, 68, 8517, 68, 119811, 68, 119863, 68, 119915, 68, 119967, 68, 120019, 68, 120071, 68, 120123, 68, 120175, 68, 120227, 68, 120279, 68, 120331, 68, 120383, 68, 120435, 68, 5024, 68, 5598, 68, 5610, 68, 42195, 68, 8494, 101, 65349, 101, 8495, 101, 8519, 101, 119838, 101, 119890, 101, 119942, 101, 120046, 101, 120098, 101, 120150, 101, 120202, 101, 120254, 101, 120306, 101, 120358, 101, 120410, 101, 120462, 101, 43826, 101, 1213, 101, 8959, 69, 65317, 69, 8496, 69, 119812, 69, 119864, 69, 119916, 69, 120020, 69, 120072, 69, 120124, 69, 120176, 69, 120228, 69, 120280, 69, 120332, 69, 120384, 69, 120436, 69, 917, 69, 120492, 69, 120550, 69, 120608, 69, 120666, 69, 120724, 69, 11577, 69, 5036, 69, 42224, 69, 71846, 69, 71854, 69, 66182, 69, 119839, 102, 119891, 102, 119943, 102, 119995, 102, 120047, 102, 120099, 102, 120151, 102, 120203, 102, 120255, 102, 120307, 102, 120359, 102, 120411, 102, 120463, 102, 43829, 102, 42905, 102, 383, 102, 7837, 102, 1412, 102, 119315, 70, 8497, 70, 119813, 70, 119865, 70, 119917, 70, 120021, 70, 120073, 70, 120125, 70, 120177, 70, 120229, 70, 120281, 70, 120333, 70, 120385, 70, 120437, 70, 42904, 70, 988, 70, 120778, 70, 5556, 70, 42205, 70, 71874, 70, 71842, 70, 66183, 70, 66213, 70, 66853, 70, 65351, 103, 8458, 103, 119840, 103, 119892, 103, 119944, 103, 120048, 103, 120100, 103, 120152, 103, 120204, 103, 120256, 103, 120308, 103, 120360, 103, 120412, 103, 120464, 103, 609, 103, 7555, 103, 397, 103, 1409, 103, 119814, 71, 119866, 71, 119918, 71, 119970, 71, 120022, 71, 120074, 71, 120126, 71, 120178, 71, 120230, 71, 120282, 71, 120334, 71, 120386, 71, 120438, 71, 1292, 71, 5056, 71, 5107, 71, 42198, 71, 65352, 104, 8462, 104, 119841, 104, 119945, 104, 119997, 104, 120049, 104, 120101, 104, 120153, 104, 120205, 104, 120257, 104, 120309, 104, 120361, 104, 120413, 104, 120465, 104, 1211, 104, 1392, 104, 5058, 104, 65320, 72, 8459, 72, 8460, 72, 8461, 72, 119815, 72, 119867, 72, 119919, 72, 120023, 72, 120179, 72, 120231, 72, 120283, 72, 120335, 72, 120387, 72, 120439, 72, 919, 72, 120494, 72, 120552, 72, 120610, 72, 120668, 72, 120726, 72, 11406, 72, 5051, 72, 5500, 72, 42215, 72, 66255, 72, 731, 105, 9075, 105, 65353, 105, 8560, 105, 8505, 105, 8520, 105, 119842, 105, 119894, 105, 119946, 105, 119998, 105, 120050, 105, 120102, 105, 120154, 105, 120206, 105, 120258, 105, 120310, 105, 120362, 105, 120414, 105, 120466, 105, 120484, 105, 618, 105, 617, 105, 953, 105, 8126, 105, 890, 105, 120522, 105, 120580, 105, 120638, 105, 120696, 105, 120754, 105, 1110, 105, 42567, 105, 1231, 105, 43893, 105, 5029, 105, 71875, 105, 65354, 106, 8521, 106, 119843, 106, 119895, 106, 119947, 106, 119999, 106, 120051, 106, 120103, 106, 120155, 106, 120207, 106, 120259, 106, 120311, 106, 120363, 106, 120415, 106, 120467, 106, 1011, 106, 1112, 106, 65322, 74, 119817, 74, 119869, 74, 119921, 74, 119973, 74, 120025, 74, 120077, 74, 120129, 74, 120181, 74, 120233, 74, 120285, 74, 120337, 74, 120389, 74, 120441, 74, 42930, 74, 895, 74, 1032, 74, 5035, 74, 5261, 74, 42201, 74, 119844, 107, 119896, 107, 119948, 107, 120000, 107, 120052, 107, 120104, 107, 120156, 107, 120208, 107, 120260, 107, 120312, 107, 120364, 107, 120416, 107, 120468, 107, 8490, 75, 65323, 75, 119818, 75, 119870, 75, 119922, 75, 119974, 75, 120026, 75, 120078, 75, 120130, 75, 120182, 75, 120234, 75, 120286, 75, 120338, 75, 120390, 75, 120442, 75, 922, 75, 120497, 75, 120555, 75, 120613, 75, 120671, 75, 120729, 75, 11412, 75, 5094, 75, 5845, 75, 42199, 75, 66840, 75, 1472, 108, 8739, 73, 9213, 73, 65512, 73, 1633, 108, 1777, 73, 66336, 108, 125127, 108, 120783, 73, 120793, 73, 120803, 73, 120813, 73, 120823, 73, 130033, 73, 65321, 73, 8544, 73, 8464, 73, 8465, 73, 119816, 73, 119868, 73, 119920, 73, 120024, 73, 120128, 73, 120180, 73, 120232, 73, 120284, 73, 120336, 73, 120388, 73, 120440, 73, 65356, 108, 8572, 73, 8467, 108, 119845, 108, 119897, 108, 119949, 108, 120001, 108, 120053, 108, 120105, 73, 120157, 73, 120209, 73, 120261, 73, 120313, 73, 120365, 73, 120417, 73, 120469, 73, 448, 73, 120496, 73, 120554, 73, 120612, 73, 120670, 73, 120728, 73, 11410, 73, 1030, 73, 1216, 73, 1493, 108, 1503, 108, 1575, 108, 126464, 108, 126592, 108, 65166, 108, 65165, 108, 1994, 108, 11599, 73, 5825, 73, 42226, 73, 93992, 73, 66186, 124, 66313, 124, 119338, 76, 8556, 76, 8466, 76, 119819, 76, 119871, 76, 119923, 76, 120027, 76, 120079, 76, 120131, 76, 120183, 76, 120235, 76, 120287, 76, 120339, 76, 120391, 76, 120443, 76, 11472, 76, 5086, 76, 5290, 76, 42209, 76, 93974, 76, 71843, 76, 71858, 76, 66587, 76, 66854, 76, 65325, 77, 8559, 77, 8499, 77, 119820, 77, 119872, 77, 119924, 77, 120028, 77, 120080, 77, 120132, 77, 120184, 77, 120236, 77, 120288, 77, 120340, 77, 120392, 77, 120444, 77, 924, 77, 120499, 77, 120557, 77, 120615, 77, 120673, 77, 120731, 77, 1018, 77, 11416, 77, 5047, 77, 5616, 77, 5846, 77, 42207, 77, 66224, 77, 66321, 77, 119847, 110, 119899, 110, 119951, 110, 120003, 110, 120055, 110, 120107, 110, 120159, 110, 120211, 110, 120263, 110, 120315, 110, 120367, 110, 120419, 110, 120471, 110, 1400, 110, 1404, 110, 65326, 78, 8469, 78, 119821, 78, 119873, 78, 119925, 78, 119977, 78, 120029, 78, 120081, 78, 120185, 78, 120237, 78, 120289, 78, 120341, 78, 120393, 78, 120445, 78, 925, 78, 120500, 78, 120558, 78, 120616, 78, 120674, 78, 120732, 78, 11418, 78, 42208, 78, 66835, 78, 3074, 111, 3202, 111, 3330, 111, 3458, 111, 2406, 111, 2662, 111, 2790, 111, 3046, 111, 3174, 111, 3302, 111, 3430, 111, 3664, 111, 3792, 111, 4160, 111, 1637, 111, 1781, 111, 65359, 111, 8500, 111, 119848, 111, 119900, 111, 119952, 111, 120056, 111, 120108, 111, 120160, 111, 120212, 111, 120264, 111, 120316, 111, 120368, 111, 120420, 111, 120472, 111, 7439, 111, 7441, 111, 43837, 111, 959, 111, 120528, 111, 120586, 111, 120644, 111, 120702, 111, 120760, 111, 963, 111, 120532, 111, 120590, 111, 120648, 111, 120706, 111, 120764, 111, 11423, 111, 4351, 111, 1413, 111, 1505, 111, 1607, 111, 126500, 111, 126564, 111, 126596, 111, 65259, 111, 65260, 111, 65258, 111, 65257, 111, 1726, 111, 64428, 111, 64429, 111, 64427, 111, 64426, 111, 1729, 111, 64424, 111, 64425, 111, 64423, 111, 64422, 111, 1749, 111, 3360, 111, 4125, 111, 66794, 111, 71880, 111, 71895, 111, 66604, 111, 1984, 79, 2534, 79, 2918, 79, 12295, 79, 70864, 79, 71904, 79, 120782, 79, 120792, 79, 120802, 79, 120812, 79, 120822, 79, 130032, 79, 65327, 79, 119822, 79, 119874, 79, 119926, 79, 119978, 79, 120030, 79, 120082, 79, 120134, 79, 120186, 79, 120238, 79, 120290, 79, 120342, 79, 120394, 79, 120446, 79, 927, 79, 120502, 79, 120560, 79, 120618, 79, 120676, 79, 120734, 79, 11422, 79, 1365, 79, 11604, 79, 4816, 79, 2848, 79, 66754, 79, 42227, 79, 71861, 79, 66194, 79, 66219, 79, 66564, 79, 66838, 79, 9076, 112, 65360, 112, 119849, 112, 119901, 112, 119953, 112, 120005, 112, 120057, 112, 120109, 112, 120161, 112, 120213, 112, 120265, 112, 120317, 112, 120369, 112, 120421, 112, 120473, 112, 961, 112, 120530, 112, 120544, 112, 120588, 112, 120602, 112, 120646, 112, 120660, 112, 120704, 112, 120718, 112, 120762, 112, 120776, 112, 11427, 112, 65328, 80, 8473, 80, 119823, 80, 119875, 80, 119927, 80, 119979, 80, 120031, 80, 120083, 80, 120187, 80, 120239, 80, 120291, 80, 120343, 80, 120395, 80, 120447, 80, 929, 80, 120504, 80, 120562, 80, 120620, 80, 120678, 80, 120736, 80, 11426, 80, 5090, 80, 5229, 80, 42193, 80, 66197, 80, 119850, 113, 119902, 113, 119954, 113, 120006, 113, 120058, 113, 120110, 113, 120162, 113, 120214, 113, 120266, 113, 120318, 113, 120370, 113, 120422, 113, 120474, 113, 1307, 113, 1379, 113, 1382, 113, 8474, 81, 119824, 81, 119876, 81, 119928, 81, 119980, 81, 120032, 81, 120084, 81, 120188, 81, 120240, 81, 120292, 81, 120344, 81, 120396, 81, 120448, 81, 11605, 81, 119851, 114, 119903, 114, 119955, 114, 120007, 114, 120059, 114, 120111, 114, 120163, 114, 120215, 114, 120267, 114, 120319, 114, 120371, 114, 120423, 114, 120475, 114, 43847, 114, 43848, 114, 7462, 114, 11397, 114, 43905, 114, 119318, 82, 8475, 82, 8476, 82, 8477, 82, 119825, 82, 119877, 82, 119929, 82, 120033, 82, 120189, 82, 120241, 82, 120293, 82, 120345, 82, 120397, 82, 120449, 82, 422, 82, 5025, 82, 5074, 82, 66740, 82, 5511, 82, 42211, 82, 94005, 82, 65363, 115, 119852, 115, 119904, 115, 119956, 115, 120008, 115, 120060, 115, 120112, 115, 120164, 115, 120216, 115, 120268, 115, 120320, 115, 120372, 115, 120424, 115, 120476, 115, 42801, 115, 445, 115, 1109, 115, 43946, 115, 71873, 115, 66632, 115, 65331, 83, 119826, 83, 119878, 83, 119930, 83, 119982, 83, 120034, 83, 120086, 83, 120138, 83, 120190, 83, 120242, 83, 120294, 83, 120346, 83, 120398, 83, 120450, 83, 1029, 83, 1359, 83, 5077, 83, 5082, 83, 42210, 83, 94010, 83, 66198, 83, 66592, 83, 119853, 116, 119905, 116, 119957, 116, 120009, 116, 120061, 116, 120113, 116, 120165, 116, 120217, 116, 120269, 116, 120321, 116, 120373, 116, 120425, 116, 120477, 116, 8868, 84, 10201, 84, 128872, 84, 65332, 84, 119827, 84, 119879, 84, 119931, 84, 119983, 84, 120035, 84, 120087, 84, 120139, 84, 120191, 84, 120243, 84, 120295, 84, 120347, 84, 120399, 84, 120451, 84, 932, 84, 120507, 84, 120565, 84, 120623, 84, 120681, 84, 120739, 84, 11430, 84, 5026, 84, 42196, 84, 93962, 84, 71868, 84, 66199, 84, 66225, 84, 66325, 84, 119854, 117, 119906, 117, 119958, 117, 120010, 117, 120062, 117, 120114, 117, 120166, 117, 120218, 117, 120270, 117, 120322, 117, 120374, 117, 120426, 117, 120478, 117, 42911, 117, 7452, 117, 43854, 117, 43858, 117, 651, 117, 965, 117, 120534, 117, 120592, 117, 120650, 117, 120708, 117, 120766, 117, 1405, 117, 66806, 117, 71896, 117, 8746, 85, 8899, 85, 119828, 85, 119880, 85, 119932, 85, 119984, 85, 120036, 85, 120088, 85, 120140, 85, 120192, 85, 120244, 85, 120296, 85, 120348, 85, 120400, 85, 120452, 85, 1357, 85, 4608, 85, 66766, 85, 5196, 85, 42228, 85, 94018, 85, 71864, 85, 8744, 118, 8897, 118, 65366, 118, 8564, 118, 119855, 118, 119907, 118, 119959, 118, 120011, 118, 120063, 118, 120115, 118, 120167, 118, 120219, 118, 120271, 118, 120323, 118, 120375, 118, 120427, 118, 120479, 118, 7456, 118, 957, 118, 120526, 118, 120584, 118, 120642, 118, 120700, 118, 120758, 118, 1141, 118, 1496, 118, 71430, 118, 43945, 118, 71872, 118, 119309, 86, 1639, 86, 1783, 86, 8548, 86, 119829, 86, 119881, 86, 119933, 86, 119985, 86, 120037, 86, 120089, 86, 120141, 86, 120193, 86, 120245, 86, 120297, 86, 120349, 86, 120401, 86, 120453, 86, 1140, 86, 11576, 86, 5081, 86, 5167, 86, 42719, 86, 42214, 86, 93960, 86, 71840, 86, 66845, 86, 623, 119, 119856, 119, 119908, 119, 119960, 119, 120012, 119, 120064, 119, 120116, 119, 120168, 119, 120220, 119, 120272, 119, 120324, 119, 120376, 119, 120428, 119, 120480, 119, 7457, 119, 1121, 119, 1309, 119, 1377, 119, 71434, 119, 71438, 119, 71439, 119, 43907, 119, 71919, 87, 71910, 87, 119830, 87, 119882, 87, 119934, 87, 119986, 87, 120038, 87, 120090, 87, 120142, 87, 120194, 87, 120246, 87, 120298, 87, 120350, 87, 120402, 87, 120454, 87, 1308, 87, 5043, 87, 5076, 87, 42218, 87, 5742, 120, 10539, 120, 10540, 120, 10799, 120, 65368, 120, 8569, 120, 119857, 120, 119909, 120, 119961, 120, 120013, 120, 120065, 120, 120117, 120, 120169, 120, 120221, 120, 120273, 120, 120325, 120, 120377, 120, 120429, 120, 120481, 120, 5441, 120, 5501, 120, 5741, 88, 9587, 88, 66338, 88, 71916, 88, 65336, 88, 8553, 88, 119831, 88, 119883, 88, 119935, 88, 119987, 88, 120039, 88, 120091, 88, 120143, 88, 120195, 88, 120247, 88, 120299, 88, 120351, 88, 120403, 88, 120455, 88, 42931, 88, 935, 88, 120510, 88, 120568, 88, 120626, 88, 120684, 88, 120742, 88, 11436, 88, 11613, 88, 5815, 88, 42219, 88, 66192, 88, 66228, 88, 66327, 88, 66855, 88, 611, 121, 7564, 121, 65369, 121, 119858, 121, 119910, 121, 119962, 121, 120014, 121, 120066, 121, 120118, 121, 120170, 121, 120222, 121, 120274, 121, 120326, 121, 120378, 121, 120430, 121, 120482, 121, 655, 121, 7935, 121, 43866, 121, 947, 121, 8509, 121, 120516, 121, 120574, 121, 120632, 121, 120690, 121, 120748, 121, 1199, 121, 4327, 121, 71900, 121, 65337, 89, 119832, 89, 119884, 89, 119936, 89, 119988, 89, 120040, 89, 120092, 89, 120144, 89, 120196, 89, 120248, 89, 120300, 89, 120352, 89, 120404, 89, 120456, 89, 933, 89, 978, 89, 120508, 89, 120566, 89, 120624, 89, 120682, 89, 120740, 89, 11432, 89, 1198, 89, 5033, 89, 5053, 89, 42220, 89, 94019, 89, 71844, 89, 66226, 89, 119859, 122, 119911, 122, 119963, 122, 120015, 122, 120067, 122, 120119, 122, 120171, 122, 120223, 122, 120275, 122, 120327, 122, 120379, 122, 120431, 122, 120483, 122, 7458, 122, 43923, 122, 71876, 122, 66293, 90, 71909, 90, 65338, 90, 8484, 90, 8488, 90, 119833, 90, 119885, 90, 119937, 90, 119989, 90, 120041, 90, 120197, 90, 120249, 90, 120301, 90, 120353, 90, 120405, 90, 120457, 90, 918, 90, 120493, 90, 120551, 90, 120609, 90, 120667, 90, 120725, 90, 5059, 90, 42204, 90, 71849, 90, 65282, 34, 65284, 36, 65285, 37, 65286, 38, 65290, 42, 65291, 43, 65294, 46, 65295, 47, 65296, 48, 65297, 49, 65298, 50, 65299, 51, 65300, 52, 65301, 53, 65302, 54, 65303, 55, 65304, 56, 65305, 57, 65308, 60, 65309, 61, 65310, 62, 65312, 64, 65316, 68, 65318, 70, 65319, 71, 65324, 76, 65329, 81, 65330, 82, 65333, 85, 65334, 86, 65335, 87, 65343, 95, 65346, 98, 65348, 100, 65350, 102, 65355, 107, 65357, 109, 65358, 110, 65361, 113, 65362, 114, 65364, 116, 65365, 117, 65367, 119, 65370, 122, 65371, 123, 65373, 125, 119846, 109],
            _default: [160, 32, 8211, 45, 65374, 126, 65306, 58, 65281, 33, 8216, 96, 8217, 96, 8245, 96, 180, 96, 12494, 47, 1047, 51, 1073, 54, 1072, 97, 1040, 65, 1068, 98, 1042, 66, 1089, 99, 1057, 67, 1077, 101, 1045, 69, 1053, 72, 305, 105, 1050, 75, 921, 73, 1052, 77, 1086, 111, 1054, 79, 1009, 112, 1088, 112, 1056, 80, 1075, 114, 1058, 84, 215, 120, 1093, 120, 1061, 88, 1091, 121, 1059, 89, 65283, 35, 65288, 40, 65289, 41, 65292, 44, 65307, 59, 65311, 63],
            cs: [65374, 126, 65306, 58, 65281, 33, 8216, 96, 8217, 96, 8245, 96, 180, 96, 12494, 47, 1047, 51, 1073, 54, 1072, 97, 1040, 65, 1068, 98, 1042, 66, 1089, 99, 1057, 67, 1077, 101, 1045, 69, 1053, 72, 305, 105, 1050, 75, 921, 73, 1052, 77, 1086, 111, 1054, 79, 1009, 112, 1088, 112, 1056, 80, 1075, 114, 1058, 84, 1093, 120, 1061, 88, 1091, 121, 1059, 89, 65283, 35, 65288, 40, 65289, 41, 65292, 44, 65307, 59, 65311, 63],
            de: [65374, 126, 65306, 58, 65281, 33, 8216, 96, 8217, 96, 8245, 96, 180, 96, 12494, 47, 1047, 51, 1073, 54, 1072, 97, 1040, 65, 1068, 98, 1042, 66, 1089, 99, 1057, 67, 1077, 101, 1045, 69, 1053, 72, 305, 105, 1050, 75, 921, 73, 1052, 77, 1086, 111, 1054, 79, 1009, 112, 1088, 112, 1056, 80, 1075, 114, 1058, 84, 1093, 120, 1061, 88, 1091, 121, 1059, 89, 65283, 35, 65288, 40, 65289, 41, 65292, 44, 65307, 59, 65311, 63],
            es: [8211, 45, 65374, 126, 65306, 58, 65281, 33, 8245, 96, 180, 96, 12494, 47, 1047, 51, 1073, 54, 1072, 97, 1040, 65, 1068, 98, 1042, 66, 1089, 99, 1057, 67, 1077, 101, 1045, 69, 1053, 72, 305, 105, 1050, 75, 1052, 77, 1086, 111, 1054, 79, 1009, 112, 1088, 112, 1056, 80, 1075, 114, 1058, 84, 215, 120, 1093, 120, 1061, 88, 1091, 121, 1059, 89, 65283, 35, 65288, 40, 65289, 41, 65292, 44, 65307, 59, 65311, 63],
            fr: [65374, 126, 65306, 58, 65281, 33, 8216, 96, 8245, 96, 12494, 47, 1047, 51, 1073, 54, 1072, 97, 1040, 65, 1068, 98, 1042, 66, 1089, 99, 1057, 67, 1077, 101, 1045, 69, 1053, 72, 305, 105, 1050, 75, 921, 73, 1052, 77, 1086, 111, 1054, 79, 1009, 112, 1088, 112, 1056, 80, 1075, 114, 1058, 84, 215, 120, 1093, 120, 1061, 88, 1091, 121, 1059, 89, 65283, 35, 65288, 40, 65289, 41, 65292, 44, 65307, 59, 65311, 63],
            it: [160, 32, 8211, 45, 65374, 126, 65306, 58, 65281, 33, 8216, 96, 8245, 96, 180, 96, 12494, 47, 1047, 51, 1073, 54, 1072, 97, 1040, 65, 1068, 98, 1042, 66, 1089, 99, 1057, 67, 1077, 101, 1045, 69, 1053, 72, 305, 105, 1050, 75, 921, 73, 1052, 77, 1086, 111, 1054, 79, 1009, 112, 1088, 112, 1056, 80, 1075, 114, 1058, 84, 215, 120, 1093, 120, 1061, 88, 1091, 121, 1059, 89, 65283, 35, 65288, 40, 65289, 41, 65292, 44, 65307, 59, 65311, 63],
            ja: [8211, 45, 65306, 58, 65281, 33, 8216, 96, 8217, 96, 8245, 96, 180, 96, 1047, 51, 1073, 54, 1072, 97, 1040, 65, 1068, 98, 1042, 66, 1089, 99, 1057, 67, 1077, 101, 1045, 69, 1053, 72, 305, 105, 1050, 75, 921, 73, 1052, 77, 1086, 111, 1054, 79, 1009, 112, 1088, 112, 1056, 80, 1075, 114, 1058, 84, 215, 120, 1093, 120, 1061, 88, 1091, 121, 1059, 89, 65283, 35, 65292, 44, 65307, 59],
            ko: [8211, 45, 65374, 126, 65306, 58, 65281, 33, 8245, 96, 180, 96, 12494, 47, 1047, 51, 1073, 54, 1072, 97, 1040, 65, 1068, 98, 1042, 66, 1089, 99, 1057, 67, 1077, 101, 1045, 69, 1053, 72, 305, 105, 1050, 75, 921, 73, 1052, 77, 1086, 111, 1054, 79, 1009, 112, 1088, 112, 1056, 80, 1075, 114, 1058, 84, 215, 120, 1093, 120, 1061, 88, 1091, 121, 1059, 89, 65283, 35, 65288, 40, 65289, 41, 65292, 44, 65307, 59, 65311, 63],
            pl: [65374, 126, 65306, 58, 65281, 33, 8216, 96, 8217, 96, 8245, 96, 180, 96, 12494, 47, 1047, 51, 1073, 54, 1072, 97, 1040, 65, 1068, 98, 1042, 66, 1089, 99, 1057, 67, 1077, 101, 1045, 69, 1053, 72, 305, 105, 1050, 75, 921, 73, 1052, 77, 1086, 111, 1054, 79, 1009, 112, 1088, 112, 1056, 80, 1075, 114, 1058, 84, 215, 120, 1093, 120, 1061, 88, 1091, 121, 1059, 89, 65283, 35, 65288, 40, 65289, 41, 65292, 44, 65307, 59, 65311, 63],
            "pt-BR": [65374, 126, 65306, 58, 65281, 33, 8216, 96, 8217, 96, 8245, 96, 180, 96, 12494, 47, 1047, 51, 1073, 54, 1072, 97, 1040, 65, 1068, 98, 1042, 66, 1089, 99, 1057, 67, 1077, 101, 1045, 69, 1053, 72, 305, 105, 1050, 75, 921, 73, 1052, 77, 1086, 111, 1054, 79, 1009, 112, 1088, 112, 1056, 80, 1075, 114, 1058, 84, 215, 120, 1093, 120, 1061, 88, 1091, 121, 1059, 89, 65283, 35, 65288, 40, 65289, 41, 65292, 44, 65307, 59, 65311, 63],
            "qps-ploc": [160, 32, 8211, 45, 65374, 126, 65306, 58, 65281, 33, 8216, 96, 8217, 96, 8245, 96, 180, 96, 12494, 47, 1047, 51, 1073, 54, 1072, 97, 1040, 65, 1068, 98, 1042, 66, 1089, 99, 1057, 67, 1077, 101, 1045, 69, 1053, 72, 305, 105, 1050, 75, 921, 73, 1052, 77, 1086, 111, 1054, 79, 1088, 112, 1056, 80, 1075, 114, 1058, 84, 215, 120, 1093, 120, 1061, 88, 1091, 121, 1059, 89, 65283, 35, 65288, 40, 65289, 41, 65292, 44, 65307, 59, 65311, 63],
            ru: [65374, 126, 65306, 58, 65281, 33, 8216, 96, 8217, 96, 8245, 96, 180, 96, 12494, 47, 305, 105, 921, 73, 1009, 112, 215, 120, 65283, 35, 65288, 40, 65289, 41, 65292, 44, 65307, 59, 65311, 63],
            tr: [160, 32, 8211, 45, 65374, 126, 65306, 58, 65281, 33, 8245, 96, 180, 96, 12494, 47, 1047, 51, 1073, 54, 1072, 97, 1040, 65, 1068, 98, 1042, 66, 1089, 99, 1057, 67, 1077, 101, 1045, 69, 1053, 72, 1050, 75, 921, 73, 1052, 77, 1086, 111, 1054, 79, 1009, 112, 1088, 112, 1056, 80, 1075, 114, 1058, 84, 215, 120, 1093, 120, 1061, 88, 1091, 121, 1059, 89, 65283, 35, 65288, 40, 65289, 41, 65292, 44, 65307, 59, 65311, 63],
            "zh-hans": [65374, 126, 65306, 58, 65281, 33, 8245, 96, 180, 96, 12494, 47, 1047, 51, 1073, 54, 1072, 97, 1040, 65, 1068, 98, 1042, 66, 1089, 99, 1057, 67, 1077, 101, 1045, 69, 1053, 72, 305, 105, 1050, 75, 921, 73, 1052, 77, 1086, 111, 1054, 79, 1009, 112, 1088, 112, 1056, 80, 1075, 114, 1058, 84, 215, 120, 1093, 120, 1061, 88, 1091, 121, 1059, 89, 65288, 40, 65289, 41],
            "zh-hant": [8211, 45, 65374, 126, 180, 96, 12494, 47, 1047, 51, 1073, 54, 1072, 97, 1040, 65, 1068, 98, 1042, 66, 1089, 99, 1057, 67, 1077, 101, 1045, 69, 1053, 72, 305, 105, 1050, 75, 921, 73, 1052, 77, 1086, 111, 1054, 79, 1009, 112, 1088, 112, 1056, 80, 1075, 114, 1058, 84, 215, 120, 1093, 120, 1061, 88, 1091, 121, 1059, 89, 65283, 35, 65307, 59]
          }));
        }
        static {
          this.d = new fv({
            getCacheKey: JSON.stringify
          }, e => {
            function i(u) {
              const d = new Map();
              for (let f = 0; f < u.length; f += 2) {
                d.set(u[f], u[f + 1]);
              }
              return d;
            }
            function s(u, d) {
              const f = new Map(u);
              for (const [p, w] of d) {
                f.set(p, w);
              }
              return f;
            }
            function r(u, d) {
              if (!u) {
                return d;
              }
              const f = new Map();
              for (const [p, w] of u) {
                if (d.has(p)) {
                  f.set(p, w);
                }
              }
              return f;
            }
            const n = this.c.value;
            let o = e.filter(u => !u.startsWith("_") && u in n);
            if (o.length === 0) {
              o = ["_default"];
            }
            let a;
            for (const u of o) {
              const d = i(n[u]);
              a = r(a, d);
            }
            const c = i(n._common);
            const l = s(c, a);
            return new El(l);
          });
        }
        static getInstance(e) {
          return El.d.get(Array.from(e));
        }
        static {
          this.e = new vr(() => Object.keys(El.c.value).filter(e => !e.startsWith("_")));
        }
        static getLocales() {
          return El.e.value;
        }
        constructor(e) {
          this.f = e;
        }
        isAmbiguous(e) {
          return this.f.has(e);
        }
        containsAmbiguousCharacter(e) {
          for (let i = 0; i < e.length; i++) {
            const s = e.codePointAt(i);
            if (typeof s == "number" && this.isAmbiguous(s)) {
              return true;
            }
          }
          return false;
        }
        getPrimaryConfusable(e) {
          return this.f.get(e);
        }
        getConfusableCodePoints() {
          return new Set(this.f.keys());
        }
      };
      UE = class kl {
        static c() {
          return [9, 10, 11, 12, 13, 32, 127, 160, 173, 847, 1564, 4447, 4448, 6068, 6069, 6155, 6156, 6157, 6158, 7355, 7356, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8203, 8204, 8205, 8206, 8207, 8234, 8235, 8236, 8237, 8238, 8239, 8287, 8288, 8289, 8290, 8291, 8292, 8293, 8294, 8295, 8296, 8297, 8298, 8299, 8300, 8301, 8302, 8303, 10240, 12288, 12644, 65024, 65025, 65026, 65027, 65028, 65029, 65030, 65031, 65032, 65033, 65034, 65035, 65036, 65037, 65038, 65039, 65279, 65440, 65520, 65521, 65522, 65523, 65524, 65525, 65526, 65527, 65528, 65532, 78844, 119155, 119156, 119157, 119158, 119159, 119160, 119161, 119162, 917504, 917505, 917506, 917507, 917508, 917509, 917510, 917511, 917512, 917513, 917514, 917515, 917516, 917517, 917518, 917519, 917520, 917521, 917522, 917523, 917524, 917525, 917526, 917527, 917528, 917529, 917530, 917531, 917532, 917533, 917534, 917535, 917536, 917537, 917538, 917539, 917540, 917541, 917542, 917543, 917544, 917545, 917546, 917547, 917548, 917549, 917550, 917551, 917552, 917553, 917554, 917555, 917556, 917557, 917558, 917559, 917560, 917561, 917562, 917563, 917564, 917565, 917566, 917567, 917568, 917569, 917570, 917571, 917572, 917573, 917574, 917575, 917576, 917577, 917578, 917579, 917580, 917581, 917582, 917583, 917584, 917585, 917586, 917587, 917588, 917589, 917590, 917591, 917592, 917593, 917594, 917595, 917596, 917597, 917598, 917599, 917600, 917601, 917602, 917603, 917604, 917605, 917606, 917607, 917608, 917609, 917610, 917611, 917612, 917613, 917614, 917615, 917616, 917617, 917618, 917619, 917620, 917621, 917622, 917623, 917624, 917625, 917626, 917627, 917628, 917629, 917630, 917631, 917760, 917761, 917762, 917763, 917764, 917765, 917766, 917767, 917768, 917769, 917770, 917771, 917772, 917773, 917774, 917775, 917776, 917777, 917778, 917779, 917780, 917781, 917782, 917783, 917784, 917785, 917786, 917787, 917788, 917789, 917790, 917791, 917792, 917793, 917794, 917795, 917796, 917797, 917798, 917799, 917800, 917801, 917802, 917803, 917804, 917805, 917806, 917807, 917808, 917809, 917810, 917811, 917812, 917813, 917814, 917815, 917816, 917817, 917818, 917819, 917820, 917821, 917822, 917823, 917824, 917825, 917826, 917827, 917828, 917829, 917830, 917831, 917832, 917833, 917834, 917835, 917836, 917837, 917838, 917839, 917840, 917841, 917842, 917843, 917844, 917845, 917846, 917847, 917848, 917849, 917850, 917851, 917852, 917853, 917854, 917855, 917856, 917857, 917858, 917859, 917860, 917861, 917862, 917863, 917864, 917865, 917866, 917867, 917868, 917869, 917870, 917871, 917872, 917873, 917874, 917875, 917876, 917877, 917878, 917879, 917880, 917881, 917882, 917883, 917884, 917885, 917886, 917887, 917888, 917889, 917890, 917891, 917892, 917893, 917894, 917895, 917896, 917897, 917898, 917899, 917900, 917901, 917902, 917903, 917904, 917905, 917906, 917907, 917908, 917909, 917910, 917911, 917912, 917913, 917914, 917915, 917916, 917917, 917918, 917919, 917920, 917921, 917922, 917923, 917924, 917925, 917926, 917927, 917928, 917929, 917930, 917931, 917932, 917933, 917934, 917935, 917936, 917937, 917938, 917939, 917940, 917941, 917942, 917943, 917944, 917945, 917946, 917947, 917948, 917949, 917950, 917951, 917952, 917953, 917954, 917955, 917956, 917957, 917958, 917959, 917960, 917961, 917962, 917963, 917964, 917965, 917966, 917967, 917968, 917969, 917970, 917971, 917972, 917973, 917974, 917975, 917976, 917977, 917978, 917979, 917980, 917981, 917982, 917983, 917984, 917985, 917986, 917987, 917988, 917989, 917990, 917991, 917992, 917993, 917994, 917995, 917996, 917997, 917998, 917999];
        }
        static {
          this.d = undefined;
        }
        static e() {
          this.d ||= new Set(kl.c());
          return this.d;
        }
        static isInvisibleCharacter(e) {
          return kl.e().has(e);
        }
        static containsInvisibleCharacter(e) {
          for (let i = 0; i < e.length; i++) {
            const s = e.codePointAt(i);
            if (typeof s == "number" && kl.isInvisibleCharacter(s)) {
              return true;
            }
          }
          return false;
        }
        static get codePoints() {
          return kl.e();
        }
      };
    }
  });
  function yr(t) {
    return t === 47 || t === 92;
  }
  function Xn(t) {
    return t.replace(/[\\/]/g, ae.sep);
  }
  function BE(t) {
    if (t.indexOf("/") === -1) {
      t = Xn(t);
    }
    if (/^[a-zA-Z]:(\/|$)/.test(t)) {
      t = "/" + t;
    }
    return t;
  }
  function Sv(t, e = ae.sep) {
    if (!t) {
      return "";
    }
    const i = t.length;
    const s = t.charCodeAt(0);
    if (yr(s)) {
      if (yr(t.charCodeAt(1)) && !yr(t.charCodeAt(2))) {
        let n = 3;
        const o = n;
        for (; n < i && !yr(t.charCodeAt(n)); n++);
        if (o !== n && !yr(t.charCodeAt(n + 1))) {
          for (n += 1; n < i; n++) {
            if (yr(t.charCodeAt(n))) {
              return t.slice(0, n + 1).replace(/[\\/]/g, e);
            }
          }
        }
      }
      return e;
    } else if (Sp(s) && t.charCodeAt(1) === 58) {
      if (yr(t.charCodeAt(2))) {
        return t.slice(0, 2) + e;
      } else {
        return t.slice(0, 2);
      }
    }
    let r = t.indexOf("://");
    if (r !== -1) {
      for (r += 3; r < i; r++) {
        if (yr(t.charCodeAt(r))) {
          return t.slice(0, r + 1);
        }
      }
    }
    return "";
  }
  function qE(t) {
    if (!j || !t || t.length < 5) {
      return false;
    }
    let e = t.charCodeAt(0);
    if (e !== 92 || (e = t.charCodeAt(1), e !== 92)) {
      return false;
    }
    let i = 2;
    const s = i;
    for (; i < t.length && (e = t.charCodeAt(i), e !== 92); i++);
    return s !== i && !(e = t.charCodeAt(i + 1), isNaN(e) || e === 92);
  }
  function zE(t, e = j) {
    const i = e ? Dv : Pv;
    return !!t && t.length !== 0 && !/^\s+$/.test(t) && !(i.lastIndex = 0, i.test(t)) && (!e || !$v.test(t)) && t !== "." && t !== ".." && (!e || t[t.length - 1] !== ".") && (!e || t.length === t.trim().length) && !(t.length > 255);
  }
  function tu(t, e, i) {
    const s = t === e;
    if (!i || s) {
      return s;
    } else if (!t || !e) {
      return false;
    } else {
      return br(t, e);
    }
  }
  function Ba(t, e, i, s = Vt) {
    if (t === e) {
      return true;
    }
    if (!t || !e || e.length > t.length) {
      return false;
    }
    if (i) {
      if (!eu(t, e)) {
        return false;
      }
      if (e.length === t.length) {
        return true;
      }
      let n = e.length;
      if (e.charAt(e.length - 1) === s) {
        n--;
      }
      return t.charAt(n) === s;
    }
    if (e.charAt(e.length - 1) !== s) {
      e += s;
    }
    return t.indexOf(e) === 0;
  }
  function Sp(t) {
    return t >= 65 && t <= 90 || t >= 97 && t <= 122;
  }
  function Ev(t, e) {
    if (j && t.endsWith(":")) {
      t += Vt;
    }
    if (!Zr(t)) {
      t = F(e, t);
    }
    t = pi(t);
    return kv(t);
  }
  function kv(t) {
    if (j) {
      t = Qr(t, Vt);
      if (t.endsWith(":")) {
        t += Vt;
      }
    } else {
      t = Qr(t, Vt);
      t ||= Vt;
    }
    return t;
  }
  function HE(t) {
    const e = pi(t);
    if (j) {
      if (t.length > 3) {
        return false;
      } else {
        return xv(e) && (t.length === 2 || e.charCodeAt(2) === 92);
      }
    } else {
      return e === ae.sep;
    }
  }
  function xv(t, e = j) {
    if (e) {
      return Sp(t.charCodeAt(0)) && t.charCodeAt(1) === 58;
    } else {
      return false;
    }
  }
  function iu(t) {
    const e = t.split(":");
    let i;
    let s;
    let r;
    for (const n of e) {
      const o = Number(n);
      if (Hl(o)) {
        if (s === undefined) {
          s = o;
        } else if (r === undefined) {
          r = o;
        }
      } else {
        i = i ? [i, n].join(":") : n;
      }
    }
    if (!i) {
      throw new Error("Format for `--goto` should be: `FILE:LINE(:COLUMN)`");
    }
    return {
      path: i,
      line: s !== undefined ? s : undefined,
      column: r !== undefined ? r : s !== undefined ? 1 : undefined
    };
  }
  function qa(t, e, i = 8) {
    let s = "";
    for (let n = 0; n < i; n++) {
      let o;
      if (n === 0 && j && !e && (i === 3 || i === 4)) {
        o = Av;
      } else {
        o = Iv;
      }
      s += o.charAt(Math.floor(Math.random() * o.length));
    }
    let r;
    if (e) {
      r = `${e}-${s}`;
    } else {
      r = s;
    }
    if (t) {
      return F(t, r);
    } else {
      return r;
    }
  }
  var Dv;
  var Pv;
  var $v;
  var Iv;
  var Av;
  var gi = g({
    "out-build/vs/base/common/extpath.js"() {
      "use strict";
  
      we();
      H();
      Wt();
      _e();
      Dv = /[\\/:\*\?"<>\|]/g;
      Pv = /[/]/g;
      $v = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])(\.(.*?))?$/i;
      Iv = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      Av = "BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789";
    }
  });
  function VE(t, e) {
    if (P.isUri(t)) {
      return br(t.scheme, e);
    } else {
      return eu(t, e + ":");
    }
  }
  function GE(t, ...e) {
    return e.some(i => VE(t, i));
  }
  function JE(t, e) {
    return ae.join(e ?? "/", `${t.quality ?? "oss"}-${t.commit ?? "dev"}`);
  }
  var R;
  var Cv;
  var _v;
  var Ep;
  var za;
  var Rv;
  var Ct;
  var Ov;
  var Lv;
  var Ha;
  var Ie = g({
    "out-build/vs/base/common/network.js"() {
      "use strict";
  
      $e();
      H();
      Wt();
      se();
      we();
      (function (t) {
        t.inMemory = "inmemory";
        t.vscode = "vscode";
        t.internal = "private";
        t.walkThrough = "walkThrough";
        t.walkThroughSnippet = "walkThroughSnippet";
        t.http = "http";
        t.https = "https";
        t.file = "file";
        t.mailto = "mailto";
        t.untitled = "untitled";
        t.data = "data";
        t.command = "command";
        t.vscodeRemote = "vscode-remote";
        t.vscodeRemoteResource = "vscode-remote-resource";
        t.vscodeManagedRemoteResource = "vscode-managed-remote-resource";
        t.vscodeUserData = "vscode-userdata";
        t.vscodeCustomEditor = "vscode-custom-editor";
        t.vscodeNotebook = "vscode-notebook";
        t.vscodeNotebookCell = "vscode-notebook-cell";
        t.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata";
        t.vscodeNotebookCellMetadataDiff = "vscode-notebook-cell-metadata-diff";
        t.vscodeNotebookCellOutput = "vscode-notebook-cell-output";
        t.vscodeNotebookCellOutputDiff = "vscode-notebook-cell-output-diff";
        t.vscodeNotebookMetadata = "vscode-notebook-metadata";
        t.vscodeInteractiveInput = "vscode-interactive-input";
        t.vscodeSettings = "vscode-settings";
        t.vscodeWorkspaceTrust = "vscode-workspace-trust";
        t.vscodeTerminal = "vscode-terminal";
        t.vscodeChatCodeBlock = "vscode-chat-code-block";
        t.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block";
        t.vscodeChatSesssion = "vscode-chat-editor";
        t.webviewPanel = "webview-panel";
        t.vscodeWebview = "vscode-webview";
        t.extension = "extension";
        t.aiChat = "cursor.aichat";
        t.notepad = "cursor.notepad";
        t.contextObject = "cursor.context-object";
        t.composer = "cursor.composer";
        t.aiSettings = "cursor.aisettings";
        t.tinderDiffEditor = "cursor.tinderdiffeditor";
        t.vscodeFileResource = "vscode-file";
        t.tmp = "tmp";
        t.vsls = "vsls";
        t.vscodeSourceControl = "vscode-scm";
        t.commentsInput = "comment";
        t.codeSetting = "code-setting";
        t.cursorDev = "cursor-dev";
        t.outputChannel = "output";
        t.accessibleView = "accessible-view";
        t.backgroundComposer = "cursor.backgroundcomposer";
        t.personalEnvironmentJson = "cursor.personalenvironmentjson";
        t.bugbot = "cursor.bugbot";
        t.aiEditorBox = "aiEditorBox";
      })(R ||= {});
      Cv = "tkn";
      _v = class {
        constructor() {
          this.a = Object.create(null);
          this.b = Object.create(null);
          this.c = Object.create(null);
          this.d = "http";
          this.e = null;
          this.f = "/";
        }
        setPreferredWebSchema(t) {
          this.d = t;
        }
        setDelegate(t) {
          this.e = t;
        }
        setServerRootPath(t, e) {
          this.f = JE(t, e);
        }
        getServerRootPath() {
          return this.f;
        }
        get g() {
          return ae.join(this.f, R.vscodeRemoteResource);
        }
        set(t, e, i) {
          this.a[t] = e;
          this.b[t] = i;
        }
        setConnectionToken(t, e) {
          this.c[t] = e;
        }
        getPreferredWebSchema() {
          return this.d;
        }
        rewrite(t) {
          if (this.e) {
            try {
              return this.e(t);
            } catch (o) {
              Ft(o);
              return t;
            }
          }
          const e = t.authority;
          let i = this.a[e];
          if (i && i.indexOf(":") !== -1 && i.indexOf("[") === -1) {
            i = `[${i}]`;
          }
          const s = this.b[e];
          const r = this.c[e];
          let n = `path=${encodeURIComponent(t.path)}`;
          if (typeof r == "string") {
            n += `&${Cv}=${encodeURIComponent(r)}`;
          }
          return P.from({
            scheme: fr ? this.d : R.vscodeRemoteResource,
            authority: `${i}:${s}`,
            path: this.g,
            query: n
          });
        }
      };
      Ep = new _v();
      za = "vscode-app";
      Rv = class Ef {
        static {
          this.a = za;
        }
        asBrowserUri(e) {
          const i = this.b(e);
          return this.uriToBrowserUri(i);
        }
        uriToBrowserUri(e) {
          if (e.scheme === R.vscodeRemote) {
            return Ep.rewrite(e);
          } else if (e.scheme === R.file && (Jf || ew === `${R.vscodeFileResource}://${Ef.a}`)) {
            return e.with({
              scheme: R.vscodeFileResource,
              authority: e.authority || Ef.a,
              query: null,
              fragment: null
            });
          } else {
            return e;
          }
        }
        asFileUri(e) {
          const i = this.b(e);
          return this.uriToFileUri(i);
        }
        uriToFileUri(e) {
          if (e.scheme === R.vscodeFileResource) {
            return e.with({
              scheme: R.file,
              authority: e.authority !== Ef.a ? e.authority : null,
              query: null,
              fragment: null
            });
          } else {
            return e;
          }
        }
        b(e, i) {
          if (P.isUri(e)) {
            return e;
          }
          if (globalThis._VSCODE_FILE_ROOT) {
            const s = globalThis._VSCODE_FILE_ROOT;
            if (/^\w[\w\d+.-]*:\/\//.test(s)) {
              return P.joinPath(P.parse(s, true), e);
            }
            const r = F(s, e);
            return P.file(r);
          }
          return P.parse(i.toUrl(e));
        }
      };
      Ct = new Rv();
      Ov = Object.freeze({
        "Cache-Control": "no-cache, no-store"
      });
      Lv = Object.freeze({
        "Document-Policy": "include-js-call-stacks-in-crash-reports, js-profiling"
      });
      (function (t) {
        const e = new Map([["1", {
          "Cross-Origin-Opener-Policy": "same-origin"
        }], ["2", {
          "Cross-Origin-Embedder-Policy": "require-corp"
        }], ["3", {
          "Cross-Origin-Opener-Policy": "same-origin",
          "Cross-Origin-Embedder-Policy": "require-corp"
        }]]);
        t.CoopAndCoep = Object.freeze(e.get("3"));
        const i = "vscode-coi";
        function s(n) {
          let o;
          if (typeof n == "string") {
            o = new URL(n).searchParams;
          } else if (n instanceof URL) {
            o = n.searchParams;
          } else if (P.isUri(n)) {
            o = new URL(n.toString(true)).searchParams;
          }
          const a = o?.get(i);
          if (a) {
            return e.get(a);
          }
        }
        t.getHeadersFromQuery = s;
        function r(n, o, a) {
          if (!globalThis.crossOriginIsolated) {
            return;
          }
          const c = o && a ? "3" : a ? "2" : "1";
          if (n instanceof URLSearchParams) {
            n.set(i, c);
          } else {
            n[i] = c;
          }
        }
        t.addSearchParam = r;
      })(Ha ||= {});
    }
  });
  function Ci(t) {
    return Yl(t, true);
  }
  var Va;
  var ke;
  var tt;
  var kp;
  var xp;
  var Dp;
  var KE;
  var ZE;
  var ks;
  var Mv;
  var Fv;
  var he;
  var Pp;
  var YE;
  var XE;
  var Nv;
  var mi;
  var $p;
  var Wv;
  var QE;
  var Tv;
  var nt = g({
    "out-build/vs/base/common/resources.js"() {
      "use strict";
  
      gi();
      Ie();
      we();
      H();
      Wt();
      se();
      Va = class {
        constructor(t) {
          this.a = t;
        }
        compare(t, e, i = false) {
          if (t === e) {
            return 0;
          } else {
            return vp(this.getComparisonKey(t, i), this.getComparisonKey(e, i));
          }
        }
        isEqual(t, e, i = false) {
          if (t === e) {
            return true;
          } else if (!t || !e) {
            return false;
          } else {
            return this.getComparisonKey(t, i) === this.getComparisonKey(e, i);
          }
        }
        getComparisonKey(t, e = false) {
          return t.with({
            path: this.a(t) ? t.path.toLowerCase() : undefined,
            fragment: e ? null : undefined
          }).toString();
        }
        ignorePathCasing(t) {
          return this.a(t);
        }
        isEqualOrParent(t, e, i = false) {
          if (t.scheme === e.scheme) {
            if (t.scheme === R.file) {
              return Ba(Ci(t), Ci(e), this.a(t)) && t.query === e.query && (i || t.fragment === e.fragment);
            }
            if (mi(t.authority, e.authority)) {
              return Ba(t.path, e.path, this.a(t), "/") && t.query === e.query && (i || t.fragment === e.fragment);
            }
          }
          return false;
        }
        joinPath(t, ...e) {
          return P.joinPath(t, ...e);
        }
        basenameOrAuthority(t) {
          return ks(t) || t.authority;
        }
        basename(t) {
          return ae.basename(t.path);
        }
        extname(t) {
          return ae.extname(t.path);
        }
        dirname(t) {
          if (t.path.length === 0) {
            return t;
          }
          let e;
          if (t.scheme === R.file) {
            e = P.file(Xe(Ci(t))).path;
          } else {
            e = ae.dirname(t.path);
            if (t.authority && e.length && e.charCodeAt(0) !== 47) {
              console.error(`dirname("${t.toString})) resulted in a relative path`);
              e = "/";
            }
          }
          return t.with({
            path: e
          });
        }
        normalizePath(t) {
          if (!t.path.length) {
            return t;
          }
          let e;
          if (t.scheme === R.file) {
            e = P.file(pi(Ci(t))).path;
          } else {
            e = ae.normalize(t.path);
          }
          return t.with({
            path: e
          });
        }
        relativePath(t, e) {
          if (t.scheme !== e.scheme || !mi(t.authority, e.authority)) {
            return;
          }
          if (t.scheme === R.file) {
            const r = Zw(Ci(t), Ci(e));
            if (j) {
              return Xn(r);
            } else {
              return r;
            }
          }
          let i = t.path || "/";
          const s = e.path || "/";
          if (this.a(t)) {
            let r = 0;
            for (const n = Math.min(i.length, s.length); r < n && (i.charCodeAt(r) === s.charCodeAt(r) || i.charAt(r).toLowerCase() === s.charAt(r).toLowerCase()); r++);
            i = s.substr(0, r) + i.substr(r);
          }
          return ae.relative(i, s);
        }
        resolvePath(t, e) {
          if (t.scheme === R.file) {
            const i = P.file(Gi(Ci(t), e));
            return t.with({
              authority: i.authority,
              path: i.path
            });
          }
          e = BE(e);
          return t.with({
            path: ae.resolve(t.path, e)
          });
        }
        isAbsolutePath(t) {
          return !!t.path && t.path[0] === "/";
        }
        isEqualAuthority(t, e) {
          return t === e || t !== undefined && e !== undefined && br(t, e);
        }
        hasTrailingPathSeparator(t, e = Vt) {
          if (t.scheme === R.file) {
            const i = Ci(t);
            return i.length > Sv(i).length && i[i.length - 1] === e;
          } else {
            const i = t.path;
            return i.length > 1 && i.charCodeAt(i.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(t.fsPath);
          }
        }
        removeTrailingPathSeparator(t, e = Vt) {
          if ($p(t, e)) {
            return t.with({
              path: t.path.substr(0, t.path.length - 1)
            });
          } else {
            return t;
          }
        }
        addTrailingPathSeparator(t, e = Vt) {
          let i = false;
          if (t.scheme === R.file) {
            const s = Ci(t);
            i = s !== undefined && s.length === Sv(s).length && s[s.length - 1] === e;
          } else {
            e = "/";
            const s = t.path;
            i = s.length === 1 && s.charCodeAt(s.length - 1) === 47;
          }
          if (!i && !$p(t, e)) {
            return t.with({
              path: t.path + "/"
            });
          } else {
            return t;
          }
        }
      };
      ke = new Va(() => false);
      tt = new Va(t => t.scheme === R.file ? !Se : true);
      kp = new Va(t => true);
      xp = ke.isEqual.bind(ke);
      Dp = ke.isEqualOrParent.bind(ke);
      KE = ke.getComparisonKey.bind(ke);
      ZE = ke.basenameOrAuthority.bind(ke);
      ks = ke.basename.bind(ke);
      Mv = ke.extname.bind(ke);
      Fv = ke.dirname.bind(ke);
      he = ke.joinPath.bind(ke);
      Pp = ke.normalizePath.bind(ke);
      YE = ke.relativePath.bind(ke);
      XE = ke.resolvePath.bind(ke);
      Nv = ke.isAbsolutePath.bind(ke);
      mi = ke.isEqualAuthority.bind(ke);
      $p = ke.hasTrailingPathSeparator.bind(ke);
      Wv = ke.removeTrailingPathSeparator.bind(ke);
      QE = ke.addTrailingPathSeparator.bind(ke);
      (function (t) {
        t.META_DATA_LABEL = "label";
        t.META_DATA_DESCRIPTION = "description";
        t.META_DATA_SIZE = "size";
        t.META_DATA_MIME = "mime";
        function e(i) {
          const s = new Map();
          i.path.substring(i.path.indexOf(";") + 1, i.path.lastIndexOf(";")).split(";").forEach(o => {
            const [a, c] = o.split(":");
            if (a && c) {
              s.set(a, c);
            }
          });
          const n = i.path.substring(0, i.path.indexOf(";"));
          if (n) {
            s.set(t.META_DATA_MIME, n);
          }
          return s;
        }
        t.parseMetaData = e;
      })(Tv ||= {});
    }
  });
  var jv;
  var ek = g({
    "out-build/vs/base/common/symbols.js"() {
      "use strict";
  
      jv = Symbol("MicrotaskDelay");
    }
  });
  function Ip(t) {
    return !!t && typeof t.then == "function";
  }
  function Qn(t) {
    const e = new ns();
    const i = t(e.token);
    const s = new Promise((r, n) => {
      const o = e.token.onCancellationRequested(() => {
        o.dispose();
        n(new hi());
      });
      Promise.resolve(i).then(a => {
        o.dispose();
        e.dispose();
        r(a);
      }, a => {
        o.dispose();
        e.dispose();
        n(a);
      });
    });
    return new class {
      cancel() {
        e.cancel();
        e.dispose();
      }
      then(r, n) {
        return s.then(r, n);
      }
      catch(r) {
        return this.then(undefined, r);
      }
      finally(r) {
        return s.finally(r);
      }
    }();
  }
  function tk() {
    let t;
    let e;
    return {
      promise: new Promise((s, r) => {
        t = s;
        e = r;
      }),
      resolve: t,
      reject: e
    };
  }
  function wi(t, e) {
    if (e) {
      return new Promise((i, s) => {
        const r = setTimeout(() => {
          n.dispose();
          i();
        }, t);
        const n = e.onCancellationRequested(() => {
          clearTimeout(r);
          n.dispose();
          s(new hi());
        });
      });
    } else {
      return Qn(i => wi(t, i));
    }
  }
  function ik(t, e = 0, i) {
    const s = setTimeout(() => {
      t();
      if (i) {
        r.dispose();
      }
    }, e);
    const r = xe(() => {
      clearTimeout(s);
      i?.delete(r);
    });
    i?.add(r);
    return r;
  }
  function sk(t, e = s => !!s, i = null) {
    let s = 0;
    const r = t.length;
    const n = () => {
      if (s >= r) {
        return Promise.resolve(i);
      }
      const o = t[s++];
      return Promise.resolve(o()).then(c => e(c) ? Promise.resolve(c) : n());
    };
    return n();
  }
  async function rk(t, e, i) {
    let s;
    for (let r = 0; r < i; r++) {
      try {
        return await t();
      } catch (n) {
        s = n;
        await wi(e);
      }
    }
    throw s;
  }
  var Ap;
  var Uv;
  var Bv;
  var su;
  var Ys;
  var Ga;
  var qv;
  var eo;
  var Cp;
  var os;
  var zv;
  var _p;
  var Rp;
  var ru;
  var Hv;
  var Vv;
  var Gv;
  var Xs;
  var Tt;
  var Jv;
  var nk;
  var ce = g({
    "out-build/vs/base/common/async.js"() {
      "use strict";
  
      At();
      $e();
      B();
      M();
      nt();
      H();
      ek();
      Ta();
      Ap = class {
        constructor() {
          this.f = false;
          this.a = null;
          this.b = null;
          this.d = null;
        }
        queue(t) {
          if (this.f) {
            return Promise.reject(new Error("Throttler is disposed"));
          }
          if (this.a) {
            this.d = t;
            if (!this.b) {
              const e = () => {
                this.b = null;
                if (this.f) {
                  return;
                }
                const i = this.queue(this.d);
                this.d = null;
                return i;
              };
              this.b = new Promise(i => {
                this.a.then(e, e).then(i);
              });
            }
            return new Promise((e, i) => {
              this.b.then(e, i);
            });
          }
          this.a = t();
          return new Promise((e, i) => {
            this.a.then(s => {
              this.a = null;
              e(s);
            }, s => {
              this.a = null;
              i(s);
            });
          });
        }
        dispose() {
          this.f = true;
        }
      };
      Uv = (t, e) => {
        let i = true;
        const s = setTimeout(() => {
          i = false;
          e();
        }, t);
        return {
          isTriggered: () => i,
          dispose: () => {
            clearTimeout(s);
            i = false;
          }
        };
      };
      Bv = t => {
        let e = true;
        queueMicrotask(() => {
          if (e) {
            e = false;
            t();
          }
        });
        return {
          isTriggered: () => e,
          dispose: () => {
            e = false;
          }
        };
      };
      su = class {
        constructor(t) {
          this.defaultDelay = t;
          this.a = null;
          this.b = null;
          this.d = null;
          this.f = null;
          this.g = null;
        }
        trigger(t, e = this.defaultDelay) {
          this.g = t;
          this.h();
          this.b ||= new Promise((s, r) => {
            this.d = s;
            this.f = r;
          }).then(() => {
            this.b = null;
            this.d = null;
            if (this.g) {
              const s = this.g;
              this.g = null;
              return s();
            }
          });
          const i = () => {
            this.a = null;
            this.d?.(null);
          };
          this.a = e === jv ? Bv(i) : Uv(e, i);
          return this.b;
        }
        isTriggered() {
          return !!this.a?.isTriggered();
        }
        cancel() {
          this.h();
          if (this.b) {
            this.f?.(new hi());
            this.b = null;
          }
        }
        h() {
          this.a?.dispose();
          this.a = null;
        }
        dispose() {
          this.cancel();
        }
      };
      Ys = class {
        constructor(t) {
          this.a = new su(t);
          this.b = new Ap();
        }
        trigger(t, e) {
          return this.a.trigger(() => this.b.queue(t), e);
        }
        isTriggered() {
          return this.a.isTriggered();
        }
        cancel() {
          this.a.cancel();
        }
        dispose() {
          this.a.dispose();
          this.b.dispose();
        }
      };
      Ga = class {
        constructor() {
          this.a = false;
          this.b = new Promise((t, e) => {
            this.d = t;
          });
        }
        isOpen() {
          return this.a;
        }
        open() {
          this.a = true;
          this.d(true);
        }
        wait() {
          return this.b;
        }
      };
      qv = class {
        constructor(t) {
          this.a = 0;
          this.b = false;
          this.f = t;
          this.g = [];
          this.d = 0;
          this.h = new $();
        }
        whenIdle() {
          if (this.size > 0) {
            return x.toPromise(this.onDrained);
          } else {
            return Promise.resolve();
          }
        }
        get onDrained() {
          return this.h.event;
        }
        get size() {
          return this.a;
        }
        queue(t) {
          if (this.b) {
            throw new Error("Object has been disposed");
          }
          this.a++;
          return new Promise((e, i) => {
            this.g.push({
              factory: t,
              c: e,
              e: i
            });
            this.j();
          });
        }
        j() {
          while (this.g.length && this.d < this.f) {
            const t = this.g.shift();
            this.d++;
            const e = t.factory();
            e.then(t.c, t.e);
            e.then(() => this.k(), () => this.k());
          }
        }
        k() {
          if (!this.b) {
            this.d--;
            if (--this.a === 0) {
              this.h.fire();
            }
            if (this.g.length > 0) {
              this.j();
            }
          }
        }
        clear() {
          if (this.b) {
            throw new Error("Object has been disposed");
          }
          this.g.length = 0;
          this.a = this.d;
        }
        dispose() {
          this.b = true;
          this.g.length = 0;
          this.a = 0;
          this.h.dispose();
        }
      };
      eo = class extends qv {
        constructor() {
          super(1);
        }
      };
      Cp = class {
        constructor() {
          this.a = new Map();
          this.b = new Set();
          this.d = undefined;
          this.f = 0;
        }
        async whenDrained() {
          if (this.g()) {
            return;
          }
          const t = new Xs();
          this.b.add(t);
          return t.p;
        }
        g() {
          for (const [, t] of this.a) {
            if (t.size > 0) {
              return false;
            }
          }
          return true;
        }
        queueSize(t, e = ke) {
          const i = e.getComparisonKey(t);
          return this.a.get(i)?.size ?? 0;
        }
        queueFor(t, e, i = ke) {
          const s = i.getComparisonKey(t);
          let r = this.a.get(s);
          if (!r) {
            r = new eo();
            const n = this.f++;
            const o = x.once(r.onDrained)(() => {
              r?.dispose();
              this.a.delete(s);
              this.h();
              this.d?.deleteAndDispose(n);
              if (this.d?.size === 0) {
                this.d.dispose();
                this.d = undefined;
              }
            });
            this.d ||= new Xf();
            this.d.set(n, o);
            this.a.set(s, r);
          }
          return r.queue(e);
        }
        h() {
          if (this.g()) {
            this.j();
          }
        }
        j() {
          for (const t of this.b) {
            t.complete();
          }
          this.b.clear();
        }
        dispose() {
          for (const [, t] of this.a) {
            t.dispose();
          }
          this.a.clear();
          this.j();
          this.d?.dispose();
        }
      };
      os = class {
        constructor(t, e) {
          this.b = -1;
          this.a = t;
          this.d = e;
          this.f = this.g.bind(this);
        }
        dispose() {
          this.cancel();
          this.a = null;
        }
        cancel() {
          if (this.isScheduled()) {
            clearTimeout(this.b);
            this.b = -1;
          }
        }
        schedule(t = this.d) {
          this.cancel();
          this.b = setTimeout(this.f, t);
        }
        get delay() {
          return this.d;
        }
        set delay(t) {
          this.d = t;
        }
        isScheduled() {
          return this.b !== -1;
        }
        flush() {
          if (this.isScheduled()) {
            this.cancel();
            this.h();
          }
        }
        g() {
          this.b = -1;
          if (this.a) {
            this.h();
          }
        }
        h() {
          this.a?.();
        }
      };
      zv = class extends os {
        constructor(t, e) {
          super(t, e);
          this.j = [];
        }
        work(t) {
          this.j.push(t);
          if (!this.isScheduled()) {
            this.schedule();
          }
        }
        h() {
          const t = this.j;
          this.j = [];
          this.a?.(t);
        }
        dispose() {
          this.j = [];
          super.dispose();
        }
      };
      _p = class extends T {
        constructor(t, e) {
          super();
          this.h = t;
          this.j = e;
          this.a = [];
          this.b = this.D(new pr());
          this.f = false;
          this.g = 0;
        }
        get pending() {
          return this.a.length;
        }
        work(t) {
          if (this.f) {
            return false;
          }
          if (typeof this.h.maxBufferedWork == "number") {
            if (this.b.value) {
              if (this.pending + t.length > this.h.maxBufferedWork) {
                return false;
              }
            } else if (this.pending + t.length - this.h.maxWorkChunkSize > this.h.maxBufferedWork) {
              return false;
            }
          }
          for (const i of t) {
            this.a.push(i);
          }
          const e = Date.now() - this.g;
          if (!this.b.value && (!this.h.waitThrottleDelayBetweenWorkUnits || e >= this.h.throttleDelay)) {
            this.m();
          } else if (!this.b.value && this.h.waitThrottleDelayBetweenWorkUnits) {
            this.q(Math.max(this.h.throttleDelay - e, 0));
          }
          return true;
        }
        m() {
          this.g = Date.now();
          this.j(this.a.splice(0, this.h.maxWorkChunkSize));
          if (this.a.length > 0) {
            this.q();
          }
        }
        q(t = this.h.throttleDelay) {
          this.b.value = new os(() => {
            this.b.clear();
            this.m();
          }, t);
          this.b.value.schedule();
        }
        dispose() {
          super.dispose();
          this.a.length = 0;
          this.f = true;
        }
      };
      (function () {
        if (typeof globalThis.requestIdleCallback != "function" || typeof globalThis.cancelIdleCallback != "function") {
          ru = (t, e, i) => {
            rw(() => {
              if (s) {
                return;
              }
              const r = Date.now() + 15;
              e(Object.freeze({
                didTimeout: true,
                timeRemaining() {
                  return Math.max(0, r - Date.now());
                }
              }));
            });
            let s = false;
            return {
              dispose() {
                s ||= true;
              }
            };
          };
        } else {
          ru = (t, e, i) => {
            const s = t.requestIdleCallback(e, typeof i == "number" ? {
              timeout: i
            } : undefined);
            let r = false;
            return {
              dispose() {
                if (!r) {
                  r = true;
                  t.cancelIdleCallback(s);
                }
              }
            };
          };
        }
        Rp = (t, e) => ru(globalThis, t, e);
      })();
      Hv = class {
        constructor(t, e) {
          this.g = false;
          this.d = () => {
            try {
              this.j = e();
            } catch (i) {
              this.l = i;
            } finally {
              this.g = true;
            }
          };
          this.f = ru(t, () => this.d());
        }
        dispose() {
          this.f.dispose();
        }
        get value() {
          if (!this.g) {
            this.f.dispose();
            this.d();
          }
          if (this.l) {
            throw this.l;
          }
          return this.j;
        }
        get isInitialized() {
          return this.g;
        }
      };
      Vv = class extends Hv {
        constructor(t) {
          super(globalThis, t);
        }
      };
      (function (t) {
        t[t.Resolved = 0] = "Resolved";
        t[t.Rejected = 1] = "Rejected";
      })(Gv ||= {});
      Xs = class {
        get isRejected() {
          return this.d?.outcome === 1;
        }
        get isResolved() {
          return this.d?.outcome === 0;
        }
        get isSettled() {
          return !!this.d;
        }
        get value() {
          if (this.d?.outcome === 0) {
            return this.d?.value;
          } else {
            return undefined;
          }
        }
        constructor() {
          this.p = new Promise((t, e) => {
            this.a = t;
            this.b = e;
          });
        }
        complete(t) {
          return new Promise(e => {
            this.a(t);
            this.d = {
              outcome: 0,
              value: t
            };
            e();
          });
        }
        error(t) {
          return new Promise(e => {
            this.b(t);
            this.d = {
              outcome: 1,
              value: t
            };
            e();
          });
        }
        cancel() {
          return this.error(new hi());
        }
      };
      (function (t) {
        async function e(s) {
          let r;
          const n = await Promise.all(s.map(o => o.then(a => a, a => {
            r ||= a;
          })));
          if (typeof r !== "undefined") {
            throw r;
          }
          return n;
        }
        t.settled = e;
        function i(s) {
          return new Promise(async (r, n) => {
            try {
              await s(r, n);
            } catch (o) {
              n(o);
            }
          });
        }
        t.withAsyncBody = i;
      })(Tt ||= {});
      (function (t) {
        t[t.Initial = 0] = "Initial";
        t[t.DoneOK = 1] = "DoneOK";
        t[t.DoneError = 2] = "DoneError";
      })(Jv ||= {});
      nk = class qi {
        static fromArray(e) {
          return new qi(i => {
            i.emitMany(e);
          });
        }
        static fromPromise(e) {
          return new qi(async i => {
            i.emitMany(await e);
          });
        }
        static fromPromisesResolveOrder(e) {
          return new qi(async i => {
            await Promise.all(e.map(async s => i.emitOne(await s)));
          });
        }
        static merge(e) {
          return new qi(async i => {
            await Promise.all(e.map(async s => {
              for await (const r of s) {
                i.emitOne(r);
              }
            }));
          });
        }
        static {
          this.EMPTY = qi.fromArray([]);
        }
        constructor(e, i) {
          this.a = 0;
          this.b = [];
          this.d = null;
          this.f = i;
          this.g = new $();
          queueMicrotask(async () => {
            const s = {
              emitOne: r => this.h(r),
              emitMany: r => this.j(r),
              reject: r => this.l(r)
            };
            try {
              await Promise.resolve(e(s));
              this.k();
            } catch (r) {
              this.l(r);
            } finally {
              s.emitOne = undefined;
              s.emitMany = undefined;
              s.reject = undefined;
            }
          });
        }
        [Symbol.asyncIterator]() {
          let e = 0;
          return {
            next: async () => {
              do {
                if (this.a === 2) {
                  throw this.d;
                }
                if (e < this.b.length) {
                  return {
                    done: false,
                    value: this.b[e++]
                  };
                }
                if (this.a === 1) {
                  return {
                    done: true,
                    value: undefined
                  };
                }
                await x.toPromise(this.g.event);
              } while (true);
            },
            return: async () => {
              this.f?.();
              return {
                done: true,
                value: undefined
              };
            }
          };
        }
        static map(e, i) {
          return new qi(async s => {
            for await (const r of e) {
              s.emitOne(i(r));
            }
          });
        }
        map(e) {
          return qi.map(this, e);
        }
        static filter(e, i) {
          return new qi(async s => {
            for await (const r of e) {
              if (i(r)) {
                s.emitOne(r);
              }
            }
          });
        }
        filter(e) {
          return qi.filter(this, e);
        }
        static coalesce(e) {
          return qi.filter(e, i => !!i);
        }
        coalesce() {
          return qi.coalesce(this);
        }
        static async toPromise(e) {
          const i = [];
          for await (const s of e) {
            i.push(s);
          }
          return i;
        }
        toPromise() {
          return qi.toPromise(this);
        }
        h(e) {
          if (this.a === 0) {
            this.b.push(e);
            this.g.fire();
          }
        }
        j(e) {
          if (this.a === 0) {
            this.b = this.b.concat(e);
            this.g.fire();
          }
        }
        k() {
          if (this.a === 0) {
            this.a = 1;
            this.g.fire();
          }
        }
        l(e) {
          if (this.a === 0) {
            this.a = 2;
            this.d = e;
            this.g.fire();
          }
        }
      };
    }
  });
  function Op(t, e) {
    if (e && (t.stack || t.stacktrace)) {
      return v(110, null, Zv(t), Kv(t.stack) || Kv(t.stacktrace));
    } else {
      return Zv(t);
    }
  }
  function Kv(t) {
    if (Array.isArray(t)) {
      return t.join(`
  `);
    } else {
      return t;
    }
  }
  function Zv(t) {
    if (t.code === "ERR_UNC_HOST_NOT_ALLOWED") {
      return `${t.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`;
    } else if (typeof t.code == "string" && typeof t.errno == "number" && typeof t.syscall == "string") {
      return v(111, null, t.message);
    } else {
      return t.message || v(112, null);
    }
  }
  function Ki(t = null, e = false) {
    if (!t) {
      return v(113, null);
    }
    if (Array.isArray(t)) {
      const i = $t(t);
      const s = Ki(i[0], e);
      if (i.length > 1) {
        return v(114, null, s, i.length);
      } else {
        return s;
      }
    }
    if (wt(t)) {
      return t;
    }
    if (t.detail) {
      const i = t.detail;
      if (i.error) {
        return Op(i.error, e);
      }
      if (i.exception) {
        return Op(i.exception, e);
      }
    }
    if (t.stack) {
      return Op(t, e);
    } else if (t.message) {
      return t.message;
    } else {
      return v(115, null);
    }
  }
  var en = g({
    "out-build/vs/base/common/errorMessage.js"() {
      "use strict";
  
      zt();
      _e();
      be();
    }
  });
  function to(t, e) {
    const {
      os: i,
      tildify: s,
      relative: r
    } = e;
    if (r) {
      const a = ok(t, r, i);
      if (typeof a == "string") {
        return a;
      }
    }
    let n = t.fsPath;
    if (i === 1 && !j) {
      n = n.replace(/\//g, "\\");
    } else if (i !== 1 && j) {
      n = n.replace(/\\/g, "/");
    }
    if (i !== 1 && s?.userHome) {
      const a = s.userHome.fsPath;
      let c;
      if (t.scheme !== s.userHome.scheme && t.path[0] === ae.sep && t.path[1] !== ae.sep) {
        c = s.userHome.with({
          path: t.path
        }).fsPath;
      } else {
        c = n;
      }
      n = ak(c, a, i);
    }
    return (i === 1 ? Ge : ae).normalize(Lp(n, i === 1));
  }
  function ok(t, e, i) {
    const s = i === 1 ? Ge : ae;
    const r = i === 3 ? ke : kp;
    const n = e.getWorkspace();
    const o = n.folders.at(0);
    if (!o) {
      return;
    }
    if (t.scheme !== o.uri.scheme && t.path[0] === ae.sep && t.path[1] !== ae.sep) {
      t = o.uri.with({
        path: t.path
      });
    }
    const a = e.getWorkspaceFolder(t);
    if (!a) {
      return;
    }
    let c;
    if (r.isEqual(a.uri, t)) {
      c = "";
    } else {
      c = r.relativePath(a.uri, t) ?? "";
    }
    c &&= s.normalize(c);
    if (n.folders.length > 1 && !e.noPrefix) {
      const l = a.name ? a.name : r.basenameOrAuthority(a.uri);
      c = c ? `${l} \u2022 ${c}` : l;
    }
    return c;
  }
  function Lp(t, e = j) {
    if (xv(t, e)) {
      return t.charAt(0).toUpperCase() + t.slice(1);
    } else {
      return t;
    }
  }
  function ak(t, e, i = Wi) {
    if (i === 1 || !t || !e) {
      return t;
    }
    let s = nu.original === e ? nu.normalized : undefined;
    if (!s) {
      s = e;
      if (j) {
        s = Xn(s);
      }
      s = `${Qr(s, ae.sep)}${ae.sep}`;
      nu = {
        original: e,
        normalized: s
      };
    }
    let r = t;
    if (j) {
      r = Xn(r);
    }
    if (i === 3 ? r.startsWith(s) : eu(r, s)) {
      return `~/${r.substr(s.length)}`;
    } else {
      return t;
    }
  }
  function ck(t, e) {
    if (N || e) {
      return t.replace(/\(&&\w\)|&&/g, "").replace(/&/g, N ? "&" : "&&");
    } else {
      return t.replace(/&&|&/g, i => i === "&" ? "&&" : "&");
    }
  }
  function Yv(t, e) {
    if (N || e) {
      return t.replace(/\(&&\w\)|&&/g, "");
    } else if (j) {
      return t.replace(/&&|&/g, i => i === "&" ? "&&" : "&");
    } else {
      return t.replace(/&&/g, "_");
    }
  }
  function lk(t) {
    if (t.endsWith("]")) {
      const e = t.lastIndexOf(" [", t.length - 2);
      if (e !== -1) {
        const i = Xv(t.substring(0, e));
        const s = t.substring(e);
        return {
          name: i.name + s,
          parentPath: i.parentPath
        };
      }
    }
    return Xv(t);
  }
  function Xv(t) {
    const e = t.indexOf("/") !== -1 ? ae : Ge;
    const i = e.basename(t);
    const s = e.dirname(t);
    if (i.length) {
      return {
        name: i,
        parentPath: s
      };
    } else {
      return {
        name: s,
        parentPath: ""
      };
    }
  }
  var nu;
  var Qv;
  var Sr = g({
    "out-build/vs/base/common/labels.js"() {
      "use strict";
  
      gi();
      we();
      H();
      nt();
      Wt();
      nu = Object.create(null);
      (function (t) {
        t[t.TEXT = 0] = "TEXT";
        t[t.VARIABLE = 1] = "VARIABLE";
        t[t.SEPARATOR = 2] = "SEPARATOR";
      })(Qv ||= {});
    }
  });
  function io(t) {
    return uk(t, "NFC", eb);
  }
  function uk(t, e, i) {
    if (!t) {
      return t;
    }
    const s = i.get(t);
    if (s) {
      return s;
    }
    let r;
    if (tb.test(t)) {
      r = t.normalize(e);
    } else {
      r = t;
    }
    i.set(t, r);
    return r;
  }
  var eb;
  var hk;
  var tb;
  var ou = g({
    "out-build/vs/base/common/normalization.js"() {
      "use strict";
  
      $i();
      eb = new Da(10000);
      hk = new Da(10000);
      tb = /[^\u0000-\u0080]/;
    }
  });
  import * as Fe from "fs";
  import { tmpdir as dk } from "os";
  import { promisify as Ja } from "util";
  async function ib(t, e = tn.UNLINK, i) {
    if (HE(t)) {
      throw new Error("rimraf - will refuse to recursively delete root");
    }
    if (e === tn.UNLINK) {
      return Mp(t);
    } else {
      return fk(t, i);
    }
  }
  async function fk(t, e = qa(dk())) {
    try {
      try {
        await Fe.promises.rename(t, e);
      } catch (i) {
        if (i.code === "ENOENT") {
          return undefined;
        } else {
          return Mp(t);
        }
      }
      Mp(e).catch(i => {});
    } catch (i) {
      if (i.code !== "ENOENT") {
        throw i;
      }
    }
  }
  async function Mp(t) {
    return Fe.promises.rm(t, {
      recursive: true,
      force: true,
      maxRetries: 3
    });
  }
  async function au(t, e) {
    return gk(await (e ? pk(t) : Fe.promises.readdir(t)));
  }
  async function pk(t) {
    try {
      return await Fe.promises.readdir(t, {
        withFileTypes: true
      });
    } catch (s) {
      console.warn("[node.js fs] readdir with filetypes failed with error: ", s);
    }
    const e = [];
    const i = await au(t);
    for (const s of i) {
      let r = false;
      let n = false;
      let o = false;
      try {
        const a = await Fe.promises.lstat(F(t, s));
        r = a.isFile();
        n = a.isDirectory();
        o = a.isSymbolicLink();
      } catch (a) {
        console.warn("[node.js fs] unexpected error from lstat after readdir: ", a);
      }
      e.push({
        name: s,
        isFile: () => r,
        isDirectory: () => n,
        isSymbolicLink: () => o
      });
    }
    return e;
  }
  function gk(t) {
    return t.map(e => typeof e == "string" ? N ? io(e) : e : (e.name = N ? io(e.name) : e.name, e));
  }
  async function mk(t) {
    const e = await au(t);
    const i = [];
    for (const s of e) {
      if (await jt.existsDirectory(F(t, s))) {
        i.push(s);
      }
    }
    return i;
  }
  function wk(t, e = 1000) {
    return new Promise(i => {
      let s = false;
      const r = setInterval(() => {
        if (!s) {
          s = true;
          Fe.access(t, n => {
            s = false;
            if (n) {
              clearInterval(r);
              i(undefined);
            }
          });
        }
      }, e);
    });
  }
  function vk(t, e, i) {
    return ob.queueFor(P.file(t), () => {
      const s = Sk(i);
      return new Promise((r, n) => yk(t, e, s, o => o ? n(o) : r()));
    }, tt);
  }
  function bk(t) {
    Fp = t;
  }
  function yk(t, e, i, s) {
    if (!Fp) {
      return Fe.writeFile(t, e, {
        mode: i.mode,
        flag: i.flag
      }, s);
    }
    Fe.open(t, i.flag, i.mode, (r, n) => {
      if (r) {
        return s(r);
      }
      Fe.writeFile(n, e, o => {
        if (o) {
          return Fe.close(n, () => s(o));
        }
        Fe.fdatasync(n, a => {
          if (a) {
            console.warn("[node.js fs] fdatasync is now disabled for this session because it failed: ", a);
            bk(false);
          }
          return Fe.close(n, c => s(c));
        });
      });
    });
  }
  function Sk(t) {
    if (t) {
      return {
        mode: typeof t.mode == "number" ? t.mode : 438,
        flag: typeof t.flag == "string" ? t.flag : "w"
      };
    } else {
      return {
        mode: 438,
        flag: "w"
      };
    }
  }
  async function Ek(t, e, i = 60000) {
    if (t !== e) {
      try {
        if (j && typeof i == "number") {
          await sb(t, e, Date.now(), i);
        } else {
          await Fe.promises.rename(t, e);
        }
      } catch (s) {
        if (t.toLowerCase() !== e.toLowerCase() && s.code === "EXDEV" || t.endsWith(".")) {
          await rb(t, e, {
            preserveSymlinks: false
          });
          await ib(t, tn.MOVE);
        } else {
          throw s;
        }
      }
    }
  }
  async function sb(t, e, i, s, r = 0) {
    try {
      return await Fe.promises.rename(t, e);
    } catch (n) {
      if (n.code !== "EACCES" && n.code !== "EPERM" && n.code !== "EBUSY") {
        throw n;
      }
      if (Date.now() - i >= s) {
        console.error(`[node.js fs] rename failed after ${r} retries with error: ${n}`);
        throw n;
      }
      if (r === 0) {
        let o = false;
        try {
          const {
            stat: a
          } = await jt.stat(e);
          if (!a.isFile()) {
            o = true;
          }
        } catch {}
        if (o) {
          throw n;
        }
      }
      await wi(Math.min(100, r * 10));
      return sb(t, e, i, s, r + 1);
    }
  }
  async function rb(t, e, i) {
    return nb(t, e, {
      root: {
        source: t,
        target: e
      },
      options: i,
      handledSourcePaths: new Set()
    });
  }
  async function nb(t, e, i) {
    if (i.handledSourcePaths.has(t)) {
      return;
    }
    i.handledSourcePaths.add(t);
    const {
      stat: s,
      symbolicLink: r
    } = await jt.stat(t);
    if (r) {
      if (i.options.preserveSymlinks) {
        try {
          return await Dk(t, e, i);
        } catch {}
      }
      if (r.dangling) {
        return;
      }
    }
    if (s.isDirectory()) {
      return kk(t, e, s.mode & Np, i);
    } else {
      return xk(t, e, s.mode & Np);
    }
  }
  async function kk(t, e, i, s) {
    await Fe.promises.mkdir(e, {
      recursive: true,
      mode: i
    });
    const r = await au(t);
    for (const n of r) {
      await nb(F(t, n), F(e, n), s);
    }
  }
  async function xk(t, e, i) {
    await Fe.promises.copyFile(t, e);
    await Fe.promises.chmod(e, i);
  }
  async function Dk(t, e, i) {
    let s = await Fe.promises.readlink(t);
    if (Ba(s, i.root.source, !Se)) {
      s = F(i.root.target, s.substr(i.root.source.length + 1));
    }
    await Fe.promises.symlink(s, e);
  }
  var tn;
  var jt;
  var ob;
  var Fp;
  var Np;
  var ee;
  var _t = g({
    "out-build/vs/base/node/pfs.js"() {
      "use strict";
  
      ce();
      gi();
      ou();
      we();
      H();
      nt();
      se();
      (function (t) {
        t[t.UNLINK = 0] = "UNLINK";
        t[t.MOVE = 1] = "MOVE";
      })(tn ||= {});
      (function (t) {
        async function e(r) {
          let n;
          try {
            n = await Fe.promises.lstat(r);
            if (!n.isSymbolicLink()) {
              return {
                stat: n
              };
            }
          } catch {}
          try {
            return {
              stat: await Fe.promises.stat(r),
              symbolicLink: n?.isSymbolicLink() ? {
                dangling: false
              } : undefined
            };
          } catch (o) {
            if (o.code === "ENOENT" && n) {
              return {
                stat: n,
                symbolicLink: {
                  dangling: true
                }
              };
            }
            if (j && o.code === "EACCES") {
              try {
                return {
                  stat: await Fe.promises.stat(await Fe.promises.readlink(r)),
                  symbolicLink: {
                    dangling: false
                  }
                };
              } catch (a) {
                if (a.code === "ENOENT" && n) {
                  return {
                    stat: n,
                    symbolicLink: {
                      dangling: true
                    }
                  };
                }
                throw a;
              }
            }
            throw o;
          }
        }
        t.stat = e;
        async function i(r) {
          try {
            const {
              stat: n,
              symbolicLink: o
            } = await t.stat(r);
            return n.isFile() && o?.dangling !== true;
          } catch {}
          return false;
        }
        t.existsFile = i;
        async function s(r) {
          try {
            const {
              stat: n,
              symbolicLink: o
            } = await t.stat(r);
            return n.isDirectory() && o?.dangling !== true;
          } catch {}
          return false;
        }
        t.existsDirectory = s;
      })(jt ||= {});
      ob = new Cp();
      Fp = true;
      Np = 511;
      ee = new class {
        get read() {
          return (t, e, i, s, r) => new Promise((n, o) => {
            Fe.read(t, e, i, s, r, (a, c, l) => a ? o(a) : n({
              bytesRead: c,
              buffer: l
            }));
          });
        }
        get write() {
          return (t, e, i, s, r) => new Promise((n, o) => {
            Fe.write(t, e, i, s, r, (a, c, l) => a ? o(a) : n({
              bytesWritten: c,
              buffer: l
            }));
          });
        }
        get fdatasync() {
          return Ja(Fe.fdatasync);
        }
        get open() {
          return Ja(Fe.open);
        }
        get close() {
          return Ja(Fe.close);
        }
        get realpath() {
          return Ja(Fe.realpath);
        }
        get ftruncate() {
          return Ja(Fe.ftruncate);
        }
        async exists(t) {
          try {
            await Fe.promises.access(t);
            return true;
          } catch {
            return false;
          }
        }
        get readdir() {
          return au;
        }
        get readDirsInDir() {
          return mk;
        }
        get writeFile() {
          return vk;
        }
        get rm() {
          return ib;
        }
        get rename() {
          return Ek;
        }
        get copy() {
          return rb;
        }
      }();
    }
  });
  function cu(t) {
    const e = t;
    if (e) {
      return [e.on, e.pause, e.resume, e.destroy].every(i => typeof i == "function");
    } else {
      return false;
    }
  }
  function Wp(t) {
    const e = t;
    if (e) {
      return cu(e.stream) && Array.isArray(e.buffer) && typeof e.ended == "boolean";
    } else {
      return false;
    }
  }
  function lu(t, e) {
    return new lb(t, e);
  }
  function Pk(t, e) {
    const i = [];
    let s;
    while ((s = t.read()) !== null) {
      i.push(s);
    }
    return e(i);
  }
  function $k(t, e, i) {
    const s = [];
    let r;
    while ((r = t.read()) !== null && s.length < i) {
      s.push(r);
    }
    if (r === null && s.length > 0) {
      return e(s);
    } else {
      return {
        read: () => {
          if (s.length > 0) {
            return s.shift();
          }
          if (typeof r !== "undefined") {
            const n = r;
            r = undefined;
            return n;
          }
          return t.read();
        }
      };
    }
  }
  function ab(t, e) {
    return new Promise((i, s) => {
      const r = [];
      uu(t, {
        onData: n => {
          if (e) {
            r.push(n);
          }
        },
        onError: n => {
          if (e) {
            s(n);
          } else {
            i(undefined);
          }
        },
        onEnd: () => {
          i(e ? e(r) : undefined);
        }
      });
    });
  }
  function uu(t, e, i) {
    t.on("error", s => {
      if (!i?.isCancellationRequested) {
        e.onError(s);
      }
    });
    t.on("end", () => {
      if (!i?.isCancellationRequested) {
        e.onEnd();
      }
    });
    t.on("data", s => {
      if (!i?.isCancellationRequested) {
        e.onData(s);
      }
    });
  }
  function Ik(t, e) {
    return new Promise((i, s) => {
      const r = new De();
      const n = [];
      const o = l => {
        n.push(l);
        if (n.length > e) {
          r.dispose();
          t.pause();
          return i({
            stream: t,
            buffer: n,
            ended: false
          });
        }
      };
      const a = l => {
        r.dispose();
        return s(l);
      };
      const c = () => {
        r.dispose();
        return i({
          stream: t,
          buffer: n,
          ended: true
        });
      };
      r.add(xe(() => t.removeListener("error", a)));
      t.on("error", a);
      r.add(xe(() => t.removeListener("end", c)));
      t.on("end", c);
      r.add(xe(() => t.removeListener("data", o)));
      t.on("data", o);
    });
  }
  function Ak(t) {
    let e = false;
    return {
      read: () => e ? null : (e = true, t)
    };
  }
  function cb(t, e, i) {
    const s = lu(i);
    uu(t, {
      onData: r => s.write(e.data(r)),
      onError: r => s.error(e.error ? e.error(r) : r),
      onEnd: () => s.end()
    });
    return s;
  }
  var lb;
  var Ka = g({
    "out-build/vs/base/common/stream.js"() {
      "use strict";
  
      $e();
      M();
      lb = class {
        constructor(t, e) {
          this.e = t;
          this.f = e;
          this.a = {
            flowing: false,
            ended: false,
            destroyed: false
          };
          this.b = {
            data: [],
            error: []
          };
          this.c = {
            data: [],
            error: [],
            end: []
          };
          this.d = [];
        }
        pause() {
          if (!this.a.destroyed) {
            this.a.flowing = false;
          }
        }
        resume() {
          if (!this.a.destroyed && !this.a.flowing) {
            this.a.flowing = true;
            this.j();
            this.k();
            this.l();
          }
        }
        write(t) {
          if (!this.a.destroyed) {
            if (this.a.flowing) {
              this.g(t);
            } else {
              this.b.data.push(t);
              if (typeof this.f?.highWaterMark == "number" && this.b.data.length > this.f.highWaterMark) {
                return new Promise(e => this.d.push(e));
              }
            }
          }
        }
        error(t) {
          if (!this.a.destroyed) {
            if (this.a.flowing) {
              this.h(t);
            } else {
              this.b.error.push(t);
            }
          }
        }
        end(t) {
          if (!this.a.destroyed) {
            if (typeof t !== "undefined") {
              this.write(t);
            }
            if (this.a.flowing) {
              this.i();
              this.destroy();
            } else {
              this.a.ended = true;
            }
          }
        }
        g(t) {
          this.c.data.slice(0).forEach(e => e(t));
        }
        h(t) {
          if (this.c.error.length === 0) {
            Ft(t);
          } else {
            this.c.error.slice(0).forEach(e => e(t));
          }
        }
        i() {
          this.c.end.slice(0).forEach(t => t());
        }
        on(t, e) {
          if (!this.a.destroyed) {
            switch (t) {
              case "data":
                this.c.data.push(e);
                this.resume();
                break;
              case "end":
                this.c.end.push(e);
                if (this.a.flowing && this.l()) {
                  this.destroy();
                }
                break;
              case "error":
                this.c.error.push(e);
                if (this.a.flowing) {
                  this.k();
                }
                break;
            }
          }
        }
        removeListener(t, e) {
          if (this.a.destroyed) {
            return;
          }
          let i;
          switch (t) {
            case "data":
              i = this.c.data;
              break;
            case "end":
              i = this.c.end;
              break;
            case "error":
              i = this.c.error;
              break;
          }
          if (i) {
            const s = i.indexOf(e);
            if (s >= 0) {
              i.splice(s, 1);
            }
          }
        }
        j() {
          if (this.b.data.length > 0) {
            const t = this.e(this.b.data);
            this.g(t);
            this.b.data.length = 0;
            const e = [...this.d];
            this.d.length = 0;
            e.forEach(i => i());
          }
        }
        k() {
          if (this.c.error.length > 0) {
            for (const t of this.b.error) {
              this.h(t);
            }
            this.b.error.length = 0;
          }
        }
        l() {
          if (this.a.ended) {
            this.i();
            return this.c.end.length > 0;
          } else {
            return false;
          }
        }
        destroy() {
          if (!this.a.destroyed) {
            this.a.destroyed = true;
            this.a.ended = true;
            this.b.data.length = 0;
            this.b.error.length = 0;
            this.c.data.length = 0;
            this.c.error.length = 0;
            this.c.end.length = 0;
            this.d.length = 0;
          }
        }
      };
    }
  });
  function Ck(t, e, i = 0) {
    const s = e.byteLength;
    const r = t.byteLength;
    if (s === 0) {
      return 0;
    }
    if (s === 1) {
      return t.indexOf(e[0]);
    }
    if (s > r - i) {
      return -1;
    }
    const n = ub.value;
    n.fill(e.length);
    for (let l = 0; l < e.length; l++) {
      n[e[l]] = e.length - l - 1;
    }
    let o = i + e.length - 1;
    let a = o;
    let c = -1;
    while (o < r) {
      if (t[o] === e[a]) {
        if (a === 0) {
          c = o;
          break;
        }
        o--;
        a--;
      } else {
        o += Math.max(e.length - a, n[t[o]]);
        a = e.length - 1;
      }
    }
    return c;
  }
  function _k(t, e) {
    return t[e] * 16777216 + t[e + 1] * 65536 + t[e + 2] * 256 + t[e + 3];
  }
  function Rk(t, e, i) {
    t[i + 3] = e;
    e = e >>> 8;
    t[i + 2] = e;
    e = e >>> 8;
    t[i + 1] = e;
    e = e >>> 8;
    t[i] = e;
  }
  function Ok(t, e) {
    return t[e + 0] << 0 >>> 0 | t[e + 1] << 8 >>> 0 | t[e + 2] << 16 >>> 0 | t[e + 3] << 24 >>> 0;
  }
  function Lk(t, e, i) {
    t[i + 0] = e & 255;
    e = e >>> 8;
    t[i + 1] = e & 255;
    e = e >>> 8;
    t[i + 2] = e & 255;
    e = e >>> 8;
    t[i + 3] = e & 255;
  }
  function Mk(t, e) {
    return t[e];
  }
  function Fk(t, e, i) {
    t[i] = e;
  }
  function Nk(t) {
    return Pk(t, e => z.concat(e));
  }
  function Wk(t) {
    return Ak(t);
  }
  function Za(t) {
    return ab(t, e => z.concat(e));
  }
  async function Tk(t) {
    if (t.ended) {
      return z.concat(t.buffer);
    } else {
      return z.concat([...t.buffer, await Za(t.stream)]);
    }
  }
  function jk(t) {
    return cb(t, {
      data: e => typeof e == "string" ? z.fromString(e) : z.wrap(e)
    }, e => z.concat(e));
  }
  function Uk(t) {
    return lu(e => z.concat(e), t);
  }
  var Ya;
  var ub;
  var Tp;
  var jp;
  var z;
  var Ze = g({
    "out-build/vs/base/common/buffer.js"() {
      "use strict";
  
      Ta();
      Ka();
      Ya = typeof Buffer !== "undefined";
      ub = new vr(() => new Uint8Array(256));
      z = class es {
        static alloc(e) {
          if (Ya) {
            return new es(Buffer.allocUnsafe(e));
          } else {
            return new es(new Uint8Array(e));
          }
        }
        static wrap(e) {
          if (Ya && !Buffer.isBuffer(e)) {
            e = Buffer.from(e.buffer, e.byteOffset, e.byteLength);
          }
          return new es(e);
        }
        static fromString(e, i) {
          if (!i?.dontUseNodeBuffer && !false && Ya) {
            return new es(Buffer.from(e));
          } else {
            Tp ||= new TextEncoder();
            return new es(Tp.encode(e));
          }
        }
        static fromByteArray(e) {
          const i = es.alloc(e.length);
          for (let s = 0, r = e.length; s < r; s++) {
            i.buffer[s] = e[s];
          }
          return i;
        }
        static concat(e, i) {
          if (typeof i === "undefined") {
            i = 0;
            for (let n = 0, o = e.length; n < o; n++) {
              i += e[n].byteLength;
            }
          }
          const s = es.alloc(i);
          let r = 0;
          for (let n = 0, o = e.length; n < o; n++) {
            const a = e[n];
            s.set(a, r);
            r += a.byteLength;
          }
          return s;
        }
        constructor(e) {
          this.buffer = e;
          this.byteLength = this.buffer.byteLength;
        }
        clone() {
          const e = es.alloc(this.byteLength);
          e.set(this);
          return e;
        }
        toString() {
          if (Ya) {
            return this.buffer.toString();
          } else {
            jp ||= new TextDecoder();
            return jp.decode(this.buffer);
          }
        }
        slice(e, i) {
          return new es(this.buffer.subarray(e, i));
        }
        set(e, i) {
          if (e instanceof es) {
            this.buffer.set(e.buffer, i);
          } else if (e instanceof Uint8Array) {
            this.buffer.set(e, i);
          } else if (e instanceof ArrayBuffer) {
            this.buffer.set(new Uint8Array(e), i);
          } else if (ArrayBuffer.isView(e)) {
            this.buffer.set(new Uint8Array(e.buffer, e.byteOffset, e.byteLength), i);
          } else {
            throw new Error("Unknown argument 'array'");
          }
        }
        readUInt32BE(e) {
          return _k(this.buffer, e);
        }
        writeUInt32BE(e, i) {
          Rk(this.buffer, e, i);
        }
        readUInt32LE(e) {
          return Ok(this.buffer, e);
        }
        writeUInt32LE(e, i) {
          Lk(this.buffer, e, i);
        }
        readUInt8(e) {
          return Mk(this.buffer, e);
        }
        writeUInt8(e, i) {
          Fk(this.buffer, e, i);
        }
        indexOf(e, i = 0) {
          return Ck(this.buffer, e instanceof es ? e.buffer : e, i);
        }
      };
    }
  });
  function de(t, e, i) {
    let s = null;
    let r = null;
    if (typeof i.value == "function") {
      s = "value";
      r = i.value;
      if (r.length !== 0) {
        console.warn("Memoize should only be used in functions with zero parameters");
      }
    } else if (typeof i.get == "function") {
      s = "get";
      r = i.get;
    }
    if (!r) {
      throw new Error("not supported");
    }
    const n = `$memoize$${e}`;
    i[s] = function (...o) {
      if (!this.hasOwnProperty(n)) {
        Object.defineProperty(this, n, {
          configurable: false,
          enumerable: false,
          writable: false,
          value: r.apply(this, o)
        });
      }
      return this[n];
    };
  }
  var sn = g({
    "out-build/vs/base/common/decorators.js"() {
      "use strict";
    }
  });
  function Bk(t) {
    return JSON.stringify(t, zk);
  }
  function qk(t) {
    let e = JSON.parse(t);
    e = Er(e);
    return e;
  }
  function zk(t, e) {
    if (e instanceof RegExp) {
      return {
        $mid: 2,
        source: e.source,
        flags: e.flags
      };
    } else {
      return e;
    }
  }
  function Er(t, e = 0) {
    if (!t || e > 200) {
      return t;
    }
    if (typeof t == "object") {
      switch (t.$mid) {
        case 1:
          return P.revive(t);
        case 2:
          return new RegExp(t.source, t.flags);
        case 17:
          return new Date(t.source);
      }
      if (t instanceof z || t instanceof Uint8Array) {
        return t;
      }
      if (Array.isArray(t)) {
        for (let i = 0; i < t.length; ++i) {
          t[i] = Er(t[i], e + 1);
        }
      } else {
        for (const i in t) {
          if (Object.hasOwnProperty.call(t, i)) {
            t[i] = Er(t[i], e + 1);
          }
        }
      }
    }
    return t;
  }
  var hu = g({
    "out-build/vs/base/common/marshalling.js"() {
      "use strict";
  
      Ze();
      se();
    }
  });
  function so(t) {
    switch (t) {
      case 100:
        return "req";
      case 101:
        return "cancel";
      case 102:
        return "subscribe";
      case 103:
        return "unsubscribe";
    }
  }
  function du(t) {
    switch (t) {
      case 200:
        return "init";
      case 201:
        return "reply:";
      case 202:
      case 203:
        return "replyErr:";
      case 204:
        return "event:";
    }
  }
  function ro(t) {
    let e = 0;
    for (let i = 0;; i += 7) {
      const s = t.read(1);
      e |= (s.buffer[0] & 127) << i;
      if (!(s.buffer[0] & 128)) {
        return e;
      }
    }
  }
  function no(t, e) {
    if (e === 0) {
      t.write(fb);
      return;
    }
    let i = 0;
    for (let r = e; r !== 0; r = r >>> 7) {
      i++;
    }
    const s = z.alloc(i);
    for (let r = 0; e !== 0; r++) {
      s.buffer[r] = e & 127;
      e = e >>> 7;
      if (e > 0) {
        s.buffer[r] |= 128;
      }
    }
    t.write(s);
  }
  function kr(t) {
    const e = z.alloc(1);
    e.writeUInt8(t, 0);
    return e;
  }
  function oo(t, e) {
    if (typeof e === "undefined") {
      t.write(xr.Undefined);
    } else if (typeof e == "string") {
      const i = z.fromString(e);
      t.write(xr.String);
      no(t, i.byteLength);
      t.write(i);
    } else if (pb && Buffer.isBuffer(e)) {
      const i = z.wrap(e);
      t.write(xr.Buffer);
      no(t, i.byteLength);
      t.write(i);
    } else if (e instanceof z) {
      t.write(xr.VSBuffer);
      no(t, e.byteLength);
      t.write(e);
    } else if (Array.isArray(e)) {
      t.write(xr.Array);
      no(t, e.length);
      for (const i of e) {
        oo(t, i);
      }
    } else if (typeof e == "number" && (e | 0) === e) {
      t.write(xr.Uint);
      no(t, e);
    } else {
      const i = z.fromString(JSON.stringify(e));
      t.write(xr.Object);
      no(t, i.byteLength);
      t.write(i);
    }
  }
  function ao(t) {
    switch (t.read(1).readUInt8(0)) {
      case ei.Undefined:
        return;
      case ei.String:
        return t.read(ro(t)).toString();
      case ei.Buffer:
        return t.read(ro(t)).buffer;
      case ei.VSBuffer:
        return t.read(ro(t));
      case ei.Array:
        {
          const i = ro(t);
          const s = [];
          for (let r = 0; r < i; r++) {
            s.push(ao(t));
          }
          return s;
        }
      case ei.Object:
        return JSON.parse(t.read(ro(t)).toString());
      case ei.Int:
        return ro(t);
    }
  }
  function fu(t) {
    return {
      call(e, i, s) {
        return t.then(r => r.call(e, i, s));
      },
      listen(e, i) {
        const s = new ip();
        t.then(r => s.input = r.listen(e, i));
        return s.event;
      }
    };
  }
  function Hk(t) {
    let e = false;
    return {
      call(i, s, r) {
        if (e) {
          return t.call(i, s, r);
        } else {
          return wi(0).then(() => e = true).then(() => t.call(i, s, r));
        }
      },
      listen(i, s) {
        if (e) {
          return t.listen(i, s);
        }
        const r = new ip();
        wi(0).then(() => e = true).then(() => r.input = t.listen(i, s));
        return r.event;
      }
    };
  }
  var hb;
  var db;
  var rn;
  var fb;
  var pu;
  var gu;
  var ei;
  var xr;
  var pb;
  var Up;
  var gb;
  var Xa;
  var Bp;
  var qp;
  var mb;
  var ze;
  var xs = g({
    "out-build/vs/base/parts/ipc/common/ipc.js"() {
      "use strict";
  
      zt();
      ce();
      Ze();
      At();
      sn();
      $e();
      B();
      Ul();
      M();
      hu();
      Wt();
      _e();
      (function (t) {
        t[t.Promise = 100] = "Promise";
        t[t.PromiseCancel = 101] = "PromiseCancel";
        t[t.EventListen = 102] = "EventListen";
        t[t.EventDispose = 103] = "EventDispose";
      })(hb ||= {});
      (function (t) {
        t[t.Initialize = 200] = "Initialize";
        t[t.PromiseSuccess = 201] = "PromiseSuccess";
        t[t.PromiseError = 202] = "PromiseError";
        t[t.PromiseErrorObj = 203] = "PromiseErrorObj";
        t[t.EventFire = 204] = "EventFire";
      })(db ||= {});
      (function (t) {
        t[t.Uninitialized = 0] = "Uninitialized";
        t[t.Idle = 1] = "Idle";
      })(rn ||= {});
      fb = kr(0);
      pu = class {
        constructor(t) {
          this.b = t;
          this.a = 0;
        }
        read(t) {
          const e = this.b.slice(this.a, this.a + t);
          this.a += e.byteLength;
          return e;
        }
      };
      gu = class {
        constructor() {
          this.a = [];
        }
        get buffer() {
          return z.concat(this.a);
        }
        write(t) {
          this.a.push(t);
        }
      };
      (function (t) {
        t[t.Undefined = 0] = "Undefined";
        t[t.String = 1] = "String";
        t[t.Buffer = 2] = "Buffer";
        t[t.VSBuffer = 3] = "VSBuffer";
        t[t.Array = 4] = "Array";
        t[t.Object = 5] = "Object";
        t[t.Int = 6] = "Int";
      })(ei ||= {});
      xr = {
        Undefined: kr(ei.Undefined),
        String: kr(ei.String),
        Buffer: kr(ei.Buffer),
        VSBuffer: kr(ei.VSBuffer),
        Array: kr(ei.Array),
        Object: kr(ei.Object),
        Uint: kr(ei.Int)
      };
      pb = typeof Buffer !== "undefined";
      Up = class {
        constructor(t, e, i = null, s = 1000) {
          this.h = t;
          this.j = e;
          this.k = i;
          this.l = s;
          this.b = new Map();
          this.d = new Map();
          this.g = new Map();
          this.f = this.h.onMessage(r => this.q(r));
          this.m({
            type: 200
          });
        }
        registerChannel(t, e) {
          this.b.set(t, e);
          setTimeout(() => this.w(t), 0);
        }
        m(t) {
          switch (t.type) {
            case 200:
              {
                const e = this.o([t.type]);
                this.k?.logOutgoing(e, 0, 1, du(t.type));
                return;
              }
            case 201:
            case 202:
            case 204:
            case 203:
              {
                const e = this.o([t.type, t.id], t.data);
                this.k?.logOutgoing(e, t.id, 1, du(t.type), t.data);
                return;
              }
          }
        }
        o(t, e = undefined) {
          const i = new gu();
          oo(i, t);
          oo(i, e);
          return this.p(i.buffer);
        }
        p(t) {
          try {
            this.h.send(t);
            return t.byteLength;
          } catch {
            return 0;
          }
        }
        q(t) {
          const e = new pu(t);
          const i = ao(e);
          const s = ao(e);
          const r = i[0];
          switch (r) {
            case 100:
              this.k?.logIncoming(t.byteLength, i[1], 1, `${so(r)}: ${i[2]}.${i[3]}`, s);
              return this.s({
                type: r,
                id: i[1],
                channelName: i[2],
                name: i[3],
                arg: s
              });
            case 102:
              this.k?.logIncoming(t.byteLength, i[1], 1, `${so(r)}: ${i[2]}.${i[3]}`, s);
              return this.t({
                type: r,
                id: i[1],
                channelName: i[2],
                name: i[3],
                arg: s
              });
            case 101:
              this.k?.logIncoming(t.byteLength, i[1], 1, `${so(r)}`);
              return this.u({
                type: r,
                id: i[1]
              });
            case 103:
              this.k?.logIncoming(t.byteLength, i[1], 1, `${so(r)}`);
              return this.u({
                type: r,
                id: i[1]
              });
          }
        }
        s(t) {
          const e = this.b.get(t.channelName);
          if (!e) {
            this.v(t);
            return;
          }
          const i = new ns();
          let s;
          try {
            s = e.call(this.j, t.name, t.arg, i.token);
          } catch (o) {
            s = Promise.reject(o);
          }
          const r = t.id;
          s.then(o => {
            this.m({
              id: r,
              data: o,
              type: 201
            });
          }, o => {
            if (o instanceof Error) {
              this.m({
                id: r,
                data: {
                  message: o.message,
                  name: o.name,
                  stack: o.stack ? o.stack.split(`
  `) : undefined
                },
                type: 202
              });
            } else {
              this.m({
                id: r,
                data: o,
                type: 203
              });
            }
          }).finally(() => {
            n.dispose();
            this.d.delete(t.id);
          });
          const n = xe(() => i.cancel());
          this.d.set(t.id, n);
        }
        t(t) {
          const e = this.b.get(t.channelName);
          if (!e) {
            this.v(t);
            return;
          }
          const i = t.id;
          const r = e.listen(this.j, t.name, t.arg)(n => this.m({
            id: i,
            data: n,
            type: 204
          }));
          this.d.set(t.id, r);
        }
        u(t) {
          const e = this.d.get(t.id);
          if (e) {
            e.dispose();
            this.d.delete(t.id);
          }
        }
        v(t) {
          let e = this.g.get(t.channelName);
          if (!e) {
            e = [];
            this.g.set(t.channelName, e);
          }
          const i = setTimeout(() => {
            console.error(`Unknown channel: ${t.channelName}`);
            if (t.type === 100) {
              this.m({
                id: t.id,
                data: {
                  name: "Unknown channel",
                  message: `Channel name '${t.channelName}' timed out after ${this.l}ms`,
                  stack: undefined
                },
                type: 202
              });
            }
          }, this.l);
          e.push({
            request: t,
            timeoutTimer: i
          });
        }
        w(t) {
          const e = this.g.get(t);
          if (e) {
            for (const i of e) {
              clearTimeout(i.timeoutTimer);
              switch (i.request.type) {
                case 100:
                  this.s(i.request);
                  break;
                case 102:
                  this.t(i.request);
                  break;
              }
            }
            this.g.delete(t);
          }
        }
        dispose() {
          if (this.f) {
            this.f.dispose();
            this.f = null;
          }
          Et(this.d.values());
          this.d.clear();
        }
      };
      (function (t) {
        t[t.LocalSide = 0] = "LocalSide";
        t[t.OtherSide = 1] = "OtherSide";
      })(gb ||= {});
      Xa = class {
        constructor(t, e = null) {
          this.l = t;
          this.a = false;
          this.b = rn.Uninitialized;
          this.d = new Set();
          this.f = new Map();
          this.g = 0;
          this.k = new $();
          this.onDidInitialize = this.k.event;
          this.h = this.l.onMessage(i => this.s(i));
          this.j = e;
        }
        getChannel(t) {
          const e = this;
          return {
            call(i, s, r) {
              if (e.a) {
                return Promise.reject(new hi());
              } else {
                return e.m(t, i, s, r);
              }
            },
            listen(i, s) {
              if (e.a) {
                return x.None;
              } else {
                return e.o(t, i, s);
              }
            }
          };
        }
        m(t, e, i, s = We.None) {
          const r = this.g++;
          const o = {
            id: r,
            type: 100,
            channelName: t,
            name: e,
            arg: i
          };
          if (s.isCancellationRequested) {
            return Promise.reject(new hi());
          }
          let a;
          let c;
          return new Promise((u, d) => {
            if (s.isCancellationRequested) {
              return d(new hi());
            }
            const f = () => {
              const m = y => {
                switch (y.type) {
                  case 201:
                    this.f.delete(r);
                    u(y.data);
                    break;
                  case 202:
                    {
                      this.f.delete(r);
                      const b = new Error(y.data.message);
                      b.stack = Array.isArray(y.data.stack) ? y.data.stack.join(`
  `) : y.data.stack;
                      b.name = y.data.name;
                      d(b);
                      break;
                    }
                  case 203:
                    this.f.delete(r);
                    d(y.data);
                    break;
                }
              };
              this.f.set(r, m);
              this.p(o);
            };
            let p = null;
            if (this.b === rn.Idle) {
              f();
            } else {
              p = Qn(m => this.u());
              p.then(() => {
                p = null;
                f();
              });
            }
            const w = () => {
              if (p) {
                p.cancel();
                p = null;
              } else {
                this.p({
                  id: r,
                  type: 101
                });
              }
              d(new hi());
            };
            a = s.onCancellationRequested(w);
            c = {
              dispose: jl(() => {
                w();
                a.dispose();
              })
            };
            this.d.add(c);
          }).finally(() => {
            a.dispose();
            this.d.delete(c);
          });
        }
        o(t, e, i) {
          const s = this.g++;
          const n = {
            id: s,
            type: 102,
            channelName: t,
            name: e,
            arg: i
          };
          let o = null;
          const a = new $({
            onWillAddFirstListener: () => {
              const l = () => {
                this.d.add(a);
                this.p(n);
              };
              if (this.b === rn.Idle) {
                l();
              } else {
                o = Qn(u => this.u());
                o.then(() => {
                  o = null;
                  l();
                });
              }
            },
            onDidRemoveLastListener: () => {
              if (o) {
                o.cancel();
                o = null;
              } else {
                this.d.delete(a);
                this.p({
                  id: s,
                  type: 103
                });
              }
            }
          });
          const c = l => a.fire(l.data);
          this.f.set(s, c);
          return a.event;
        }
        p(t) {
          switch (t.type) {
            case 100:
            case 102:
              {
                const e = this.q([t.type, t.id, t.channelName, t.name], t.arg);
                this.j?.logOutgoing(e, t.id, 0, `${so(t.type)}: ${t.channelName}.${t.name}`, t.arg);
                return;
              }
            case 101:
            case 103:
              {
                const e = this.q([t.type, t.id]);
                this.j?.logOutgoing(e, t.id, 0, so(t.type));
                return;
              }
          }
        }
        q(t, e = undefined) {
          const i = new gu();
          oo(i, t);
          oo(i, e);
          return this.r(i.buffer);
        }
        r(t) {
          try {
            this.l.send(t);
            return t.byteLength;
          } catch {
            return 0;
          }
        }
        s(t) {
          const e = new pu(t);
          const i = ao(e);
          const s = ao(e);
          const r = i[0];
          switch (r) {
            case 200:
              this.j?.logIncoming(t.byteLength, 0, 0, du(r));
              return this.t({
                type: i[0]
              });
            case 201:
            case 202:
            case 204:
            case 203:
              this.j?.logIncoming(t.byteLength, i[1], 0, du(r), s);
              return this.t({
                type: i[0],
                id: i[1],
                data: s
              });
          }
        }
        t(t) {
          if (t.type === 200) {
            this.b = rn.Idle;
            this.k.fire();
            return;
          }
          this.f.get(t.id)?.(t);
        }
        get onDidInitializePromise() {
          return x.toPromise(this.onDidInitialize);
        }
        u() {
          if (this.b === rn.Idle) {
            return Promise.resolve();
          } else {
            return this.onDidInitializePromise;
          }
        }
        dispose() {
          this.a = true;
          if (this.h) {
            this.h.dispose();
            this.h = null;
          }
          Et(this.d.values());
          this.d.clear();
        }
      };
      __decorate([de], Xa.prototype, "onDidInitializePromise", null);
      Bp = class {
        get connections() {
          const t = [];
          this.f.forEach(e => t.push(e));
          return t;
        }
        constructor(t, e, i) {
          this.a = new Map();
          this.f = new Set();
          this.g = new $();
          this.onDidAddConnection = this.g.event;
          this.h = new $();
          this.onDidRemoveConnection = this.h.event;
          this.j = new De();
          this.j.add(t(({
            protocol: s,
            onDidClientDisconnect: r
          }) => {
            const n = x.once(s.onMessage);
            this.j.add(n(o => {
              const a = new pu(o);
              const c = ao(a);
              const l = new Up(s, c, e, i);
              const u = new Xa(s, e);
              this.a.forEach((f, p) => l.registerChannel(p, f));
              const d = {
                channelServer: l,
                channelClient: u,
                ctx: c
              };
              this.f.add(d);
              this.g.fire(d);
              this.j.add(r(() => {
                l.dispose();
                u.dispose();
                this.f.delete(d);
                this.h.fire(d);
              }));
            }));
          }));
        }
        getChannel(t, e) {
          const i = this;
          return {
            call(s, r, n) {
              let o;
              if (jw(e)) {
                const c = JS(i.connections.filter(e));
                o = c ? Promise.resolve(c) : x.toPromise(x.filter(i.onDidAddConnection, e));
              } else {
                o = e.routeCall(i, s, r);
              }
              const a = o.then(c => c.channelClient.getChannel(t));
              return fu(a).call(s, r, n);
            },
            listen(s, r) {
              if (jw(e)) {
                return i.k(t, e, s, r);
              }
              const n = e.routeEvent(i, s, r).then(o => o.channelClient.getChannel(t));
              return fu(n).listen(s, r);
            }
          };
        }
        k(t, e, i, s) {
          const r = this;
          let n;
          const o = new $({
            onWillAddFirstListener: () => {
              n = new De();
              const a = new Ww();
              const c = new Map();
              const l = d => {
                const p = d.channelClient.getChannel(t).listen(i, s);
                const w = a.add(p);
                c.set(d, w);
              };
              const u = d => {
                const f = c.get(d);
                if (f) {
                  f.dispose();
                  c.delete(d);
                }
              };
              r.connections.filter(e).forEach(l);
              x.filter(r.onDidAddConnection, e)(l, undefined, n);
              r.onDidRemoveConnection(u, undefined, n);
              a.event(o.fire, o, n);
              n.add(a);
            },
            onDidRemoveLastListener: () => {
              n?.dispose();
              n = undefined;
            }
          });
          r.j.add(o);
          return o.event;
        }
        registerChannel(t, e) {
          this.a.set(t, e);
          for (const i of this.f) {
            i.channelServer.registerChannel(t, e);
          }
        }
        dispose() {
          this.j.dispose();
          for (const t of this.f) {
            t.channelClient.dispose();
            t.channelServer.dispose();
          }
          this.f.clear();
          this.a.clear();
          this.g.dispose();
          this.h.dispose();
        }
      };
      qp = class {
        constructor(t, e, i = null) {
          const s = new gu();
          oo(s, e);
          t.send(s.buffer);
          this.a = new Xa(t, i);
          this.d = new Up(t, e, i);
        }
        getChannel(t) {
          return this.a.getChannel(t);
        }
        registerChannel(t, e) {
          this.d.registerChannel(t, e);
        }
        dispose() {
          this.a.dispose();
          this.d.dispose();
        }
      };
      mb = class {
        constructor(t) {
          this.a = t;
        }
        routeCall(t) {
          return this.b(t);
        }
        routeEvent(t) {
          return this.b(t);
        }
        async b(t) {
          for (const e of t.connections) {
            if (await Promise.resolve(this.a(e.ctx))) {
              return Promise.resolve(e);
            }
          }
          await x.toPromise(t.onDidAddConnection);
          return await this.b(t);
        }
      };
      (function (t) {
        function e(n, o, a) {
          const c = n;
          const l = a && a.disableMarshalling;
          const u = new Map();
          for (const d in c) {
            if (s(d)) {
              u.set(d, x.buffer(c[d], true, undefined, o));
            }
          }
          return new class {
            listen(d, f, p) {
              const w = u.get(f);
              if (w) {
                return w;
              }
              const m = c[f];
              if (typeof m == "function") {
                if (r(f)) {
                  return m.call(c, p);
                }
                if (s(f)) {
                  u.set(f, x.buffer(c[f], true, undefined, o));
                  return u.get(f);
                }
              }
              throw new Vs(`Event not found: ${f}`);
            }
            call(d, f, p) {
              const w = c[f];
              if (typeof w == "function") {
                if (!l && Array.isArray(p)) {
                  for (let y = 0; y < p.length; y++) {
                    p[y] = Er(p[y]);
                  }
                }
                let m = w.apply(c, p);
                if (!(m instanceof Promise)) {
                  m = Promise.resolve(m);
                }
                return m;
              }
              throw new Vs(`Method not found: ${f}`);
            }
          }();
        }
        t.fromService = e;
        function i(n, o) {
          const a = o && o.disableMarshalling;
          return new Proxy({}, {
            get(c, l) {
              if (typeof l == "string") {
                if (o?.properties?.has(l)) {
                  return o.properties.get(l);
                } else if (r(l)) {
                  return function (u) {
                    return n.listen(l, u);
                  };
                } else if (s(l)) {
                  return n.listen(l);
                } else {
                  return async function (...u) {
                    let d;
                    if (o && !Qt(o.context)) {
                      d = [o.context, ...u];
                    } else {
                      d = u;
                    }
                    const f = await n.call(l, d);
                    if (a) {
                      return f;
                    } else {
                      return Er(f);
                    }
                  };
                }
              }
              throw new Vs(`Property not found: ${String(l)}`);
            }
          });
        }
        t.toService = i;
        function s(n) {
          return n[0] === "o" && n[1] === "n" && wv(n.charCodeAt(2));
        }
        function r(n) {
          return /^onDynamic/.test(n) && wv(n.charCodeAt(9));
        }
      })(ze ||= {});
    }
  });
  function Vk(t) {
    return wb.test(t);
  }
  var wb;
  var ti;
  var _i = g({
    "out-build/vs/base/common/uuid.js"() {
      "use strict";
  
      wb = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      ti = function () {
        if (typeof crypto == "object" && typeof crypto.randomUUID == "function") {
          return crypto.randomUUID.bind(crypto);
        }
        let t;
        if (typeof crypto == "object" && typeof crypto.getRandomValues == "function") {
          t = crypto.getRandomValues.bind(crypto);
        } else {
          t = function (s) {
            for (let r = 0; r < s.length; r++) {
              s[r] = Math.floor(Math.random() * 256);
            }
            return s;
          };
        }
        const e = new Uint8Array(16);
        const i = [];
        for (let s = 0; s < 256; s++) {
          i.push(s.toString(16).padStart(2, "0"));
        }
        return function () {
          t(e);
          e[6] = e[6] & 15 | 64;
          e[8] = e[8] & 63 | 128;
          let r = 0;
          let n = "";
          n += i[e[r++]];
          n += i[e[r++]];
          n += i[e[r++]];
          n += i[e[r++]];
          n += "-";
          n += i[e[r++]];
          n += i[e[r++]];
          n += "-";
          n += i[e[r++]];
          n += i[e[r++]];
          n += "-";
          n += i[e[r++]];
          n += i[e[r++]];
          n += "-";
          n += i[e[r++]];
          n += i[e[r++]];
          n += i[e[r++]];
          n += i[e[r++]];
          n += i[e[r++]];
          n += i[e[r++]];
          return n;
        };
      }();
    }
  });
  function Dr() {
    mu ||= z.alloc(0);
    return mu;
  }
  function vb(t) {
    switch (t) {
      case 0:
        return "None";
      case 1:
        return "Regular";
      case 2:
        return "Control";
      case 3:
        return "Ack";
      case 5:
        return "Disconnect";
      case 6:
        return "ReplayRequest";
      case 7:
        return "PauseWriting";
      case 8:
        return "ResumeWriting";
      case 9:
        return "KeepAlive";
    }
  }
  var bb;
  var zp;
  var yb;
  var mu;
  var Sb;
  var Eb;
  var kb;
  var Zi;
  var wu;
  var vu;
  var Hp;
  var xb;
  var co;
  var Db;
  var Pb;
  var $b;
  var Ib;
  var Ab = g({
    "out-build/vs/base/parts/ipc/common/ipc.net.js"() {
      "use strict";
  
      Ze();
      B();
      M();
      xs();
      (function (t) {
        t.Created = "created";
        t.Read = "read";
        t.Write = "write";
        t.Open = "open";
        t.Error = "error";
        t.Close = "close";
        t.BrowserWebSocketBlobReceived = "browserWebSocketBlobReceived";
        t.NodeEndReceived = "nodeEndReceived";
        t.NodeEndSent = "nodeEndSent";
        t.NodeDrainBegin = "nodeDrainBegin";
        t.NodeDrainEnd = "nodeDrainEnd";
        t.zlibInflateError = "zlibInflateError";
        t.zlibInflateData = "zlibInflateData";
        t.zlibInflateInitialWrite = "zlibInflateInitialWrite";
        t.zlibInflateInitialFlushFired = "zlibInflateInitialFlushFired";
        t.zlibInflateWrite = "zlibInflateWrite";
        t.zlibInflateFlushFired = "zlibInflateFlushFired";
        t.zlibDeflateError = "zlibDeflateError";
        t.zlibDeflateData = "zlibDeflateData";
        t.zlibDeflateWrite = "zlibDeflateWrite";
        t.zlibDeflateFlushFired = "zlibDeflateFlushFired";
        t.WebSocketNodeSocketWrite = "webSocketNodeSocketWrite";
        t.WebSocketNodeSocketPeekedHeader = "webSocketNodeSocketPeekedHeader";
        t.WebSocketNodeSocketReadHeader = "webSocketNodeSocketReadHeader";
        t.WebSocketNodeSocketReadData = "webSocketNodeSocketReadData";
        t.WebSocketNodeSocketUnmaskedData = "webSocketNodeSocketUnmaskedData";
        t.WebSocketNodeSocketDrainBegin = "webSocketNodeSocketDrainBegin";
        t.WebSocketNodeSocketDrainEnd = "webSocketNodeSocketDrainEnd";
        t.ProtocolHeaderRead = "protocolHeaderRead";
        t.ProtocolMessageRead = "protocolMessageRead";
        t.ProtocolHeaderWrite = "protocolHeaderWrite";
        t.ProtocolMessageWrite = "protocolMessageWrite";
        t.ProtocolWrite = "protocolWrite";
      })(bb ||= {});
      (function (t) {
        t.enableDiagnostics = false;
        t.records = [];
        const e = new WeakMap();
        let i = 0;
        function s(n, o) {
          if (!e.has(n)) {
            const a = String(++i);
            e.set(n, a);
          }
          return e.get(n);
        }
        function r(n, o, a, c) {
          if (!t.enableDiagnostics) {
            return;
          }
          const l = s(n, o);
          if (c instanceof z || c instanceof Uint8Array || c instanceof ArrayBuffer || ArrayBuffer.isView(c)) {
            const u = z.alloc(c.byteLength);
            u.set(c);
            t.records.push({
              timestamp: Date.now(),
              id: l,
              label: o,
              type: a,
              buff: u
            });
          } else {
            t.records.push({
              timestamp: Date.now(),
              id: l,
              label: o,
              type: a,
              data: c
            });
          }
        }
        t.traceSocketEvent = r;
      })(zp ||= {});
      (function (t) {
        t[t.NodeSocketCloseEvent = 0] = "NodeSocketCloseEvent";
        t[t.WebSocketCloseEvent = 1] = "WebSocketCloseEvent";
      })(yb ||= {});
      mu = null;
      Sb = class {
        get byteLength() {
          return this.b;
        }
        constructor() {
          this.a = [];
          this.b = 0;
        }
        acceptChunk(t) {
          this.a.push(t);
          this.b += t.byteLength;
        }
        read(t) {
          return this.c(t, true);
        }
        peek(t) {
          return this.c(t, false);
        }
        c(t, e) {
          if (t === 0) {
            return Dr();
          }
          if (t > this.b) {
            throw new Error("Cannot read so many bytes!");
          }
          if (this.a[0].byteLength === t) {
            const n = this.a[0];
            if (e) {
              this.a.shift();
              this.b -= t;
            }
            return n;
          }
          if (this.a[0].byteLength > t) {
            const n = this.a[0].slice(0, t);
            if (e) {
              this.a[0] = this.a[0].slice(t);
              this.b -= t;
            }
            return n;
          }
          const i = z.alloc(t);
          let s = 0;
          let r = 0;
          while (t > 0) {
            const n = this.a[r];
            if (n.byteLength > t) {
              const o = n.slice(0, t);
              i.set(o, s);
              s += t;
              if (e) {
                this.a[r] = n.slice(t);
                this.b -= t;
              }
              t -= t;
            } else {
              i.set(n, s);
              s += n.byteLength;
              if (e) {
                this.a.shift();
                this.b -= n.byteLength;
              } else {
                r++;
              }
              t -= n.byteLength;
            }
          }
          return i;
        }
      };
      (function (t) {
        t[t.None = 0] = "None";
        t[t.Regular = 1] = "Regular";
        t[t.Control = 2] = "Control";
        t[t.Ack = 3] = "Ack";
        t[t.Disconnect = 5] = "Disconnect";
        t[t.ReplayRequest = 6] = "ReplayRequest";
        t[t.Pause = 7] = "Pause";
        t[t.Resume = 8] = "Resume";
        t[t.KeepAlive = 9] = "KeepAlive";
      })(Eb ||= {});
      (function (t) {
        t[t.HeaderLength = 13] = "HeaderLength";
        t[t.AcknowledgeTime = 2000] = "AcknowledgeTime";
        t[t.TimeoutTime = 20000] = "TimeoutTime";
        t[t.ReconnectionGraceTime = 10800000] = "ReconnectionGraceTime";
        t[t.ReconnectionShortGraceTime = 300000] = "ReconnectionShortGraceTime";
        t[t.KeepAliveSendTime = 5000] = "KeepAliveSendTime";
      })(kb ||= {});
      Zi = class {
        constructor(t, e, i, s) {
          this.type = t;
          this.id = e;
          this.ack = i;
          this.data = s;
          this.writtenTime = 0;
        }
        get size() {
          return this.data.byteLength;
        }
      };
      wu = class extends T {
        constructor(t) {
          super();
          this.f = this.D(new $());
          this.onMessage = this.f.event;
          this.g = {
            readHead: true,
            readLen: 13,
            messageType: 0,
            id: 0,
            ack: 0
          };
          this.a = t;
          this.b = false;
          this.c = new Sb();
          this.D(this.a.onData(e => this.acceptChunk(e)));
          this.lastReadTime = Date.now();
        }
        acceptChunk(t) {
          if (!!t && t.byteLength !== 0) {
            this.lastReadTime = Date.now();
            this.c.acceptChunk(t);
            while (this.c.byteLength >= this.g.readLen) {
              const e = this.c.read(this.g.readLen);
              if (this.g.readHead) {
                this.g.readHead = false;
                this.g.readLen = e.readUInt32BE(9);
                this.g.messageType = e.readUInt8(0);
                this.g.id = e.readUInt32BE(1);
                this.g.ack = e.readUInt32BE(5);
                this.a.traceSocketEvent("protocolHeaderRead", {
                  messageType: vb(this.g.messageType),
                  id: this.g.id,
                  ack: this.g.ack,
                  messageSize: this.g.readLen
                });
              } else {
                const i = this.g.messageType;
                const s = this.g.id;
                const r = this.g.ack;
                this.g.readHead = true;
                this.g.readLen = 13;
                this.g.messageType = 0;
                this.g.id = 0;
                this.g.ack = 0;
                this.a.traceSocketEvent("protocolMessageRead", e);
                this.f.fire(new Zi(i, s, r, e));
                if (this.b) {
                  break;
                }
              }
            }
          }
        }
        readEntireBuffer() {
          return this.c.read(this.c.byteLength);
        }
        dispose() {
          this.b = true;
          super.dispose();
        }
      };
      vu = class {
        constructor(t) {
          this.k = null;
          this.a = false;
          this.b = false;
          this.c = t;
          this.d = [];
          this.f = 0;
          this.lastWriteTime = 0;
        }
        dispose() {
          try {
            this.flush();
          } catch {}
          this.a = true;
        }
        drain() {
          this.flush();
          return this.c.drain();
        }
        flush() {
          this.m();
        }
        pause() {
          this.b = true;
        }
        resume() {
          this.b = false;
          this.l();
        }
        write(t) {
          if (this.a) {
            return;
          }
          t.writtenTime = Date.now();
          this.lastWriteTime = Date.now();
          const e = z.alloc(13);
          e.writeUInt8(t.type, 0);
          e.writeUInt32BE(t.id, 1);
          e.writeUInt32BE(t.ack, 5);
          e.writeUInt32BE(t.data.byteLength, 9);
          this.c.traceSocketEvent("protocolHeaderWrite", {
            messageType: vb(t.type),
            id: t.id,
            ack: t.ack,
            messageSize: t.data.byteLength
          });
          this.c.traceSocketEvent("protocolMessageWrite", t.data);
          this.j(e, t.data);
        }
        g(t, e) {
          const i = this.f === 0;
          this.d.push(t, e);
          this.f += t.byteLength + e.byteLength;
          return i;
        }
        h() {
          const t = z.concat(this.d, this.f);
          this.d.length = 0;
          this.f = 0;
          return t;
        }
        j(t, e) {
          if (this.g(t, e)) {
            this.l();
          }
        }
        l() {
          this.k ||= setTimeout(() => {
            this.k = null;
            this.m();
          });
        }
        m() {
          if (this.f === 0 || this.b) {
            return;
          }
          const t = this.h();
          this.c.traceSocketEvent("protocolWrite", {
            byteLength: t.byteLength
          });
          this.c.write(t);
        }
      };
      Hp = class extends T {
        constructor(t) {
          super();
          this.f = new $();
          this.onMessage = this.f.event;
          this.g = new $();
          this.onDidDispose = this.g.event;
          this.a = t;
          this.b = this.D(new vu(this.a));
          this.c = this.D(new wu(this.a));
          this.D(this.c.onMessage(e => {
            if (e.type === 1) {
              this.f.fire(e.data);
            }
          }));
          this.D(this.a.onClose(() => this.g.fire()));
        }
        drain() {
          return this.b.drain();
        }
        getSocket() {
          return this.a;
        }
        sendDisconnect() {}
        send(t) {
          this.b.write(new Zi(1, 0, 0, t));
        }
      };
      xb = class W3 extends qp {
        static fromSocket(e, i) {
          return new W3(new Hp(e), i);
        }
        get onDidDispose() {
          return this.b.onDidDispose;
        }
        constructor(e, i, s = null) {
          super(e, i, s);
          this.b = e;
        }
        dispose() {
          super.dispose();
          const e = this.b.getSocket();
          this.b.sendDisconnect();
          this.b.dispose();
          e.end();
        }
      };
      co = class {
        constructor() {
          this.b = false;
          this.c = false;
          this.d = [];
          this.a = new $({
            onWillAddFirstListener: () => {
              this.b = true;
              queueMicrotask(() => this.f());
            },
            onDidRemoveLastListener: () => {
              this.b = false;
            }
          });
          this.event = this.a.event;
        }
        f() {
          if (!this.c) {
            for (this.c = true; this.b && this.d.length > 0;) {
              this.a.fire(this.d.shift());
            }
            this.c = false;
          }
        }
        fire(t) {
          if (this.b) {
            if (this.d.length > 0) {
              this.d.push(t);
            } else {
              this.a.fire(t);
            }
          } else {
            this.d.push(t);
          }
        }
        flushBuffer() {
          this.d = [];
        }
      };
      Db = class {
        constructor(t) {
          this.data = t;
          this.next = null;
        }
      };
      Pb = class {
        constructor() {
          this.a = null;
          this.b = null;
        }
        length() {
          let t = 0;
          let e = this.a;
          while (e) {
            e = e.next;
            t++;
          }
          return t;
        }
        peek() {
          if (this.a) {
            return this.a.data;
          } else {
            return null;
          }
        }
        toArray() {
          const t = [];
          let e = 0;
          let i = this.a;
          while (i) {
            t[e++] = i.data;
            i = i.next;
          }
          return t;
        }
        pop() {
          if (this.a) {
            if (this.a === this.b) {
              this.a = null;
              this.b = null;
              return;
            }
            this.a = this.a.next;
          }
        }
        push(t) {
          const e = new Db(t);
          if (!this.a) {
            this.a = e;
            this.b = e;
            return;
          }
          this.b.next = e;
          this.b = e;
        }
      };
      $b = class js {
        static {
          this.a = 10;
        }
        static {
          this.b = null;
        }
        static getInstance() {
          js.b ||= new js();
          return js.b;
        }
        constructor() {
          this.c = [];
          const e = Date.now();
          for (let i = 0; i < js.a; i++) {
            this.c[i] = e - i * 1000;
          }
          setInterval(() => {
            for (let i = js.a; i >= 1; i--) {
              this.c[i] = this.c[i - 1];
            }
            this.c[0] = Date.now();
          }, 1000);
        }
        d() {
          const e = Date.now();
          const i = (1 + js.a) * 1000;
          let s = 0;
          for (let r = 0; r < js.a; r++) {
            if (e - this.c[r] <= i) {
              s++;
            }
          }
          return 1 - s / js.a;
        }
        hasHighLoad() {
          return this.d() >= 0.5;
        }
      };
      Ib = class {
        get unacknowledgedCount() {
          return this.d - this.f;
        }
        constructor(t) {
          this.v = new co();
          this.onControlMessage = this.v.event;
          this.w = new co();
          this.onMessage = this.w.event;
          this.x = new co();
          this.onDidDispose = this.x.event;
          this.y = new co();
          this.onSocketClose = this.y.event;
          this.z = new co();
          this.onSocketTimeout = this.z.event;
          this.t = t.loadEstimator ?? $b.getInstance();
          this.u = t.sendKeepAlive ?? true;
          this.a = false;
          this.c = new Pb();
          this.d = 0;
          this.f = 0;
          this.g = null;
          this.h = 0;
          this.j = 0;
          this.k = 0;
          this.l = null;
          this.n = 0;
          this.o = Date.now();
          this.s = new De();
          this.p = t.socket;
          this.q = this.s.add(new vu(this.p));
          this.r = this.s.add(new wu(this.p));
          this.s.add(this.r.onMessage(e => this.A(e)));
          this.s.add(this.p.onClose(e => this.y.fire(e)));
          if (t.initialChunk) {
            this.r.acceptChunk(t.initialChunk);
          }
          if (this.u) {
            this.m = setInterval(() => {
              this.E();
            }, 5000);
          } else {
            this.m = null;
          }
        }
        dispose() {
          if (this.g) {
            clearTimeout(this.g);
            this.g = null;
          }
          if (this.l) {
            clearTimeout(this.l);
            this.l = null;
          }
          if (this.m) {
            clearInterval(this.m);
            this.m = null;
          }
          this.s.dispose();
        }
        drain() {
          return this.q.drain();
        }
        sendDisconnect() {
          if (!this.b) {
            this.b = true;
            const t = new Zi(5, 0, 0, Dr());
            this.q.write(t);
            this.q.flush();
          }
        }
        sendPause() {
          const t = new Zi(7, 0, 0, Dr());
          this.q.write(t);
        }
        sendResume() {
          const t = new Zi(8, 0, 0, Dr());
          this.q.write(t);
        }
        pauseSocketWriting() {
          this.q.pause();
        }
        getSocket() {
          return this.p;
        }
        getMillisSinceLastIncomingData() {
          return Date.now() - this.r.lastReadTime;
        }
        beginAcceptReconnection(t, e) {
          this.a = true;
          this.s.dispose();
          this.s = new De();
          this.v.flushBuffer();
          this.y.flushBuffer();
          this.z.flushBuffer();
          this.p.dispose();
          this.n = 0;
          this.o = Date.now();
          this.p = t;
          this.q = this.s.add(new vu(this.p));
          this.r = this.s.add(new wu(this.p));
          this.s.add(this.r.onMessage(i => this.A(i)));
          this.s.add(this.p.onClose(i => this.y.fire(i)));
          this.r.acceptChunk(e);
        }
        endAcceptReconnection() {
          this.a = false;
          this.j = this.h;
          const t = new Zi(3, 0, this.j, Dr());
          this.q.write(t);
          const e = this.c.toArray();
          for (let i = 0, s = e.length; i < s; i++) {
            this.q.write(e[i]);
          }
          this.C();
        }
        acceptDisconnect() {
          this.x.fire();
        }
        A(t) {
          if (t.ack > this.f) {
            this.f = t.ack;
            do {
              const e = this.c.peek();
              if (e && e.id <= t.ack) {
                this.c.pop();
              } else {
                break;
              }
            } while (true);
          }
          switch (t.type) {
            case 0:
              break;
            case 1:
              {
                if (t.id > this.h) {
                  if (t.id !== this.h + 1) {
                    const e = Date.now();
                    if (e - this.n > 10000) {
                      this.n = e;
                      this.q.write(new Zi(6, 0, 0, Dr()));
                    }
                  } else {
                    this.h = t.id;
                    this.k = Date.now();
                    this.B();
                    this.w.fire(t.data);
                  }
                }
                break;
              }
            case 2:
              {
                this.v.fire(t.data);
                break;
              }
            case 3:
              break;
            case 5:
              {
                this.x.fire();
                break;
              }
            case 6:
              {
                const e = this.c.toArray();
                for (let i = 0, s = e.length; i < s; i++) {
                  this.q.write(e[i]);
                }
                this.C();
                break;
              }
            case 7:
              {
                this.q.pause();
                break;
              }
            case 8:
              {
                this.q.resume();
                break;
              }
            case 9:
              break;
          }
        }
        readEntireBuffer() {
          return this.r.readEntireBuffer();
        }
        flush() {
          this.q.flush();
        }
        send(t) {
          const e = ++this.d;
          this.j = this.h;
          const i = new Zi(1, e, this.j, t);
          this.c.push(i);
          if (!this.a) {
            this.q.write(i);
            this.C();
          }
        }
        sendControl(t) {
          const e = new Zi(2, 0, 0, t);
          this.q.write(e);
        }
        B() {
          if (this.h <= this.j || this.l) {
            return;
          }
          const t = Date.now() - this.k;
          if (t >= 2000) {
            this.D();
            return;
          }
          this.l = setTimeout(() => {
            this.l = null;
            this.B();
          }, 2000 - t + 5);
        }
        C() {
          if (this.d <= this.f || this.g || this.a) {
            return;
          }
          const t = this.c.peek();
          const e = Date.now() - t.writtenTime;
          const i = Date.now() - this.r.lastReadTime;
          const s = Date.now() - this.o;
          if (e >= 20000 && i >= 20000 && s >= 20000 && !this.t.hasHighLoad()) {
            this.o = Date.now();
            this.z.fire({
              unacknowledgedMsgCount: this.c.length(),
              timeSinceOldestUnacknowledgedMsg: e,
              timeSinceLastReceivedSomeData: i
            });
            return;
          }
          const r = Math.max(20000 - e, 20000 - i, 20000 - s, 500);
          this.g = setTimeout(() => {
            this.g = null;
            this.C();
          }, r);
        }
        D() {
          if (this.h <= this.j) {
            return;
          }
          this.j = this.h;
          const t = new Zi(3, 0, this.j, Dr());
          this.q.write(t);
        }
        E() {
          this.j = this.h;
          const t = new Zi(9, 0, this.j, Dr());
          this.q.write(t);
        }
      };
    }
  });
  import { createHash as Gk } from "crypto";
  import { createServer as Jk, createConnection as Kk } from "net";
  import "os";
  import "zlib";
  function Zk(t, e, i) {
    const r = Gk("sha256").update(t).digest("hex").substr(0, 8);
    if (process.platform === "win32") {
      return `\\\\.\\pipe\\${r}-${i}-${e}-sock`;
    }
    const n = i.substr(0, 4);
    const o = e.substr(0, 6);
    let a;
    if (process.platform !== "darwin" && bu && !process.env.VSCODE_PORTABLE) {
      a = F(bu, `vscode-${r}-${n}-${o}.sock`);
    } else {
      a = F(t, `${n}-${o}.sock`);
    }
    Yk(a);
    return a;
  }
  function Yk(t) {
    const e = Ob[Ea];
    if (typeof e == "number" && t.length >= e) {
      console.warn(`WARNING: IPC handle "${t}" is longer than ${e} chars, try a shorter --user-data-dir`);
    }
  }
  function Xk(t) {
    return new Promise((e, i) => {
      const s = Jk();
      s.on("error", i);
      s.listen(t, () => {
        s.removeListener("error", i);
        e(new Lb(s));
      });
    });
  }
  function Qk(t, e) {
    return new Promise((i, s) => {
      const r = Kk(t, () => {
        r.removeListener("error", s);
        i(xb.fromSocket(new Qa(r, `ipc-client${e}`), e));
      });
      r.once("error", s);
    });
  }
  var Cb;
  var Qa;
  var _b;
  var Rb;
  var bu;
  var Ob;
  var Lb;
  var Vp = g({
    "out-build/vs/base/parts/ipc/node/ipc.net.js"() {
      "use strict";
  
      Ze();
      $e();
      B();
      M();
      we();
      H();
      _i();
      xs();
      Ab();
      Cb = 30000;
      Qa = class {
        traceSocketEvent(t, e) {
          zp.traceSocketEvent(this.socket, this.debugLabel, t, e);
        }
        constructor(t, e = "") {
          this.f = true;
          this.debugLabel = e;
          this.socket = t;
          this.traceSocketEvent("created", {
            type: "NodeSocket"
          });
          this.a = s => {
            this.traceSocketEvent("error", {
              code: s?.code,
              message: s?.message
            });
            if (s) {
              if (s.code === "EPIPE") {
                return;
              }
              Ft(s);
            }
          };
          this.socket.on("error", this.a);
          let i;
          this.b = s => {
            this.traceSocketEvent("close", {
              hadError: s
            });
            this.f = false;
            if (i) {
              clearTimeout(i);
            }
          };
          this.socket.on("close", this.b);
          this.d = () => {
            this.traceSocketEvent("nodeEndReceived");
            this.f = false;
            i = setTimeout(() => t.destroy(), Cb);
          };
          this.socket.on("end", this.d);
        }
        dispose() {
          this.socket.off("error", this.a);
          this.socket.off("close", this.b);
          this.socket.off("end", this.d);
          this.socket.destroy();
        }
        onData(t) {
          const e = i => {
            this.traceSocketEvent("read", i);
            t(z.wrap(i));
          };
          this.socket.on("data", e);
          return {
            dispose: () => this.socket.off("data", e)
          };
        }
        onClose(t) {
          const e = i => {
            t({
              type: 0,
              hadError: i,
              error: undefined
            });
          };
          this.socket.on("close", e);
          return {
            dispose: () => this.socket.off("close", e)
          };
        }
        onEnd(t) {
          const e = () => {
            t();
          };
          this.socket.on("end", e);
          return {
            dispose: () => this.socket.off("end", e)
          };
        }
        write(t) {
          if (!this.socket.destroyed && !!this.f) {
            try {
              this.traceSocketEvent("write", t);
              this.socket.write(t.buffer, e => {
                if (e) {
                  if (e.code === "EPIPE") {
                    return;
                  }
                  Ft(e);
                }
              });
            } catch (e) {
              if (e.code === "EPIPE") {
                return;
              }
              Ft(e);
            }
          }
        }
        end() {
          this.traceSocketEvent("nodeEndSent");
          this.socket.end();
        }
        drain() {
          this.traceSocketEvent("nodeDrainBegin");
          return new Promise((t, e) => {
            if (this.socket.bufferSize === 0) {
              this.traceSocketEvent("nodeDrainEnd");
              t();
              return;
            }
            const i = () => {
              this.socket.off("close", i);
              this.socket.off("end", i);
              this.socket.off("error", i);
              this.socket.off("timeout", i);
              this.socket.off("drain", i);
              this.traceSocketEvent("nodeDrainEnd");
              t();
            };
            this.socket.on("close", i);
            this.socket.on("end", i);
            this.socket.on("error", i);
            this.socket.on("timeout", i);
            this.socket.on("drain", i);
          });
        }
      };
      (function (t) {
        t[t.MinHeaderByteSize = 2] = "MinHeaderByteSize";
        t[t.MaxWebSocketMessageLength = 262144] = "MaxWebSocketMessageLength";
      })(_b ||= {});
      (function (t) {
        t[t.PeekHeader = 1] = "PeekHeader";
        t[t.ReadHeader = 2] = "ReadHeader";
        t[t.ReadBody = 3] = "ReadBody";
        t[t.Fin = 4] = "Fin";
      })(Rb ||= {});
      bu = process.env.XDG_RUNTIME_DIR;
      Ob = {
        2: 107,
        1: 103
      };
      Lb = class T3 extends Bp {
        static b(e) {
          const i = x.fromNodeEventEmitter(e, "connection");
          return x.map(i, s => ({
            protocol: new Hp(new Qa(s, "ipc-server-connection")),
            onDidClientDisconnect: x.once(x.fromNodeEventEmitter(s, "close"))
          }));
        }
        constructor(e) {
          super(T3.b(e));
          this.d = e;
        }
        dispose() {
          super.dispose();
          if (this.d) {
            this.d.close();
            this.d = null;
          }
        }
      };
    }
  });
  import ec from "electron";
  var Mb;
  var it;
  var as = g({
    "out-build/vs/base/parts/ipc/electron-main/ipcMain.js"() {
      "use strict";
  
      $e();
      Ie();
      Mb = class {
        constructor() {
          this.a = new WeakMap();
        }
        on(t, e) {
          const i = (s, ...r) => {
            if (this.b(t, s)) {
              e(s, ...r);
            }
          };
          this.a.set(e, i);
          ec.ipcMain.on(t, i);
          return this;
        }
        once(t, e) {
          ec.ipcMain.once(t, (i, ...s) => {
            if (this.b(t, i)) {
              e(i, ...s);
            }
          });
          return this;
        }
        handle(t, e) {
          ec.ipcMain.handle(t, (i, ...s) => this.b(t, i) ? e(i, ...s) : Promise.reject(`Invalid channel '${t}' or sender for ipcMain.handle() usage.`));
          return this;
        }
        removeHandler(t) {
          ec.ipcMain.removeHandler(t);
          return this;
        }
        removeListener(t, e) {
          const i = this.a.get(e);
          if (i) {
            ec.ipcMain.removeListener(t, i);
            this.a.delete(e);
          }
          return this;
        }
        b(t, e) {
          if (!t || !t.startsWith("vscode:") && !t.startsWith("cursor:")) {
            Ft(`Refused to handle ipcMain event for channel '${t}' because the channel is unknown.`);
            return false;
          }
          const i = e.senderFrame;
          const s = i?.url;
          if (!s || s === "about:blank") {
            return true;
          }
          let r = "unknown";
          try {
            r = new URL(s).host;
          } catch {
            Ft(`Refused to handle ipcMain event for channel '${t}' because of a malformed URL '${s}'.`);
            return false;
          }
          if (r !== za) {
            Ft(`Refused to handle ipcMain event for channel '${t}' because of a bad origin of '${r}'.`);
            return false;
          } else if (i?.parent !== null) {
            Ft(`Refused to handle ipcMain event for channel '${t}' because sender of origin '${r}' is not a main frame.`);
            return false;
          } else {
            return true;
          }
        }
      };
      it = new Mb();
    }
  });
  var Fb;
  var Nb;
  var ex = g({
    "out-build/vs/base/parts/contextmenu/common/contextmenu.js"() {
      "use strict";
  
      Fb = "vscode:contextmenu";
      Nb = "vscode:onCloseContextMenu";
    }
  });
  import { Menu as tx, MenuItem as Gp, BrowserWindow as ix } from "electron";
  function sx() {
    it.on(Fb, (t, e, i, s, r) => {
      const n = Wb(t, s, i);
      let o = r ? r.x : undefined;
      let a = r ? r.y : undefined;
      if (typeof o == "number" && typeof a == "number") {
        try {
          const c = ix.fromWebContents(t.sender);
          if (c && c.contentView?.children) {
            for (const l of c.contentView.children) {
              if (l?.webContents?.id === t.sender.id && typeof l.getBounds == "function") {
                const u = l.getBounds();
                o += u.x;
                a += u.y;
                break;
              }
            }
          }
        } catch {}
      }
      n.popup({
        x: o,
        y: a,
        positioningItem: r ? r.positioningItem : undefined,
        callback: () => {
          if (n) {
            t.sender.send(Nb, e);
          }
        }
      });
    });
  }
  function Wb(t, e, i) {
    const s = new tx();
    i.forEach(r => {
      let n;
      if (r.type === "separator") {
        n = new Gp({
          type: r.type
        });
      } else if (Array.isArray(r.submenu)) {
        n = new Gp({
          submenu: Wb(t, e, r.submenu),
          label: r.label
        });
      } else {
        n = new Gp({
          label: r.label,
          type: r.type,
          accelerator: r.accelerator,
          checked: r.checked,
          enabled: r.enabled,
          visible: r.visible,
          click: (o, a, c) => t.sender.send(e, r.id, c)
        });
      }
      s.append(n);
    });
    return s;
  }
  var rx = g({
    "out-build/vs/base/parts/contextmenu/electron-main/contextmenu.js"() {
      "use strict";
  
      as();
      ex();
    }
  });
  var Tb;
  var nx = g({
    "out-build/vs/base/parts/ipc/common/ipc.electron.js"() {
      "use strict";
  
      Tb = class {
        constructor(t, e) {
          this.a = t;
          this.onMessage = e;
        }
        send(t) {
          try {
            this.a.send("vscode:message", t.buffer);
          } catch {}
        }
        disconnect() {
          this.a.send("vscode:disconnect", null);
        }
      };
    }
  });
  function jb(t, e) {
    const i = x.fromNodeEventEmitter(it, e, (r, n) => ({
      event: r,
      message: n
    }));
    const s = x.filter(i, ({
      event: r
    }) => r.sender.id === t);
    return x.map(s, ({
      message: r
    }) => r && z.wrap(r));
  }
  var Ub;
  var ox = g({
    "out-build/vs/base/parts/ipc/electron-main/ipc.electron.js"() {
      "use strict";
  
      as();
      Ze();
      B();
      M();
      xs();
      nx();
      Ub = class kf extends Bp {
        static {
          this.b = new Map();
        }
        static d() {
          const e = x.fromNodeEventEmitter(it, "vscode:hello", ({
            sender: i
          }) => i);
          return x.map(e, i => {
            const s = i.id;
            kf.b.get(s)?.dispose();
            const n = new $();
            kf.b.set(s, xe(() => n.fire()));
            const o = jb(s, "vscode:message");
            const a = x.any(x.signal(jb(s, "vscode:disconnect")), n.event);
            return {
              protocol: new Tb(i, o),
              onDidClientDisconnect: a
            };
          });
        }
        constructor() {
          super(kf.d());
        }
      };
    }
  });
  var Bb;
  var qb;
  var ax = g({
    "out-build/vs/base/parts/ipc/common/ipc.mp.js"() {
      "use strict";
  
      Ze();
      B();
      xs();
      Bb = class {
        constructor(t) {
          this.a = t;
          this.onMessage = x.fromDOMEventEmitter(this.a, "message", e => e.data ? z.wrap(e.data) : z.alloc(0));
          t.start();
        }
        send(t) {
          this.a.postMessage(t.buffer);
        }
        disconnect() {
          this.a.close();
        }
      };
      qb = class extends qp {
        constructor(t, e) {
          const i = new Bb(t);
          super(i, e);
          this.b = i;
        }
        dispose() {
          this.b.disconnect();
          super.dispose();
        }
      };
    }
  });
  var Jp;
  var zb = g({
    "out-build/vs/base/parts/ipc/electron-main/ipc.mp.js"() {
      "use strict";
  
      as();
      B();
      _i();
      ax();
      Jp = class extends qb {
        constructor(t, e) {
          super({
            addEventListener: (i, s) => t.addListener(i, s),
            removeEventListener: (i, s) => t.removeListener(i, s),
            postMessage: i => t.postMessage(i),
            start: () => t.start(),
            close: () => t.close()
          }, e);
        }
      };
    }
  });
  function Ds(t) {
    return Kp(t, 0);
  }
  function Kp(t, e) {
    switch (typeof t) {
      case "object":
        if (t === null) {
          return Qs(349, e);
        } else if (Array.isArray(t)) {
          return lx(t, e);
        } else {
          return ux(t, e);
        }
      case "string":
        return Hb(t, e);
      case "boolean":
        return cx(t, e);
      case "number":
        return Qs(t, e);
      case "undefined":
        return Qs(937, e);
      default:
        return Qs(617, e);
    }
  }
  function Qs(t, e) {
    return (e << 5) - e + t | 0;
  }
  function cx(t, e) {
    return Qs(t ? 433 : 863, e);
  }
  function Hb(t, e) {
    e = Qs(149417, e);
    for (let i = 0, s = t.length; i < s; i++) {
      e = Qs(t.charCodeAt(i), e);
    }
    return e;
  }
  function lx(t, e) {
    e = Qs(104579, e);
    return t.reduce((i, s) => Kp(s, i), e);
  }
  function ux(t, e) {
    e = Qs(181387, e);
    return Object.keys(t).sort().reduce((i, s) => {
      i = Hb(s, i);
      return Kp(t[s], i);
    }, e);
  }
  function Zp(t, e, i = 32) {
    const s = i - e;
    const r = ~((1 << s) - 1);
    return (t << e | (r & t) >>> s) >>> 0;
  }
  function tc(t, e = 32) {
    if (t instanceof ArrayBuffer) {
      return Array.from(new Uint8Array(t)).map(i => i.toString(16).padStart(2, "0")).join("");
    } else {
      return (t >>> 0).toString(16).padStart(e / 4, "0");
    }
  }
  var Vb;
  var hx;
  var er = g({
    "out-build/vs/base/common/hash.js"() {
      "use strict";
  
      Ze();
      Wt();
      (function (t) {
        t[t.BLOCK_SIZE = 64] = "BLOCK_SIZE";
        t[t.UNICODE_REPLACEMENT = 65533] = "UNICODE_REPLACEMENT";
      })(Vb ||= {});
      hx = class j3 {
        static {
          this.g = new DataView(new ArrayBuffer(320));
        }
        constructor() {
          this.h = 1732584193;
          this.l = 4023233417;
          this.m = 2562383102;
          this.n = 271733878;
          this.o = 3285377520;
          this.p = new Uint8Array(67);
          this.q = new DataView(this.p.buffer);
          this.r = 0;
          this.t = 0;
          this.u = 0;
          this.v = false;
        }
        update(e) {
          const i = e.length;
          if (i === 0) {
            return;
          }
          const s = this.p;
          let r = this.r;
          let n = this.u;
          let o;
          let a;
          for (n !== 0 ? (o = n, a = -1, n = 0) : (o = e.charCodeAt(0), a = 0);;) {
            let c = o;
            if (ME(o)) {
              if (a + 1 < i) {
                const l = e.charCodeAt(a + 1);
                if (vv(l)) {
                  a++;
                  c = FE(o, l);
                } else {
                  c = 65533;
                }
              } else {
                n = o;
                break;
              }
            } else if (vv(o)) {
              c = 65533;
            }
            r = this.w(s, r, c);
            a++;
            if (a < i) {
              o = e.charCodeAt(a);
            } else {
              break;
            }
          }
          this.r = r;
          this.u = n;
        }
        w(e, i, s) {
          if (s < 128) {
            e[i++] = s;
          } else if (s < 2048) {
            e[i++] = (s & 1984) >>> 6 | 192;
            e[i++] = (s & 63) >>> 0 | 128;
          } else if (s < 65536) {
            e[i++] = (s & 61440) >>> 12 | 224;
            e[i++] = (s & 4032) >>> 6 | 128;
            e[i++] = (s & 63) >>> 0 | 128;
          } else {
            e[i++] = (s & 1835008) >>> 18 | 240;
            e[i++] = (s & 258048) >>> 12 | 128;
            e[i++] = (s & 4032) >>> 6 | 128;
            e[i++] = (s & 63) >>> 0 | 128;
          }
          if (i >= 64) {
            this.y();
            i -= 64;
            this.t += 64;
            e[0] = e[64];
            e[1] = e[65];
            e[2] = e[66];
          }
          return i;
        }
        digest() {
          if (!this.v) {
            this.v = true;
            if (this.u) {
              this.u = 0;
              this.r = this.w(this.p, this.r, 65533);
            }
            this.t += this.r;
            this.x();
          }
          return tc(this.h) + tc(this.l) + tc(this.m) + tc(this.n) + tc(this.o);
        }
        x() {
          this.p[this.r++] = 128;
          this.p.subarray(this.r).fill(0);
          if (this.r > 56) {
            this.y();
            this.p.fill(0);
          }
          const e = this.t * 8;
          this.q.setUint32(56, Math.floor(e / 4294967296), false);
          this.q.setUint32(60, e % 4294967296, false);
          this.y();
        }
        y() {
          const e = j3.g;
          const i = this.q;
          for (let d = 0; d < 64; d += 4) {
            e.setUint32(d, i.getUint32(d, false), false);
          }
          for (let d = 64; d < 320; d += 4) {
            e.setUint32(d, Zp(e.getUint32(d - 12, false) ^ e.getUint32(d - 32, false) ^ e.getUint32(d - 56, false) ^ e.getUint32(d - 64, false), 1), false);
          }
          let s = this.h;
          let r = this.l;
          let n = this.m;
          let o = this.n;
          let a = this.o;
          let c;
          let l;
          let u;
          for (let d = 0; d < 80; d++) {
            if (d < 20) {
              c = r & n | ~r & o;
              l = 1518500249;
            } else if (d < 40) {
              c = r ^ n ^ o;
              l = 1859775393;
            } else if (d < 60) {
              c = r & n | r & o | n & o;
              l = 2400959708;
            } else {
              c = r ^ n ^ o;
              l = 3395469782;
            }
            u = Zp(s, 5) + c + a + l + e.getUint32(d * 4, false) & -1;
            a = o;
            o = n;
            n = Zp(r, 30);
            r = s;
            s = u;
          }
          this.h = this.h + s & -1;
          this.l = this.l + r & -1;
          this.m = this.m + n & -1;
          this.n = this.n + o & -1;
          this.o = this.o + a & -1;
        }
      };
    }
  });
  var dx;
  var yu;
  var Gb;
  var Jb;
  var Kb = g({
    "out-build/vs/platform/encryption/common/encryptionService.js"() {
      "use strict";
  
      Y();
      dx = q("encryptionService");
      yu = q("encryptionMainService");
      (function (t) {
        t.kwallet = "kwallet";
        t.kwallet5 = "kwallet5";
        t.gnomeLibsecret = "gnome-libsecret";
        t.basic = "basic";
      })(Gb ||= {});
      (function (t) {
        t.unknown = "unknown";
        t.basicText = "basic_text";
        t.gnomeAny = "gnome_any";
        t.gnomeLibsecret = "gnome_libsecret";
        t.gnomeKeyring = "gnome_keyring";
        t.kwallet = "kwallet";
        t.kwallet5 = "kwallet5";
        t.kwallet6 = "kwallet6";
        t.dplib = "dpapi";
        t.keychainAccess = "keychain_access";
      })(Jb ||= {});
    }
  });
  var Yi;
  var tr;
  var Ri = g({
    "out-build/vs/platform/environment/common/environment.js"() {
      "use strict";
  
      Y();
      Yi = q("environmentService");
      tr = Yi;
    }
  });
  function fx(t) {
    return t.getFullYear() + "-" + String(t.getMonth() + 1).padStart(2, "0") + "-" + String(t.getDate()).padStart(2, "0") + "T" + String(t.getHours()).padStart(2, "0") + ":" + String(t.getMinutes()).padStart(2, "0") + ":" + String(t.getSeconds()).padStart(2, "0") + "." + (t.getMilliseconds() / 1000).toFixed(3).slice(2, 5) + "Z";
  }
  var Zb;
  var Yb;
  var Su;
  var px;
  var gx;
  var mx;
  var wx = g({
    "out-build/vs/base/common/date.js"() {
      "use strict";
  
      be();
      H();
      Zb = 60;
      Yb = Zb * 60;
      Su = Yb * 24;
      px = Su * 7;
      gx = Su * 30;
      mx = Su * 365;
    }
  });
  function vx(t, e) {
    return Yp(t["inspect-extensions"], t["inspect-brk-extensions"], 5870, e, t.debugId, t.extensionEnvironment);
  }
  function Yp(t, e, i, s, r, n) {
    const a = Number(e || t) || (s ? null : i);
    const c = a ? !!e : false;
    let l;
    if (n) {
      try {
        l = JSON.parse(n);
      } catch {}
    }
    return {
      port: a,
      break: c,
      debugId: r,
      env: l
    };
  }
  var Xp;
  var Me;
  var bx = g({
    "out-build/vs/platform/environment/common/environmentService.js"() {
      "use strict";
  
      wx();
      sn();
      Ie();
      we();
      ys();
      nt();
      se();
      Xp = /^([^.]+\..+)[:=](.+)$/;
      Me = class {
        get appRoot() {
          return Xe(Ct.asFileUri("").fsPath);
        }
        get userHome() {
          return P.file(this.b.homeDir);
        }
        get userDataPath() {
          return this.b.userDataDir;
        }
        get appSettingsHome() {
          return P.file(F(this.userDataPath, "User"));
        }
        get tmpDir() {
          return P.file(this.b.tmpDir);
        }
        get cacheHome() {
          return P.file(this.userDataPath);
        }
        get stateResource() {
          return he(this.appSettingsHome, "globalStorage", "storage.json");
        }
        get userRoamingDataHome() {
          return this.appSettingsHome.with({
            scheme: R.vscodeUserData
          });
        }
        get userDataSyncHome() {
          return he(this.appSettingsHome, "sync");
        }
        get logsHome() {
          if (!this.args.logsPath) {
            const t = fx(new Date()).replace(/-|:|\.\d+Z$/g, "");
            this.args.logsPath = F(this.userDataPath, "logs", t);
          }
          return P.file(this.args.logsPath);
        }
        get sync() {
          return this.args.sync;
        }
        get machineSettingsResource() {
          return he(P.file(F(this.userDataPath, "Machine")), "settings.json");
        }
        get workspaceStorageHome() {
          return he(this.appSettingsHome, "workspaceStorage");
        }
        get localHistoryHome() {
          return he(this.appSettingsHome, "History");
        }
        get keyboardLayoutResource() {
          return he(this.userRoamingDataHome, "keyboardLayout.json");
        }
        get argvResource() {
          const t = Ii.VSCODE_PORTABLE;
          if (t) {
            return P.file(F(t, "argv.json"));
          } else {
            return he(this.userHome, this.c.dataFolderName, "argv.json");
          }
        }
        get isExtensionDevelopment() {
          return !!this.args.extensionDevelopmentPath;
        }
        get untitledWorkspacesHome() {
          return P.file(F(this.userDataPath, "Workspaces"));
        }
        get builtinExtensionsPath() {
          const t = this.args["builtin-extensions-dir"];
          if (t) {
            return Gi(t);
          } else {
            return pi(F(Ct.asFileUri("").fsPath, "..", "extensions"));
          }
        }
        get extensionsDownloadLocation() {
          const t = this.args["extensions-download-dir"];
          if (t) {
            return P.file(Gi(t));
          } else {
            return P.file(F(this.userDataPath, "CachedExtensionVSIXs"));
          }
        }
        get extensionsPath() {
          const t = this.args["extensions-dir"];
          if (t) {
            return Gi(t);
          }
          const e = Ii.VSCODE_EXTENSIONS;
          if (e) {
            return e;
          }
          const i = Ii.VSCODE_PORTABLE;
          if (i) {
            return F(i, "extensions");
          } else {
            return he(this.userHome, this.c.dataFolderName, "extensions").fsPath;
          }
        }
        get extensionDevelopmentLocationURI() {
          const t = this.args.extensionDevelopmentPath;
          if (Array.isArray(t)) {
            return t.map(e => /^[^:/?#]+?:\/\//.test(e) ? P.parse(e) : P.file(pi(e)));
          }
        }
        get extensionDevelopmentKind() {
          return this.args.extensionDevelopmentKind?.map(t => t === "ui" || t === "workspace" || t === "web" ? t : "workspace");
        }
        get extensionTestsLocationURI() {
          const t = this.args.extensionTestsPath;
          if (t) {
            if (/^[^:/?#]+?:\/\//.test(t)) {
              return P.parse(t);
            } else {
              return P.file(pi(t));
            }
          }
        }
        get disableExtensions() {
          if (this.args["disable-extensions"]) {
            return true;
          }
          const t = this.args["disable-extension"];
          if (t) {
            if (typeof t == "string") {
              return [t];
            }
            if (Array.isArray(t) && t.length > 0) {
              return t;
            }
          }
          return false;
        }
        get debugExtensionHost() {
          return vx(this.args, this.isBuilt);
        }
        get debugRenderer() {
          return !!this.args.debugRenderer;
        }
        get isBuilt() {
          return !Ii.VSCODE_DEV;
        }
        get verbose() {
          return !!this.args.verbose;
        }
        get logLevel() {
          return this.args.log?.find(t => !Xp.test(t));
        }
        get extensionLogLevel() {
          const t = [];
          for (const e of this.args.log || []) {
            const i = Xp.exec(e);
            if (i && i[1] && i[2]) {
              t.push([i[1], i[2]]);
            }
          }
          if (t.length) {
            return t;
          } else {
            return undefined;
          }
        }
        get serviceMachineIdResource() {
          return he(P.file(this.userDataPath), "machineid");
        }
        get crashReporterId() {
          return this.args["crash-reporter-id"];
        }
        get crashReporterDirectory() {
          return this.args["crash-reporter-directory"];
        }
        get disableTelemetry() {
          return !!this.args["disable-telemetry"];
        }
        get disableWorkspaceTrust() {
          return !!this.args["disable-workspace-trust"];
        }
        get useInMemorySecretStorage() {
          return !!this.args["use-inmemory-secretstorage"];
        }
        get policyFile() {
          if (this.args["__enable-file-policy"]) {
            const t = Ii.VSCODE_PORTABLE;
            if (t) {
              return P.file(F(t, "policy.json"));
            } else {
              return he(this.userHome, this.c.dataFolderName, "policy.json");
            }
          }
        }
        get editSessionId() {
          return this.args.editSessionId;
        }
        get continueOn() {
          return this.args.continueOn;
        }
        set continueOn(t) {
          this.args.continueOn = t;
        }
        get args() {
          return this.a;
        }
        constructor(t, e, i) {
          this.a = t;
          this.b = e;
          this.c = i;
        }
      };
      __decorate([de], Me.prototype, "appRoot", null);
      __decorate([de], Me.prototype, "userHome", null);
      __decorate([de], Me.prototype, "userDataPath", null);
      __decorate([de], Me.prototype, "appSettingsHome", null);
      __decorate([de], Me.prototype, "tmpDir", null);
      __decorate([de], Me.prototype, "cacheHome", null);
      __decorate([de], Me.prototype, "stateResource", null);
      __decorate([de], Me.prototype, "userRoamingDataHome", null);
      __decorate([de], Me.prototype, "userDataSyncHome", null);
      __decorate([de], Me.prototype, "sync", null);
      __decorate([de], Me.prototype, "machineSettingsResource", null);
      __decorate([de], Me.prototype, "workspaceStorageHome", null);
      __decorate([de], Me.prototype, "localHistoryHome", null);
      __decorate([de], Me.prototype, "keyboardLayoutResource", null);
      __decorate([de], Me.prototype, "argvResource", null);
      __decorate([de], Me.prototype, "isExtensionDevelopment", null);
      __decorate([de], Me.prototype, "untitledWorkspacesHome", null);
      __decorate([de], Me.prototype, "builtinExtensionsPath", null);
      __decorate([de], Me.prototype, "extensionsPath", null);
      __decorate([de], Me.prototype, "extensionDevelopmentLocationURI", null);
      __decorate([de], Me.prototype, "extensionDevelopmentKind", null);
      __decorate([de], Me.prototype, "extensionTestsLocationURI", null);
      __decorate([de], Me.prototype, "debugExtensionHost", null);
      __decorate([de], Me.prototype, "logLevel", null);
      __decorate([de], Me.prototype, "extensionLogLevel", null);
      __decorate([de], Me.prototype, "serviceMachineIdResource", null);
      __decorate([de], Me.prototype, "disableTelemetry", null);
      __decorate([de], Me.prototype, "disableWorkspaceTrust", null);
      __decorate([de], Me.prototype, "useInMemorySecretStorage", null);
      __decorate([de], Me.prototype, "policyFile", null);
    }
  });
  import { homedir as yx, tmpdir as Sx } from "os";
  function Ex(t, e) {
    return Yp(t["inspect-ptyhost"], t["inspect-brk-ptyhost"], 5877, e, t.extensionEnvironment);
  }
  function kx(t, e) {
    return Yp(t["inspect-sharedprocess"], t["inspect-brk-sharedprocess"], 5879, e, t.extensionEnvironment);
  }
  var Xb;
  var Qp = g({
    "out-build/vs/platform/environment/node/environmentService.js"() {
      "use strict";
  
      bx();
      j0();
      Xb = class extends Me {
        constructor(t, e) {
          super(t, {
            homeDir: yx(),
            tmpDir: Sx(),
            userDataDir: W0(t, e.nameShort)
          }, e);
        }
      };
    }
  });
  var ot;
  var ir;
  var vt = g({
    "out-build/vs/platform/environment/electron-main/environmentMainService.js"() {
      "use strict";
  
      sn();
      we();
      H();
      Vp();
      Ri();
      Qp();
      Y();
      ot = Yi;
      ir = class extends Xb {
        constructor() {
          super(...arguments);
          this.d = {};
        }
        get backupHome() {
          return F(this.userDataPath, "Backups");
        }
        get mainIPCHandle() {
          return Zk(this.userDataPath, "main", this.c.version);
        }
        get mainLockfile() {
          return F(this.userDataPath, "code.lock");
        }
        get disableUpdates() {
          return !!this.args["disable-updates"];
        }
        get crossOriginIsolated() {
          return !!this.args["enable-coi"];
        }
        get codeCachePath() {
          return process.env.VSCODE_CODE_CACHE_PATH || undefined;
        }
        get useCodeCache() {
          return !!this.codeCachePath;
        }
        unsetSnapExportedVariables() {
          if (Se) {
            for (const t in process.env) {
              if (t.endsWith("_VSCODE_SNAP_ORIG")) {
                const e = t.slice(0, -17);
                if (this.d[e]) {
                  continue;
                }
                if (process.env[e]) {
                  this.d[e] = process.env[e];
                }
                if (process.env[t]) {
                  process.env[e] = process.env[t];
                } else {
                  delete process.env[e];
                }
              }
            }
          }
        }
        restoreSnapExportedVariables() {
          if (Se) {
            for (const t in this.d) {
              process.env[t] = this.d[t];
              delete this.d[t];
            }
          }
        }
      };
      __decorate([de], ir.prototype, "backupHome", null);
      __decorate([de], ir.prototype, "mainIPCHandle", null);
      __decorate([de], ir.prototype, "mainLockfile", null);
      __decorate([de], ir.prototype, "disableUpdates", null);
      __decorate([de], ir.prototype, "crossOriginIsolated", null);
      __decorate([de], ir.prototype, "codeCachePath", null);
      __decorate([de], ir.prototype, "useCodeCache", null);
    }
  });
  function e1(...t) {
    switch (t.length) {
      case 1:
        return v(1728, null, t[0]);
      case 2:
        return v(1729, null, t[0], t[1]);
      case 3:
        return v(1730, null, t[0], t[1], t[2]);
      default:
        return;
    }
  }
  var Qb;
  var ey;
  var ty;
  var lo;
  var xx = g({
    "out-build/vs/platform/contextkey/common/scanner.js"() {
      "use strict";
  
      $e();
      be();
      (function (t) {
        t[t.LParen = 0] = "LParen";
        t[t.RParen = 1] = "RParen";
        t[t.Neg = 2] = "Neg";
        t[t.Eq = 3] = "Eq";
        t[t.NotEq = 4] = "NotEq";
        t[t.Lt = 5] = "Lt";
        t[t.LtEq = 6] = "LtEq";
        t[t.Gt = 7] = "Gt";
        t[t.GtEq = 8] = "GtEq";
        t[t.RegexOp = 9] = "RegexOp";
        t[t.RegexStr = 10] = "RegexStr";
        t[t.True = 11] = "True";
        t[t.False = 12] = "False";
        t[t.In = 13] = "In";
        t[t.Not = 14] = "Not";
        t[t.And = 15] = "And";
        t[t.Or = 16] = "Or";
        t[t.Str = 17] = "Str";
        t[t.QuotedStr = 18] = "QuotedStr";
        t[t.Error = 19] = "Error";
        t[t.EOF = 20] = "EOF";
      })(Qb ||= {});
      ey = v(1731, null);
      ty = v(1732, null);
      lo = class S0 {
        constructor() {
          this.c = "";
          this.d = 0;
          this.e = 0;
          this.f = [];
          this.g = [];
          this.m = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy;
        }
        static getLexeme(e) {
          switch (e.type) {
            case 0:
              return "(";
            case 1:
              return ")";
            case 2:
              return "!";
            case 3:
              if (e.isTripleEq) {
                return "===";
              } else {
                return "==";
              }
            case 4:
              if (e.isTripleEq) {
                return "!==";
              } else {
                return "!=";
              }
            case 5:
              return "<";
            case 6:
              return "<=";
            case 7:
              return ">=";
            case 8:
              return ">=";
            case 9:
              return "=~";
            case 10:
              return e.lexeme;
            case 11:
              return "true";
            case 12:
              return "false";
            case 13:
              return "in";
            case 14:
              return "not";
            case 15:
              return "&&";
            case 16:
              return "||";
            case 17:
              return e.lexeme;
            case 18:
              return e.lexeme;
            case 19:
              return e.lexeme;
            case 20:
              return "EOF";
            default:
              throw uw(`unhandled token type: ${JSON.stringify(e)}; have you forgotten to add a case?`);
          }
        }
        static {
          this.a = new Set(["i", "g", "s", "m", "y", "u"].map(e => e.charCodeAt(0)));
        }
        static {
          this.b = new Map([["not", 14], ["in", 13], ["false", 12], ["true", 11]]);
        }
        get errors() {
          return this.g;
        }
        reset(e) {
          this.c = e;
          this.d = 0;
          this.e = 0;
          this.f = [];
          this.g = [];
          return this;
        }
        scan() {
          while (!this.r()) {
            this.d = this.e;
            switch (this.i()) {
              case 40:
                this.k(0);
                break;
              case 41:
                this.k(1);
                break;
              case 33:
                if (this.h(61)) {
                  const i = this.h(61);
                  this.f.push({
                    type: 4,
                    offset: this.d,
                    isTripleEq: i
                  });
                } else {
                  this.k(2);
                }
                break;
              case 39:
                this.o();
                break;
              case 47:
                this.q();
                break;
              case 61:
                if (this.h(61)) {
                  const i = this.h(61);
                  this.f.push({
                    type: 3,
                    offset: this.d,
                    isTripleEq: i
                  });
                } else if (this.h(126)) {
                  this.k(9);
                } else {
                  this.l(e1("==", "=~"));
                }
                break;
              case 60:
                this.k(this.h(61) ? 6 : 5);
                break;
              case 62:
                this.k(this.h(61) ? 8 : 7);
                break;
              case 38:
                if (this.h(38)) {
                  this.k(15);
                } else {
                  this.l(e1("&&"));
                }
                break;
              case 124:
                if (this.h(124)) {
                  this.k(16);
                } else {
                  this.l(e1("||"));
                }
                break;
              case 32:
              case 13:
              case 9:
              case 10:
              case 160:
                break;
              default:
                this.n();
            }
          }
          this.d = this.e;
          this.k(20);
          return Array.from(this.f);
        }
        h(e) {
          if (this.r() || this.c.charCodeAt(this.e) !== e) {
            return false;
          } else {
            this.e++;
            return true;
          }
        }
        i() {
          return this.c.charCodeAt(this.e++);
        }
        j() {
          if (this.r()) {
            return 0;
          } else {
            return this.c.charCodeAt(this.e);
          }
        }
        k(e) {
          this.f.push({
            type: e,
            offset: this.d
          });
        }
        l(e) {
          const i = this.d;
          const s = this.c.substring(this.d, this.e);
          const r = {
            type: 19,
            offset: this.d,
            lexeme: s
          };
          this.g.push({
            offset: i,
            lexeme: s,
            additionalInfo: e
          });
          this.f.push(r);
        }
        n() {
          this.m.lastIndex = this.d;
          const e = this.m.exec(this.c);
          if (e) {
            this.e = this.d + e[0].length;
            const i = this.c.substring(this.d, this.e);
            const s = S0.b.get(i);
            if (s) {
              this.k(s);
            } else {
              this.f.push({
                type: 17,
                lexeme: i,
                offset: this.d
              });
            }
          }
        }
        o() {
          while (this.j() !== 39 && !this.r()) {
            this.i();
          }
          if (this.r()) {
            this.l(ey);
            return;
          }
          this.i();
          this.f.push({
            type: 18,
            lexeme: this.c.substring(this.d + 1, this.e - 1),
            offset: this.d + 1
          });
        }
        q() {
          let e = this.e;
          let i = false;
          let s = false;
          while (true) {
            if (e >= this.c.length) {
              this.e = e;
              this.l(ty);
              return;
            }
            const n = this.c.charCodeAt(e);
            if (i) {
              i = false;
            } else if (n === 47 && !s) {
              e++;
              break;
            } else if (n === 91) {
              s = true;
            } else if (n === 92) {
              i = true;
            } else if (n === 93) {
              s = false;
            }
            e++;
          }
          while (e < this.c.length && S0.a.has(this.c.charCodeAt(e))) {
            e++;
          }
          this.e = e;
          const r = this.c.substring(this.d, this.e);
          this.f.push({
            type: 10,
            lexeme: r,
            offset: this.d
          });
        }
        r() {
          return this.e >= this.c.length;
        }
      };
    }
  });
  function Dx(t, e) {
    if (uo.has(t)) {
      console.warn(`A context key function with id '${t}' is already registered. Function collisions can lead to unexpected behavior.`);
      uo.delete(t);
    }
    uo.set(t, e);
    return {
      dispose: () => {
        uo.delete(t);
      }
    };
  }
  function iy(t) {
    return uo.get(t);
  }
  function ic(t, e) {
    return t.cmp(e);
  }
  function Eu(t, e) {
    if (typeof t == "string") {
      const i = parseFloat(t);
      if (!isNaN(i)) {
        t = i;
      }
    }
    if (typeof t == "string" || typeof t == "number") {
      return e(t);
    } else {
      return ii.INSTANCE;
    }
  }
  function sy(t) {
    let e = null;
    for (let i = 0, s = t.length; i < s; i++) {
      const r = t[i].substituteConstants();
      if (t[i] !== r && e === null) {
        e = [];
        for (let n = 0; n < i; n++) {
          e[n] = t[n];
        }
      }
      if (e !== null) {
        e[i] = r;
      }
    }
    if (e === null) {
      return t;
    } else {
      return e;
    }
  }
  function t1(t, e) {
    if (t < e) {
      return -1;
    } else if (t > e) {
      return 1;
    } else {
      return 0;
    }
  }
  function nn(t, e, i, s) {
    if (t < i) {
      return -1;
    } else if (t > i) {
      return 1;
    } else if (e < s) {
      return -1;
    } else if (e > s) {
      return 1;
    } else {
      return 0;
    }
  }
  function ry(t) {
    if (t.type === 9) {
      return t.expr;
    } else {
      return [t];
    }
  }
  var kt;
  var uo;
  var ny;
  var oy;
  var ay;
  var cy;
  var ly;
  var uy;
  var i1;
  var hy;
  var dy;
  var fy;
  var py;
  var gy;
  var Jt;
  var ku;
  var ii;
  var vi;
  var ho;
  var xu;
  var s1;
  var r1;
  var Du;
  var fo;
  var Pu;
  var $u;
  var Iu;
  var Au;
  var Cu;
  var my;
  var n1;
  var _u;
  var o1;
  var Px;
  var wy = g({
    "out-build/vs/platform/contextkey/common/contextkey.js"() {
      "use strict";
  
      H();
      Wt();
      xx();
      Y();
      be();
      $e();
      kt = new Map();
      kt.set("false", false);
      kt.set("true", true);
      kt.set("isMac", N);
      kt.set("isLinux", Se);
      kt.set("isWindows", j);
      kt.set("isWeb", fr);
      kt.set("isMacNative", N && !fr);
      kt.set("isEdge", cw);
      kt.set("isFirefox", ow);
      kt.set("isChrome", Zf);
      kt.set("isSafari", aw);
      uo = new Map();
      ny = Object.prototype.hasOwnProperty;
      (function (t) {
        t[t.False = 0] = "False";
        t[t.True = 1] = "True";
        t[t.Defined = 2] = "Defined";
        t[t.Not = 3] = "Not";
        t[t.Equals = 4] = "Equals";
        t[t.NotEquals = 5] = "NotEquals";
        t[t.And = 6] = "And";
        t[t.Regex = 7] = "Regex";
        t[t.NotRegex = 8] = "NotRegex";
        t[t.Or = 9] = "Or";
        t[t.In = 10] = "In";
        t[t.NotIn = 11] = "NotIn";
        t[t.Greater = 12] = "Greater";
        t[t.GreaterEquals = 13] = "GreaterEquals";
        t[t.Smaller = 14] = "Smaller";
        t[t.SmallerEquals = 15] = "SmallerEquals";
        t[t.Function = 16] = "Function";
      })(oy ||= {});
      ay = {
        regexParsingWithErrorRecovery: true
      };
      cy = v(1708, null);
      ly = v(1709, null);
      uy = v(1710, null);
      i1 = v(1711, null);
      hy = v(1712, null);
      dy = v(1713, null);
      fy = v(1714, null);
      py = v(1715, null);
      gy = class xl {
        static {
          this.c = new Error();
        }
        get lexingErrors() {
          return this.d.errors;
        }
        get parsingErrors() {
          return this.h;
        }
        constructor(e = ay) {
          this.k = e;
          this.d = new lo();
          this.f = [];
          this.g = 0;
          this.h = [];
          this.v = /g|y/g;
        }
        parse(e) {
          if (e === "") {
            this.h.push({
              message: cy,
              offset: 0,
              lexeme: "",
              additionalInfo: ly
            });
            return;
          }
          this.f = this.d.reset(e).scan();
          this.g = 0;
          this.h = [];
          try {
            const i = this.l();
            if (!this.E()) {
              const s = this.D();
              const r = s.type === 17 ? dy : undefined;
              this.h.push({
                message: hy,
                offset: s.offset,
                lexeme: lo.getLexeme(s),
                additionalInfo: r
              });
              throw xl.c;
            }
            return i;
          } catch (i) {
            if (i !== xl.c) {
              throw i;
            }
            return;
          }
        }
        l() {
          return this.m();
        }
        m() {
          const e = [this.o()];
          while (this.y(16)) {
            const i = this.o();
            e.push(i);
          }
          if (e.length === 1) {
            return e[0];
          } else {
            return Jt.or(...e);
          }
        }
        o() {
          const e = [this.s()];
          while (this.y(15)) {
            const i = this.s();
            e.push(i);
          }
          if (e.length === 1) {
            return e[0];
          } else {
            return Jt.and(...e);
          }
        }
        s() {
          if (this.y(2)) {
            const e = this.D();
            switch (e.type) {
              case 11:
                this.z();
                return ii.INSTANCE;
              case 12:
                this.z();
                return vi.INSTANCE;
              case 0:
                {
                  this.z();
                  const i = this.l();
                  this.A(1, i1);
                  return i?.negate();
                }
              case 17:
                this.z();
                return fo.create(e.lexeme);
              default:
                throw this.B("KEY | true | false | '(' expression ')'", e);
            }
          }
          return this.t();
        }
        t() {
          const e = this.D();
          switch (e.type) {
            case 11:
              this.z();
              return Jt.true();
            case 12:
              this.z();
              return Jt.false();
            case 0:
              {
                this.z();
                const i = this.l();
                this.A(1, i1);
                return i;
              }
            case 17:
              {
                if (e.lexeme.startsWith("@")) {
                  this.z();
                  const r = e.lexeme.substring(1);
                  if (r.startsWith("!")) {
                    const o = r.substring(1);
                    const a = iy(o);
                    if (a) {
                      return ku.createWithoutRegistration(r, () => !a());
                    }
                  }
                  const n = iy(r) || (() => false);
                  return ku.createWithoutRegistration(r, n);
                }
                const i = e.lexeme;
                this.z();
                if (this.y(9)) {
                  const r = this.D();
                  if (!this.k.regexParsingWithErrorRecovery) {
                    this.z();
                    if (r.type !== 10) {
                      throw this.B("REGEX", r);
                    }
                    const n = r.lexeme;
                    const o = n.lastIndexOf("/");
                    const a = o === n.length - 1 ? undefined : this.w(n.substring(o + 1));
                    let c;
                    try {
                      c = new RegExp(n.substring(1, o), a);
                    } catch {
                      throw this.B("REGEX", r);
                    }
                    return Cu.create(i, c);
                  }
                  switch (r.type) {
                    case 10:
                    case 19:
                      {
                        const n = [r.lexeme];
                        this.z();
                        let o = this.D();
                        let a = 0;
                        for (let f = 0; f < r.lexeme.length; f++) {
                          if (r.lexeme.charCodeAt(f) === 40) {
                            a++;
                          } else if (r.lexeme.charCodeAt(f) === 41) {
                            a--;
                          }
                        }
                        while (!this.E() && o.type !== 15 && o.type !== 16) {
                          switch (o.type) {
                            case 0:
                              a++;
                              break;
                            case 1:
                              a--;
                              break;
                            case 10:
                            case 18:
                              for (let f = 0; f < o.lexeme.length; f++) {
                                if (o.lexeme.charCodeAt(f) === 40) {
                                  a++;
                                } else if (r.lexeme.charCodeAt(f) === 41) {
                                  a--;
                                }
                              }
                          }
                          if (a < 0) {
                            break;
                          }
                          n.push(lo.getLexeme(o));
                          this.z();
                          o = this.D();
                        }
                        const c = n.join("");
                        const l = c.lastIndexOf("/");
                        const u = l === c.length - 1 ? undefined : this.w(c.substring(l + 1));
                        let d;
                        try {
                          d = new RegExp(c.substring(1, l), u);
                        } catch {
                          throw this.B("REGEX", r);
                        }
                        return Jt.regex(i, d);
                      }
                    case 18:
                      {
                        const n = r.lexeme;
                        this.z();
                        let o = null;
                        if (!LE(n)) {
                          const a = n.indexOf("/");
                          const c = n.lastIndexOf("/");
                          if (a !== c && a >= 0) {
                            const l = n.slice(a + 1, c);
                            const u = n[c + 1] === "i" ? "i" : "";
                            try {
                              o = new RegExp(l, u);
                            } catch {
                              throw this.B("REGEX", r);
                            }
                          }
                        }
                        if (o === null) {
                          throw this.B("REGEX", r);
                        }
                        return Cu.create(i, o);
                      }
                    default:
                      throw this.B("REGEX", this.D());
                  }
                }
                if (this.y(14)) {
                  this.A(13, uy);
                  const r = this.u();
                  return Jt.notIn(i, r);
                }
                switch (this.D().type) {
                  case 3:
                    {
                      this.z();
                      const r = this.u();
                      if (this.x().type === 18) {
                        return Jt.equals(i, r);
                      }
                      switch (r) {
                        case "true":
                          return Jt.has(i);
                        case "false":
                          return Jt.not(i);
                        default:
                          return Jt.equals(i, r);
                      }
                    }
                  case 4:
                    {
                      this.z();
                      const r = this.u();
                      if (this.x().type === 18) {
                        return Jt.notEquals(i, r);
                      }
                      switch (r) {
                        case "true":
                          return Jt.not(i);
                        case "false":
                          return Jt.has(i);
                        default:
                          return Jt.notEquals(i, r);
                      }
                    }
                  case 5:
                    this.z();
                    return Iu.create(i, this.u());
                  case 6:
                    this.z();
                    return Au.create(i, this.u());
                  case 7:
                    this.z();
                    return Pu.create(i, this.u());
                  case 8:
                    this.z();
                    return $u.create(i, this.u());
                  case 13:
                    this.z();
                    return Jt.in(i, this.u());
                  default:
                    return Jt.has(i);
                }
              }
            case 20:
              this.h.push({
                message: fy,
                offset: e.offset,
                lexeme: "",
                additionalInfo: py
              });
              throw xl.c;
            default:
              throw this.B(`true | false | KEY 
      | KEY '=~' REGEX 
      | KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this.D());
          }
        }
        u() {
          const e = this.D();
          switch (e.type) {
            case 17:
            case 18:
              this.z();
              return e.lexeme;
            case 11:
              this.z();
              return "true";
            case 12:
              this.z();
              return "false";
            case 13:
              this.z();
              return "in";
            default:
              return "";
          }
        }
        w(e) {
          return e.replaceAll(this.v, "");
        }
        x() {
          return this.f[this.g - 1];
        }
        y(e) {
          if (this.C(e)) {
            this.z();
            return true;
          } else {
            return false;
          }
        }
        z() {
          if (!this.E()) {
            this.g++;
          }
          return this.x();
        }
        A(e, i) {
          if (this.C(e)) {
            return this.z();
          }
          throw this.B(i, this.D());
        }
        B(e, i, s) {
          const r = v(1716, null, e, lo.getLexeme(i));
          const n = i.offset;
          const o = lo.getLexeme(i);
          this.h.push({
            message: r,
            offset: n,
            lexeme: o,
            additionalInfo: s
          });
          return xl.c;
        }
        C(e) {
          return this.D().type === e;
        }
        D() {
          return this.f[this.g];
        }
        E() {
          return this.D().type === 20;
        }
      };
      Jt = class {
        static false() {
          return ii.INSTANCE;
        }
        static true() {
          return vi.INSTANCE;
        }
        static has(t) {
          return ho.create(t);
        }
        static equals(t, e) {
          return xu.create(t, e);
        }
        static notEquals(t, e) {
          return Du.create(t, e);
        }
        static regex(t, e) {
          return Cu.create(t, e);
        }
        static in(t, e) {
          return s1.create(t, e);
        }
        static notIn(t, e) {
          return r1.create(t, e);
        }
        static not(t) {
          return fo.create(t);
        }
        static and(...t) {
          return n1.create(t, null, true);
        }
        static or(...t) {
          return _u.create(t, null, true);
        }
        static greater(t, e) {
          return Pu.create(t, e);
        }
        static greaterEquals(t, e) {
          return $u.create(t, e);
        }
        static smaller(t, e) {
          return Iu.create(t, e);
        }
        static smallerEquals(t, e) {
          return Au.create(t, e);
        }
        static function(t, e) {
          return ku.create(t, e);
        }
        static {
          this.c = new gy({
            regexParsingWithErrorRecovery: false
          });
        }
        static deserialize(t) {
          if (t == null) {
            return undefined;
          } else {
            return this.c.parse(t);
          }
        }
      };
      ku = class xf {
        static create(e, i) {
          Dx(e, i);
          return new xf(e, i);
        }
        static createWithoutRegistration(e, i) {
          return new xf(e, i);
        }
        constructor(e, i) {
          this.type = 16;
          this.d = e;
          this.c = i;
        }
        cmp(e) {
          if (e.type !== this.type) {
            return this.type - e.type;
          } else {
            return t1(this.d, e.d);
          }
        }
        equals(e) {
          return e.type === this.type && this.d === e.d;
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          return this.c();
        }
        serialize() {
          return `@${this.d}`;
        }
        keys() {
          return [];
        }
        map(e) {
          return this;
        }
        negate() {
          return xf.createWithoutRegistration(`!${this.d}`, () => !this.c());
        }
      };
      ii = class U3 {
        static {
          this.INSTANCE = new U3();
        }
        constructor() {
          this.type = 0;
        }
        cmp(e) {
          return this.type - e.type;
        }
        equals(e) {
          return e.type === this.type;
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          return false;
        }
        serialize() {
          return "false";
        }
        keys() {
          return [];
        }
        map(e) {
          return this;
        }
        negate() {
          return vi.INSTANCE;
        }
      };
      vi = class B3 {
        static {
          this.INSTANCE = new B3();
        }
        constructor() {
          this.type = 1;
        }
        cmp(e) {
          return this.type - e.type;
        }
        equals(e) {
          return e.type === this.type;
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          return true;
        }
        serialize() {
          return "true";
        }
        keys() {
          return [];
        }
        map(e) {
          return this;
        }
        negate() {
          return ii.INSTANCE;
        }
      };
      ho = class q3 {
        static create(e, i = null) {
          const s = kt.get(e);
          if (typeof s == "boolean") {
            if (s) {
              return vi.INSTANCE;
            } else {
              return ii.INSTANCE;
            }
          } else {
            return new q3(e, i);
          }
        }
        constructor(e, i) {
          this.key = e;
          this.c = i;
          this.type = 2;
        }
        cmp(e) {
          if (e.type !== this.type) {
            return this.type - e.type;
          } else {
            return t1(this.key, e.key);
          }
        }
        equals(e) {
          if (e.type === this.type) {
            return this.key === e.key;
          } else {
            return false;
          }
        }
        substituteConstants() {
          const e = kt.get(this.key);
          if (typeof e == "boolean") {
            if (e) {
              return vi.INSTANCE;
            } else {
              return ii.INSTANCE;
            }
          } else {
            return this;
          }
        }
        evaluate(e) {
          return !!e.getValue(this.key);
        }
        serialize() {
          return this.key;
        }
        keys() {
          return [this.key];
        }
        map(e) {
          return e.mapDefined(this.key);
        }
        negate() {
          this.c ||= fo.create(this.key, this);
          return this.c;
        }
      };
      xu = class z3 {
        static create(e, i, s = null) {
          if (typeof i == "boolean") {
            if (i) {
              return ho.create(e, s);
            } else {
              return fo.create(e, s);
            }
          }
          const r = kt.get(e);
          if (typeof r == "boolean") {
            if (i === (r ? "true" : "false")) {
              return vi.INSTANCE;
            } else {
              return ii.INSTANCE;
            }
          } else {
            return new z3(e, i, s);
          }
        }
        constructor(e, i, s) {
          this.c = e;
          this.d = i;
          this.f = s;
          this.type = 4;
        }
        cmp(e) {
          if (e.type !== this.type) {
            return this.type - e.type;
          } else {
            return nn(this.c, this.d, e.c, e.d);
          }
        }
        equals(e) {
          if (e.type === this.type) {
            return this.c === e.c && this.d === e.d;
          } else {
            return false;
          }
        }
        substituteConstants() {
          const e = kt.get(this.c);
          if (typeof e == "boolean") {
            const i = e ? "true" : "false";
            if (this.d === i) {
              return vi.INSTANCE;
            } else {
              return ii.INSTANCE;
            }
          }
          return this;
        }
        evaluate(e) {
          return e.getValue(this.c) == this.d;
        }
        serialize() {
          return `${this.c} == '${this.d}'`;
        }
        keys() {
          return [this.c];
        }
        map(e) {
          return e.mapEquals(this.c, this.d);
        }
        negate() {
          this.f ||= Du.create(this.c, this.d, this);
          return this.f;
        }
      };
      s1 = class H3 {
        static create(e, i) {
          return new H3(e, i);
        }
        constructor(e, i) {
          this.d = e;
          this.f = i;
          this.type = 10;
          this.c = null;
        }
        cmp(e) {
          if (e.type !== this.type) {
            return this.type - e.type;
          } else {
            return nn(this.d, this.f, e.d, e.f);
          }
        }
        equals(e) {
          if (e.type === this.type) {
            return this.d === e.d && this.f === e.f;
          } else {
            return false;
          }
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          const i = e.getValue(this.f);
          const s = e.getValue(this.d);
          if (Array.isArray(i)) {
            return i.includes(s);
          } else if (typeof s == "string" && typeof i == "object" && i !== null) {
            return ny.call(i, s);
          } else {
            return false;
          }
        }
        serialize() {
          return `${this.d} in '${this.f}'`;
        }
        keys() {
          return [this.d, this.f];
        }
        map(e) {
          return e.mapIn(this.d, this.f);
        }
        negate() {
          this.c ||= r1.create(this.d, this.f);
          return this.c;
        }
      };
      r1 = class V3 {
        static create(e, i) {
          return new V3(e, i);
        }
        constructor(e, i) {
          this.d = e;
          this.f = i;
          this.type = 11;
          this.c = s1.create(e, i);
        }
        cmp(e) {
          if (e.type !== this.type) {
            return this.type - e.type;
          } else {
            return this.c.cmp(e.c);
          }
        }
        equals(e) {
          if (e.type === this.type) {
            return this.c.equals(e.c);
          } else {
            return false;
          }
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          return !this.c.evaluate(e);
        }
        serialize() {
          return `${this.d} not in '${this.f}'`;
        }
        keys() {
          return this.c.keys();
        }
        map(e) {
          return e.mapNotIn(this.d, this.f);
        }
        negate() {
          return this.c;
        }
      };
      Du = class G3 {
        static create(e, i, s = null) {
          if (typeof i == "boolean") {
            if (i) {
              return fo.create(e, s);
            } else {
              return ho.create(e, s);
            }
          }
          const r = kt.get(e);
          if (typeof r == "boolean") {
            if (i === (r ? "true" : "false")) {
              return ii.INSTANCE;
            } else {
              return vi.INSTANCE;
            }
          } else {
            return new G3(e, i, s);
          }
        }
        constructor(e, i, s) {
          this.c = e;
          this.d = i;
          this.f = s;
          this.type = 5;
        }
        cmp(e) {
          if (e.type !== this.type) {
            return this.type - e.type;
          } else {
            return nn(this.c, this.d, e.c, e.d);
          }
        }
        equals(e) {
          if (e.type === this.type) {
            return this.c === e.c && this.d === e.d;
          } else {
            return false;
          }
        }
        substituteConstants() {
          const e = kt.get(this.c);
          if (typeof e == "boolean") {
            const i = e ? "true" : "false";
            if (this.d === i) {
              return ii.INSTANCE;
            } else {
              return vi.INSTANCE;
            }
          }
          return this;
        }
        evaluate(e) {
          return e.getValue(this.c) != this.d;
        }
        serialize() {
          return `${this.c} != '${this.d}'`;
        }
        keys() {
          return [this.c];
        }
        map(e) {
          return e.mapNotEquals(this.c, this.d);
        }
        negate() {
          this.f ||= xu.create(this.c, this.d, this);
          return this.f;
        }
      };
      fo = class J3 {
        static create(e, i = null) {
          const s = kt.get(e);
          if (typeof s == "boolean") {
            if (s) {
              return ii.INSTANCE;
            } else {
              return vi.INSTANCE;
            }
          } else {
            return new J3(e, i);
          }
        }
        constructor(e, i) {
          this.c = e;
          this.d = i;
          this.type = 3;
        }
        cmp(e) {
          if (e.type !== this.type) {
            return this.type - e.type;
          } else {
            return t1(this.c, e.c);
          }
        }
        equals(e) {
          if (e.type === this.type) {
            return this.c === e.c;
          } else {
            return false;
          }
        }
        substituteConstants() {
          const e = kt.get(this.c);
          if (typeof e == "boolean") {
            if (e) {
              return ii.INSTANCE;
            } else {
              return vi.INSTANCE;
            }
          } else {
            return this;
          }
        }
        evaluate(e) {
          return !e.getValue(this.c);
        }
        serialize() {
          return `!${this.c}`;
        }
        keys() {
          return [this.c];
        }
        map(e) {
          return e.mapNot(this.c);
        }
        negate() {
          this.d ||= ho.create(this.c, this);
          return this.d;
        }
      };
      Pu = class K3 {
        static create(e, i, s = null) {
          return Eu(i, r => new K3(e, r, s));
        }
        constructor(e, i, s) {
          this.c = e;
          this.d = i;
          this.f = s;
          this.type = 12;
        }
        cmp(e) {
          if (e.type !== this.type) {
            return this.type - e.type;
          } else {
            return nn(this.c, this.d, e.c, e.d);
          }
        }
        equals(e) {
          if (e.type === this.type) {
            return this.c === e.c && this.d === e.d;
          } else {
            return false;
          }
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          if (typeof this.d == "string") {
            return false;
          } else {
            return parseFloat(e.getValue(this.c)) > this.d;
          }
        }
        serialize() {
          return `${this.c} > ${this.d}`;
        }
        keys() {
          return [this.c];
        }
        map(e) {
          return e.mapGreater(this.c, this.d);
        }
        negate() {
          this.f ||= Au.create(this.c, this.d, this);
          return this.f;
        }
      };
      $u = class Z3 {
        static create(e, i, s = null) {
          return Eu(i, r => new Z3(e, r, s));
        }
        constructor(e, i, s) {
          this.c = e;
          this.d = i;
          this.f = s;
          this.type = 13;
        }
        cmp(e) {
          if (e.type !== this.type) {
            return this.type - e.type;
          } else {
            return nn(this.c, this.d, e.c, e.d);
          }
        }
        equals(e) {
          if (e.type === this.type) {
            return this.c === e.c && this.d === e.d;
          } else {
            return false;
          }
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          if (typeof this.d == "string") {
            return false;
          } else {
            return parseFloat(e.getValue(this.c)) >= this.d;
          }
        }
        serialize() {
          return `${this.c} >= ${this.d}`;
        }
        keys() {
          return [this.c];
        }
        map(e) {
          return e.mapGreaterEquals(this.c, this.d);
        }
        negate() {
          this.f ||= Iu.create(this.c, this.d, this);
          return this.f;
        }
      };
      Iu = class Y3 {
        static create(e, i, s = null) {
          return Eu(i, r => new Y3(e, r, s));
        }
        constructor(e, i, s) {
          this.c = e;
          this.d = i;
          this.f = s;
          this.type = 14;
        }
        cmp(e) {
          if (e.type !== this.type) {
            return this.type - e.type;
          } else {
            return nn(this.c, this.d, e.c, e.d);
          }
        }
        equals(e) {
          if (e.type === this.type) {
            return this.c === e.c && this.d === e.d;
          } else {
            return false;
          }
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          if (typeof this.d == "string") {
            return false;
          } else {
            return parseFloat(e.getValue(this.c)) < this.d;
          }
        }
        serialize() {
          return `${this.c} < ${this.d}`;
        }
        keys() {
          return [this.c];
        }
        map(e) {
          return e.mapSmaller(this.c, this.d);
        }
        negate() {
          this.f ||= $u.create(this.c, this.d, this);
          return this.f;
        }
      };
      Au = class X3 {
        static create(e, i, s = null) {
          return Eu(i, r => new X3(e, r, s));
        }
        constructor(e, i, s) {
          this.c = e;
          this.d = i;
          this.f = s;
          this.type = 15;
        }
        cmp(e) {
          if (e.type !== this.type) {
            return this.type - e.type;
          } else {
            return nn(this.c, this.d, e.c, e.d);
          }
        }
        equals(e) {
          if (e.type === this.type) {
            return this.c === e.c && this.d === e.d;
          } else {
            return false;
          }
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          if (typeof this.d == "string") {
            return false;
          } else {
            return parseFloat(e.getValue(this.c)) <= this.d;
          }
        }
        serialize() {
          return `${this.c} <= ${this.d}`;
        }
        keys() {
          return [this.c];
        }
        map(e) {
          return e.mapSmallerEquals(this.c, this.d);
        }
        negate() {
          this.f ||= Pu.create(this.c, this.d, this);
          return this.f;
        }
      };
      Cu = class Q3 {
        static create(e, i) {
          return new Q3(e, i);
        }
        constructor(e, i) {
          this.d = e;
          this.f = i;
          this.type = 7;
          this.c = null;
        }
        cmp(e) {
          if (e.type !== this.type) {
            return this.type - e.type;
          }
          if (this.d < e.d) {
            return -1;
          }
          if (this.d > e.d) {
            return 1;
          }
          const i = this.f ? this.f.source : "";
          const s = e.f ? e.f.source : "";
          if (i < s) {
            return -1;
          } else if (i > s) {
            return 1;
          } else {
            return 0;
          }
        }
        equals(e) {
          if (e.type === this.type) {
            const i = this.f ? this.f.source : "";
            const s = e.f ? e.f.source : "";
            return this.d === e.d && i === s;
          }
          return false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          const i = e.getValue(this.d);
          if (this.f) {
            return this.f.test(i);
          } else {
            return false;
          }
        }
        serialize() {
          const e = this.f ? `/${this.f.source}/${this.f.flags}` : "/invalid/";
          return `${this.d} =~ ${e}`;
        }
        keys() {
          return [this.d];
        }
        map(e) {
          return e.mapRegex(this.d, this.f);
        }
        negate() {
          this.c ||= my.create(this);
          return this.c;
        }
      };
      my = class E0 {
        static create(e) {
          return new E0(e);
        }
        constructor(e) {
          this.c = e;
          this.type = 8;
        }
        cmp(e) {
          if (e.type !== this.type) {
            return this.type - e.type;
          } else {
            return this.c.cmp(e.c);
          }
        }
        equals(e) {
          if (e.type === this.type) {
            return this.c.equals(e.c);
          } else {
            return false;
          }
        }
        substituteConstants() {
          return this;
        }
        evaluate(e) {
          return !this.c.evaluate(e);
        }
        serialize() {
          return `!(${this.c.serialize()})`;
        }
        keys() {
          return this.c.keys();
        }
        map(e) {
          return new E0(this.c.map(e));
        }
        negate() {
          return this.c;
        }
      };
      n1 = class ha {
        static create(e, i, s) {
          return ha.d(e, i, s);
        }
        constructor(e, i) {
          this.expr = e;
          this.c = i;
          this.type = 6;
        }
        cmp(e) {
          if (e.type !== this.type) {
            return this.type - e.type;
          }
          if (this.expr.length < e.expr.length) {
            return -1;
          }
          if (this.expr.length > e.expr.length) {
            return 1;
          }
          for (let i = 0, s = this.expr.length; i < s; i++) {
            const r = ic(this.expr[i], e.expr[i]);
            if (r !== 0) {
              return r;
            }
          }
          return 0;
        }
        equals(e) {
          if (e.type === this.type) {
            if (this.expr.length !== e.expr.length) {
              return false;
            }
            for (let i = 0, s = this.expr.length; i < s; i++) {
              if (!this.expr[i].equals(e.expr[i])) {
                return false;
              }
            }
            return true;
          }
          return false;
        }
        substituteConstants() {
          const e = sy(this.expr);
          if (e === this.expr) {
            return this;
          } else {
            return ha.create(e, this.c, false);
          }
        }
        evaluate(e) {
          for (let i = 0, s = this.expr.length; i < s; i++) {
            if (!this.expr[i].evaluate(e)) {
              return false;
            }
          }
          return true;
        }
        static d(e, i, s) {
          const r = [];
          let n = false;
          for (const o of e) {
            if (o) {
              if (o.type === 1) {
                n = true;
                continue;
              }
              if (o.type === 0) {
                return ii.INSTANCE;
              }
              if (o.type === 6) {
                r.push(...o.expr);
                continue;
              }
              r.push(o);
            }
          }
          if (r.length === 0 && n) {
            return vi.INSTANCE;
          }
          if (r.length !== 0) {
            if (r.length === 1) {
              return r[0];
            }
            r.sort(ic);
            for (let o = 1; o < r.length; o++) {
              if (r[o - 1].equals(r[o])) {
                r.splice(o, 1);
                o--;
              }
            }
            if (r.length === 1) {
              return r[0];
            }
            while (r.length > 1) {
              const o = r[r.length - 1];
              if (o.type !== 9) {
                break;
              }
              r.pop();
              const a = r.pop();
              const c = r.length === 0;
              const l = _u.create(o.expr.map(u => ha.create([u, a], null, s)), null, c);
              if (l) {
                r.push(l);
                r.sort(ic);
              }
            }
            if (r.length === 1) {
              return r[0];
            }
            if (s) {
              for (let o = 0; o < r.length; o++) {
                for (let a = o + 1; a < r.length; a++) {
                  if (r[o].negate().equals(r[a])) {
                    return ii.INSTANCE;
                  }
                }
              }
              if (r.length === 1) {
                return r[0];
              }
            }
            return new ha(r, i);
          }
        }
        serialize() {
          return this.expr.map(e => e.serialize()).join(" && ");
        }
        keys() {
          const e = [];
          for (const i of this.expr) {
            e.push(...i.keys());
          }
          return e;
        }
        map(e) {
          return new ha(this.expr.map(i => i.map(e)), null);
        }
        negate() {
          if (!this.c) {
            const e = [];
            for (const i of this.expr) {
              e.push(i.negate());
            }
            this.c = _u.create(e, this, true);
          }
          return this.c;
        }
      };
      _u = class Tn {
        static create(e, i, s) {
          return Tn.d(e, i, s);
        }
        constructor(e, i) {
          this.expr = e;
          this.c = i;
          this.type = 9;
        }
        cmp(e) {
          if (e.type !== this.type) {
            return this.type - e.type;
          }
          if (this.expr.length < e.expr.length) {
            return -1;
          }
          if (this.expr.length > e.expr.length) {
            return 1;
          }
          for (let i = 0, s = this.expr.length; i < s; i++) {
            const r = ic(this.expr[i], e.expr[i]);
            if (r !== 0) {
              return r;
            }
          }
          return 0;
        }
        equals(e) {
          if (e.type === this.type) {
            if (this.expr.length !== e.expr.length) {
              return false;
            }
            for (let i = 0, s = this.expr.length; i < s; i++) {
              if (!this.expr[i].equals(e.expr[i])) {
                return false;
              }
            }
            return true;
          }
          return false;
        }
        substituteConstants() {
          const e = sy(this.expr);
          if (e === this.expr) {
            return this;
          } else {
            return Tn.create(e, this.c, false);
          }
        }
        evaluate(e) {
          for (let i = 0, s = this.expr.length; i < s; i++) {
            if (this.expr[i].evaluate(e)) {
              return true;
            }
          }
          return false;
        }
        static d(e, i, s) {
          let r = [];
          let n = false;
          if (e) {
            for (let o = 0, a = e.length; o < a; o++) {
              const c = e[o];
              if (c) {
                if (c.type === 0) {
                  n = true;
                  continue;
                }
                if (c.type === 1) {
                  return vi.INSTANCE;
                }
                if (c.type === 9) {
                  r = r.concat(c.expr);
                  continue;
                }
                r.push(c);
              }
            }
            if (r.length === 0 && n) {
              return ii.INSTANCE;
            }
            r.sort(ic);
          }
          if (r.length !== 0) {
            if (r.length === 1) {
              return r[0];
            }
            for (let o = 1; o < r.length; o++) {
              if (r[o - 1].equals(r[o])) {
                r.splice(o, 1);
                o--;
              }
            }
            if (r.length === 1) {
              return r[0];
            }
            if (s) {
              for (let o = 0; o < r.length; o++) {
                for (let a = o + 1; a < r.length; a++) {
                  if (r[o].negate().equals(r[a])) {
                    return vi.INSTANCE;
                  }
                }
              }
              if (r.length === 1) {
                return r[0];
              }
            }
            return new Tn(r, i);
          }
        }
        serialize() {
          return this.expr.map(e => e.serialize()).join(" || ");
        }
        keys() {
          const e = [];
          for (const i of this.expr) {
            e.push(...i.keys());
          }
          return e;
        }
        map(e) {
          return new Tn(this.expr.map(i => i.map(e)), null);
        }
        negate() {
          if (!this.c) {
            const e = [];
            for (const i of this.expr) {
              e.push(i.negate());
            }
            while (e.length > 1) {
              const i = e.shift();
              const s = e.shift();
              const r = [];
              for (const n of ry(i)) {
                for (const o of ry(s)) {
                  r.push(n1.create([n, o], null, false));
                }
              }
              e.unshift(Tn.create(r, null, false));
            }
            this.c = Tn.create(e, this, true);
          }
          return this.c;
        }
      };
      o1 = class Df extends ho {
        static {
          this.d = [];
        }
        static all() {
          return Df.d.values();
        }
        constructor(e, i, s) {
          super(e, null);
          this.f = i;
          if (typeof s == "object") {
            Df.d.push({
              ...s,
              key: e
            });
          } else if (s !== true) {
            Df.d.push({
              key: e,
              description: s,
              type: i != null ? typeof i : undefined
            });
          }
        }
        bindTo(e) {
          return e.createKey(this.key, this.f);
        }
        getValue(e) {
          return e.getContextKeyValue(this.key);
        }
        toNegated() {
          return this.negate();
        }
        isEqualTo(e) {
          return xu.create(this.key, e);
        }
        notEqualsTo(e) {
          return Du.create(this.key, e);
        }
      };
      Px = q("contextKeyService");
    }
  });
  function Ps() {
    return new Date().toISOString();
  }
  function vy(t) {
    return Hl(t);
  }
  function a1(t, e, i) {
    switch (e) {
      case J.Trace:
        t.trace(i);
        break;
      case J.Debug:
        t.debug(i);
        break;
      case J.Info:
        t.info(i);
        break;
      case J.Warning:
        t.warn(i);
        break;
      case J.Error:
        t.error(i);
        break;
      case J.Off:
        break;
      default:
        throw new Error(`Invalid log level ${e}`);
    }
  }
  function po(t, e = false) {
    let i = "";
    for (let s = 0; s < t.length; s++) {
      let r = t[s];
      if (r instanceof Error) {
        r = Ki(r, e);
      }
      if (typeof r == "object") {
        try {
          r = JSON.stringify(r);
        } catch {}
      }
      i += (s > 0 ? " " : "") + r;
    }
    return i;
  }
  function $x(t) {
    if (t.verbose) {
      return J.Trace;
    }
    if (typeof t.logLevel == "string") {
      const e = Ax(t.logLevel.toLowerCase());
      if (e !== undefined) {
        return e;
      }
    }
    return rc;
  }
  function Ix(t) {
    switch (t) {
      case J.Trace:
        return "trace";
      case J.Debug:
        return "debug";
      case J.Info:
        return "info";
      case J.Warning:
        return "warn";
      case J.Error:
        return "error";
      case J.Off:
        return "off";
    }
  }
  function Ax(t) {
    switch (t) {
      case "trace":
        return J.Trace;
      case "debug":
        return J.Debug;
      case "info":
        return J.Info;
      case "warn":
        return J.Warning;
      case "error":
        return J.Error;
      case "critical":
        return J.Error;
      case "off":
        return J.Off;
    }
  }
  var V;
  var sc;
  var J;
  var rc;
  var Ru;
  var c1;
  var by;
  var yy;
  var Sy;
  var Ey;
  var ky;
  var Cx;
  var X = g({
    "out-build/vs/platform/log/common/log.js"() {
      "use strict";
  
      be();
      en();
      B();
      er();
      M();
      $i();
      H();
      nt();
      _e();
      se();
      wy();
      Y();
      V = q("logService");
      sc = q("loggerService");
      (function (t) {
        t[t.Off = 0] = "Off";
        t[t.Trace = 1] = "Trace";
        t[t.Debug = 2] = "Debug";
        t[t.Info = 3] = "Info";
        t[t.Warning = 4] = "Warning";
        t[t.Error = 5] = "Error";
      })(J ||= {});
      rc = J.Info;
      Ru = class extends T {
        constructor() {
          super(...arguments);
          this.b = rc;
          this.c = this.D(new $());
          this.onDidChangeLogLevel = this.c.event;
        }
        setLevel(t) {
          if (this.b !== t) {
            this.b = t;
            this.c.fire(this.b);
          }
        }
        getLevel() {
          return this.b;
        }
        f(t) {
          return this.b !== J.Off && this.b <= t;
        }
        g(t) {
          if (this.B.isDisposed) {
            return false;
          } else {
            return this.f(t);
          }
        }
      };
      c1 = class extends Ru {
        constructor(t) {
          super();
          this.h = t;
        }
        f(t) {
          return this.h || super.f(t);
        }
        trace(t, ...e) {
          if (this.g(J.Trace)) {
            this.m(J.Trace, po([t, ...e], true));
          }
        }
        debug(t, ...e) {
          if (this.g(J.Debug)) {
            this.m(J.Debug, po([t, ...e]));
          }
        }
        info(t, ...e) {
          if (this.g(J.Info)) {
            this.m(J.Info, po([t, ...e]));
          }
        }
        warn(t, ...e) {
          if (this.g(J.Warning)) {
            this.m(J.Warning, po([t, ...e]));
          }
        }
        error(t, ...e) {
          if (this.g(J.Error)) {
            if (t instanceof Error) {
              const i = Array.prototype.slice.call(arguments);
              i[0] = t.stack;
              this.m(J.Error, po(i));
            } else {
              this.m(J.Error, po([t, ...e]));
            }
          }
        }
        flush() {}
      };
      by = class extends Ru {
        constructor(t = rc) {
          super();
          this.setLevel(t);
          this.h = !j;
        }
        trace(t, ...e) {
          if (this.g(J.Trace)) {
            if (this.h) {
              console.log(`\x1B[90m[main ${Ps()}]\x1B[0m`, t, ...e);
            } else {
              console.log(`[main ${Ps()}]`, t, ...e);
            }
          }
        }
        debug(t, ...e) {
          if (this.g(J.Debug)) {
            if (this.h) {
              console.log(`\x1B[90m[main ${Ps()}]\x1B[0m`, t, ...e);
            } else {
              console.log(`[main ${Ps()}]`, t, ...e);
            }
          }
        }
        info(t, ...e) {
          if (this.g(J.Info)) {
            if (this.h) {
              console.log(`\x1B[90m[main ${Ps()}]\x1B[0m`, t, ...e);
            } else {
              console.log(`[main ${Ps()}]`, t, ...e);
            }
          }
        }
        warn(t, ...e) {
          if (this.g(J.Warning)) {
            if (this.h) {
              console.warn(`\x1B[93m[main ${Ps()}]\x1B[0m`, t, ...e);
            } else {
              console.warn(`[main ${Ps()}]`, t, ...e);
            }
          }
        }
        error(t, ...e) {
          if (this.g(J.Error)) {
            if (this.h) {
              console.error(`\x1B[91m[main ${Ps()}]\x1B[0m`, t, ...e);
            } else {
              console.error(`[main ${Ps()}]`, t, ...e);
            }
          }
        }
        flush() {}
      };
      yy = class extends Ru {
        constructor(t) {
          super();
          this.h = t;
          if (t.length) {
            this.setLevel(t[0].getLevel());
          }
        }
        setLevel(t) {
          for (const e of this.h) {
            e.setLevel(t);
          }
          super.setLevel(t);
        }
        trace(t, ...e) {
          for (const i of this.h) {
            i.trace(t, ...e);
          }
        }
        debug(t, ...e) {
          for (const i of this.h) {
            i.debug(t, ...e);
          }
        }
        info(t, ...e) {
          for (const i of this.h) {
            i.info(t, ...e);
          }
        }
        warn(t, ...e) {
          for (const i of this.h) {
            i.warn(t, ...e);
          }
        }
        error(t, ...e) {
          for (const i of this.h) {
            i.error(t, ...e);
          }
        }
        flush() {
          for (const t of this.h) {
            t.flush();
          }
        }
        dispose() {
          for (const t of this.h) {
            t.dispose();
          }
          super.dispose();
        }
      };
      Sy = class extends T {
        constructor(t, e, i) {
          super();
          this.h = t;
          this.j = e;
          this.b = new Ht();
          this.c = this.D(new $());
          this.onDidChangeLoggers = this.c.event;
          this.f = this.D(new $());
          this.onDidChangeLogLevel = this.f.event;
          this.g = this.D(new $());
          this.onDidChangeVisibility = this.g.event;
          if (i) {
            for (const s of i) {
              this.b.set(s.resource, {
                logger: undefined,
                info: s
              });
            }
          }
        }
        m(t) {
          if (wt(t)) {
            return [...this.b.values()].find(e => e.info.id === t);
          } else {
            return this.b.get(t);
          }
        }
        getLogger(t) {
          return this.m(t)?.logger;
        }
        createLogger(t, e) {
          const i = this.n(t);
          const s = wt(t) ? t : e?.id ?? Ds(i.toString()).toString(16);
          let r = this.b.get(i)?.logger;
          const n = e?.logLevel === "always" ? J.Trace : e?.logLevel;
          r ||= this.q(i, n ?? this.getLogLevel(i) ?? this.h, {
            ...e,
            id: s
          });
          const o = {
            logger: r,
            info: {
              resource: i,
              id: s,
              logLevel: n,
              name: e?.name,
              hidden: e?.hidden,
              extensionId: e?.extensionId,
              when: e?.when
            }
          };
          this.registerLogger(o.info);
          this.b.set(i, o);
          return r;
        }
        n(t) {
          if (wt(t)) {
            return he(this.j, `${t}.log`);
          } else {
            return t;
          }
        }
        setLogLevel(t, e) {
          if (P.isUri(t)) {
            const i = t;
            const s = e;
            const r = this.b.get(i);
            if (r && s !== r.info.logLevel) {
              r.info.logLevel = s === this.h ? undefined : s;
              r.logger?.setLevel(s);
              this.b.set(r.info.resource, r);
              this.f.fire([i, s]);
            }
          } else {
            this.h = t;
            for (const [i, s] of this.b.entries()) {
              if (this.b.get(i)?.info.logLevel === undefined) {
                s.logger?.setLevel(this.h);
              }
            }
            this.f.fire(this.h);
          }
        }
        setVisibility(t, e) {
          const i = this.m(t);
          if (i && e !== !i.info.hidden) {
            i.info.hidden = !e;
            this.b.set(i.info.resource, i);
            this.g.fire([i.info.resource, e]);
          }
        }
        getLogLevel(t) {
          let e;
          if (t) {
            e = this.b.get(t)?.info.logLevel;
          }
          return e ?? this.h;
        }
        registerLogger(t) {
          const e = this.b.get(t.resource);
          if (e) {
            if (e.info.hidden !== t.hidden) {
              this.setVisibility(t.resource, !t.hidden);
            }
          } else {
            this.b.set(t.resource, {
              info: t,
              logger: undefined
            });
            this.c.fire({
              added: [t],
              removed: []
            });
          }
        }
        deregisterLogger(t) {
          const e = this.b.get(t);
          if (e) {
            if (e.logger) {
              e.logger.dispose();
            }
            this.b.delete(t);
            this.c.fire({
              added: [],
              removed: [e.info]
            });
          }
        }
        *getRegisteredLoggers() {
          for (const t of this.b.values()) {
            yield t.info;
          }
        }
        getRegisteredLogger(t) {
          return this.b.get(t)?.info;
        }
        dispose() {
          this.b.forEach(t => t.logger?.dispose());
          this.b.clear();
          super.dispose();
        }
      };
      Ey = class {
        constructor() {
          this.onDidChangeLogLevel = new $().event;
        }
        setLevel(t) {}
        getLevel() {
          return J.Info;
        }
        trace(t, ...e) {}
        debug(t, ...e) {}
        info(t, ...e) {}
        warn(t, ...e) {}
        error(t, ...e) {}
        critical(t, ...e) {}
        dispose() {}
        flush() {}
      };
      ky = class extends Ey {};
      Cx = new o1("logLevel", Ix(J.Info));
    }
  });
  var xy;
  var Dy;
  var l1;
  var Py;
  var $y;
  var nc;
  var Iy;
  var Pr;
  var go = g({
    "out-build/vs/base/common/ternarySearchTree.js"() {
      "use strict";
  
      zt();
      Wt();
      xy = class {
        constructor() {
          this.b = "";
          this.c = 0;
        }
        reset(t) {
          this.b = t;
          this.c = 0;
          return this;
        }
        next() {
          this.c += 1;
          return this;
        }
        hasNext() {
          return this.c < this.b.length - 1;
        }
        cmp(t) {
          const e = t.charCodeAt(0);
          const i = this.b.charCodeAt(this.c);
          return e - i;
        }
        value() {
          return this.b[this.c];
        }
      };
      Dy = class {
        constructor(t = true) {
          this.e = t;
        }
        reset(t) {
          this.b = t;
          this.c = 0;
          this.d = 0;
          return this.next();
        }
        hasNext() {
          return this.d < this.b.length;
        }
        next() {
          this.c = this.d;
          let t = true;
          for (; this.d < this.b.length; this.d++) {
            if (this.b.charCodeAt(this.d) === 46) {
              if (t) {
                this.c++;
              } else {
                break;
              }
            } else {
              t = false;
            }
          }
          return this;
        }
        cmp(t) {
          if (this.e) {
            return bp(t, this.b, 0, t.length, this.c, this.d);
          } else {
            return Ua(t, this.b, 0, t.length, this.c, this.d);
          }
        }
        value() {
          return this.b.substring(this.c, this.d);
        }
      };
      l1 = class {
        constructor(t = true, e = true) {
          this.f = t;
          this.g = e;
        }
        reset(t) {
          this.d = 0;
          this.e = 0;
          this.b = t;
          this.c = t.length;
          for (let e = t.length - 1; e >= 0; e--, this.c--) {
            const i = this.b.charCodeAt(e);
            if (i !== 47 && (!this.f || i !== 92)) {
              break;
            }
          }
          return this.next();
        }
        hasNext() {
          return this.e < this.c;
        }
        next() {
          this.d = this.e;
          let t = true;
          for (; this.e < this.c; this.e++) {
            const e = this.b.charCodeAt(this.e);
            if (e === 47 || this.f && e === 92) {
              if (t) {
                this.d++;
              } else {
                break;
              }
            } else {
              t = false;
            }
          }
          return this;
        }
        cmp(t) {
          if (this.g) {
            return bp(t, this.b, 0, t.length, this.d, this.e);
          } else {
            return Ua(t, this.b, 0, t.length, this.d, this.e);
          }
        }
        value() {
          return this.b.substring(this.d, this.e);
        }
      };
      (function (t) {
        t[t.Scheme = 1] = "Scheme";
        t[t.Authority = 2] = "Authority";
        t[t.Path = 3] = "Path";
        t[t.Query = 4] = "Query";
        t[t.Fragment = 5] = "Fragment";
      })(Py ||= {});
      $y = class {
        constructor(t, e) {
          this.f = t;
          this.g = e;
          this.d = [];
          this.e = 0;
        }
        reset(t) {
          this.c = t;
          this.d = [];
          if (this.c.scheme) {
            this.d.push(1);
          }
          if (this.c.authority) {
            this.d.push(2);
          }
          if (this.c.path) {
            this.b = new l1(false, !this.f(t));
            this.b.reset(t.path);
            if (this.b.value()) {
              this.d.push(3);
            }
          }
          if (!this.g(t)) {
            if (this.c.query) {
              this.d.push(4);
            }
            if (this.c.fragment) {
              this.d.push(5);
            }
          }
          this.e = 0;
          return this;
        }
        next() {
          if (this.d[this.e] === 3 && this.b.hasNext()) {
            this.b.next();
          } else {
            this.e += 1;
          }
          return this;
        }
        hasNext() {
          return this.d[this.e] === 3 && this.b.hasNext() || this.e < this.d.length - 1;
        }
        cmp(t) {
          if (this.d[this.e] === 1) {
            return yp(t, this.c.scheme);
          }
          if (this.d[this.e] === 2) {
            return yp(t, this.c.authority);
          }
          if (this.d[this.e] === 3) {
            return this.b.cmp(t);
          }
          if (this.d[this.e] === 4) {
            return vp(t, this.c.query);
          }
          if (this.d[this.e] === 5) {
            return vp(t, this.c.fragment);
          }
          throw new Error();
        }
        value() {
          if (this.d[this.e] === 1) {
            return this.c.scheme;
          }
          if (this.d[this.e] === 2) {
            return this.c.authority;
          }
          if (this.d[this.e] === 3) {
            return this.b.value();
          }
          if (this.d[this.e] === 4) {
            return this.c.query;
          }
          if (this.d[this.e] === 5) {
            return this.c.fragment;
          }
          throw new Error();
        }
      };
      nc = class {
        constructor() {
          this.height = 1;
        }
        isEmpty() {
          return !this.left && !this.mid && !this.right && !this.value;
        }
        rotateLeft() {
          const t = this.right;
          this.right = t.left;
          t.left = this;
          this.updateHeight();
          t.updateHeight();
          return t;
        }
        rotateRight() {
          const t = this.left;
          this.left = t.right;
          t.right = this;
          this.updateHeight();
          t.updateHeight();
          return t;
        }
        updateHeight() {
          this.height = 1 + Math.max(this.heightLeft, this.heightRight);
        }
        balanceFactor() {
          return this.heightRight - this.heightLeft;
        }
        get heightLeft() {
          return this.left?.height ?? 0;
        }
        get heightRight() {
          return this.right?.height ?? 0;
        }
      };
      (function (t) {
        t[t.Left = -1] = "Left";
        t[t.Mid = 0] = "Mid";
        t[t.Right = 1] = "Right";
      })(Iy ||= {});
      Pr = class Dl {
        static forUris(e = () => false, i = () => false) {
          return new Dl(new $y(e, i));
        }
        static forPaths(e = false) {
          return new Dl(new l1(undefined, !e));
        }
        static forStrings() {
          return new Dl(new xy());
        }
        static forConfigKeys() {
          return new Dl(new Dy());
        }
        constructor(e) {
          this.b = e;
        }
        clear() {
          this.c = undefined;
        }
        fill(e, i) {
          if (i) {
            const s = i.slice(0);
            fw(s);
            for (const r of s) {
              this.set(r, e);
            }
          } else {
            const s = e.slice(0);
            fw(s);
            for (const r of s) {
              this.set(r[0], r[1]);
            }
          }
        }
        set(e, i) {
          const s = this.b.reset(e);
          let r;
          if (!this.c) {
            this.c = new nc();
            this.c.segment = s.value();
          }
          const n = [];
          for (r = this.c;;) {
            const a = s.cmp(r.segment);
            if (a > 0) {
              if (!r.left) {
                r.left = new nc();
                r.left.segment = s.value();
              }
              n.push([-1, r]);
              r = r.left;
            } else if (a < 0) {
              if (!r.right) {
                r.right = new nc();
                r.right.segment = s.value();
              }
              n.push([1, r]);
              r = r.right;
            } else if (s.hasNext()) {
              s.next();
              if (!r.mid) {
                r.mid = new nc();
                r.mid.segment = s.value();
              }
              n.push([0, r]);
              r = r.mid;
            } else {
              break;
            }
          }
          const o = r.value;
          r.value = i;
          r.key = e;
          for (let a = n.length - 1; a >= 0; a--) {
            const c = n[a][1];
            c.updateHeight();
            const l = c.balanceFactor();
            if (l < -1 || l > 1) {
              const u = n[a][0];
              const d = n[a + 1][0];
              if (u === 1 && d === 1) {
                n[a][1] = c.rotateLeft();
              } else if (u === -1 && d === -1) {
                n[a][1] = c.rotateRight();
              } else if (u === 1 && d === -1) {
                c.right = n[a + 1][1] = n[a + 1][1].rotateRight();
                n[a][1] = c.rotateLeft();
              } else if (u === -1 && d === 1) {
                c.left = n[a + 1][1] = n[a + 1][1].rotateLeft();
                n[a][1] = c.rotateRight();
              } else {
                throw new Error();
              }
              if (a > 0) {
                switch (n[a - 1][0]) {
                  case -1:
                    n[a - 1][1].left = n[a][1];
                    break;
                  case 1:
                    n[a - 1][1].right = n[a][1];
                    break;
                  case 0:
                    n[a - 1][1].mid = n[a][1];
                    break;
                }
              } else {
                this.c = n[0][1];
              }
            }
          }
          return o;
        }
        get(e) {
          return this.d(e)?.value;
        }
        d(e) {
          const i = this.b.reset(e);
          let s = this.c;
          while (s) {
            const r = i.cmp(s.segment);
            if (r > 0) {
              s = s.left;
            } else if (r < 0) {
              s = s.right;
            } else if (i.hasNext()) {
              i.next();
              s = s.mid;
            } else {
              break;
            }
          }
          return s;
        }
        has(e) {
          const i = this.d(e);
          return i?.value !== undefined || i?.mid !== undefined;
        }
        delete(e) {
          return this.e(e, false);
        }
        deleteSuperstr(e) {
          return this.e(e, true);
        }
        e(e, i) {
          const s = this.b.reset(e);
          const r = [];
          let n = this.c;
          while (n) {
            const o = s.cmp(n.segment);
            if (o > 0) {
              r.push([-1, n]);
              n = n.left;
            } else if (o < 0) {
              r.push([1, n]);
              n = n.right;
            } else if (s.hasNext()) {
              s.next();
              r.push([0, n]);
              n = n.mid;
            } else {
              break;
            }
          }
          if (n) {
            if (i) {
              n.left = undefined;
              n.mid = undefined;
              n.right = undefined;
              n.height = 1;
            } else {
              n.key = undefined;
              n.value = undefined;
            }
            if (!n.mid && !n.value) {
              if (n.left && n.right) {
                const o = this.f(n.right);
                if (o.key) {
                  const {
                    key: a,
                    value: c,
                    segment: l
                  } = o;
                  this.e(o.key, false);
                  n.key = a;
                  n.value = c;
                  n.segment = l;
                }
              } else {
                const o = n.left ?? n.right;
                if (r.length > 0) {
                  const [a, c] = r[r.length - 1];
                  switch (a) {
                    case -1:
                      c.left = o;
                      break;
                    case 0:
                      c.mid = o;
                      break;
                    case 1:
                      c.right = o;
                      break;
                  }
                } else {
                  this.c = o;
                }
              }
            }
            for (let o = r.length - 1; o >= 0; o--) {
              const a = r[o][1];
              a.updateHeight();
              const c = a.balanceFactor();
              if (c > 1) {
                if (!(a.right.balanceFactor() >= 0)) {
                  a.right = a.right.rotateRight();
                }
                r[o][1] = a.rotateLeft();
              } else if (c < -1) {
                if (!(a.left.balanceFactor() <= 0)) {
                  a.left = a.left.rotateLeft();
                }
                r[o][1] = a.rotateRight();
              }
              if (o > 0) {
                switch (r[o - 1][0]) {
                  case -1:
                    r[o - 1][1].left = r[o][1];
                    break;
                  case 1:
                    r[o - 1][1].right = r[o][1];
                    break;
                  case 0:
                    r[o - 1][1].mid = r[o][1];
                    break;
                }
              } else {
                this.c = r[0][1];
              }
            }
          }
        }
        f(e) {
          while (e.left) {
            e = e.left;
          }
          return e;
        }
        findSubstr(e) {
          const i = this.b.reset(e);
          let s = this.c;
          let r;
          while (s) {
            const n = i.cmp(s.segment);
            if (n > 0) {
              s = s.left;
            } else if (n < 0) {
              s = s.right;
            } else if (i.hasNext()) {
              i.next();
              r = s.value || r;
              s = s.mid;
            } else {
              break;
            }
          }
          return s && s.value || r;
        }
        findSuperstr(e) {
          return this.g(e, false);
        }
        g(e, i) {
          const s = this.b.reset(e);
          let r = this.c;
          while (r) {
            const n = s.cmp(r.segment);
            if (n > 0) {
              r = r.left;
            } else if (n < 0) {
              r = r.right;
            } else if (s.hasNext()) {
              s.next();
              r = r.mid;
            } else if (r.mid) {
              return this.h(r.mid);
            } else if (i) {
              return r.value;
            } else {
              return undefined;
            }
          }
        }
        hasElementOrSubtree(e) {
          return this.g(e, true) !== undefined;
        }
        forEach(e) {
          for (const [i, s] of this) {
            e(s, i);
          }
        }
        *[Symbol.iterator]() {
          yield* this.h(this.c);
        }
        h(e) {
          const i = [];
          this.j(e, i);
          return i[Symbol.iterator]();
        }
        j(e, i) {
          if (e) {
            if (e.left) {
              this.j(e.left, i);
            }
            if (e.value) {
              i.push([e.key, e.value]);
            }
            if (e.mid) {
              this.j(e.mid, i);
            }
            if (e.right) {
              this.j(e.right, i);
            }
          }
        }
        _isBalanced() {
          const e = i => {
            if (!i) {
              return true;
            }
            const s = i.balanceFactor();
            if (s < -1 || s > 1) {
              return false;
            } else {
              return e(i.left) && e(i.right);
            }
          };
          return e(this.c);
        }
      };
    }
  });
  function mo(t) {
    return t.create === true;
  }
  function Xi(t) {
    return !!(t.capabilities & 2);
  }
  function u1(t) {
    return !!(t.capabilities & 8);
  }
  function Ay(t) {
    return !!(t.capabilities & 131072);
  }
  function $r(t) {
    return !!(t.capabilities & 4);
  }
  function h1(t) {
    return !!(t.capabilities & 16);
  }
  function d1(t) {
    if (Xi(t)) {
      return !!(t.capabilities & 16384);
    } else {
      return false;
    }
  }
  function Cy(t) {
    if (Xi(t)) {
      return !!(t.capabilities & 32768);
    } else {
      return false;
    }
  }
  function _x(t) {
    return !!(t.capabilities & 65536);
  }
  function cs(t, e) {
    return Lu.create(t, e);
  }
  function on(t) {
    return t || cs(v(1914, null), oe.Unknown);
  }
  function Rx(t, e) {
    t.name = e ? `${e} (FileSystemError)` : "FileSystemError";
    return t;
  }
  function Ou(t) {
    if (!t) {
      return oe.Unknown;
    }
    if (t instanceof Lu) {
      return t.code;
    }
    const e = /^(.+) \(FileSystemError\)$/.exec(t.name);
    if (!e) {
      return oe.Unknown;
    }
    switch (e[1]) {
      case oe.FileExists:
        return oe.FileExists;
      case oe.FileIsADirectory:
        return oe.FileIsADirectory;
      case oe.FileNotADirectory:
        return oe.FileNotADirectory;
      case oe.FileNotFound:
        return oe.FileNotFound;
      case oe.FileTooLarge:
        return oe.FileTooLarge;
      case oe.FileWriteLocked:
        return oe.FileWriteLocked;
      case oe.NoPermissions:
        return oe.NoPermissions;
      case oe.Unavailable:
        return oe.Unavailable;
    }
    return oe.Unknown;
  }
  function $s(t) {
    if (t instanceof si) {
      return t.fileOperationResult;
    }
    switch (Ou(t)) {
      case oe.FileNotFound:
        return 1;
      case oe.FileIsADirectory:
        return 0;
      case oe.FileNotADirectory:
        return 9;
      case oe.FileWriteLocked:
        return 5;
      case oe.NoPermissions:
        return 6;
      case oe.FileExists:
        return 4;
      case oe.FileTooLarge:
        return 7;
      default:
        return 10;
    }
  }
  function Ox(t, e, i) {
    if (!t || !e || t === e || e.length > t.length) {
      return false;
    } else {
      if (e.charAt(e.length - 1) !== Vt) {
        e += Vt;
      }
      if (i) {
        return eu(t, e);
      } else {
        return t.indexOf(e) === 0;
      }
    }
  }
  function _y(t) {
    if (typeof t.size == "number" && typeof t.mtime == "number") {
      return t.mtime.toString(29) + t.size.toString(31);
    }
  }
  var at;
  var Rt;
  var wo;
  var Ry;
  var Oy;
  var oe;
  var Lu;
  var Ly;
  var an;
  var My;
  var Fy;
  var si;
  var Mu;
  var Fu;
  var Ny;
  var Nu;
  var Wy;
  var Wu;
  var cn;
  var He = g({
    "out-build/vs/platform/files/common/files.js"() {
      "use strict";
  
      go();
      we();
      Wt();
      _e();
      se();
      be();
      Y();
      H();
      Ie();
      Ta();
      at = q("fileService");
      (function (t) {
        t[t.Unknown = 0] = "Unknown";
        t[t.File = 1] = "File";
        t[t.Directory = 2] = "Directory";
        t[t.SymbolicLink = 64] = "SymbolicLink";
      })(Rt ||= {});
      (function (t) {
        t[t.Readonly = 1] = "Readonly";
        t[t.Locked = 2] = "Locked";
      })(wo ||= {});
      (function (t) {
        t[t.UPDATED = 2] = "UPDATED";
        t[t.ADDED = 4] = "ADDED";
        t[t.DELETED = 8] = "DELETED";
      })(Ry ||= {});
      (function (t) {
        t[t.None = 0] = "None";
        t[t.FileReadWrite = 2] = "FileReadWrite";
        t[t.FileOpenReadWriteClose = 4] = "FileOpenReadWriteClose";
        t[t.FileReadStream = 16] = "FileReadStream";
        t[t.FileFolderCopy = 8] = "FileFolderCopy";
        t[t.PathCaseSensitive = 1024] = "PathCaseSensitive";
        t[t.Readonly = 2048] = "Readonly";
        t[t.Trash = 4096] = "Trash";
        t[t.FileWriteUnlock = 8192] = "FileWriteUnlock";
        t[t.FileAtomicRead = 16384] = "FileAtomicRead";
        t[t.FileAtomicWrite = 32768] = "FileAtomicWrite";
        t[t.FileAtomicDelete = 65536] = "FileAtomicDelete";
        t[t.FileClone = 131072] = "FileClone";
      })(Oy ||= {});
      (function (t) {
        t.FileExists = "EntryExists";
        t.FileNotFound = "EntryNotFound";
        t.FileNotADirectory = "EntryNotADirectory";
        t.FileIsADirectory = "EntryIsADirectory";
        t.FileExceedsStorageQuota = "EntryExceedsStorageQuota";
        t.FileTooLarge = "EntryTooLarge";
        t.FileWriteLocked = "EntryWriteLocked";
        t.NoPermissions = "NoPermissions";
        t.Unavailable = "Unavailable";
        t.Unknown = "Unknown";
      })(oe ||= {});
      Lu = class eS extends Error {
        static create(e, i) {
          const s = new eS(e.toString(), i);
          Rx(s, i);
          return s;
        }
        constructor(e, i) {
          super(e);
          this.code = i;
        }
      };
      (function (t) {
        t[t.CREATE = 0] = "CREATE";
        t[t.DELETE = 1] = "DELETE";
        t[t.MOVE = 2] = "MOVE";
        t[t.COPY = 3] = "COPY";
        t[t.WRITE = 4] = "WRITE";
      })(Ly ||= {});
      an = class {
        constructor(t, e, i) {
          this.resource = t;
          this.operation = e;
          this.target = i;
        }
        isOperation(t) {
          return this.operation === t;
        }
      };
      (function (t) {
        t[t.UPDATED = 0] = "UPDATED";
        t[t.ADDED = 1] = "ADDED";
        t[t.DELETED = 2] = "DELETED";
      })(My ||= {});
      Fy = class Pf {
        static {
          this.a = null;
        }
        constructor(e, i) {
          this.c = i;
          this.b = undefined;
          this.d = new vr(() => {
            const s = Pr.forUris(() => this.c);
            s.fill(this.rawAdded.map(r => [r, true]));
            return s;
          });
          this.f = new vr(() => {
            const s = Pr.forUris(() => this.c);
            s.fill(this.rawUpdated.map(r => [r, true]));
            return s;
          });
          this.g = new vr(() => {
            const s = Pr.forUris(() => this.c);
            s.fill(this.rawDeleted.map(r => [r, true]));
            return s;
          });
          this.rawAdded = [];
          this.rawUpdated = [];
          this.rawDeleted = [];
          for (const s of e) {
            switch (s.type) {
              case 1:
                this.rawAdded.push(s.resource);
                break;
              case 0:
                this.rawUpdated.push(s.resource);
                break;
              case 2:
                this.rawDeleted.push(s.resource);
                break;
            }
            if (this.b !== Pf.a) {
              if (typeof s.cId == "number") {
                if (this.b === undefined) {
                  this.b = s.cId;
                } else if (this.b !== s.cId) {
                  this.b = Pf.a;
                }
              } else if (this.b !== undefined) {
                this.b = Pf.a;
              }
            }
          }
        }
        contains(e, ...i) {
          return this.h(e, {
            includeChildren: false
          }, ...i);
        }
        affects(e, ...i) {
          return this.h(e, {
            includeChildren: true
          }, ...i);
        }
        h(e, i, ...s) {
          if (!e) {
            return false;
          }
          const r = s.length > 0;
          return (!r || !!s.includes(1)) && (!!this.d.value.get(e) || !!i.includeChildren && !!this.d.value.findSuperstr(e)) || (!r || !!s.includes(0)) && (!!this.f.value.get(e) || !!i.includeChildren && !!this.f.value.findSuperstr(e)) || (!r || !!s.includes(2)) && (!!this.g.value.findSubstr(e) || !!i.includeChildren && !!this.g.value.findSuperstr(e));
        }
        gotAdded() {
          return this.rawAdded.length > 0;
        }
        gotDeleted() {
          return this.rawDeleted.length > 0;
        }
        gotUpdated() {
          return this.rawUpdated.length > 0;
        }
        correlates(e) {
          return this.b === e;
        }
        hasCorrelation() {
          return typeof this.b == "number";
        }
      };
      si = class extends Error {
        constructor(t, e, i) {
          super(t);
          this.fileOperationResult = e;
          this.options = i;
        }
      };
      Mu = class extends si {
        constructor(t, e, i, s) {
          super(t, e, s);
          this.fileOperationResult = e;
          this.size = i;
        }
      };
      Fu = class extends si {
        constructor(t, e, i) {
          super(t, 2, i);
          this.stat = e;
        }
      };
      (function (t) {
        t[t.FILE_IS_DIRECTORY = 0] = "FILE_IS_DIRECTORY";
        t[t.FILE_NOT_FOUND = 1] = "FILE_NOT_FOUND";
        t[t.FILE_NOT_MODIFIED_SINCE = 2] = "FILE_NOT_MODIFIED_SINCE";
        t[t.FILE_MODIFIED_SINCE = 3] = "FILE_MODIFIED_SINCE";
        t[t.FILE_MOVE_CONFLICT = 4] = "FILE_MOVE_CONFLICT";
        t[t.FILE_WRITE_LOCKED = 5] = "FILE_WRITE_LOCKED";
        t[t.FILE_PERMISSION_DENIED = 6] = "FILE_PERMISSION_DENIED";
        t[t.FILE_TOO_LARGE = 7] = "FILE_TOO_LARGE";
        t[t.FILE_INVALID_PATH = 8] = "FILE_INVALID_PATH";
        t[t.FILE_NOT_DIRECTORY = 9] = "FILE_NOT_DIRECTORY";
        t[t.FILE_OTHER_ERROR = 10] = "FILE_OTHER_ERROR";
      })(Ny ||= {});
      Nu = {
        OFF: "off",
        ON_EXIT: "onExit",
        ON_EXIT_AND_WINDOW_CLOSE: "onExitAndWindowClose"
      };
      (function (t) {
        t[t.FILE = 0] = "FILE";
        t[t.FOLDER = 1] = "FOLDER";
        t[t.ROOT_FOLDER = 2] = "ROOT_FOLDER";
      })(Wy ||= {});
      Wu = "";
      cn = class xi {
        static {
          this.KB = 1024;
        }
        static {
          this.MB = xi.KB * xi.KB;
        }
        static {
          this.GB = xi.MB * xi.KB;
        }
        static {
          this.TB = xi.GB * xi.KB;
        }
        static formatSize(e) {
          if (!Hl(e)) {
            e = 0;
          }
          if (e < xi.KB) {
            return v(1915, null, e.toFixed(0));
          } else if (e < xi.MB) {
            return v(1916, null, (e / xi.KB).toFixed(2));
          } else if (e < xi.GB) {
            return v(1917, null, (e / xi.MB).toFixed(2));
          } else if (e < xi.TB) {
            return v(1918, null, (e / xi.GB).toFixed(2));
          } else {
            return v(1919, null, (e / xi.TB).toFixed(2));
          }
        }
      };
    }
  });
  var f1;
  var Oi;
  var Ti = g({
    "out-build/vs/platform/state/node/state.js"() {
      "use strict";
  
      Y();
      f1 = q("stateReadService");
      Oi = q("stateService");
    }
  });
  import ji from "electron";
  var oc;
  var Te;
  var Ty;
  var jy;
  var Tu;
  var ct = g({
    "out-build/vs/platform/lifecycle/electron-main/lifecycleMainService.js"() {
      "use strict";
  
      as();
      ce();
      B();
      M();
      H();
      ys();
      _e();
      Y();
      X();
      Ti();
      vt();
      Te = q("lifecycleMainService");
      (function (t) {
        t[t.QUIT = 1] = "QUIT";
        t[t.KILL = 2] = "KILL";
      })(Ty ||= {});
      (function (t) {
        t[t.Starting = 1] = "Starting";
        t[t.Ready = 2] = "Ready";
        t[t.AfterWindowOpen = 3] = "AfterWindowOpen";
        t[t.Eventually = 4] = "Eventually";
      })(jy ||= {});
      Tu = class extends T {
        static {
          oc = this;
        }
        static {
          this.b = "lifecycle.quitAndRestart";
        }
        get quitRequested() {
          return this.j;
        }
        get wasRestarted() {
          return this.m;
        }
        get phase() {
          return this.n;
        }
        constructor(e, i, s) {
          super();
          this.F = e;
          this.G = i;
          this.H = s;
          this.c = this.D(new $());
          this.onBeforeShutdown = this.c.event;
          this.f = this.D(new $());
          this.onWillShutdown = this.f.event;
          this.g = this.D(new $());
          this.onWillLoadWindow = this.g.event;
          this.h = this.D(new $());
          this.onBeforeCloseWindow = this.h.event;
          this.j = false;
          this.m = false;
          this.n = 1;
          this.q = new Set();
          this.r = 0;
          this.s = 0;
          this.t = undefined;
          this.u = undefined;
          this.w = undefined;
          this.y = new Map();
          this.z = new Map();
          this.C = undefined;
          this.I();
          this.when(2).then(() => this.J());
        }
        I() {
          this.m = !!this.G.getItem(oc.b);
          if (this.m) {
            this.G.removeItem(oc.b);
          }
        }
        J() {
          const e = () => {
            if (!this.j) {
              this.S("Lifecycle#app.on(before-quit)");
              this.j = true;
              this.S("Lifecycle#onBeforeShutdown.fire()");
              this.c.fire();
              if (N && this.s === 0) {
                this.L(1);
              }
            }
          };
          ji.app.addListener("before-quit", e);
          const i = () => {
            this.S("Lifecycle#app.on(window-all-closed)");
            if (this.j || !N) {
              ji.app.quit();
            }
          };
          ji.app.addListener("window-all-closed", i);
          ji.app.once("will-quit", s => {
            this.S("Lifecycle#app.on(will-quit) - begin");
            s.preventDefault();
            this.L(1).finally(() => {
              this.S("Lifecycle#app.on(will-quit) - after fireOnWillShutdown");
              this.O(false);
              ji.app.removeListener("before-quit", e);
              ji.app.removeListener("window-all-closed", i);
              this.S("Lifecycle#app.on(will-quit) - calling app.quit()");
              ji.app.quit();
            });
          });
        }
        L(e) {
          if (this.w) {
            return this.w;
          }
          const i = this.F;
          this.S("Lifecycle#onWillShutdown.fire()");
          const s = [];
          this.f.fire({
            reason: e,
            join(r, n) {
              i.trace(`Lifecycle#onWillShutdown - begin '${r}'`);
              s.push(n.finally(() => {
                i.trace(`Lifecycle#onWillShutdown - end '${r}'`);
              }));
            }
          });
          this.w = (async () => {
            try {
              await Tt.settled(s);
            } catch (r) {
              this.F.error(r);
            }
            try {
              await this.G.close();
            } catch (r) {
              this.F.error(r);
            }
          })();
          return this.w;
        }
        set phase(e) {
          if (e < this.phase) {
            throw new Error("Lifecycle cannot go backwards");
          }
          if (this.n === e) {
            return;
          }
          this.S(`lifecycle (main): phase changed (value: ${e})`);
          this.n = e;
          const i = this.z.get(this.n);
          if (i) {
            i.open();
            this.z.delete(this.n);
          }
        }
        async when(e) {
          if (e <= this.n) {
            return;
          }
          let i = this.z.get(e);
          if (!i) {
            i = new Ga();
            this.z.set(e, i);
          }
          await i.wait();
        }
        registerWindow(e) {
          const i = new De();
          this.s++;
          i.add(e.onWillLoad(r => this.g.fire({
            window: e,
            workspace: r.workspace,
            reason: r.reason
          })));
          let s = e.win && i.add(x.fromNodeEventEmitter(e.win, "close")(r => {
            const n = e.id;
            if (this.q.has(n)) {
              this.q.delete(n);
              return;
            }
            this.S(`Lifecycle#window.on('close') - window ID ${e.id}`);
            r.preventDefault();
            this.unload(e, 1).then(o => {
              if (o) {
                this.q.delete(n);
                return;
              }
              this.q.add(n);
              this.S(`Lifecycle#onBeforeCloseWindow.fire() - window ID ${n}`);
              this.h.fire(e);
              e.close();
            });
          }));
          i.add(e.onDidClose(() => {
            this.S(`Lifecycle#window.on('closed') - window ID ${e.id}`);
            this.s--;
            i.dispose();
            if (this.s === 0 && (!N || this.j)) {
              this.L(1);
            }
          }));
        }
        registerAuxWindow(e) {
          const i = Vl(e.win);
          const s = new De();
          s.add(x.fromNodeEventEmitter(i, "close")(r => {
            this.S(`Lifecycle#auxWindow.on('close') - window ID ${e.id}`);
            if (this.j) {
              this.S("Lifecycle#auxWindow.on('close') - preventDefault() because quit requested");
              r.preventDefault();
            }
          }));
          s.add(x.fromNodeEventEmitter(i, "closed")(() => {
            this.S(`Lifecycle#auxWindow.on('closed') - window ID ${e.id}`);
            s.dispose();
          }));
        }
        async reload(e, i) {
          if (!(await this.unload(e, 3))) {
            e.reload(i);
          }
        }
        unload(e, i) {
          const s = this.y.get(e.id);
          if (s) {
            return s;
          }
          const r = this.M(e, i).finally(() => {
            this.y.delete(e.id);
          });
          this.y.set(e.id, r);
          return r;
        }
        async M(e, i) {
          if (!e.isReady) {
            return false;
          }
          this.S(`Lifecycle#unload() - window ID ${e.id}`);
          const s = this.j ? 2 : i;
          const r = await this.P(e, s);
          if (r) {
            this.S(`Lifecycle#unload() - veto in renderer (window ID ${e.id})`);
            return this.N(r);
          } else {
            await this.Q(e, s);
            return false;
          }
        }
        N(e) {
          if (e) {
            this.O(true);
            this.j = false;
            return true;
          } else {
            return false;
          }
        }
        O(e) {
          if (this.u) {
            this.u(e);
            this.u = undefined;
            this.t = undefined;
          }
        }
        P(e, i) {
          return new Promise(s => {
            const r = this.r++;
            const n = `vscode:ok${r}`;
            const o = `vscode:cancel${r}`;
            it.once(n, () => {
              s(false);
            });
            it.once(o, () => {
              s(true);
            });
            e.send("vscode:onBeforeUnload", {
              okChannel: n,
              cancelChannel: o,
              reason: i
            });
          });
        }
        Q(e, i) {
          return new Promise(s => {
            const n = `vscode:reply${this.r++}`;
            it.once(n, () => s());
            e.send("vscode:onWillUnload", {
              replyChannel: n,
              reason: i
            });
          });
        }
        quit(e) {
          return this.R(e).then(i => {
            if (!i && e) {
              try {
                if (j) {
                  const s = bs();
                  if (s !== process.cwd()) {
                    process.chdir(s);
                  }
                }
              } catch (s) {
                this.F.error(s);
              }
            }
            return i;
          });
        }
        R(e) {
          this.S(`Lifecycle#quit() - begin (willRestart: ${e})`);
          if (this.t) {
            this.S("Lifecycle#quit() - returning pending quit promise");
            return this.t;
          } else {
            if (e) {
              this.G.setItem(oc.b, true);
            }
            this.t = new Promise(i => {
              this.u = i;
              this.S("Lifecycle#quit() - calling app.quit()");
              ji.app.quit();
            });
            return this.t;
          }
        }
        S(e) {
          if (this.H.args["enable-smoke-test-driver"]) {
            this.F.info(e);
          } else {
            this.F.trace(e);
          }
        }
        setRelaunchHandler(e) {
          this.C = e;
        }
        async relaunch(e) {
          this.S("Lifecycle#relaunch()");
          const i = process.argv.slice(1);
          if (e?.addArgs) {
            i.push(...e.addArgs);
          }
          if (e?.removeArgs) {
            for (const n of e.removeArgs) {
              const o = i.indexOf(n);
              if (o >= 0) {
                i.splice(o, 1);
              }
            }
          }
          const s = () => {
            if (!this.C?.handleRelaunch(e)) {
              this.S("Lifecycle#relaunch() - calling app.relaunch()");
              ji.app.relaunch({
                args: i
              });
            }
          };
          ji.app.once("quit", s);
          if (await this.quit(true)) {
            ji.app.removeListener("quit", s);
          }
        }
        async kill(e) {
          this.S("Lifecycle#kill()");
          await this.L(2);
          await Promise.race([wi(1000), (async () => {
            for (const i of ji.BrowserWindow.getAllWindows()) {
              if (i && !i.isDestroyed()) {
                let s;
                if (i.webContents && !i.webContents.isDestroyed()) {
                  s = new Promise(r => i.once("closed", r));
                } else {
                  s = Promise.resolve();
                }
                i.destroy();
                await s;
              }
            }
          })()]);
          ji.app.exit(e);
        }
      };
      Tu = oc = __decorate([__param(0, V), __param(1, Oi), __param(2, ot)], Tu);
    }
  });
  var Is;
  var bi;
  var ac;
  var p1;
  var Uy = g({
    "out-build/vs/base/parts/storage/common/storage.js"() {
      "use strict";
  
      ce();
      B();
      M();
      hu();
      _e();
      (function (t) {
        t[t.STORAGE_DOES_NOT_EXIST = 0] = "STORAGE_DOES_NOT_EXIST";
        t[t.STORAGE_IN_MEMORY = 1] = "STORAGE_IN_MEMORY";
      })(Is ||= {});
      (function (t) {
        t[t.None = 0] = "None";
        t[t.Initialized = 1] = "Initialized";
        t[t.Closed = 2] = "Closed";
      })(bi ||= {});
      ac = class tS extends T {
        static {
          this.a = 100;
        }
        constructor(e, i = Object.create(null)) {
          super();
          this.q = e;
          this.r = i;
          this.b = this.D(new zl());
          this.onDidChangeStorage = this.b.event;
          this.c = bi.None;
          this.f = new Map();
          this.g = this.D(new Ys(tS.a));
          this.h = new Set();
          this.j = new Map();
          this.m = undefined;
          this.n = [];
          this.s();
        }
        s() {
          this.D(this.q.onDidChangeItemsExternal(e => this.t(e)));
        }
        t(e) {
          this.b.pause();
          try {
            e.changed?.forEach((i, s) => this.u(s, i));
            e.deleted?.forEach(i => this.u(i, undefined));
          } finally {
            this.b.resume();
          }
        }
        u(e, i) {
          if (this.c === bi.Closed) {
            return;
          }
          let s = false;
          if (Qt(i)) {
            s = this.f.delete(e);
          } else if (this.f.get(e) !== i) {
            this.f.set(e, i);
            s = true;
          }
          if (s) {
            this.b.fire({
              key: e,
              external: true
            });
          }
        }
        get items() {
          return this.f;
        }
        get size() {
          return this.f.size;
        }
        async init() {
          if (this.c === bi.None) {
            this.c = bi.Initialized;
            if (this.r.hint !== Is.STORAGE_DOES_NOT_EXIST) {
              this.f = await this.q.getItems();
            }
          }
        }
        cursorDiskKVGet(e) {
          return this.q.cursorDiskKVGet(e);
        }
        cursorDiskKVSet(e, i) {
          return this.q.cursorDiskKVSet(e, i);
        }
        cursorDiskKVClearPrefix(e) {
          return this.q.cursorDiskKVClearPrefix(e);
        }
        get(e, i) {
          const s = this.f.get(e);
          if (Qt(s)) {
            return i;
          } else {
            return s;
          }
        }
        getBoolean(e, i) {
          const s = this.get(e);
          if (Qt(s)) {
            return i;
          } else {
            return s === "true";
          }
        }
        getNumber(e, i) {
          const s = this.get(e);
          if (Qt(s)) {
            return i;
          } else {
            return parseInt(s, 10);
          }
        }
        getObject(e, i) {
          const s = this.get(e);
          if (Qt(s)) {
            return i;
          } else {
            return qk(s);
          }
        }
        async set(e, i, s = false) {
          if (this.c === bi.Closed) {
            return;
          }
          if (Qt(i)) {
            return this.delete(e, s);
          }
          const r = Nt(i) || Array.isArray(i) ? Bk(i) : String(i);
          if (this.f.get(e) !== r) {
            this.f.set(e, r);
            this.j.set(e, r);
            this.h.delete(e);
            this.b.fire({
              key: e,
              external: s
            });
            return this.C();
          }
        }
        async delete(e, i = false) {
          if (this.c !== bi.Closed && !!this.f.delete(e)) {
            if (!this.h.has(e)) {
              this.h.add(e);
            }
            this.j.delete(e);
            this.b.fire({
              key: e,
              external: i
            });
            return this.C();
          }
        }
        async optimize() {
          if (this.c !== bi.Closed) {
            await this.flush(0);
            return this.q.optimize();
          }
        }
        async close() {
          this.m ||= this.w();
          return this.m;
        }
        async w() {
          this.c = bi.Closed;
          try {
            await this.C(0);
          } catch {}
          await this.q.close(() => this.f);
        }
        get y() {
          return this.j.size > 0 || this.h.size > 0;
        }
        async z() {
          if (!this.y) {
            return;
          }
          const e = {
            insert: this.j,
            delete: this.h
          };
          this.h = new Set();
          this.j = new Map();
          return this.q.updateItems(e).finally(() => {
            if (!this.y) {
              while (this.n.length) {
                this.n.pop()?.();
              }
            }
          });
        }
        async flush(e) {
          if (this.c !== bi.Closed && !this.m) {
            return this.C(e);
          }
        }
        async C(e) {
          if (this.r.hint === Is.STORAGE_IN_MEMORY) {
            return this.z();
          } else {
            return this.g.trigger(() => this.z(), e);
          }
        }
        async whenFlushed() {
          if (this.y) {
            return new Promise(e => this.n.push(e));
          }
        }
        isInMemory() {
          return this.r.hint === Is.STORAGE_IN_MEMORY;
        }
      };
      p1 = class {
        constructor() {
          this.onDidChangeItemsExternal = x.None;
          this.a = new Map();
        }
        async getItems() {
          return this.a;
        }
        async cursorDiskKVGet(t) {}
        async cursorDiskKVSet(t, e) {}
        async cursorDiskKVClearPrefix(t) {}
        async updateItems(t) {
          t.insert?.forEach((e, i) => this.a.set(i, e));
          t.delete?.forEach(e => this.a.delete(e));
        }
        async optimize() {}
        async close() {}
      };
    }
  });
  function Li(t) {
    const e = t;
    return typeof e?.id == "string" && P.isUri(e.uri);
  }
  function ju(t, e) {
    if (typeof t == "string" || typeof t === "undefined") {
      if (typeof t == "string") {
        return {
          id: Ue(t)
        };
      } else if (e) {
        return qy;
      } else {
        return zy;
      }
    }
    const i = t;
    if (i.configuration) {
      return {
        id: i.id,
        configPath: i.configuration
      };
    } else if (i.folders.length === 1) {
      return {
        id: i.id,
        uri: i.folders[0].uri
      };
    } else {
      return {
        id: i.id
      };
    }
  }
  function Kt(t) {
    const e = t;
    return typeof e?.id == "string" && P.isUri(e.configPath);
  }
  function Lx(t) {
    const e = t;
    if (e?.uri) {
      return {
        id: e.id,
        uri: P.revive(e.uri)
      };
    }
    const i = t;
    if (i?.configPath) {
      return {
        id: i.id,
        configPath: P.revive(i.configPath)
      };
    }
    if (t?.id) {
      return {
        id: t.id
      };
    }
  }
  function By(t, e) {
    return tt.isEqualOrParent(t, e.untitledWorkspacesHome);
  }
  function ln(t) {
    return (typeof t == "string" ? Kl(t) : Mv(t)) === Gy;
  }
  var Mx;
  var qy;
  var zy;
  var Hy;
  var Vy;
  var cc;
  var Gy;
  var Jy;
  var g1;
  var ri = g({
    "out-build/vs/platform/workspace/common/workspace.js"() {
      "use strict";
  
      be();
      we();
      go();
      nt();
      se();
      Y();
      Ie();
      Mx = q("contextService");
      qy = {
        id: "ext-dev"
      };
      zy = {
        id: "empty-window"
      };
      (function (t) {
        t[t.EMPTY = 1] = "EMPTY";
        t[t.FOLDER = 2] = "FOLDER";
        t[t.WORKSPACE = 3] = "WORKSPACE";
      })(Hy ||= {});
      Vy = class {
        constructor(t, e) {
          this.raw = e;
          this.uri = t.uri;
          this.index = t.index;
          this.name = t.name;
        }
        toResource(t) {
          return he(this.uri, t);
        }
        toJSON() {
          return {
            uri: this.uri,
            name: this.name,
            index: this.index
          };
        }
      };
      cc = "code-workspace";
      Gy = `.${cc}`;
      Jy = [{
        name: v(2533, null),
        extensions: [cc]
      }];
      g1 = "workspace.json";
    }
  });
  var yi;
  var As = g({
    "out-build/vs/platform/uriIdentity/common/uriIdentity.js"() {
      "use strict";
  
      Y();
      yi = q("IUriIdentityService");
    }
  });
  function Fx(t) {
    const e = t;
    return !!e && typeof e == "object" && typeof e.id == "string" && typeof e.isDefault == "boolean" && typeof e.name == "string" && !!P.isUri(e.location) && !!P.isUri(e.globalStorageHome) && !!P.isUri(e.settingsResource) && !!P.isUri(e.keybindingsResource) && !!P.isUri(e.tasksResource) && !!P.isUri(e.snippetsHome) && !!P.isUri(e.extensionsResource);
  }
  function Uu(t, e, i, s, r, n) {
    return {
      id: t,
      name: e,
      location: i,
      isDefault: false,
      icon: r?.icon,
      globalStorageHome: n && r?.useDefaultFlags?.globalState ? n.globalStorageHome : he(i, "globalStorage"),
      settingsResource: n && r?.useDefaultFlags?.settings ? n.settingsResource : he(i, "settings.json"),
      keybindingsResource: n && r?.useDefaultFlags?.keybindings ? n.keybindingsResource : he(i, "keybindings.json"),
      tasksResource: n && r?.useDefaultFlags?.tasks ? n.tasksResource : he(i, "tasks.json"),
      snippetsHome: n && r?.useDefaultFlags?.snippets ? n.snippetsHome : he(i, "snippets"),
      extensionsResource: n && r?.useDefaultFlags?.extensions ? n.extensionsResource : he(i, "extensions.json"),
      cacheHome: he(s, t),
      useDefaultFlags: r?.useDefaultFlags,
      isTransient: r?.transient,
      workspaces: r?.workspaces
    };
  }
  var Ky;
  var Cs;
  var Bu;
  var _s = g({
    "out-build/vs/platform/userDataProfile/common/userDataProfile.js"() {
      "use strict";
  
      er();
      B();
      M();
      nt();
      se();
      be();
      Ri();
      He();
      Y();
      X();
      ri();
      As();
      ce();
      _i();
      Wt();
      _e();
      (function (t) {
        t.Settings = "settings";
        t.Keybindings = "keybindings";
        t.Snippets = "snippets";
        t.Tasks = "tasks";
        t.Extensions = "extensions";
        t.GlobalState = "globalState";
      })(Ky ||= {});
      Cs = q("IUserDataProfilesService");
      Bu = class extends T {
        static {
          this.b = "userDataProfiles";
        }
        static {
          this.c = "profileAssociations";
        }
        get defaultProfile() {
          return this.profiles[0];
        }
        get profiles() {
          return [...this.z.profiles, ...this.q.profiles];
        }
        constructor(e, i, s, r) {
          super();
          this.r = e;
          this.s = i;
          this.t = s;
          this.u = r;
          this.g = this.D(new $());
          this.onDidChangeProfiles = this.g.event;
          this.h = this.D(new $());
          this.onWillCreateProfile = this.h.event;
          this.j = this.D(new $());
          this.onWillRemoveProfile = this.j.event;
          this.m = this.D(new $());
          this.onDidResetWorkspaces = this.m.event;
          this.n = new Map();
          this.q = {
            profiles: [],
            emptyWindows: new Map()
          };
          this.profilesHome = he(this.r.userRoamingDataHome, "profiles");
          this.f = he(this.r.cacheHome, "CachedProfilesData");
        }
        init() {
          this.y = undefined;
        }
        get z() {
          if (!this.y) {
            const e = this.C();
            const i = [e];
            try {
              for (const r of this.N()) {
                if (!r.name || !wt(r.name) || !r.location) {
                  this.u.warn("Skipping the invalid stored profile", r.location || r.name);
                  continue;
                }
                i.push(Uu(ks(r.location), r.name, r.location, this.f, {
                  icon: r.icon,
                  useDefaultFlags: r.useDefaultFlags
                }, e));
              }
            } catch (r) {
              this.u.error(r);
            }
            const s = new Map();
            if (i.length) {
              try {
                const r = this.P();
                if (r.workspaces) {
                  for (const [n, o] of Object.entries(r.workspaces)) {
                    const a = P.parse(n);
                    const c = i.find(l => l.id === o);
                    if (c) {
                      const l = c.workspaces ? c.workspaces.slice(0) : [];
                      l.push(a);
                      c.workspaces = l;
                    }
                  }
                }
                if (r.emptyWindows) {
                  for (const [n, o] of Object.entries(r.emptyWindows)) {
                    const a = i.find(c => c.id === o);
                    if (a) {
                      s.set(n, a);
                    }
                  }
                }
              } catch (r) {
                this.u.error(r);
              }
            }
            this.y = {
              profiles: i,
              emptyWindows: s
            };
          }
          return this.y;
        }
        C() {
          const e = Uu("__default__profile__", v(2486, null), this.r.userRoamingDataHome, this.f);
          return {
            ...e,
            extensionsResource: this.R() ?? e.extensionsResource,
            isDefault: true
          };
        }
        async createTransientProfile(e) {
          const i = "Temp";
          const s = new RegExp(`${ja(i)}\\s(\\d+)`);
          let r = 0;
          for (const o of this.profiles) {
            const a = s.exec(o.name);
            const c = a ? parseInt(a[1]) : 0;
            r = c > r ? c : r;
          }
          const n = `${i} ${r + 1}`;
          return this.createProfile(Ds(ti()).toString(16), n, {
            transient: true
          }, e);
        }
        async createNamedProfile(e, i, s) {
          return this.createProfile(Ds(ti()).toString(16), e, i, s);
        }
        async createProfile(e, i, s, r) {
          return await this.F(e, i, s, r);
        }
        async F(e, i, s, r) {
          if (!wt(i) || !i) {
            throw new Error("Name of the profile is mandatory and must be of type `string`");
          }
          let n = this.n.get(i);
          if (!n) {
            n = (async () => {
              try {
                if (this.profiles.find(u => u.id === e || !u.isTransient && !s?.transient && u.name === i)) {
                  throw new Error(`Profile with ${i} name already exists`);
                }
                const a = r ? this.G(r) : undefined;
                if (P.isUri(a)) {
                  s = {
                    ...s,
                    workspaces: [a]
                  };
                }
                const c = Uu(e, i, he(this.profilesHome, e), this.f, s, this.defaultProfile);
                await this.s.createFolder(c.location);
                const l = [];
                this.h.fire({
                  profile: c,
                  join(u) {
                    l.push(u);
                  }
                });
                await Tt.settled(l);
                if (a && !P.isUri(a)) {
                  this.L(a, c, !!c.isTransient);
                }
                this.I([c], [], []);
                return c;
              } finally {
                this.n.delete(i);
              }
            })();
            this.n.set(i, n);
          }
          return n;
        }
        async updateProfile(e, i) {
          const s = [];
          for (const n of this.profiles) {
            let o;
            if (e.id === n.id) {
              if (n.isDefault) {
                if (i.workspaces) {
                  o = n;
                  o.workspaces = i.workspaces;
                }
              } else {
                o = Uu(n.id, i.name ?? n.name, n.location, this.f, {
                  icon: i.icon === null ? undefined : i.icon ?? n.icon,
                  transient: i.transient ?? n.isTransient,
                  useDefaultFlags: i.useDefaultFlags ?? n.useDefaultFlags,
                  workspaces: i.workspaces ?? n.workspaces
                }, this.defaultProfile);
              }
            } else if (i.workspaces) {
              const a = n.workspaces?.filter(c => !i.workspaces?.some(l => this.t.extUri.isEqual(c, l)));
              if (n.workspaces?.length !== a?.length) {
                o = n;
                o.workspaces = a;
              }
            }
            if (o) {
              s.push(o);
            }
          }
          if (!s.length) {
            throw e.isDefault ? new Error("Cannot update default profile") : new Error(`Profile '${e.name}' does not exist`);
          }
          this.I([], [], s);
          const r = this.profiles.find(n => n.id === e.id);
          if (!r) {
            throw new Error(`Profile '${e.name}' was not updated`);
          }
          return r;
        }
        async removeProfile(e) {
          if (e.isDefault) {
            throw new Error("Cannot remove default profile");
          }
          const i = this.profiles.find(r => r.id === e.id);
          if (!i) {
            throw new Error(`Profile '${e.name}' does not exist`);
          }
          const s = [];
          this.j.fire({
            profile: i,
            join(r) {
              s.push(r);
            }
          });
          try {
            await Promise.allSettled(s);
          } catch (r) {
            this.u.error(r);
          }
          this.I([], [i], []);
          try {
            await this.s.del(i.cacheHome, {
              recursive: true
            });
          } catch (r) {
            if ($s(r) !== 1) {
              this.u.error(r);
            }
          }
        }
        async setProfileForWorkspace(e, i) {
          const s = this.profiles.find(n => n.id === i.id);
          if (!s) {
            throw new Error(`Profile '${i.name}' does not exist`);
          }
          const r = this.G(e);
          if (P.isUri(r)) {
            const n = s.workspaces ? [...s.workspaces] : [];
            if (!n.some(o => this.t.extUri.isEqual(o, r))) {
              n.push(r);
              await this.updateProfile(s, {
                workspaces: n
              });
            }
          } else {
            this.L(r, s, false);
            this.M(this.profiles);
          }
        }
        unsetWorkspace(e, i = false) {
          const s = this.G(e);
          if (P.isUri(s)) {
            const r = this.getProfileForWorkspace(e);
            if (r) {
              this.updateProfile(r, {
                workspaces: r.workspaces?.filter(n => !this.t.extUri.isEqual(n, s))
              });
            }
          } else {
            this.L(s, undefined, i);
            this.M(this.profiles);
          }
        }
        async resetWorkspaces() {
          this.q.emptyWindows.clear();
          this.z.emptyWindows.clear();
          for (const e of this.profiles) {
            e.workspaces = undefined;
          }
          this.I([], [], this.profiles);
          this.m.fire();
        }
        async cleanUp() {
          if (await this.s.exists(this.profilesHome)) {
            const e = await this.s.resolve(this.profilesHome);
            await Promise.all((e.children || []).filter(i => i.isDirectory && this.profiles.every(s => !this.t.extUri.isEqual(s.location, i.resource))).map(i => this.s.del(i.resource, {
              recursive: true
            })));
          }
        }
        async cleanUpTransientProfiles() {
          const e = this.q.profiles.filter(i => !this.H(i));
          await Promise.allSettled(e.map(i => this.removeProfile(i)));
        }
        getProfileForWorkspace(e) {
          const i = this.G(e);
          if (P.isUri(i)) {
            return this.profiles.find(s => s.workspaces?.some(r => this.t.extUri.isEqual(r, i)));
          } else {
            return this.z.emptyWindows.get(i) ?? this.q.emptyWindows.get(i);
          }
        }
        G(e) {
          if (Li(e)) {
            return e.uri;
          } else if (Kt(e)) {
            return e.configPath;
          } else {
            return e.id;
          }
        }
        H(e) {
          return !!e.workspaces?.length || !![...this.z.emptyWindows.values()].some(i => this.t.extUri.isEqual(i.location, e.location)) || !![...this.q.emptyWindows.values()].some(i => this.t.extUri.isEqual(i.location, e.location));
        }
        I(e, i, s) {
          const r = [...this.profiles, ...e];
          const n = this.q.profiles;
          this.q.profiles = [];
          const o = [];
          for (let a of r) {
            if (i.some(c => a.id === c.id)) {
              for (const c of [...this.z.emptyWindows.keys()]) {
                if (a.id === this.z.emptyWindows.get(c)?.id) {
                  this.z.emptyWindows.delete(c);
                }
              }
              continue;
            }
            if (!a.isDefault) {
              a = s.find(l => a.id === l.id) ?? a;
              const c = n.find(l => a.id === l.id);
              if (a.isTransient) {
                this.q.profiles.push(a);
              } else if (c) {
                for (const [l, u] of this.q.emptyWindows.entries()) {
                  if (a.id === u.id) {
                    this.q.emptyWindows.delete(l);
                    this.z.emptyWindows.set(l, a);
                    break;
                  }
                }
              }
            }
            if (a.workspaces?.length === 0) {
              a.workspaces = undefined;
            }
            o.push(a);
          }
          this.M(o);
          this.J(e, i, s);
        }
        J(e, i, s) {
          this.g.fire({
            added: e,
            removed: i,
            updated: s,
            all: this.profiles
          });
        }
        L(e, i, s) {
          s = i?.isTransient ? true : s;
          if (s) {
            if (i) {
              this.q.emptyWindows.set(e, i);
            } else {
              this.q.emptyWindows.delete(e);
            }
          } else {
            this.q.emptyWindows.delete(e);
            if (i) {
              this.z.emptyWindows.set(e, i);
            } else {
              this.z.emptyWindows.delete(e);
            }
          }
        }
        M(e) {
          const i = [];
          const s = {};
          const r = {};
          for (const n of e) {
            if (!n.isTransient && (n.isDefault || i.push({
              location: n.location,
              name: n.name,
              icon: n.icon,
              useDefaultFlags: n.useDefaultFlags
            }), n.workspaces)) {
              for (const o of n.workspaces) {
                s[o.toString()] = n.id;
              }
            }
          }
          for (const [n, o] of this.z.emptyWindows.entries()) {
            r[n.toString()] = o.id;
          }
          this.Q({
            workspaces: s,
            emptyWindows: r
          });
          this.O(i);
          this.y = undefined;
        }
        N() {
          return [];
        }
        O(e) {
          throw new Error("not implemented");
        }
        P() {
          return {};
        }
        Q(e) {
          throw new Error("not implemented");
        }
        R() {}
      };
      Bu = __decorate([__param(0, Yi), __param(1, at), __param(2, yi), __param(3, V)], Bu);
    }
  });
  function m1(t) {
    const e = t.get(sr);
    if (e) {
      try {
        return JSON.parse(e);
      } catch {}
    }
    return Object.create(null);
  }
  function w1(t) {
    return t.isDefault || !!t.useDefaultFlags?.globalState;
  }
  async function Nx(t, e, i, s, r, n) {
    const o = m => {
      try {
        return JSON.parse(m);
      } catch {
        return m;
      }
    };
    const a = new Map();
    const c = new Map();
    t.forEach((m, y) => {
      a.set(y, m);
      c.set(y, o(m));
    });
    const l = new Map();
    const u = new Map();
    e.forEach((m, y) => {
      l.set(y, m);
      u.set(y, o(m));
    });
    const d = new Map();
    const f = new Map();
    i.forEach((m, y) => {
      d.set(y, m);
      f.set(y, o(m));
    });
    console.group(s !== r ? `Storage: Application (path: ${s})` : `Storage: Application & Profile (path: ${s}, default profile)`);
    const p = [];
    a.forEach((m, y) => {
      p.push({
        key: y,
        value: m
      });
    });
    console.table(p);
    console.groupEnd();
    console.log(c);
    if (s !== r) {
      console.group(`Storage: Profile (path: ${r}, profile specific)`);
      const m = [];
      l.forEach((y, b) => {
        m.push({
          key: b,
          value: y
        });
      });
      console.table(m);
      console.groupEnd();
      console.log(u);
    }
    console.group(`Storage: Workspace (path: ${n})`);
    const w = [];
    d.forEach((m, y) => {
      w.push({
        key: y,
        value: m
      });
    });
    console.table(w);
    console.groupEnd();
    console.log(f);
  }
  var lc;
  var sr;
  var Wx;
  var vo;
  var Zy;
  var Yy;
  var Xy;
  var v1 = g({
    "out-build/vs/platform/storage/common/storage.js"() {
      "use strict";
  
      ce();
      B();
      M();
      Hs();
      _e();
      Uy();
      Y();
      _s();
      lc = "__$__isNewStorageMarker";
      sr = "__$__targetStorageMarker";
      Wx = q("storageService");
      (function (t) {
        t[t.NONE = 0] = "NONE";
        t[t.SHUTDOWN = 1] = "SHUTDOWN";
      })(vo ||= {});
      (function (t) {
        t[t.APPLICATION = -1] = "APPLICATION";
        t[t.PROFILE = 0] = "PROFILE";
        t[t.WORKSPACE = 1] = "WORKSPACE";
      })(Zy ||= {});
      (function (t) {
        t[t.USER = 0] = "USER";
        t[t.MACHINE = 1] = "MACHINE";
      })(Yy ||= {});
      Xy = class iS extends T {
        static {
          this.a = 60000;
        }
        constructor(e = {
          flushInterval: iS.a
        }) {
          super();
          this.n = e;
          this.b = this.D(new zl());
          this.f = this.D(new zl());
          this.onDidChangeTarget = this.f.event;
          this.g = this.D(new $());
          this.onWillSaveState = this.g.event;
          this.j = this.D(new os(() => this.q(), this.n.flushInterval));
          this.m = this.D(new pr());
          this.C = undefined;
          this.G = undefined;
          this.I = undefined;
          this.N = [];
        }
        onDidChangeValue(e, i, s) {
          return x.filter(this.b.event, r => r.scope === e && (i === undefined || r.key === i), s);
        }
        q() {
          this.m.value = Rp(() => {
            if (this.r()) {
              this.flush();
            }
            this.j.schedule();
          });
        }
        r() {
          return true;
        }
        t() {
          Et([this.m, this.j]);
        }
        initialize() {
          this.h ||= (async () => {
            Ne("code/willInitStorage");
            try {
              await this.Q();
            } finally {
              Ne("code/didInitStorage");
            }
            this.j.schedule();
          })();
          return this.h;
        }
        u(e, i) {
          const {
            key: s,
            external: r
          } = i;
          if (s === sr) {
            switch (e) {
              case -1:
                this.I = undefined;
                break;
              case 0:
                this.G = undefined;
                break;
              case 1:
                this.C = undefined;
                break;
            }
            this.f.fire({
              scope: e
            });
          } else {
            this.b.fire({
              scope: e,
              key: s,
              target: this.L(e)[s],
              external: r
            });
          }
        }
        w(e) {
          this.g.fire({
            reason: e
          });
        }
        get(e, i, s) {
          return this.R(i)?.get(e, s);
        }
        getBoolean(e, i, s) {
          return this.R(i)?.getBoolean(e, s);
        }
        getNumber(e, i, s) {
          return this.R(i)?.getNumber(e, s);
        }
        getObject(e, i, s) {
          return this.R(i)?.getObject(e, s);
        }
        storeAll(e, i) {
          this.y(() => {
            for (const s of e) {
              this.store(s.key, s.value, s.scope, s.target, i);
            }
          });
        }
        store(e, i, s, r, n = false) {
          if (Qt(i)) {
            this.remove(e, s, n);
            return;
          }
          this.y(() => {
            this.z(e, s, r);
            this.R(s)?.set(e, i, n);
          });
        }
        remove(e, i, s = false) {
          this.y(() => {
            this.z(e, i, undefined);
            this.R(i)?.delete(e, s);
          });
        }
        y(e) {
          this.b.pause();
          this.f.pause();
          try {
            e();
          } finally {
            this.b.resume();
            this.f.resume();
          }
        }
        keys(e, i) {
          const s = [];
          const r = this.L(e);
          for (const n of Object.keys(r)) {
            if (r[n] === i) {
              s.push(n);
            }
          }
          return s;
        }
        z(e, i, s, r = false) {
          const n = this.L(i);
          if (typeof s == "number") {
            if (n[e] !== s) {
              n[e] = s;
              this.R(i)?.set(sr, JSON.stringify(n), r);
            }
          } else if (typeof n[e] == "number") {
            delete n[e];
            this.R(i)?.set(sr, JSON.stringify(n), r);
          }
        }
        get F() {
          this.C ||= this.M(1);
          return this.C;
        }
        get H() {
          this.G ||= this.M(0);
          return this.G;
        }
        get J() {
          this.I ||= this.M(-1);
          return this.I;
        }
        L(e) {
          switch (e) {
            case -1:
              return this.J;
            case 0:
              return this.H;
            default:
              return this.F;
          }
        }
        M(e) {
          const i = this.R(e);
          if (i) {
            return m1(i);
          } else {
            return Object.create(null);
          }
        }
        isNew(e) {
          return this.getBoolean(lc, e) === true;
        }
        async cursorDiskKVGet(e) {
          return this.R(-1)?.cursorDiskKVGet(e);
        }
        async cursorDiskKVSet(e, i) {
          return this.R(-1)?.cursorDiskKVSet(e, i);
        }
        async cursorDiskKVClearPrefix(e) {
          return this.R(-1)?.cursorDiskKVClearPrefix(e);
        }
        cursorDiskKVOnShouldSave(e) {
          this.N.push(e);
          return {
            dispose: () => {
              this.N = this.N.filter(i => i !== e);
            }
          };
        }
        async flush(e = vo.NONE) {
          this.g.fire({
            reason: e
          });
          const i = this.R(-1);
          const s = this.R(0);
          const r = this.R(1);
          switch (e) {
            case vo.NONE:
              for (const n of this.N) {
                try {
                  n().catch(console.error);
                } catch {}
              }
              await Tt.settled([i?.whenFlushed() ?? Promise.resolve(), s?.whenFlushed() ?? Promise.resolve(), r?.whenFlushed() ?? Promise.resolve()]);
              break;
            case vo.SHUTDOWN:
              for (const n of this.N) {
                try {
                  await n();
                } catch (o) {
                  console.error(o);
                }
              }
              await Tt.settled([i?.flush(0) ?? Promise.resolve(), s?.flush(0) ?? Promise.resolve(), r?.flush(0) ?? Promise.resolve()]);
              break;
          }
        }
        async log() {
          const e = this.R(-1)?.items ?? new Map();
          const i = this.R(0)?.items ?? new Map();
          const s = this.R(1)?.items ?? new Map();
          return Nx(e, i, s, this.S(-1) ?? "", this.S(0) ?? "", this.S(1) ?? "");
        }
        async optimize(e) {
          await this.flush();
          return this.R(e)?.optimize();
        }
        async switch(e, i) {
          this.w(vo.NONE);
          if (Fx(e)) {
            return this.U(e, i);
          } else {
            return this.W(e, i);
          }
        }
        O(e, i) {
          return e.id !== i.id && (!w1(i) || !w1(e));
        }
        P(e, i, s) {
          this.y(() => {
            const r = new Set();
            for (const [n, o] of e) {
              r.add(n);
              if (i.get(n) !== o) {
                this.u(s, {
                  key: n,
                  external: true
                });
              }
            }
            for (const [n] of i.items) {
              if (!r.has(n)) {
                this.u(s, {
                  key: n,
                  external: true
                });
              }
            }
          });
        }
      };
    }
  });
  var Tx;
  var Qy;
  var e4;
  var qu;
  var jx;
  var t4;
  var Ux;
  var i4;
  var s4;
  var r4;
  var n4;
  var b1 = g({
    "out-build/vs/base/common/constants.js"() {
      "use strict";
  
      Tx = Date.now();
      Qy = false;
      e4 = "cursorai.action.windowInWindowDidShow";
      qu = "src.vs.platform.reactivestorage.browser.reactiveStorageServiceImpl.persistentStorage";
      jx = `${qu}.applicationUser`;
      t4 = `${qu}.workspaceUser`;
      Ux = `${qu}.applicationUser.subscription`;
      i4 = "workbench.panel.aichat.view";
      s4 = i4 + ".aichat.chatdata";
      r4 = "composer.composerData";
      n4 = "workbench.bugbot.data";
    }
  });
  import * as o4 from "fs";
  var uc;
  var a4;
  var Bx = g({
    "out-build/vs/base/parts/storage/node/storage.js"() {
      "use strict";
  
      ce();
      B();
      $i();
      we();
      _t();
      b1();
      uc = class jn {
        static {
          this.IN_MEMORY_PATH = ":memory:";
        }
        get onDidChangeItemsExternal() {
          return x.None;
        }
        static {
          this.a = 2000;
        }
        static {
          this.b = 256;
        }
        constructor(e, i = Object.create(null)) {
          this.g = e;
          this.h = i;
          this.c = Ue(this.g);
          this.d = new a4(this.h.logging);
          this.f = this.n(this.g);
        }
        async cursorDiskKVGet(e) {
          const i = await this.f;
          try {
            const s = await this.s(i, "SELECT value FROM cursorDiskKV WHERE key = ?", [e]);
            if (!s) {
              return;
            }
            const r = s.value;
            if (r == null || typeof r != "string") {
              return undefined;
            } else {
              return r;
            }
          } catch (s) {
            this.d.error(`[storage ${this.c}] cursorDiskKVGet(${e}): ${s}`);
            return;
          }
        }
        async cursorDiskKVSet(e, i) {
          const s = await this.f;
          try {
            await this.y(s, "INSERT INTO cursorDiskKV (key, value) VALUES (?, ?)", [e, i]);
          } catch (r) {
            this.d.error(`[storage ${this.c}] cursorDiskKVSet(${e}): ${r}`);
            throw r;
          }
        }
        async cursorDiskKVClearPrefix(e) {
          const i = await this.f;
          try {
            await this.y(i, "DELETE FROM cursorDiskKV WHERE key LIKE ? || '%'", [e]);
          } catch (s) {
            this.d.error(`[storage ${this.c}] cursorDiskKVClearPrefix(${e}): ${s}`);
            throw s;
          }
        }
        async getItems() {
          const e = await this.f;
          const i = new Map();
          await Promise.allSettled([this.t(e, t4, {
            timeout: 10000,
            maxSizeBytes: 104857600
          }), this.t(e, s4, {
            timeout: 10000,
            maxSizeBytes: 104857600
          }), this.t(e, r4, {
            timeout: 10000,
            maxSizeBytes: 104857600
          }), this.t(e, n4, {
            timeout: 10000,
            maxSizeBytes: 52428800
          })]);
          (await this.v(e, "SELECT * FROM ItemTable")).forEach(r => i.set(r.key, r.value));
          if (this.d.isTracing) {
            this.d.trace(`[storage ${this.c}] getItems(): ${i.size} rows`);
          }
          return i;
        }
        async updateItems(e) {
          const i = await this.f;
          return this.j(i, e);
        }
        j(e, i) {
          if (this.d.isTracing) {
            this.d.trace(`[storage ${this.c}] updateItems(): insert(${i.insert ? QS(i.insert) : "0"}), delete(${i.delete ? eE(i.delete) : "0"})`);
          }
          return this.w(e, () => {
            const s = i.insert;
            const r = i.delete;
            if (s && s.size > 0) {
              const n = [];
              n.push([]);
              let o = 0;
              s.forEach((a, c) => {
                let l = n[o];
                if (l.length > jn.b) {
                  o++;
                  l = [];
                  n.push(l);
                }
                l.push(c, a);
              });
              n.forEach(a => {
                this.x(e, `INSERT INTO ItemTable VALUES ${new Array(a.length / 2).fill("(?,?)").join(",")}`, c => c.run(a), () => {
                  const c = [];
                  let l = 0;
                  s.forEach((u, d) => {
                    c.push(d);
                    l += u.length;
                  });
                  return `Keys: ${c.join(", ")} Length: ${l}`;
                });
              });
            }
            if (r && r.size) {
              const n = [];
              n.push([]);
              let o = 0;
              r.forEach(a => {
                let c = n[o];
                if (c.length > jn.b) {
                  o++;
                  c = [];
                  n.push(c);
                }
                c.push(a);
              });
              n.forEach(a => {
                this.x(e, `DELETE FROM ItemTable WHERE key IN (${new Array(a.length).fill("?").join(",")})`, c => c.run(a), () => {
                  const c = [];
                  r.forEach(l => {
                    c.push(l);
                  });
                  return `Keys: ${c.join(", ")}`;
                });
              });
            }
          });
        }
        async optimize() {
          this.d.trace(`[storage ${this.c}] vacuum()`);
          const e = await this.f;
          return this.q(e, "VACUUM");
        }
        async close(e) {
          this.d.trace(`[storage ${this.c}] close()`);
          const i = await this.f;
          return this.k(i, e);
        }
        k(e, i) {
          return new Promise((s, r) => {
            e.db.close(n => {
              if (n) {
                this.o(e, `[storage ${this.c}] close(): ${n}`);
              }
              if (this.g === jn.IN_MEMORY_PATH) {
                return s();
              } else if (!e.isErroneous && !e.isInMemory) {
                return this.l().then(s, o => {
                  this.d.error(`[storage ${this.c}] backup(): ${o}`);
                  return s();
                });
              } else if (typeof i == "function") {
                return o4.promises.unlink(this.g).then(() => this.p(this.g).then(o => {
                  const a = () => this.k(o, undefined);
                  return this.j(o, {
                    insert: i()
                  }).then(() => a(), c => {
                    a();
                    return Promise.reject(c);
                  });
                })).then(s, r);
              } else {
                return r(n || new Error("Database has errors or is in-memory without recovery option"));
              }
            });
          });
        }
        l() {
          const e = this.m(this.g);
          return ee.copy(this.g, e, {
            preserveSymlinks: false
          });
        }
        m(e) {
          return `${e}.backup`;
        }
        async checkIntegrity(e) {
          this.d.trace(`[storage ${this.c}] checkIntegrity(full: ${e})`);
          const i = await this.f;
          const s = await this.r(i, e ? "PRAGMA integrity_check" : "PRAGMA quick_check");
          const r = e ? s.integrity_check : s.quick_check;
          if (i.isErroneous) {
            return `${r} (last error: ${i.lastError})`;
          } else if (i.isInMemory) {
            return `${r} (in-memory!)`;
          } else {
            return r;
          }
        }
        async n(e, i = true) {
          this.d.trace(`[storage ${this.c}] open(${e}, retryOnBusy: ${i})`);
          try {
            return await this.p(e);
          } catch (s) {
            this.d.error(`[storage ${this.c}] open(): Unable to open DB due to ${s}`);
            if (s.code === "SQLITE_BUSY" && i) {
              await wi(jn.a);
              return this.n(e, false);
            }
            try {
              await o4.promises.unlink(e);
              try {
                await ee.rename(this.m(e), e, false);
              } catch {}
              return await this.p(e);
            } catch (r) {
              this.d.error(`[storage ${this.c}] open(): Unable to use backup due to ${r}`);
              return this.p(jn.IN_MEMORY_PATH);
            }
          }
        }
        o(e, i) {
          e.isErroneous = true;
          e.lastError = i;
          this.d.error(i);
        }
        p(e) {
          return new Promise((i, s) => {
            import("@vscode/sqlite3").then(r => {
              const n = this.d.isTracing ? r.default.verbose().Database : r.default.Database;
              const o = {
                db: new n(e, a => a ? o.db && a.code !== "SQLITE_CANTOPEN" ? o.db.close(() => s(a)) : s(a) : this.q(o, ["PRAGMA user_version = 1;", "CREATE TABLE IF NOT EXISTS ItemTable (key TEXT UNIQUE ON CONFLICT REPLACE, value BLOB);", "CREATE TABLE IF NOT EXISTS cursorDiskKV (key TEXT UNIQUE ON CONFLICT REPLACE, value BLOB);"].join("")).then(() => i(o), c => o.db.close(() => s(c)))),
                isInMemory: e === jn.IN_MEMORY_PATH
              };
              o.db.on("error", a => this.o(o, `[storage ${this.c}] Error (event): ${a}`));
              if (this.d.isTracing) {
                o.db.on("trace", a => this.d.trace(`[storage ${this.c}] Trace (event): ${a}`));
              }
            }, s);
          });
        }
        q(e, i) {
          return new Promise((s, r) => {
            e.db.exec(i, n => n ? (this.o(e, `[storage ${this.c}] exec(): ${n}`), r(n)) : s());
          });
        }
        r(e, i) {
          return new Promise((s, r) => {
            e.db.get(i, (n, o) => n ? (this.o(e, `[storage ${this.c}] get(): ${n}`), r(n)) : s(o));
          });
        }
        s(e, i, s) {
          return new Promise((r, n) => {
            e.db.get(i, s, (o, a) => o ? (this.o(e, `[storage ${this.c}] getParams(): ${o}`), n(o)) : r(a));
          });
        }
        async t(e, i, s) {
          if ((await Promise.race([this.u(e, i, s.maxSizeBytes), new Promise((n, o) => setTimeout(() => n(false), s.timeout))])) === false) {
            await this.updateItems({
              delete: new Set([i])
            });
          }
        }
        async u(e, i, s) {
          try {
            const r = await new Promise((n, o) => {
              e.db.all(`SELECT LENGTH(value) as size FROM ItemTable WHERE key = '${i}'`, (a, c) => a ? (this.o(e, `[storage ${this.c}] getSize(${i}): ${a}`), o(a)) : c.length === 0 ? n(0) : c.length !== 1 ? o(new Error(`Unexpected number of rows - ${c.length}`)) : n(c[0].size));
            });
            this.d.trace(`[storage ${this.c}] ${i} is ${r} bytes and can be at most ${s} bytes`);
            if (r > s) {
              this.d.error(`[storage ${this.c}] ${i} is too large (${r} > ${s}), clearing`);
              await this.updateItems({
                delete: new Set([i])
              });
            }
          } catch (r) {
            this.d.error(`[storage ${this.c}] error checking size of ${i}: ${r}`);
          }
        }
        v(e, i) {
          return new Promise((s, r) => {
            e.db.all(i, (n, o) => n ? (this.o(e, `[storage ${this.c}] all(): ${n}`), r(n)) : s(o));
          });
        }
        w(e, i) {
          return new Promise((s, r) => {
            e.db.serialize(() => {
              e.db.run("BEGIN TRANSACTION");
              i();
              e.db.run("END TRANSACTION", n => n ? (this.o(e, `[storage ${this.c}] transaction(): ${n}`), r(n)) : s());
            });
          });
        }
        x(e, i, s, r) {
          const n = e.db.prepare(i);
          const o = a => {
            this.o(e, `[storage ${this.c}] prepare(): ${a} (${i}). Details: ${r()}`);
          };
          n.on("error", o);
          s(n);
          n.finalize(a => {
            if (a) {
              o(a);
            }
            n.removeListener("error", o);
          });
        }
        y(e, i, s) {
          return new Promise((r, n) => {
            e.db.run(i, s, o => o ? (this.o(e, `[storage ${this.c}] runParams(): ${o}`), n(o)) : r());
          });
        }
      };
      a4 = class sS {
        static {
          this.a = "VSCODE_TRACE_STORAGE";
        }
        constructor(e) {
          if (e && typeof e.logTrace == "function" && process.env[sS.a]) {
            this.b = e.logTrace;
          }
          if (e && typeof e.logError == "function") {
            this.c = e.logError;
          }
        }
        get isTracing() {
          return !!this.b;
        }
        trace(e) {
          this.b?.(e);
        }
        error(e) {
          this.c?.(e);
        }
      };
    }
  });
  var Ot;
  var qx;
  var y1;
  var S1;
  var c4;
  var E1;
  var k1;
  var x1;
  var zu;
  var l4;
  var Hu;
  var D1;
  var P1;
  var u4;
  var h4;
  var xt = g({
    "out-build/vs/platform/telemetry/common/telemetry.js"() {
      "use strict";
  
      Y();
      Ot = q("telemetryService");
      qx = q("customEndpointTelemetryService");
      y1 = "telemetry.currentSessionDate";
      S1 = "telemetry.firstSessionDate";
      c4 = "telemetry.lastSessionDate";
      E1 = "telemetry.machineId";
      k1 = "telemetry.macMachineId";
      x1 = "telemetry.sqmId";
      zu = "telemetry.devDeviceId";
      l4 = "crashReporting";
      Hu = "crashReporting.enabled";
      D1 = "telemetry.enableCrashReporter";
      P1 = "telemetry.enableTelemetry";
      (function (t) {
        t[t.NONE = 0] = "NONE";
        t[t.CRASH = 1] = "CRASH";
        t[t.ERROR = 2] = "ERROR";
        t[t.USAGE = 3] = "USAGE";
      })(u4 ||= {});
      (function (t) {
        t.OFF = "off";
        t.ON = "all";
      })(h4 ||= {});
    }
  });
  function zx(t, e) {
    switch (t) {
      case 3:
        if (e === "x64") {
          return "win32-x64";
        } else if (e === "arm64") {
          return "win32-arm64";
        } else {
          return "unknown";
        }
      case 2:
        if (e === "x64") {
          return "linux-x64";
        } else if (e === "arm64") {
          return "linux-arm64";
        } else if (e === "arm") {
          return "linux-armhf";
        } else {
          return "unknown";
        }
      case "alpine":
        if (e === "x64") {
          return "alpine-x64";
        } else if (e === "arm64") {
          return "alpine-arm64";
        } else {
          return "unknown";
        }
      case 1:
        if (e === "x64") {
          return "darwin-x64";
        } else if (e === "arm64") {
          return "darwin-arm64";
        } else {
          return "unknown";
        }
      case 0:
        return "web";
    }
  }
  function Hx(t) {
    return t && typeof t == "object" && typeof t.id == "string" && (!t.uuid || typeof t.uuid == "string");
  }
  var d4;
  var Vx;
  var f4;
  var p4;
  var g4;
  var m4;
  var w4;
  var Gx;
  var v4;
  var b4;
  var $1;
  var Jx;
  var y4;
  var Kx;
  var Zx;
  var Yx;
  var Xx;
  var Qx;
  var Vu = g({
    "out-build/vs/platform/extensionManagement/common/extensionManagement.js"() {
      "use strict";
  
      be();
      Y();
      d4 = "^([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$";
      Vx = new RegExp(d4);
      (function (t) {
        t.COMMAND = "command";
        t.SETTINGS_SYNC = "settingsSync";
      })(f4 ||= {});
      (function (t) {
        t[t.NoneOrRelevance = 0] = "NoneOrRelevance";
        t[t.LastUpdatedDate = 1] = "LastUpdatedDate";
        t[t.Title = 2] = "Title";
        t[t.PublisherName = 3] = "PublisherName";
        t[t.InstallCount = 4] = "InstallCount";
        t[t.PublishedDate = 10] = "PublishedDate";
        t[t.AverageRating = 6] = "AverageRating";
        t[t.WeightedRating = 12] = "WeightedRating";
      })(p4 ||= {});
      (function (t) {
        t[t.Default = 0] = "Default";
        t[t.Ascending = 1] = "Ascending";
        t[t.Descending = 2] = "Descending";
      })(g4 ||= {});
      (function (t) {
        t.Install = "install";
        t.Uninstall = "uninstall";
      })(m4 ||= {});
      (function (t) {
        t[t.None = 1] = "None";
        t[t.Install = 2] = "Install";
        t[t.Update = 3] = "Update";
        t[t.Migrate = 4] = "Migrate";
      })(w4 ||= {});
      Gx = q("extensionGalleryService");
      (function (t) {
        t.Timeout = "Timeout";
        t.Cancelled = "Cancelled";
        t.Failed = "Failed";
        t.DownloadFailedWriting = "DownloadFailedWriting";
        t.Offline = "Offline";
      })(v4 ||= {});
      (function (t) {
        t.Unsupported = "Unsupported";
        t.Deprecated = "Deprecated";
        t.Malicious = "Malicious";
        t.Incompatible = "Incompatible";
        t.IncompatibleApi = "IncompatibleApi";
        t.IncompatibleTargetPlatform = "IncompatibleTargetPlatform";
        t.ReleaseVersionNotFound = "ReleaseVersionNotFound";
        t.Invalid = "Invalid";
        t.Download = "Download";
        t.DownloadSignature = "DownloadSignature";
        t.DownloadFailedWriting = "DownloadFailedWriting";
        t.UpdateMetadata = "UpdateMetadata";
        t.Extract = "Extract";
        t.Scanning = "Scanning";
        t.ScanningExtension = "ScanningExtension";
        t.ReadUninstalled = "ReadUninstalled";
        t.UnsetUninstalled = "UnsetUninstalled";
        t.Delete = "Delete";
        t.Rename = "Rename";
        t.IntializeDefaultProfile = "IntializeDefaultProfile";
        t.AddToProfile = "AddToProfile";
        t.InstalledExtensionNotFound = "InstalledExtensionNotFound";
        t.PostInstall = "PostInstall";
        t.CorruptZip = "CorruptZip";
        t.IncompleteZip = "IncompleteZip";
        t.PackageNotSigned = "PackageNotSigned";
        t.SignatureVerificationInternal = "SignatureVerificationInternal";
        t.SignatureVerificationFailed = "SignatureVerificationFailed";
        t.NotAllowed = "NotAllowed";
        t.Gallery = "Gallery";
        t.Cancelled = "Cancelled";
        t.Unknown = "Unknown";
        t.Internal = "Internal";
      })(b4 ||= {});
      (function (t) {
        t.NotSigned = "NotSigned";
        t.Success = "Success";
        t.RequiredArgumentMissing = "RequiredArgumentMissing";
        t.InvalidArgument = "InvalidArgument";
        t.PackageIsUnreadable = "PackageIsUnreadable";
        t.UnhandledException = "UnhandledException";
        t.SignatureManifestIsMissing = "SignatureManifestIsMissing";
        t.SignatureManifestIsUnreadable = "SignatureManifestIsUnreadable";
        t.SignatureIsMissing = "SignatureIsMissing";
        t.SignatureIsUnreadable = "SignatureIsUnreadable";
        t.CertificateIsUnreadable = "CertificateIsUnreadable";
        t.SignatureArchiveIsUnreadable = "SignatureArchiveIsUnreadable";
        t.FileAlreadyExists = "FileAlreadyExists";
        t.SignatureArchiveIsInvalidZip = "SignatureArchiveIsInvalidZip";
        t.SignatureArchiveHasSameSignatureFile = "SignatureArchiveHasSameSignatureFile";
        t.PackageIntegrityCheckFailed = "PackageIntegrityCheckFailed";
        t.SignatureIsInvalid = "SignatureIsInvalid";
        t.SignatureManifestIsInvalid = "SignatureManifestIsInvalid";
        t.SignatureIntegrityCheckFailed = "SignatureIntegrityCheckFailed";
        t.EntryIsMissing = "EntryIsMissing";
        t.EntryIsTampered = "EntryIsTampered";
        t.Untrusted = "Untrusted";
        t.CertificateRevoked = "CertificateRevoked";
        t.SignatureIsNotValid = "SignatureIsNotValid";
        t.UnknownError = "UnknownError";
        t.PackageIsInvalidZip = "PackageIsInvalidZip";
        t.SignatureArchiveHasTooManyEntries = "SignatureArchiveHasTooManyEntries";
      })($1 ||= {});
      Jx = q("extensionManagementService");
      y4 = "extensionsIdentifiers/disabled";
      Kx = q("IGlobalExtensionEnablementService");
      Zx = q("IExtensionTipsService");
      Yx = q("IAllowedExtensionsService");
      Xx = V0(1824, "Extensions");
      Qx = V0(1825, "Preferences");
    }
  });
  import * as eD from "fs";
  var Gu;
  var I1;
  var S4;
  var E4;
  var k4;
  var A1;
  var tD = g({
    "out-build/vs/platform/storage/electron-main/storageMain.js"() {
      "use strict";
  
      zt();
      ce();
      B();
      M();
      we();
      Kn();
      se();
      _t();
      Uy();
      Bx();
      X();
      v1();
      xt();
      ri();
      Vu();
      Ie();
      Gu = class rS extends T {
        static {
          this.a = 2000;
        }
        get storage() {
          return this.f;
        }
        constructor(e, i) {
          super();
          this.m = e;
          this.n = i;
          this.b = this.D(new $());
          this.onDidChangeStorage = this.b.event;
          this.c = this.D(new $());
          this.onDidCloseStorage = this.c.event;
          this.f = this.D(new ac(new p1(), {
            hint: Is.STORAGE_IN_MEMORY
          }));
          this.g = undefined;
          this.h = new Xs();
          this.whenInit = this.h.p;
          this.j = bi.None;
        }
        cursorDiskKVGet(e) {
          return this.f.cursorDiskKVGet(e);
        }
        cursorDiskKVSet(e, i) {
          return this.f.cursorDiskKVSet(e, i);
        }
        cursorDiskKVClearPrefix(e) {
          return this.f.cursorDiskKVClearPrefix(e);
        }
        isInMemory() {
          return this.f.isInMemory();
        }
        init() {
          this.g ||= (async () => {
            if (this.j === bi.None) {
              try {
                const e = this.D(await this.t());
                this.f.dispose();
                this.f = e;
                this.D(e.onDidChangeStorage(s => this.b.fire(s)));
                await this.s(e);
                const i = e.getBoolean(lc);
                if (i === undefined) {
                  e.set(lc, true);
                } else if (i) {
                  e.set(lc, false);
                }
                this.q(e);
              } catch (e) {
                this.m.error(`[storage main] initialize(): Unable to init storage due to ${e}`);
              } finally {
                this.j = bi.Initialized;
                this.h.complete();
              }
            }
          })();
          return this.g;
        }
        q(e) {
          const i = this.vscodePath;
          if (!i) {
            return;
          }
          const s = [y4];
          try {
            import("@vscode/sqlite3").then(r => {
              let n;
              try {
                let o = false;
                n = new r.Database(i, a => {
                  o = !a;
                });
                if (!o) {
                  return;
                }
                for (const a of s) {
                  n.get("SELECT value FROM ItemTable WHERE key = ?", [a], (c, l) => {
                    try {
                      if (!c) {
                        const u = l.value;
                        e.set(`vscode/${a}`, u);
                      }
                    } catch {}
                  });
                }
              } catch {} finally {
                try {
                  if (n) {
                    n.close();
                  }
                } catch {}
              }
            });
          } catch {}
        }
        r() {
          return {
            logTrace: this.m.getLevel() === J.Trace ? e => this.m.trace(e) : undefined,
            logError: e => this.m.error(e)
          };
        }
        s(e) {
          return e.init();
        }
        get items() {
          return this.f.items;
        }
        get(e, i) {
          return this.f.get(e, i);
        }
        set(e, i) {
          return this.f.set(e, i);
        }
        delete(e) {
          return this.f.delete(e);
        }
        optimize() {
          return this.f.optimize();
        }
        async close() {
          const e = new Jr(false);
          await this.w();
          e.stop();
          if (e.elapsed() > rS.a) {
            await this.u(e);
          }
          this.c.fire();
        }
        async u(e) {
          if (this.path) {
            try {
              const i = HS(Array.from(this.f.items.entries()).map(([r, n]) => ({
                key: r,
                length: n.length
              })), (r, n) => n.length - r.length, 5).map(r => `${r.key}:${r.length}`).join(", ");
              const s = (await this.n.stat(P.file(this.path))).size;
              this.m.warn(`[storage main] detected slow close() operation: Time: ${e.elapsed()}ms, DB size: ${s}b, Large Keys: ${i}`);
            } catch (i) {
              this.m.error("[storage main] figuring out stats for slow DB on close() resulted in an error", i);
            }
          }
        }
        async w() {
          if (this.g) {
            await this.g;
          }
          this.j = bi.Closed;
          await this.f.close();
        }
      };
      I1 = class k0 extends Gu {
        static {
          this.y = "state.vscdb";
        }
        get path() {
          if (!this.C.useInMemoryStorage) {
            return F(this.z.globalStorageHome.with({
              scheme: R.file
            }).fsPath, k0.y);
          }
        }
        get vscodePath() {
          try {
            if (!this.C.useInMemoryStorage) {
              return F(Xe(Xe(Xe(this.z.globalStorageHome.fsPath))), "Code", "User", "globalStorage", k0.y);
            }
          } catch {}
        }
        constructor(e, i, s, r) {
          super(s, r);
          this.z = e;
          this.C = i;
        }
        async t() {
          return new ac(new uc(this.path ?? uc.IN_MEMORY_PATH, {
            logging: this.r()
          }), this.path ? undefined : {
            hint: Is.STORAGE_IN_MEMORY
          });
        }
      };
      S4 = class extends I1 {
        constructor(t, e, i, s) {
          super(t, e, i, s);
        }
      };
      E4 = class extends I1 {
        constructor(t, e, i, s) {
          super(e.defaultProfile, t, i, s);
        }
        async s(t) {
          await super.s(t);
          this.H(t);
        }
        H(t) {
          if (t.get(S1, undefined) === undefined) {
            t.set(S1, new Date().toUTCString());
          }
          const i = t.get(y1, undefined);
          const s = new Date().toUTCString();
          t.set(c4, typeof i === "undefined" ? null : i);
          t.set(y1, s);
        }
      };
      k4 = class $f extends Gu {
        static {
          this.y = "state.vscdb";
        }
        static {
          this.z = "workspace.json";
        }
        get path() {
          if (!this.F.useInMemoryStorage) {
            return F(this.G.workspaceStorageHome.with({
              scheme: R.file
            }).fsPath, this.C.id, $f.y);
          }
        }
        get vscodePath() {}
        constructor(e, i, s, r, n) {
          super(s, n);
          this.C = e;
          this.F = i;
          this.G = r;
        }
        async t() {
          const {
            storageFilePath: e,
            wasCreated: i
          } = await this.I();
          return new ac(new uc(e, {
            logging: this.r()
          }), {
            hint: this.F.useInMemoryStorage ? Is.STORAGE_IN_MEMORY : i ? Is.STORAGE_DOES_NOT_EXIST : undefined
          });
        }
        async I() {
          if (this.F.useInMemoryStorage) {
            return {
              storageFilePath: uc.IN_MEMORY_PATH,
              wasCreated: true
            };
          }
          const e = F(this.G.workspaceStorageHome.with({
            scheme: R.file
          }).fsPath, this.C.id);
          const i = F(e, $f.y);
          if (await ee.exists(e)) {
            return {
              storageFilePath: i,
              wasCreated: false
            };
          } else {
            await eD.promises.mkdir(e, {
              recursive: true
            });
            this.J(e);
            return {
              storageFilePath: i,
              wasCreated: true
            };
          }
        }
        async J(e) {
          let i;
          if (Li(this.C)) {
            i = {
              folder: this.C.uri.toString()
            };
          } else if (Kt(this.C)) {
            i = {
              workspace: this.C.configPath.toString()
            };
          }
          if (i) {
            try {
              const s = F(e, $f.z);
              if (!(await ee.exists(s))) {
                await ee.writeFile(s, JSON.stringify(i, undefined, 2));
              }
            } catch (s) {
              this.m.error(`[storage main] ensureWorkspaceStorageFolderMeta(): Unable to create workspace storage metadata due to ${s}`);
            }
          }
        }
      };
      A1 = class extends Gu {
        get path() {}
        get vscodePath() {}
        async t() {
          return new ac(new p1(), {
            hint: Is.STORAGE_IN_MEMORY
          });
        }
      };
    }
  });
  var x4;
  var D4;
  var Ju;
  var C1;
  var P4 = g({
    "out-build/vs/platform/state/node/stateService.js"() {
      "use strict";
  
      ce();
      Ze();
      M();
      _e();
      Ri();
      He();
      X();
      (function (t) {
        t[t.IMMEDIATE = 0] = "IMMEDIATE";
        t[t.DELAYED = 1] = "DELAYED";
      })(x4 ||= {});
      D4 = class extends T {
        constructor(t, e, i, s) {
          super();
          this.h = t;
          this.j = e;
          this.m = i;
          this.n = s;
          this.a = Object.create(null);
          this.b = "";
          this.c = this.D(new Ys(this.j === 0 ? 0 : 100));
          this.f = undefined;
          this.g = undefined;
        }
        init() {
          this.f ||= this.q();
          return this.f;
        }
        async q() {
          try {
            this.b = (await this.n.readFile(this.h)).value.toString();
            this.a = JSON.parse(this.b);
          } catch (t) {
            if (t.fileOperationResult !== 1) {
              this.m.error(t);
            }
          }
        }
        getItem(t, e) {
          const i = this.a[t];
          if (Qt(i)) {
            return e;
          } else {
            return i;
          }
        }
        setItem(t, e) {
          this.setItems([{
            key: t,
            data: e
          }]);
        }
        setItems(t) {
          let e = false;
          for (const {
            key: i,
            data: s
          } of t) {
            if (this.a[i] !== s) {
              if (Qt(s)) {
                if (!Gs(this.a[i])) {
                  this.a[i] = undefined;
                  e = true;
                }
              } else {
                this.a[i] = s;
                e = true;
              }
            }
          }
          if (e) {
            this.r();
          }
        }
        removeItem(t) {
          if (!Gs(this.a[t])) {
            this.a[t] = undefined;
            this.r();
          }
        }
        async r() {
          if (!this.g) {
            return this.c.trigger(() => this.s());
          }
        }
        async s() {
          if (!this.f) {
            return;
          }
          await this.f;
          const t = JSON.stringify(this.a, null, 4);
          if (t !== this.b) {
            try {
              await this.n.writeFile(this.h, z.fromString(t), {
                atomic: {
                  postfix: ".vsctmp"
                }
              });
              this.b = t;
            } catch (e) {
              this.m.error(e);
            }
          }
        }
        async close() {
          this.g ||= this.c.trigger(() => this.s(), 0);
          return this.g;
        }
      };
      Ju = class extends T {
        constructor(e, i, s, r) {
          super();
          this.a = this.D(new D4(i.stateResource, e, s, r));
        }
        async init() {
          await this.a.init();
        }
        getItem(e, i) {
          return this.a.getItem(e, i);
        }
      };
      Ju = __decorate([__param(1, Yi), __param(2, V), __param(3, at)], Ju);
      C1 = class extends Ju {
        setItem(t, e) {
          this.a.setItem(t, e);
        }
        setItems(t) {
          this.a.setItems(t);
        }
        removeItem(t) {
          this.a.removeItem(t);
        }
        close() {
          return this.a.close();
        }
      };
    }
  });
  var Ku;
  var bo;
  var Zu;
  var hc;
  var _1;
  var iD = g({
    "out-build/vs/platform/userDataProfile/node/userDataProfile.js"() {
      "use strict";
  
      se();
      Ri();
      He();
      X();
      Ti();
      As();
      _s();
      _e();
      P4();
      Zu = Ku = class extends Bu {
        constructor(e, i, s, r, n) {
          super(s, r, i, n);
          this.a = e;
          this.S = s;
        }
        N() {
          return this.a.getItem(Ku.b, []).map(i => ({
            ...i,
            location: wt(i.location) ? this.t.extUri.joinPath(this.profilesHome, i.location) : P.revive(i.location)
          }));
        }
        P() {
          return this.a.getItem(Ku.c, {});
        }
        R() {
          return this.t.extUri.joinPath(P.file(this.S.extensionsPath).with({
            scheme: this.profilesHome.scheme
          }), "extensions.json");
        }
      };
      Zu = Ku = __decorate([__param(0, f1), __param(1, yi), __param(2, tr), __param(3, at), __param(4, V)], Zu);
      hc = bo = class extends Zu {
        constructor(e, i, s, r, n) {
          super(e, i, s, r, n);
          this.Y = e;
        }
        O(e) {
          if (e.length) {
            this.Y.setItem(bo.b, e.map(i => ({
              ...i,
              location: this.t.extUri.basename(i.location)
            })));
          } else {
            this.Y.removeItem(bo.b);
          }
        }
        Q(e) {
          if (e.emptyWindows || e.workspaces) {
            this.Y.setItem(bo.c, e);
          } else {
            this.Y.removeItem(bo.c);
          }
        }
      };
      hc = bo = __decorate([__param(0, Oi), __param(1, yi), __param(2, tr), __param(3, at), __param(4, V)], hc);
      _1 = class extends hc {
        constructor(e, i, s, r) {
          super(new C1(0, i, r, s), e, i, s, r);
        }
        async init() {
          await this.Y.init();
          return super.init();
        }
      };
      _1 = __decorate([__param(0, yi), __param(1, tr), __param(2, at), __param(3, V)], _1);
    }
  });
  var Rs;
  var Yu;
  var un = g({
    "out-build/vs/platform/userDataProfile/electron-main/userDataProfile.js"() {
      "use strict";
  
      Ri();
      He();
      Y();
      X();
      As();
      _s();
      iD();
      Ti();
      Rs = Cs;
      Yu = class extends hc {
        constructor(e, i, s, r, n) {
          super(e, i, s, r, n);
        }
        getAssociatedEmptyWindows() {
          const e = [];
          for (const i of this.z.emptyWindows.keys()) {
            e.push({
              id: i
            });
          }
          return e;
        }
      };
      Yu = __decorate([__param(0, Oi), __param(1, yi), __param(2, tr), __param(3, at), __param(4, V)], Yu);
    }
  });
  var yo;
  var Xu;
  var dc;
  var Qu;
  var eh = g({
    "out-build/vs/platform/storage/electron-main/storageMainService.js"() {
      "use strict";
  
      se();
      B();
      M();
      Ri();
      He();
      Y();
      ct();
      X();
      v1();
      tD();
      _s();
      un();
      As();
      Ie();
      yo = q("storageMainService");
      Xu = class extends T {
        constructor(e, i, s, r, n, o) {
          super();
          this.c = e;
          this.f = i;
          this.g = s;
          this.h = r;
          this.j = n;
          this.m = o;
          this.a = undefined;
          this.b = this.D(new $());
          this.onDidChangeProfileStorage = this.b.event;
          this.applicationStorage = this.D(this.r());
          this.s = new Map();
          this.u = new Map();
          this.q();
        }
        n() {
          return {
            useInMemoryStorage: !!this.f.extensionTestsLocationURI
          };
        }
        q() {
          (async () => {
            await this.h.when(3);
            return this.applicationStorage.init();
          })();
          this.D(this.h.onWillLoadWindow(e => {
            if (e.window.profile) {
              this.profileStorage(e.window.profile).init();
            }
            if (e.workspace) {
              this.workspaceStorage(e.workspace).init();
            }
          }));
          this.D(this.h.onWillShutdown(e => {
            this.c.trace("storageMainService#onWillShutdown()");
            this.a = e.reason;
            e.join("applicationStorage", this.applicationStorage.close());
            for (const [, i] of this.s) {
              e.join("profileStorage", i.close());
            }
            for (const [, i] of this.u) {
              e.join("workspaceStorage", i.close());
            }
          }));
          this.D(this.g.onWillCreateProfile(e => {
            e.join((async () => {
              if (!(await this.j.exists(e.profile.globalStorageHome))) {
                await this.j.createFolder(e.profile.globalStorageHome);
              }
            })());
          }));
          this.D(this.g.onWillRemoveProfile(e => {
            const i = this.s.get(e.profile.id);
            if (i) {
              e.join(i.close());
            }
          }));
        }
        r() {
          this.c.trace("StorageMainService: creating application storage");
          const e = new E4(this.n(), this.g, this.c, this.j);
          this.D(x.once(e.onDidCloseStorage)(() => {
            this.c.trace("StorageMainService: closed application storage");
          }));
          return e;
        }
        profileStorage(e) {
          if (w1(e)) {
            return this.applicationStorage;
          }
          let i = this.s.get(e.id);
          if (!i) {
            this.c.trace(`StorageMainService: creating profile storage (${e.name})`);
            i = this.D(this.t(e));
            this.s.set(e.id, i);
            const s = this.D(i.onDidChangeStorage(r => this.b.fire({
              ...r,
              storage: i,
              profile: e
            })));
            this.D(x.once(i.onDidCloseStorage)(() => {
              this.c.trace(`StorageMainService: closed profile storage (${e.name})`);
              this.s.delete(e.id);
              s.dispose();
            }));
          }
          return i;
        }
        t(e) {
          if (this.a === 2) {
            return new A1(this.c, this.j);
          } else {
            return new S4(e, this.n(), this.c, this.j);
          }
        }
        workspaceStorage(e) {
          let i = this.u.get(e.id);
          if (!i) {
            this.c.trace(`StorageMainService: creating workspace storage (${e.id})`);
            i = this.D(this.w(e));
            this.u.set(e.id, i);
            this.D(x.once(i.onDidCloseStorage)(() => {
              this.c.trace(`StorageMainService: closed workspace storage (${e.id})`);
              this.u.delete(e.id);
            }));
          }
          return i;
        }
        w(e) {
          if (this.a === 2) {
            return new A1(this.c, this.j);
          } else {
            return new k4(e, this.n(), this.c, this.f, this.j);
          }
        }
        isUsed(e) {
          const i = P.file(e);
          for (const s of [this.applicationStorage, ...this.s.values(), ...this.u.values()]) {
            if (s.path && this.m.extUri.isEqualOrParent(P.file(s.path), i)) {
              return true;
            }
          }
          return false;
        }
      };
      Xu = __decorate([__param(0, V), __param(1, Yi), __param(2, Rs), __param(3, Te), __param(4, at), __param(5, yi)], Xu);
      dc = q("applicationStorageMainService");
      Qu = class extends Xy {
        constructor(e, i) {
          super();
          this.s = e;
          this.X = i;
          this.whenReady = this.X.applicationStorage.whenInit;
        }
        Q() {
          return this.X.applicationStorage.whenInit;
        }
        R(e) {
          if (e === -1) {
            return this.X.applicationStorage.storage;
          }
        }
        S(e) {
          if (e === -1) {
            return this.s.defaultProfile.globalStorageHome.with({
              scheme: R.file
            }).fsPath;
          }
        }
        r() {
          return false;
        }
        switch() {
          throw new Error("Migrating storage is unsupported from main process");
        }
        U() {
          throw new Error("Switching storage profile is unsupported from main process");
        }
        W() {
          throw new Error("Switching storage workspace is unsupported from main process");
        }
        hasScope() {
          throw new Error("Main process is never profile or workspace scoped");
        }
      };
      Qu = __decorate([__param(0, Cs), __param(1, yo)], Qu);
    }
  });
  function Ir(t, e) {
    const i = Math.pow(10, e);
    return Math.round(t * i) / i;
  }
  var E;
  var hn;
  var fc;
  var th;
  var sD = g({
    "out-build/vs/base/common/color.js"() {
      "use strict";
  
      E = class {
        constructor(t, e, i, s = 1) {
          this._rgbaBrand = undefined;
          this.r = Math.min(255, Math.max(0, t)) | 0;
          this.g = Math.min(255, Math.max(0, e)) | 0;
          this.b = Math.min(255, Math.max(0, i)) | 0;
          this.a = Ir(Math.max(Math.min(1, s), 0), 3);
        }
        static equals(t, e) {
          return t.r === e.r && t.g === e.g && t.b === e.b && t.a === e.a;
        }
      };
      hn = class Pl {
        constructor(e, i, s, r) {
          this._hslaBrand = undefined;
          this.h = Math.max(Math.min(360, e), 0) | 0;
          this.s = Ir(Math.max(Math.min(1, i), 0), 3);
          this.l = Ir(Math.max(Math.min(1, s), 0), 3);
          this.a = Ir(Math.max(Math.min(1, r), 0), 3);
        }
        static equals(e, i) {
          return e.h === i.h && e.s === i.s && e.l === i.l && e.a === i.a;
        }
        static fromRGBA(e) {
          const i = e.r / 255;
          const s = e.g / 255;
          const r = e.b / 255;
          const n = e.a;
          const o = Math.max(i, s, r);
          const a = Math.min(i, s, r);
          let c = 0;
          let l = 0;
          const u = (a + o) / 2;
          const d = o - a;
          if (d > 0) {
            l = Math.min(u <= 0.5 ? d / (u * 2) : d / (2 - u * 2), 1);
            switch (o) {
              case i:
                c = (s - r) / d + (s < r ? 6 : 0);
                break;
              case s:
                c = (r - i) / d + 2;
                break;
              case r:
                c = (i - s) / d + 4;
                break;
            }
            c *= 60;
            c = Math.round(c);
          }
          return new Pl(c, l, u, n);
        }
        static i(e, i, s) {
          if (s < 0) {
            s += 1;
          }
          if (s > 1) {
            s -= 1;
          }
          if (s < 1 / 6) {
            return e + (i - e) * 6 * s;
          } else if (s < 1 / 2) {
            return i;
          } else if (s < 2 / 3) {
            return e + (i - e) * (2 / 3 - s) * 6;
          } else {
            return e;
          }
        }
        static toRGBA(e) {
          const i = e.h / 360;
          const {
            s,
            l: r,
            a: n
          } = e;
          let o;
          let a;
          let c;
          if (s === 0) {
            o = a = c = r;
          } else {
            const l = r < 0.5 ? r * (1 + s) : r + s - r * s;
            const u = r * 2 - l;
            o = Pl.i(u, l, i + 1 / 3);
            a = Pl.i(u, l, i);
            c = Pl.i(u, l, i - 1 / 3);
          }
          return new E(Math.round(o * 255), Math.round(a * 255), Math.round(c * 255), n);
        }
      };
      fc = class nS {
        constructor(e, i, s, r) {
          this._hsvaBrand = undefined;
          this.h = Math.max(Math.min(360, e), 0) | 0;
          this.s = Ir(Math.max(Math.min(1, i), 0), 3);
          this.v = Ir(Math.max(Math.min(1, s), 0), 3);
          this.a = Ir(Math.max(Math.min(1, r), 0), 3);
        }
        static equals(e, i) {
          return e.h === i.h && e.s === i.s && e.v === i.v && e.a === i.a;
        }
        static fromRGBA(e) {
          const i = e.r / 255;
          const s = e.g / 255;
          const r = e.b / 255;
          const n = Math.max(i, s, r);
          const o = Math.min(i, s, r);
          const a = n - o;
          const c = n === 0 ? 0 : a / n;
          let l;
          if (a === 0) {
            l = 0;
          } else if (n === i) {
            l = ((s - r) / a % 6 + 6) % 6;
          } else if (n === s) {
            l = (r - i) / a + 2;
          } else {
            l = (i - s) / a + 4;
          }
          return new nS(Math.round(l * 60), c, n, e.a);
        }
        static toRGBA(e) {
          const {
            h: i,
            s,
            v: r,
            a: n
          } = e;
          const o = r * s;
          const a = o * (1 - Math.abs(i / 60 % 2 - 1));
          const c = r - o;
          let [l, u, d] = [0, 0, 0];
          if (i < 60) {
            l = o;
            u = a;
          } else if (i < 120) {
            l = a;
            u = o;
          } else if (i < 180) {
            u = o;
            d = a;
          } else if (i < 240) {
            u = a;
            d = o;
          } else if (i < 300) {
            l = a;
            d = o;
          } else if (i <= 360) {
            l = o;
            d = a;
          }
          l = Math.round((l + c) * 255);
          u = Math.round((u + c) * 255);
          d = Math.round((d + c) * 255);
          return new E(l, u, d, n);
        }
      };
      th = class je {
        static fromHex(e) {
          return je.Format.CSS.parseHex(e) || je.red;
        }
        static equals(e, i) {
          if (!e && !i) {
            return true;
          } else if (!e || !i) {
            return false;
          } else {
            return e.equals(i);
          }
        }
        get hsla() {
          if (this.i) {
            return this.i;
          } else {
            return hn.fromRGBA(this.rgba);
          }
        }
        get hsva() {
          if (this.j) {
            return this.j;
          } else {
            return fc.fromRGBA(this.rgba);
          }
        }
        constructor(e) {
          if (e) {
            if (e instanceof E) {
              this.rgba = e;
            } else if (e instanceof hn) {
              this.i = e;
              this.rgba = hn.toRGBA(e);
            } else if (e instanceof fc) {
              this.j = e;
              this.rgba = fc.toRGBA(e);
            } else {
              throw new Error("Invalid color ctor argument");
            }
          } else {
            throw new Error("Color needs a value");
          }
        }
        equals(e) {
          return !!e && E.equals(this.rgba, e.rgba) && hn.equals(this.hsla, e.hsla) && fc.equals(this.hsva, e.hsva);
        }
        getRelativeLuminance() {
          const e = je.k(this.rgba.r);
          const i = je.k(this.rgba.g);
          const s = je.k(this.rgba.b);
          const r = e * 0.2126 + i * 0.7152 + s * 0.0722;
          return Ir(r, 4);
        }
        reduceRelativeLuminace(e, i) {
          let {
            r: s,
            g: r,
            b: n
          } = e.rgba;
          let o = this.getContrastRatio(e);
          while (o < i && (s > 0 || r > 0 || n > 0)) {
            s -= Math.max(0, Math.ceil(s * 0.1));
            r -= Math.max(0, Math.ceil(r * 0.1));
            n -= Math.max(0, Math.ceil(n * 0.1));
            o = this.getContrastRatio(new je(new E(s, r, n)));
          }
          return new je(new E(s, r, n));
        }
        increaseRelativeLuminace(e, i) {
          let {
            r: s,
            g: r,
            b: n
          } = e.rgba;
          let o = this.getContrastRatio(e);
          while (o < i && (s < 255 || r < 255 || n < 255)) {
            s = Math.min(255, s + Math.ceil((255 - s) * 0.1));
            r = Math.min(255, r + Math.ceil((255 - r) * 0.1));
            n = Math.min(255, n + Math.ceil((255 - n) * 0.1));
            o = this.getContrastRatio(new je(new E(s, r, n)));
          }
          return new je(new E(s, r, n));
        }
        static k(e) {
          const i = e / 255;
          if (i <= 0.03928) {
            return i / 12.92;
          } else {
            return Math.pow((i + 0.055) / 1.055, 2.4);
          }
        }
        getContrastRatio(e) {
          const i = this.getRelativeLuminance();
          const s = e.getRelativeLuminance();
          if (i > s) {
            return (i + 0.05) / (s + 0.05);
          } else {
            return (s + 0.05) / (i + 0.05);
          }
        }
        isDarker() {
          return (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000 < 128;
        }
        isLighter() {
          return (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000 >= 128;
        }
        isLighterThan(e) {
          const i = this.getRelativeLuminance();
          const s = e.getRelativeLuminance();
          return i > s;
        }
        isDarkerThan(e) {
          const i = this.getRelativeLuminance();
          const s = e.getRelativeLuminance();
          return i < s;
        }
        ensureConstrast(e, i) {
          const s = this.getRelativeLuminance();
          const r = e.getRelativeLuminance();
          if (this.getContrastRatio(e) < i) {
            if (r < s) {
              const c = this.reduceRelativeLuminace(e, i);
              const l = this.getContrastRatio(c);
              if (l < i) {
                const u = this.increaseRelativeLuminace(e, i);
                const d = this.getContrastRatio(u);
                if (l > d) {
                  return c;
                } else {
                  return u;
                }
              }
              return c;
            }
            const o = this.increaseRelativeLuminace(e, i);
            const a = this.getContrastRatio(o);
            if (a < i) {
              const c = this.reduceRelativeLuminace(e, i);
              const l = this.getContrastRatio(c);
              if (a > l) {
                return o;
              } else {
                return c;
              }
            }
            return o;
          }
          return e;
        }
        lighten(e) {
          return new je(new hn(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * e, this.hsla.a));
        }
        darken(e) {
          return new je(new hn(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * e, this.hsla.a));
        }
        transparent(e) {
          const {
            r: i,
            g: s,
            b: r,
            a: n
          } = this.rgba;
          return new je(new E(i, s, r, n * e));
        }
        isTransparent() {
          return this.rgba.a === 0;
        }
        isOpaque() {
          return this.rgba.a === 1;
        }
        opposite() {
          return new je(new E(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
        }
        blend(e) {
          const i = e.rgba;
          const s = this.rgba.a;
          const r = i.a;
          const n = s + r * (1 - s);
          if (n < 0.000001) {
            return je.transparent;
          }
          const o = this.rgba.r * s / n + i.r * r * (1 - s) / n;
          const a = this.rgba.g * s / n + i.g * r * (1 - s) / n;
          const c = this.rgba.b * s / n + i.b * r * (1 - s) / n;
          return new je(new E(o, a, c, n));
        }
        makeOpaque(e) {
          if (this.isOpaque() || e.rgba.a !== 1) {
            return this;
          }
          const {
            r: i,
            g: s,
            b: r,
            a: n
          } = this.rgba;
          return new je(new E(e.rgba.r - n * (e.rgba.r - i), e.rgba.g - n * (e.rgba.g - s), e.rgba.b - n * (e.rgba.b - r), 1));
        }
        flatten(...e) {
          const i = e.reduceRight((s, r) => je.o(r, s));
          return je.o(this, i);
        }
        static o(e, i) {
          const s = 1 - e.rgba.a;
          return new je(new E(s * i.rgba.r + e.rgba.a * e.rgba.r, s * i.rgba.g + e.rgba.a * e.rgba.g, s * i.rgba.b + e.rgba.a * e.rgba.b));
        }
        toString() {
          this.u ||= je.Format.CSS.format(this);
          return this.u;
        }
        toNumber24Bit() {
          this.w ||= (this.rgba.r << 24 | this.rgba.g << 16 | this.rgba.b << 8 | this.rgba.a * 255 << 0) >>> 0;
          return this.w;
        }
        static getLighterColor(e, i, s) {
          if (e.isLighterThan(i)) {
            return e;
          }
          s = s || 0.5;
          const r = e.getRelativeLuminance();
          const n = i.getRelativeLuminance();
          s = s * (n - r) / n;
          return e.lighten(s);
        }
        static getDarkerColor(e, i, s) {
          if (e.isDarkerThan(i)) {
            return e;
          }
          s = s || 0.5;
          const r = e.getRelativeLuminance();
          const n = i.getRelativeLuminance();
          s = s * (r - n) / r;
          return e.darken(s);
        }
        static {
          this.white = new je(new E(255, 255, 255, 1));
        }
        static {
          this.black = new je(new E(0, 0, 0, 1));
        }
        static {
          this.red = new je(new E(255, 0, 0, 1));
        }
        static {
          this.blue = new je(new E(0, 0, 255, 1));
        }
        static {
          this.green = new je(new E(0, 255, 0, 1));
        }
        static {
          this.cyan = new je(new E(0, 255, 255, 1));
        }
        static {
          this.lightgrey = new je(new E(211, 211, 211, 1));
        }
        static {
          this.transparent = new je(new E(0, 0, 0, 0));
        }
      };
      (function (t) {
        let e;
        (function (i) {
          let s;
          (function (r) {
            function n(b) {
              if (b.rgba.a === 1) {
                return `rgb(${b.rgba.r}, ${b.rgba.g}, ${b.rgba.b})`;
              } else {
                return t.Format.CSS.formatRGBA(b);
              }
            }
            r.formatRGB = n;
            function o(b) {
              return `rgba(${b.rgba.r}, ${b.rgba.g}, ${b.rgba.b}, ${+b.rgba.a.toFixed(2)})`;
            }
            r.formatRGBA = o;
            function a(b) {
              if (b.hsla.a === 1) {
                return `hsl(${b.hsla.h}, ${(b.hsla.s * 100).toFixed(2)}%, ${(b.hsla.l * 100).toFixed(2)}%)`;
              } else {
                return t.Format.CSS.formatHSLA(b);
              }
            }
            r.formatHSL = a;
            function c(b) {
              return `hsla(${b.hsla.h}, ${(b.hsla.s * 100).toFixed(2)}%, ${(b.hsla.l * 100).toFixed(2)}%, ${b.hsla.a.toFixed(2)})`;
            }
            r.formatHSLA = c;
            function l(b) {
              const k = b.toString(16);
              if (k.length !== 2) {
                return "0" + k;
              } else {
                return k;
              }
            }
            function u(b) {
              return `#${l(b.rgba.r)}${l(b.rgba.g)}${l(b.rgba.b)}`;
            }
            r.formatHex = u;
            function d(b, k = false) {
              if (k && b.rgba.a === 1) {
                return t.Format.CSS.formatHex(b);
              } else {
                return `#${l(b.rgba.r)}${l(b.rgba.g)}${l(b.rgba.b)}${l(Math.round(b.rgba.a * 255))}`;
              }
            }
            r.formatHexA = d;
            function f(b) {
              if (b.isOpaque()) {
                return t.Format.CSS.formatHex(b);
              } else {
                return t.Format.CSS.formatRGBA(b);
              }
            }
            r.format = f;
            function p(b) {
              if (b === "transparent") {
                return t.transparent;
              }
              if (b.startsWith("#")) {
                return m(b);
              }
              if (b.startsWith("rgba(")) {
                const k = b.match(/rgba\((?<r>(?:\+|-)?\d+), *(?<g>(?:\+|-)?\d+), *(?<b>(?:\+|-)?\d+), *(?<a>(?:\+|-)?\d+(\.\d+)?)\)/);
                if (!k) {
                  throw new Error("Invalid color format " + b);
                }
                const A = parseInt(k.groups?.r ?? "0");
                const C = parseInt(k.groups?.g ?? "0");
                const _ = parseInt(k.groups?.b ?? "0");
                const Z = parseFloat(k.groups?.a ?? "0");
                return new t(new E(A, C, _, Z));
              }
              if (b.startsWith("rgb(")) {
                const k = b.match(/rgb\((?<r>(?:\+|-)?\d+), *(?<g>(?:\+|-)?\d+), *(?<b>(?:\+|-)?\d+)\)/);
                if (!k) {
                  throw new Error("Invalid color format " + b);
                }
                const A = parseInt(k.groups?.r ?? "0");
                const C = parseInt(k.groups?.g ?? "0");
                const _ = parseInt(k.groups?.b ?? "0");
                return new t(new E(A, C, _));
              }
              return w(b);
            }
            r.parse = p;
            function w(b) {
              switch (b) {
                case "aliceblue":
                  return new t(new E(240, 248, 255, 1));
                case "antiquewhite":
                  return new t(new E(250, 235, 215, 1));
                case "aqua":
                  return new t(new E(0, 255, 255, 1));
                case "aquamarine":
                  return new t(new E(127, 255, 212, 1));
                case "azure":
                  return new t(new E(240, 255, 255, 1));
                case "beige":
                  return new t(new E(245, 245, 220, 1));
                case "bisque":
                  return new t(new E(255, 228, 196, 1));
                case "black":
                  return new t(new E(0, 0, 0, 1));
                case "blanchedalmond":
                  return new t(new E(255, 235, 205, 1));
                case "blue":
                  return new t(new E(0, 0, 255, 1));
                case "blueviolet":
                  return new t(new E(138, 43, 226, 1));
                case "brown":
                  return new t(new E(165, 42, 42, 1));
                case "burlywood":
                  return new t(new E(222, 184, 135, 1));
                case "cadetblue":
                  return new t(new E(95, 158, 160, 1));
                case "chartreuse":
                  return new t(new E(127, 255, 0, 1));
                case "chocolate":
                  return new t(new E(210, 105, 30, 1));
                case "coral":
                  return new t(new E(255, 127, 80, 1));
                case "cornflowerblue":
                  return new t(new E(100, 149, 237, 1));
                case "cornsilk":
                  return new t(new E(255, 248, 220, 1));
                case "crimson":
                  return new t(new E(220, 20, 60, 1));
                case "cyan":
                  return new t(new E(0, 255, 255, 1));
                case "darkblue":
                  return new t(new E(0, 0, 139, 1));
                case "darkcyan":
                  return new t(new E(0, 139, 139, 1));
                case "darkgoldenrod":
                  return new t(new E(184, 134, 11, 1));
                case "darkgray":
                  return new t(new E(169, 169, 169, 1));
                case "darkgreen":
                  return new t(new E(0, 100, 0, 1));
                case "darkgrey":
                  return new t(new E(169, 169, 169, 1));
                case "darkkhaki":
                  return new t(new E(189, 183, 107, 1));
                case "darkmagenta":
                  return new t(new E(139, 0, 139, 1));
                case "darkolivegreen":
                  return new t(new E(85, 107, 47, 1));
                case "darkorange":
                  return new t(new E(255, 140, 0, 1));
                case "darkorchid":
                  return new t(new E(153, 50, 204, 1));
                case "darkred":
                  return new t(new E(139, 0, 0, 1));
                case "darksalmon":
                  return new t(new E(233, 150, 122, 1));
                case "darkseagreen":
                  return new t(new E(143, 188, 143, 1));
                case "darkslateblue":
                  return new t(new E(72, 61, 139, 1));
                case "darkslategray":
                  return new t(new E(47, 79, 79, 1));
                case "darkslategrey":
                  return new t(new E(47, 79, 79, 1));
                case "darkturquoise":
                  return new t(new E(0, 206, 209, 1));
                case "darkviolet":
                  return new t(new E(148, 0, 211, 1));
                case "deeppink":
                  return new t(new E(255, 20, 147, 1));
                case "deepskyblue":
                  return new t(new E(0, 191, 255, 1));
                case "dimgray":
                  return new t(new E(105, 105, 105, 1));
                case "dimgrey":
                  return new t(new E(105, 105, 105, 1));
                case "dodgerblue":
                  return new t(new E(30, 144, 255, 1));
                case "firebrick":
                  return new t(new E(178, 34, 34, 1));
                case "floralwhite":
                  return new t(new E(255, 250, 240, 1));
                case "forestgreen":
                  return new t(new E(34, 139, 34, 1));
                case "fuchsia":
                  return new t(new E(255, 0, 255, 1));
                case "gainsboro":
                  return new t(new E(220, 220, 220, 1));
                case "ghostwhite":
                  return new t(new E(248, 248, 255, 1));
                case "gold":
                  return new t(new E(255, 215, 0, 1));
                case "goldenrod":
                  return new t(new E(218, 165, 32, 1));
                case "gray":
                  return new t(new E(128, 128, 128, 1));
                case "green":
                  return new t(new E(0, 128, 0, 1));
                case "greenyellow":
                  return new t(new E(173, 255, 47, 1));
                case "grey":
                  return new t(new E(128, 128, 128, 1));
                case "honeydew":
                  return new t(new E(240, 255, 240, 1));
                case "hotpink":
                  return new t(new E(255, 105, 180, 1));
                case "indianred":
                  return new t(new E(205, 92, 92, 1));
                case "indigo":
                  return new t(new E(75, 0, 130, 1));
                case "ivory":
                  return new t(new E(255, 255, 240, 1));
                case "khaki":
                  return new t(new E(240, 230, 140, 1));
                case "lavender":
                  return new t(new E(230, 230, 250, 1));
                case "lavenderblush":
                  return new t(new E(255, 240, 245, 1));
                case "lawngreen":
                  return new t(new E(124, 252, 0, 1));
                case "lemonchiffon":
                  return new t(new E(255, 250, 205, 1));
                case "lightblue":
                  return new t(new E(173, 216, 230, 1));
                case "lightcoral":
                  return new t(new E(240, 128, 128, 1));
                case "lightcyan":
                  return new t(new E(224, 255, 255, 1));
                case "lightgoldenrodyellow":
                  return new t(new E(250, 250, 210, 1));
                case "lightgray":
                  return new t(new E(211, 211, 211, 1));
                case "lightgreen":
                  return new t(new E(144, 238, 144, 1));
                case "lightgrey":
                  return new t(new E(211, 211, 211, 1));
                case "lightpink":
                  return new t(new E(255, 182, 193, 1));
                case "lightsalmon":
                  return new t(new E(255, 160, 122, 1));
                case "lightseagreen":
                  return new t(new E(32, 178, 170, 1));
                case "lightskyblue":
                  return new t(new E(135, 206, 250, 1));
                case "lightslategray":
                  return new t(new E(119, 136, 153, 1));
                case "lightslategrey":
                  return new t(new E(119, 136, 153, 1));
                case "lightsteelblue":
                  return new t(new E(176, 196, 222, 1));
                case "lightyellow":
                  return new t(new E(255, 255, 224, 1));
                case "lime":
                  return new t(new E(0, 255, 0, 1));
                case "limegreen":
                  return new t(new E(50, 205, 50, 1));
                case "linen":
                  return new t(new E(250, 240, 230, 1));
                case "magenta":
                  return new t(new E(255, 0, 255, 1));
                case "maroon":
                  return new t(new E(128, 0, 0, 1));
                case "mediumaquamarine":
                  return new t(new E(102, 205, 170, 1));
                case "mediumblue":
                  return new t(new E(0, 0, 205, 1));
                case "mediumorchid":
                  return new t(new E(186, 85, 211, 1));
                case "mediumpurple":
                  return new t(new E(147, 112, 219, 1));
                case "mediumseagreen":
                  return new t(new E(60, 179, 113, 1));
                case "mediumslateblue":
                  return new t(new E(123, 104, 238, 1));
                case "mediumspringgreen":
                  return new t(new E(0, 250, 154, 1));
                case "mediumturquoise":
                  return new t(new E(72, 209, 204, 1));
                case "mediumvioletred":
                  return new t(new E(199, 21, 133, 1));
                case "midnightblue":
                  return new t(new E(25, 25, 112, 1));
                case "mintcream":
                  return new t(new E(245, 255, 250, 1));
                case "mistyrose":
                  return new t(new E(255, 228, 225, 1));
                case "moccasin":
                  return new t(new E(255, 228, 181, 1));
                case "navajowhite":
                  return new t(new E(255, 222, 173, 1));
                case "navy":
                  return new t(new E(0, 0, 128, 1));
                case "oldlace":
                  return new t(new E(253, 245, 230, 1));
                case "olive":
                  return new t(new E(128, 128, 0, 1));
                case "olivedrab":
                  return new t(new E(107, 142, 35, 1));
                case "orange":
                  return new t(new E(255, 165, 0, 1));
                case "orangered":
                  return new t(new E(255, 69, 0, 1));
                case "orchid":
                  return new t(new E(218, 112, 214, 1));
                case "palegoldenrod":
                  return new t(new E(238, 232, 170, 1));
                case "palegreen":
                  return new t(new E(152, 251, 152, 1));
                case "paleturquoise":
                  return new t(new E(175, 238, 238, 1));
                case "palevioletred":
                  return new t(new E(219, 112, 147, 1));
                case "papayawhip":
                  return new t(new E(255, 239, 213, 1));
                case "peachpuff":
                  return new t(new E(255, 218, 185, 1));
                case "peru":
                  return new t(new E(205, 133, 63, 1));
                case "pink":
                  return new t(new E(255, 192, 203, 1));
                case "plum":
                  return new t(new E(221, 160, 221, 1));
                case "powderblue":
                  return new t(new E(176, 224, 230, 1));
                case "purple":
                  return new t(new E(128, 0, 128, 1));
                case "rebeccapurple":
                  return new t(new E(102, 51, 153, 1));
                case "red":
                  return new t(new E(255, 0, 0, 1));
                case "rosybrown":
                  return new t(new E(188, 143, 143, 1));
                case "royalblue":
                  return new t(new E(65, 105, 225, 1));
                case "saddlebrown":
                  return new t(new E(139, 69, 19, 1));
                case "salmon":
                  return new t(new E(250, 128, 114, 1));
                case "sandybrown":
                  return new t(new E(244, 164, 96, 1));
                case "seagreen":
                  return new t(new E(46, 139, 87, 1));
                case "seashell":
                  return new t(new E(255, 245, 238, 1));
                case "sienna":
                  return new t(new E(160, 82, 45, 1));
                case "silver":
                  return new t(new E(192, 192, 192, 1));
                case "skyblue":
                  return new t(new E(135, 206, 235, 1));
                case "slateblue":
                  return new t(new E(106, 90, 205, 1));
                case "slategray":
                  return new t(new E(112, 128, 144, 1));
                case "slategrey":
                  return new t(new E(112, 128, 144, 1));
                case "snow":
                  return new t(new E(255, 250, 250, 1));
                case "springgreen":
                  return new t(new E(0, 255, 127, 1));
                case "steelblue":
                  return new t(new E(70, 130, 180, 1));
                case "tan":
                  return new t(new E(210, 180, 140, 1));
                case "teal":
                  return new t(new E(0, 128, 128, 1));
                case "thistle":
                  return new t(new E(216, 191, 216, 1));
                case "tomato":
                  return new t(new E(255, 99, 71, 1));
                case "turquoise":
                  return new t(new E(64, 224, 208, 1));
                case "violet":
                  return new t(new E(238, 130, 238, 1));
                case "wheat":
                  return new t(new E(245, 222, 179, 1));
                case "white":
                  return new t(new E(255, 255, 255, 1));
                case "whitesmoke":
                  return new t(new E(245, 245, 245, 1));
                case "yellow":
                  return new t(new E(255, 255, 0, 1));
                case "yellowgreen":
                  return new t(new E(154, 205, 50, 1));
                default:
                  return null;
              }
            }
            function m(b) {
              const k = b.length;
              if (k === 0 || b.charCodeAt(0) !== 35) {
                return null;
              }
              if (k === 7) {
                const A = y(b.charCodeAt(1)) * 16 + y(b.charCodeAt(2));
                const C = y(b.charCodeAt(3)) * 16 + y(b.charCodeAt(4));
                const _ = y(b.charCodeAt(5)) * 16 + y(b.charCodeAt(6));
                return new t(new E(A, C, _, 1));
              }
              if (k === 9) {
                const A = y(b.charCodeAt(1)) * 16 + y(b.charCodeAt(2));
                const C = y(b.charCodeAt(3)) * 16 + y(b.charCodeAt(4));
                const _ = y(b.charCodeAt(5)) * 16 + y(b.charCodeAt(6));
                const Z = y(b.charCodeAt(7)) * 16 + y(b.charCodeAt(8));
                return new t(new E(A, C, _, Z / 255));
              }
              if (k === 4) {
                const A = y(b.charCodeAt(1));
                const C = y(b.charCodeAt(2));
                const _ = y(b.charCodeAt(3));
                return new t(new E(A * 16 + A, C * 16 + C, _ * 16 + _));
              }
              if (k === 5) {
                const A = y(b.charCodeAt(1));
                const C = y(b.charCodeAt(2));
                const _ = y(b.charCodeAt(3));
                const Z = y(b.charCodeAt(4));
                return new t(new E(A * 16 + A, C * 16 + C, _ * 16 + _, (Z * 16 + Z) / 255));
              }
              return null;
            }
            r.parseHex = m;
            function y(b) {
              switch (b) {
                case 48:
                  return 0;
                case 49:
                  return 1;
                case 50:
                  return 2;
                case 51:
                  return 3;
                case 52:
                  return 4;
                case 53:
                  return 5;
                case 54:
                  return 6;
                case 55:
                  return 7;
                case 56:
                  return 8;
                case 57:
                  return 9;
                case 97:
                  return 10;
                case 65:
                  return 10;
                case 98:
                  return 11;
                case 66:
                  return 11;
                case 99:
                  return 12;
                case 67:
                  return 12;
                case 100:
                  return 13;
                case 68:
                  return 13;
                case 101:
                  return 14;
                case 69:
                  return 14;
                case 102:
                  return 15;
                case 70:
                  return 15;
              }
              return 0;
            }
          })(s = i.CSS ||= {});
        })(e = t.Format ||= {});
      })(th ||= {});
    }
  });
  function rD(t, e) {
    return P.joinPath(t.userHome, e.dataFolderName, "shadow-workspaces");
  }
  var Ve;
  var ht = g({
    "out-build/vs/platform/product/common/productService.js"() {
      "use strict";
  
      se();
      Y();
      Ve = q("productService");
    }
  });
  import ni from "electron";
  var $4;
  var I4;
  var R1;
  var O1;
  var L1;
  var M1;
  var F1;
  var So;
  var Eo;
  var ih;
  var pc = g({
    "out-build/vs/platform/theme/electron-main/themeMainService.js"() {
      "use strict";
  
      B();
      M();
      H();
      Ke();
      Y();
      Ti();
      $4 = "#FFFFFF";
      I4 = "#1F1F1F";
      R1 = "#000000";
      O1 = "#FFFFFF";
      L1 = "theme";
      M1 = "themeBackground";
      F1 = "windowSplash";
      (function (t) {
        t.DETECT_COLOR_SCHEME = "window.autoDetectColorScheme";
        t.SYSTEM_COLOR_THEME = "window.systemColorTheme";
      })(So ||= {});
      Eo = q("themeMainService");
      ih = class extends T {
        constructor(e, i) {
          super();
          this.b = e;
          this.c = i;
          this.a = this.D(new $());
          this.onDidChangeColorScheme = this.a.event;
          if (!Se) {
            this.D(this.c.onDidChangeConfiguration(s => {
              if (s.affectsConfiguration(So.SYSTEM_COLOR_THEME) || s.affectsConfiguration(So.DETECT_COLOR_SCHEME)) {
                this.f();
              }
            }));
          }
          this.f();
          this.D(x.fromNodeEventEmitter(ni.nativeTheme, "updated")(() => this.a.fire(this.getColorScheme())));
        }
        f() {
          if (Se || this.c.getValue(So.DETECT_COLOR_SCHEME)) {
            ni.nativeTheme.themeSource = "system";
          } else {
            switch (this.c.getValue(So.SYSTEM_COLOR_THEME)) {
              case "dark":
                ni.nativeTheme.themeSource = "dark";
                break;
              case "light":
                ni.nativeTheme.themeSource = "light";
                break;
              case "auto":
                switch (this.g()) {
                  case "vs":
                    ni.nativeTheme.themeSource = "light";
                    break;
                  case "vs-dark":
                    ni.nativeTheme.themeSource = "dark";
                    break;
                  default:
                    ni.nativeTheme.themeSource = "system";
                }
                break;
              default:
                ni.nativeTheme.themeSource = "system";
                break;
            }
          }
        }
        getColorScheme() {
          if (j) {
            if (ni.nativeTheme.shouldUseHighContrastColors) {
              return {
                dark: ni.nativeTheme.shouldUseInvertedColorScheme,
                highContrast: true
              };
            }
          } else if (N) {
            if (ni.nativeTheme.shouldUseInvertedColorScheme || ni.nativeTheme.shouldUseHighContrastColors) {
              return {
                dark: ni.nativeTheme.shouldUseDarkColors,
                highContrast: true
              };
            }
          } else if (Se && ni.nativeTheme.shouldUseHighContrastColors) {
            return {
              dark: true,
              highContrast: true
            };
          }
          return {
            dark: ni.nativeTheme.shouldUseDarkColors,
            highContrast: false
          };
        }
        getBackgroundColor() {
          const e = this.getColorScheme();
          if (e.highContrast && this.c.getValue("window.autoDetectHighContrast")) {
            if (e.dark) {
              return R1;
            } else {
              return O1;
            }
          }
          let i = this.b.getItem(M1, null);
          if (!i) {
            switch (this.g()) {
              case "vs":
                i = $4;
                break;
              case "hc-black":
                i = R1;
                break;
              case "hc-light":
                i = O1;
                break;
              default:
                i = I4;
            }
          }
          return i;
        }
        g() {
          switch (this.b.getItem(L1, "vs-dark").split(" ")[0]) {
            case "vs":
              return "vs";
            case "hc-black":
              return "hc-black";
            case "hc-light":
              return "hc-light";
            default:
              return "vs-dark";
          }
        }
        saveWindowSplash(e, i) {
          this.b.setItems([{
            key: L1,
            data: i.baseTheme
          }, {
            key: M1,
            data: i.colorInfo.background
          }, {
            key: F1,
            data: i
          }]);
          if (typeof e == "number") {
            this.h(e, i);
          }
          this.f();
        }
        h(e, i) {
          for (const s of ni.BrowserWindow.getAllWindows()) {
            if (s.id === e) {
              s.setBackgroundColor(i.colorInfo.background);
              break;
            }
          }
        }
        getWindowSplash() {
          return this.b.getItem(F1);
        }
      };
      ih = __decorate([__param(0, Oi), __param(1, Je)], ih);
    }
  });
  var Dt;
  var sh;
  var ko;
  var gc = g({
    "out-build/vs/platform/product/common/product.js"() {
      "use strict";
  
      ys();
      sh = globalThis.vscode;
      if (typeof sh !== "undefined" && typeof sh.context !== "undefined") {
        const t = sh.context.configuration();
        if (t) {
          Dt = t.product;
        } else {
          throw new Error("Sandbox: unable to resolve product configuration from preload script.");
        }
      } else if (globalThis._VSCODE_PRODUCT_JSON && globalThis._VSCODE_PACKAGE_JSON) {
        Dt = globalThis._VSCODE_PRODUCT_JSON;
        if (Ii.VSCODE_DEV) {
          Object.assign(Dt, {
            nameShort: `${Dt.nameShort} Dev`,
            nameLong: `${Dt.nameLong} Dev`,
            dataFolderName: `${Dt.dataFolderName}-dev`,
            serverDataFolderName: Dt.serverDataFolderName ? `${Dt.serverDataFolderName}-dev` : undefined
          });
        }
        if (Ii.VSCODE_DEV_ONBOARDING) {
          Object.assign(Dt, {
            nameShort: `${Dt.nameShort} Onboarding`,
            nameLong: `${Dt.nameLong} Onboarding`,
            dataFolderName: `${Dt.dataFolderName}-onboarding`,
            serverDataFolderName: Dt.serverDataFolderName ? `${Dt.serverDataFolderName}-onboarding` : undefined
          });
        }
        if (!Dt.version) {
          const t = globalThis._VSCODE_PACKAGE_JSON;
          Object.assign(Dt, {
            version: t.version
          });
        }
      } else {
        Dt = {};
        if (Object.keys(Dt).length === 0) {
          Object.assign(Dt, {
            version: "1.94.0-dev",
            nameShort: "Cursor Dev",
            nameLong: "Cursor Dev",
            applicationName: "cursor",
            dataFolderName: ".cursor",
            urlProtocol: "cursor",
            reportIssueUrl: "https://github.com/getcursor/cursor/issues/new",
            licenseName: "MIT",
            licenseUrl: "https://github.com/getcursor/cursor/",
            serverLicenseUrl: "https://github.com/getcursor/cursor/"
          });
        }
      }
      ko = Dt;
    }
  });
  function N1(t) {
    return !!t.workspaceUri;
  }
  function A4(t) {
    return !!t.folderUri;
  }
  function C4(t) {
    return !!t.fileUri;
  }
  function nD(t) {
    const e = dn(t);
    const i = t.getValue("window.menuBarVisibility");
    if (i === "default" || e && i === "compact" || N && Jf) {
      return "classic";
    } else {
      return i;
    }
  }
  function dn(t, e) {
    e ||= oD(t);
    return e === "native";
  }
  function oD(t) {
    if (fr) {
      return "custom";
    }
    const e = t.getValue("window");
    if (e) {
      if (N && e.nativeTabs === true || N && e.nativeFullScreen === false) {
        return "native";
      }
      const r = e.titleBarStyle;
      if (r === "native" || r === "custom") {
        return r;
      }
    }
    if (Se && ko.quality === "stable") {
      return "native";
    } else {
      return "custom";
    }
  }
  function W1(t) {
    if (N || fr || dn(t)) {
      return false;
    }
    if (Se) {
      const e = t.getValue("window.experimentalControlOverlay");
      if (typeof e == "boolean") {
        return e;
      }
    }
    return true;
  }
  function _4(t) {
    const e = t.getValue("window");
    if (!e || typeof e.nativeFullScreen != "boolean" || e.nativeTabs) {
      return true;
    } else {
      return e.nativeFullScreen !== false;
    }
  }
  function R4(t = 0) {
    return Math.pow(1.2, t);
  }
  var T1;
  var O4;
  var L4;
  var M4;
  var F4;
  var fn = g({
    "out-build/vs/platform/window/common/window.js"() {
      "use strict";
  
      H();
      gc();
      T1 = {
        WIDTH: 400,
        WIDTH_WITH_VERTICAL_PANEL: 600,
        HEIGHT: 270
      };
      (function (t) {
        t.TITLE_BAR_STYLE = "window.titleBarStyle";
        t.CUSTOM_TITLE_BAR_VISIBILITY = "window.customTitleBarVisibility";
      })(O4 ||= {});
      (function (t) {
        t.NATIVE = "native";
        t.CUSTOM = "custom";
      })(L4 ||= {});
      (function (t) {
        t.AUTO = "auto";
        t.WINDOWED = "windowed";
        t.NEVER = "never";
      })(M4 ||= {});
      F4 = 35;
    }
  });
  import aD from "electron";
  var N4;
  var W4;
  var Ar;
  var T4;
  var j4;
  var U4;
  var mc = g({
    "out-build/vs/platform/window/electron-main/window.js"() {
      "use strict";
  
      (function (t) {
        t[t.INITIAL = 1] = "INITIAL";
        t[t.LOAD = 2] = "LOAD";
        t[t.RELOAD = 3] = "RELOAD";
      })(N4 ||= {});
      (function (t) {
        t[t.CLOSE = 1] = "CLOSE";
        t[t.QUIT = 2] = "QUIT";
        t[t.RELOAD = 3] = "RELOAD";
        t[t.LOAD = 4] = "LOAD";
      })(W4 ||= {});
      Ar = function (t = 1) {
        return {
          width: 1024,
          height: 768,
          mode: t
        };
      };
      T4 = function () {
        const i = aD.screen.getPrimaryDisplay().workArea;
        const s = Math.max(i.x + i.width / 2 - 400, 0);
        const r = Math.max(i.y + i.height / 2 - 300, 0);
        return {
          x: s,
          y: r,
          width: 800,
          height: 600,
          mode: 1
        };
      };
      (function (t) {
        t[t.Maximized = 0] = "Maximized";
        t[t.Normal = 1] = "Normal";
        t[t.Minimized = 2] = "Minimized";
        t[t.Fullscreen = 3] = "Fullscreen";
      })(j4 ||= {});
      (function (t) {
        t[t.UNRESPONSIVE = 1] = "UNRESPONSIVE";
        t[t.PROCESS_GONE = 2] = "PROCESS_GONE";
        t[t.LOAD = 3] = "LOAD";
        t[t.RESPONSIVE = 4] = "RESPONSIVE";
      })(U4 ||= {});
    }
  });
  import B4 from "electron";
  function rh(t, e, i, s) {
    const r = t.get(Eo);
    const n = t.get(Ve);
    const o = t.get(Je);
    const a = t.get(ot);
    const c = o.getValue("window");
    const l = {
      backgroundColor: r.getBackgroundColor(),
      minWidth: T1.WIDTH,
      minHeight: T1.HEIGHT,
      title: n.nameLong,
      show: i.hideBecauseShadowWindow === false && e.mode !== 0 && e.mode !== 3,
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height,
      webPreferences: {
        ...s,
        enableWebSQL: false,
        spellcheck: false,
        zoomFactor: R4(e.zoomLevel ?? c?.zoomLevel),
        autoplayPolicy: "user-gesture-required",
        enableBlinkFeatures: "HighlightAPI",
        sandbox: true,
        enableDeprecatedPaste: true
      },
      experimentalDarkMode: true
    };
    if (Se) {
      l.icon = F(a.appRoot, "resources/linux/code.png");
      l.frame = false;
    } else if (j && !a.isBuilt) {
      l.icon = F(a.appRoot, "resources/win32/code_150x150.png");
    }
    if (N) {
      l.acceptFirstMouse = true;
      if (c?.clickThroughInactive === false) {
        l.acceptFirstMouse = false;
      }
    }
    if (i?.disableFullscreen) {
      l.fullscreen = false;
    } else if (N && !_4(o)) {
      l.fullscreenable = false;
    }
    if (N && c?.nativeTabs === true) {
      l.tabbingIdentifier = n.nameShort;
    }
    if (!dn(o, i?.forceNativeTitlebar ? "native" : undefined) && (l.titleBarStyle = "hidden", N || (l.frame = false), W1(o))) {
      const f = r.getWindowSplash()?.colorInfo.titleBarBackground ?? r.getBackgroundColor();
      const p = th.fromHex(f).isDarker() ? "#FFFFFF" : "#000000";
      l.titleBarOverlay = {
        height: 29,
        color: f,
        symbolColor: p
      };
    }
    return l;
  }
  function q4(t) {
    let e;
    let i = Number.MIN_VALUE;
    for (const s of t) {
      if (s.lastFocusTime > i) {
        i = s.lastFocusTime;
        e = s;
      }
    }
    return e;
  }
  var dt;
  var z4;
  var nh;
  var Lt = g({
    "out-build/vs/platform/windows/electron-main/windows.js"() {
      "use strict";
  
      sD();
      we();
      H();
      Ke();
      vt();
      Y();
      ht();
      pc();
      fn();
      mc();
      dt = q("windowsMainService");
      (function (t) {
        t[t.CLI = 0] = "CLI";
        t[t.DOCK = 1] = "DOCK";
        t[t.MENU = 2] = "MENU";
        t[t.DIALOG = 3] = "DIALOG";
        t[t.DESKTOP = 4] = "DESKTOP";
        t[t.API = 5] = "API";
        t[t.LINK = 6] = "LINK";
      })(z4 ||= {});
      (function (t) {
        function e(s, r, n = B4.screen.getAllDisplays()) {
          s.trace(`window#validateWindowState: validating window state on ${n.length} display(s)`, r);
          if (typeof r.x != "number" || typeof r.y != "number" || typeof r.width != "number" || typeof r.height != "number") {
            s.trace("window#validateWindowState: unexpected type of state values");
            return;
          }
          if (r.width <= 0 || r.height <= 0) {
            s.trace("window#validateWindowState: unexpected negative values");
            return;
          }
          if (n.length === 1) {
            const l = i(n[0]);
            s.trace("window#validateWindowState: single monitor working area", l);
            if (l) {
              let u = function () {
                if (!!r && typeof r.x == "number" && typeof r.y == "number" && !!l) {
                  if (r.x < l.x) {
                    r.x = l.x;
                  }
                  if (r.y < l.y) {
                    r.y = l.y;
                  }
                }
              };
              var o = u;
              u();
              if (r.width > l.width) {
                r.width = l.width;
              }
              if (r.height > l.height) {
                r.height = l.height;
              }
              if (r.x > l.x + l.width - 128) {
                r.x = l.x + l.width - r.width;
              }
              if (r.y > l.y + l.height - 128) {
                r.y = l.y + l.height - r.height;
              }
              u();
            }
            return r;
          }
          if (r.display && r.mode === 3) {
            const l = n.find(u => u.id === r.display);
            if (l && typeof l.bounds?.x == "number" && typeof l.bounds?.y == "number") {
              s.trace("window#validateWindowState: restoring fullscreen to previous display");
              const u = Ar(3);
              u.x = l.bounds.x;
              u.y = l.bounds.y;
              return u;
            }
          }
          let a;
          let c;
          try {
            a = B4.screen.getDisplayMatching({
              x: r.x,
              y: r.y,
              width: r.width,
              height: r.height
            });
            c = i(a);
            s.trace("window#validateWindowState: multi-monitor working area", c);
          } catch (l) {
            s.error("window#validateWindowState: error finding display for window state", l);
          }
          if (a && c && r.x + r.width > c.x && r.y + r.height > c.y && r.x < c.x + c.width && r.y < c.y + c.height) {
            return r;
          }
          s.trace("window#validateWindowState: state is outside of the multi-monitor working area");
        }
        t.validateWindowState = e;
        function i(s) {
          if (s.workArea.width > 0 && s.workArea.height > 0) {
            return s.workArea;
          }
          if (s.bounds.width > 0 && s.bounds.height > 0) {
            return s.bounds;
          }
        }
      })(nh ||= {});
    }
  });
  import { app as cD } from "electron";
  var oh;
  var ah;
  var H4 = g({
    "out-build/vs/platform/native/electron-main/auth.js"() {
      "use strict";
  
      At();
      B();
      er();
      M();
      se();
      _i();
      Ke();
      Kb();
      vt();
      Y();
      X();
      eh();
      Lt();
      oh = q("proxyAuthService");
      ah = class extends T {
        constructor(e, i, s, r, n, o) {
          super();
          this.h = e;
          this.m = i;
          this.n = s;
          this.q = r;
          this.r = n;
          this.s = o;
          this.a = "proxy-credentials://";
          this.b = new Map();
          this.c = undefined;
          this.f = new Set();
          this.g = new Map();
          this.t();
        }
        t() {
          const e = x.fromNodeEventEmitter(cD, "login", (i, s, r, n, o) => ({
            event: i,
            authInfo: {
              ...n,
              attempt: r.firstAuthAttempt ? 1 : 2
            },
            callback: o
          }));
          this.D(e(this.u, this));
        }
        async lookupAuthorization(e) {
          return this.u({
            authInfo: e
          });
        }
        async u({
          event: e,
          authInfo: i,
          callback: s
        }) {
          if (!i.isProxy) {
            return;
          }
          e?.preventDefault();
          const r = String(Ds({
            scheme: i.scheme,
            host: i.host,
            port: i.port
          }));
          let n;
          let o = this.b.get(r);
          if (o) {
            this.h.trace("auth#onLogin (proxy) - pending proxy handling found");
            n = await o;
          } else {
            this.h.trace("auth#onLogin (proxy) - no pending proxy handling found, starting new");
            o = this.w(i, r);
            this.b.set(r, o);
            try {
              n = await o;
            } finally {
              this.b.delete(r);
            }
          }
          s?.(n?.username, n?.password);
          return n;
        }
        async w(e, i) {
          this.h.trace("auth#resolveProxyCredentials (proxy) - enter");
          try {
            const s = await this.y(e, i);
            if (s) {
              this.h.trace("auth#resolveProxyCredentials (proxy) - got credentials");
              return s;
            }
            this.h.trace("auth#resolveProxyCredentials (proxy) - did not get credentials");
          } finally {
            this.h.trace("auth#resolveProxyCredentials (proxy) - exit");
          }
        }
        async y(e, i) {
          this.h.trace("auth#doResolveProxyCredentials - enter", e);
          if (this.s.extensionTestsLocationURI) {
            const l = this.r.getValue("integration-test.http.proxyAuth");
            if (l) {
              const u = l.indexOf(":");
              if (u !== -1) {
                return {
                  username: l.substring(0, u),
                  password: l.substring(u + 1)
                };
              } else {
                return {
                  username: l,
                  password: ""
                };
              }
            }
            return;
          }
          const s = (this.r.getValue("http.proxy") || "").trim() || (process.env.https_proxy || process.env.HTTPS_PROXY || process.env.http_proxy || process.env.HTTP_PROXY || "").trim() || undefined;
          if (s?.indexOf("@") !== -1) {
            const l = P.parse(s);
            const u = l.authority.indexOf("@");
            if (u !== -1) {
              if (e.attempt > 1) {
                this.h.trace("auth#doResolveProxyCredentials (proxy) - exit - ignoring previously used config/envvar credentials");
                return;
              }
              this.h.trace("auth#doResolveProxyCredentials (proxy) - exit - found config/envvar credentials to use");
              const d = l.authority.substring(0, u);
              const f = d.indexOf(":");
              if (f !== -1) {
                return {
                  username: d.substring(0, f),
                  password: d.substring(f + 1)
                };
              } else {
                return {
                  username: d,
                  password: ""
                };
              }
            }
          }
          const r = e.attempt === 1 && this.g.get(i);
          if (r) {
            this.h.trace("auth#doResolveProxyCredentials (proxy) - exit - found session credentials to use");
            const {
              username: l,
              password: u
            } = r;
            return {
              username: l,
              password: u
            };
          }
          let n;
          let o;
          try {
            const l = this.q.get(this.a + i, -1);
            if (l) {
              const u = JSON.parse(await this.n.decrypt(l));
              n = u.username;
              o = u.password;
            }
          } catch (l) {
            this.h.error(l);
          }
          if (e.attempt === 1 && typeof n == "string" && typeof o == "string") {
            this.h.trace("auth#doResolveProxyCredentials (proxy) - exit - found stored credentials to use");
            this.g.set(i, {
              username: n,
              password: o
            });
            return {
              username: n,
              password: o
            };
          }
          const a = this.c;
          const c = this.c = (async () => {
            await a;
            const l = await this.z(e, i, n, o);
            if (this.c === c) {
              this.c = undefined;
            }
            return l;
          })();
          return c;
        }
        async z(e, i, s, r) {
          if (this.f.has(i)) {
            this.h.trace("auth#doResolveProxyCredentials (proxy) - exit - login dialog was cancelled before, not showing again");
            return;
          }
          const n = this.m.getFocusedWindow() || this.m.getLastActiveWindow();
          if (!n) {
            this.h.trace("auth#doResolveProxyCredentials (proxy) - exit - no opened window found to show dialog in");
            return;
          }
          this.h.trace(`auth#doResolveProxyCredentials (proxy) - asking window ${n.id} to handle proxy login`);
          const o = this.g.get(i);
          const a = {
            authInfo: e,
            username: o?.username ?? s,
            password: o?.password ?? r,
            replyChannel: `vscode:proxyAuthResponse:${ti()}`
          };
          n.sendWhenReady("vscode:openProxyAuthenticationDialog", We.None, a);
          const c = await new Promise(l => {
            const u = async (d, f, p) => {
              if (f === a.replyChannel) {
                this.h.trace(`auth#doResolveProxyCredentials - exit - received credentials from window ${n.id}`);
                n.win?.webContents.off("ipc-message", u);
                if (p) {
                  const w = {
                    username: p.username,
                    password: p.password
                  };
                  try {
                    if (p.remember) {
                      const m = await this.n.encrypt(JSON.stringify(w));
                      this.q.store(this.a + i, m, -1, 1);
                    } else {
                      this.q.remove(this.a + i, -1);
                    }
                  } catch (m) {
                    this.h.error(m);
                  }
                  l({
                    username: w.username,
                    password: w.password
                  });
                } else {
                  this.f.add(i);
                  l(undefined);
                }
              }
            };
            n.win?.webContents.on("ipc-message", u);
          });
          this.g.set(i, c);
          return c;
        }
      };
      ah = __decorate([__param(0, V), __param(1, dt), __param(2, yu), __param(3, dc), __param(4, Je), __param(5, ot)], ah);
    }
  });
  var xo;
  var wc = g({
    "out-build/vs/platform/backup/electron-main/backup.js"() {
      "use strict";
  
      Y();
      xo = q("backupMainService");
    }
  });
  function lD(t) {
    return typeof t?.backupFolder == "string";
  }
  function uD(t) {
    let e = [];
    try {
      if (Array.isArray(t.workspaces)) {
        e = t.workspaces.map(i => ({
          workspace: {
            id: i.id,
            configPath: P.parse(i.configURIPath)
          },
          remoteAuthority: i.remoteAuthority
        }));
      }
    } catch {}
    return e;
  }
  function hD(t) {
    let e = [];
    try {
      if (Array.isArray(t.folders)) {
        e = t.folders.map(i => ({
          folderUri: P.parse(i.folderUri),
          remoteAuthority: i.remoteAuthority
        }));
      }
    } catch {}
    return e;
  }
  var dD = g({
    "out-build/vs/platform/backup/node/backup.js"() {
      "use strict";
  
      se();
    }
  });
  function fD(t) {
    return t && t.hasOwnProperty("folderUri");
  }
  var pD = g({
    "out-build/vs/platform/backup/common/backup.js"() {
      "use strict";
    }
  });
  import { createHash as j1 } from "crypto";
  function pn(t) {
    function e() {
      let i = t.scheme === R.file ? Ci(t) : t.toString();
      if (!Se) {
        i = i.toLowerCase();
      }
      return j1("md5").update(i).digest("hex");
    }
    return {
      id: e(),
      configPath: t
    };
  }
  function U1(t, e) {
    function i() {
      if (t.scheme !== R.file) {
        return j1("md5").update(t.toString()).digest("hex");
      }
      if (!e) {
        return;
      }
      let r;
      if (Se) {
        r = e.ino;
      } else if (N) {
        r = e.birthtime.getTime();
      } else if (j) {
        if (typeof e.birthtimeMs == "number") {
          r = Math.floor(e.birthtimeMs);
        } else {
          r = e.birthtime.getTime();
        }
      }
      return j1("md5").update(t.fsPath).update(r ? String(r) : "").digest("hex");
    }
    const s = i();
    if (typeof s == "string") {
      return {
        id: s,
        uri: t
      };
    }
  }
  function B1() {
    return {
      id: (Date.now() + Math.round(Math.random() * 1000)).toString()
    };
  }
  var gD;
  var q1 = g({
    "out-build/vs/platform/workspaces/node/workspaces.js"() {
      "use strict";
  
      Ie();
      H();
      nt();
      gD = 32;
    }
  });
  import { createHash as mD } from "crypto";
  var ch;
  var lh;
  var wD = g({
    "out-build/vs/platform/backup/electron-main/backupMainService.js"() {
      "use strict";
  
      gi();
      Ie();
      we();
      H();
      nt();
      _t();
      dD();
      Ke();
      vt();
      Ti();
      He();
      X();
      pD();
      ri();
      q1();
      ht();
      lh = class {
        static {
          ch = this;
        }
        static {
          this.a = "backupWorkspaces";
        }
        constructor(e, i, s, r, n) {
          this.j = e;
          this.k = i;
          this.l = s;
          this.m = r;
          this.n = n;
          this.c = this.j.backupHome;
          this.d = [];
          this.e = [];
          this.g = [];
          this.h = tt;
          this.i = {
            isEqual: (o, a) => tu(o, a, !Se)
          };
        }
        async initialize() {
          const e = this.n.getItem(ch.a) ?? {
            workspaces: [],
            folders: [],
            emptyWindows: []
          };
          this.g = await this.x(e.emptyWindows);
          this.d = await this.v(uD(e));
          this.e = await this.w(hD(e));
          this.D();
        }
        o() {
          if (this.s()) {
            return [];
          } else {
            return this.d.slice(0);
          }
        }
        q() {
          if (this.s()) {
            return [];
          } else {
            return this.e.slice(0);
          }
        }
        isHotExitEnabled() {
          return this.t() !== Nu.OFF;
        }
        s() {
          return this.t() === Nu.ON_EXIT_AND_WINDOW_CLOSE;
        }
        t() {
          return this.k.getValue()?.files?.hotExit || Nu.ON_EXIT;
        }
        getEmptyWindowBackups() {
          return this.g.slice(0);
        }
        registerWorkspaceBackup(e, i) {
          if (!this.d.some(r => e.workspace.id === r.workspace.id)) {
            this.d.push(e);
            this.D();
          }
          const s = F(this.c, e.workspace.id);
          if (i) {
            return this.u(s, i).then(() => s);
          } else {
            return s;
          }
        }
        async u(e, i) {
          if (await ee.exists(e)) {
            await this.A(e);
          }
          if (await ee.exists(i)) {
            try {
              await ee.rename(i, e, false);
            } catch (s) {
              this.m.error(`Backup: Could not move backup folder to new location: ${s.toString()}`);
            }
          }
        }
        registerFolderBackup(e) {
          if (!this.e.some(i => this.h.isEqual(e.folderUri, i.folderUri))) {
            this.e.push(e);
            this.D();
          }
          return F(this.c, this.E(e));
        }
        registerEmptyWindowBackup(e) {
          if (!this.g.some(i => !!i.backupFolder && this.i.isEqual(i.backupFolder, e.backupFolder))) {
            this.g.push(e);
            this.D();
          }
          return F(this.c, e.backupFolder);
        }
        async v(e) {
          if (!Array.isArray(e)) {
            return [];
          }
          const i = new Set();
          const s = [];
          for (const r of e) {
            const n = r.workspace;
            if (!Kt(n)) {
              return [];
            }
            const o = rD(this.j, this.l);
            if (!n.configPath.fsPath.startsWith(o.fsPath) && !i.has(n.id)) {
              i.add(n.id);
              const a = F(this.c, n.id);
              if (await this.C(a)) {
                if (n.configPath.scheme !== R.file || (await ee.exists(n.configPath.fsPath))) {
                  s.push(r);
                } else {
                  await this.A(a);
                }
              } else {
                await this.y(a);
              }
            }
          }
          return s;
        }
        async w(e) {
          if (!Array.isArray(e)) {
            return [];
          }
          const i = [];
          const s = new Set();
          for (const r of e) {
            const n = r.folderUri;
            const o = this.h.getComparisonKey(n);
            if (!s.has(o)) {
              s.add(o);
              const a = F(this.c, this.E(r));
              if (await this.C(a)) {
                if (n.scheme !== R.file || (await ee.exists(n.fsPath))) {
                  i.push(r);
                } else {
                  await this.A(a);
                }
              } else {
                await this.y(a);
              }
            }
          }
          return i;
        }
        async x(e) {
          if (!Array.isArray(e)) {
            return [];
          }
          const i = [];
          const s = new Set();
          for (const r of e) {
            const n = r.backupFolder;
            if (typeof n != "string") {
              return [];
            }
            if (!s.has(n)) {
              s.add(n);
              const o = F(this.c, n);
              if (await this.C(o)) {
                i.push(r);
              } else {
                await this.y(o);
              }
            }
          }
          return i;
        }
        async y(e) {
          try {
            await ee.rm(e, tn.MOVE);
          } catch (i) {
            this.m.error(`Backup: Could not delete stale backup: ${i.toString()}`);
          }
        }
        z() {
          let e = B1();
          while (this.g.some(i => !!i.backupFolder && this.i.isEqual(i.backupFolder, e.id))) {
            e = B1();
          }
          return {
            backupFolder: e.id
          };
        }
        async A(e) {
          const i = this.z();
          const s = F(this.c, i.backupFolder);
          try {
            await ee.rename(e, s, false);
          } catch (r) {
            this.m.error(`Backup: Could not rename backup folder: ${r.toString()}`);
            return false;
          }
          this.g.push(i);
          return true;
        }
        async getDirtyWorkspaces() {
          const e = [];
          for (const i of this.d) {
            if (await this.B(i)) {
              e.push(i);
            }
          }
          for (const i of this.e) {
            if (await this.B(i)) {
              e.push(i);
            }
          }
          return e;
        }
        B(e) {
          let i;
          if (lD(e)) {
            i = F(this.c, e.backupFolder);
          } else if (fD(e)) {
            i = F(this.c, this.E(e));
          } else {
            i = F(this.c, e.workspace.id);
          }
          return this.C(i);
        }
        async C(e) {
          try {
            const i = await ee.readdir(e);
            for (const s of i) {
              try {
                if ((await ee.readdir(F(e, s))).length > 0) {
                  return true;
                }
              } catch {}
            }
          } catch {}
          return false;
        }
        D() {
          const e = {
            workspaces: this.d.map(({
              workspace: i,
              remoteAuthority: s
            }) => {
              const r = {
                id: i.id,
                configURIPath: i.configPath.toString()
              };
              if (s) {
                r.remoteAuthority = s;
              }
              return r;
            }),
            folders: this.e.map(({
              folderUri: i,
              remoteAuthority: s
            }) => {
              const r = {
                folderUri: i.toString()
              };
              if (s) {
                r.remoteAuthority = s;
              }
              return r;
            }),
            emptyWindows: this.g.map(({
              backupFolder: i,
              remoteAuthority: s
            }) => {
              const r = {
                backupFolder: i
              };
              if (s) {
                r.remoteAuthority = s;
              }
              return r;
            })
          };
          this.n.setItem(ch.a, e);
        }
        E(e) {
          const i = e.folderUri;
          let s;
          if (i.scheme === R.file) {
            s = Se ? i.fsPath : i.fsPath.toLowerCase();
          } else {
            s = i.toString().toLowerCase();
          }
          return mD("md5").update(s).digest("hex");
        }
      };
      lh = ch = __decorate([__param(0, ot), __param(1, Je), __param(2, Ve), __param(3, V), __param(4, Oi)], lh);
    }
  });
  var V4;
  var vD = g({
    "out-build/vs/platform/debug/common/extensionHostDebugIpc.js"() {
      "use strict";
  
      B();
      M();
      V4 = class {
        constructor() {
          this.a = new $();
          this.b = new $();
          this.c = new $();
          this.d = new $();
        }
        static {
          this.ChannelName = "extensionhostdebugservice";
        }
        call(t, e, i) {
          switch (e) {
            case "close":
              return Promise.resolve(this.a.fire({
                sessionId: i[0]
              }));
            case "reload":
              return Promise.resolve(this.b.fire({
                sessionId: i[0]
              }));
            case "terminate":
              return Promise.resolve(this.c.fire({
                sessionId: i[0]
              }));
            case "attach":
              return Promise.resolve(this.d.fire({
                sessionId: i[0],
                port: i[1],
                subId: i[2]
              }));
          }
          throw new Error("Method not implemented.");
        }
        listen(t, e, i) {
          switch (e) {
            case "close":
              return this.a.event;
            case "reload":
              return this.b.event;
            case "terminate":
              return this.c.event;
            case "attach":
              return this.d.event;
          }
          throw new Error("Method not implemented.");
        }
      };
    }
  });
  function z1(t, e, i = J4) {
    const s = t.find(f => f.length > 0 && f[0] !== "-");
    const r = {};
    const n = ["_"];
    const o = [];
    const a = {};
    let c;
    for (const f in e) {
      const p = e[f];
      if (p.type === "subcommand") {
        if (f === s) {
          c = p;
        }
      } else {
        if (p.alias) {
          r[f] = p.alias;
        }
        if (p.type === "string" || p.type === "string[]") {
          n.push(f);
          if (p.deprecates) {
            n.push(...p.deprecates);
          }
        } else if (p.type === "boolean") {
          o.push(f);
          if (p.deprecates) {
            o.push(...p.deprecates);
          }
        }
        if (p.global) {
          a[f] = p;
        }
      }
    }
    if (c && s) {
      const f = a;
      for (const y in c.options) {
        f[y] = c.options[y];
      }
      const p = t.filter(y => y !== s);
      const w = i.getSubcommandReporter ? i.getSubcommandReporter(s) : undefined;
      const m = z1(p, f, w);
      return {
        [s]: m,
        _: []
      };
    }
    const l = (0, G4.default)(t, {
      string: n,
      boolean: o,
      alias: r
    });
    const u = {};
    const d = l;
    u._ = l._.map(f => String(f)).filter(f => f.length > 0);
    delete d._;
    for (const f in e) {
      const p = e[f];
      if (p.type === "subcommand") {
        continue;
      }
      if (p.alias) {
        delete d[p.alias];
      }
      let w = d[f];
      if (p.deprecates) {
        for (const m of p.deprecates) {
          if (d.hasOwnProperty(m)) {
            if (!w) {
              w = d[m];
              if (w) {
                i.onDeprecatedOption(m, p.deprecationMessage || v(1787, null, f));
              }
            }
            delete d[m];
          }
        }
      }
      if (typeof w !== "undefined") {
        if (p.type === "string[]") {
          if (!Array.isArray(w)) {
            w = [w];
          }
          if (!p.allowEmptyValue) {
            const m = w.filter(y => y.length > 0);
            if (m.length !== w.length) {
              i.onEmptyValue(f);
              w = m.length > 0 ? m : undefined;
            }
          }
        } else if (p.type === "string") {
          if (Array.isArray(w)) {
            w = w.pop();
            i.onMultipleValues(f, w);
          } else if (!w && !p.allowEmptyValue) {
            i.onEmptyValue(f);
            w = undefined;
          }
        }
        u[f] = w;
        if (p.deprecationMessage) {
          i.onDeprecatedOption(f, p.deprecationMessage);
        }
      }
      delete d[f];
    }
    for (const f in d) {
      i.onUnknownOption(f);
    }
    return u;
  }
  var G4;
  var bD;
  var H1;
  var V1;
  var J4;
  var K4 = g({
    "out-build/vs/platform/environment/node/argv.js"() {
      "use strict";
  
      G4 = R0(O0(), 1);
      H();
      be();
      bD = {
        o: v(1748, null),
        e: v(1749, null),
        t: v(1750, null)
      };
      H1 = ["tunnel", "serve-web"];
      V1 = {
        tunnel: {
          type: "subcommand",
          description: "Make the current machine accessible from vscode.dev or other machines through a secure tunnel",
          options: {
            "cli-data-dir": {
              type: "string",
              args: "dir",
              description: v(1751, null)
            },
            "disable-telemetry": {
              type: "boolean"
            },
            "telemetry-level": {
              type: "string"
            },
            user: {
              type: "subcommand",
              options: {
                login: {
                  type: "subcommand",
                  options: {
                    provider: {
                      type: "string"
                    },
                    "access-token": {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        "serve-web": {
          type: "subcommand",
          description: "Run a server that displays the editor UI in browsers.",
          options: {
            "cli-data-dir": {
              type: "string",
              args: "dir",
              description: v(1752, null)
            },
            "disable-telemetry": {
              type: "boolean"
            },
            "telemetry-level": {
              type: "string"
            }
          }
        },
        diff: {
          type: "boolean",
          cat: "o",
          alias: "d",
          args: ["file", "file"],
          description: v(1753, null)
        },
        merge: {
          type: "boolean",
          cat: "o",
          alias: "m",
          args: ["path1", "path2", "base", "result"],
          description: v(1754, null)
        },
        add: {
          type: "boolean",
          cat: "o",
          alias: "a",
          args: "folder",
          description: v(1755, null)
        },
        goto: {
          type: "boolean",
          cat: "o",
          alias: "g",
          args: "file:line[:character]",
          description: v(1756, null)
        },
        "new-window": {
          type: "boolean",
          cat: "o",
          alias: "n",
          description: v(1757, null)
        },
        "reuse-window": {
          type: "boolean",
          cat: "o",
          alias: "r",
          description: v(1758, null)
        },
        wait: {
          type: "boolean",
          cat: "o",
          alias: "w",
          description: v(1759, null)
        },
        waitMarkerFilePath: {
          type: "string"
        },
        locale: {
          type: "string",
          cat: "o",
          args: "locale",
          description: v(1760, null)
        },
        "user-data-dir": {
          type: "string",
          cat: "o",
          args: "dir",
          description: v(1761, null)
        },
        profile: {
          type: "string",
          cat: "o",
          args: "profileName",
          description: v(1762, null)
        },
        help: {
          type: "boolean",
          cat: "o",
          alias: "h",
          description: v(1763, null)
        },
        "extensions-dir": {
          type: "string",
          deprecates: ["extensionHomePath"],
          cat: "e",
          args: "dir",
          description: v(1764, null)
        },
        "extensions-download-dir": {
          type: "string"
        },
        "builtin-extensions-dir": {
          type: "string"
        },
        "list-extensions": {
          type: "boolean",
          cat: "e",
          description: v(1765, null)
        },
        "show-versions": {
          type: "boolean",
          cat: "e",
          description: v(1766, null)
        },
        category: {
          type: "string",
          allowEmptyValue: true,
          cat: "e",
          description: v(1767, null),
          args: "category"
        },
        "install-extension": {
          type: "string[]",
          cat: "e",
          args: "ext-id | path",
          description: v(1768, null)
        },
        "pre-release": {
          type: "boolean",
          cat: "e",
          description: v(1769, null)
        },
        "uninstall-extension": {
          type: "string[]",
          cat: "e",
          args: "ext-id",
          description: v(1770, null)
        },
        "update-extensions": {
          type: "boolean",
          cat: "e",
          description: v(1771, null)
        },
        "enable-proposed-api": {
          type: "string[]",
          allowEmptyValue: true,
          cat: "e",
          args: "ext-id",
          description: v(1772, null)
        },
        version: {
          type: "boolean",
          cat: "t",
          alias: "v",
          description: v(1773, null)
        },
        verbose: {
          type: "boolean",
          cat: "t",
          global: true,
          description: v(1774, null)
        },
        log: {
          type: "string[]",
          cat: "t",
          args: "level",
          global: true,
          description: v(1775, null)
        },
        status: {
          type: "boolean",
          alias: "s",
          cat: "t",
          description: v(1776, null)
        },
        "prof-startup": {
          type: "boolean",
          cat: "t",
          description: v(1777, null)
        },
        "prof-append-timers": {
          type: "string"
        },
        "prof-duration-markers": {
          type: "string[]"
        },
        "prof-duration-markers-file": {
          type: "string"
        },
        "no-cached-data": {
          type: "boolean"
        },
        "prof-startup-prefix": {
          type: "string"
        },
        "prof-v8-extensions": {
          type: "boolean"
        },
        "disable-extensions": {
          type: "boolean",
          deprecates: ["disableExtensions"],
          cat: "t",
          description: v(1778, null)
        },
        "disable-extension": {
          type: "string[]",
          cat: "t",
          args: "ext-id",
          description: v(1779, null)
        },
        sync: {
          type: "string",
          cat: "t",
          description: v(1780, null),
          args: ["on | off"]
        },
        "inspect-extensions": {
          type: "string",
          allowEmptyValue: true,
          deprecates: ["debugPluginHost"],
          args: "port",
          cat: "t",
          description: v(1781, null)
        },
        "inspect-brk-extensions": {
          type: "string",
          allowEmptyValue: true,
          deprecates: ["debugBrkPluginHost"],
          args: "port",
          cat: "t",
          description: v(1782, null)
        },
        "disable-lcd-text": {
          type: "boolean",
          cat: "t",
          description: v(1783, null)
        },
        "disable-gpu": {
          type: "boolean",
          cat: "t",
          description: v(1784, null)
        },
        "disable-chromium-sandbox": {
          type: "boolean",
          cat: "t",
          description: v(1785, null)
        },
        sandbox: {
          type: "boolean"
        },
        telemetry: {
          type: "boolean",
          cat: "t",
          description: v(1786, null)
        },
        remote: {
          type: "string",
          allowEmptyValue: true
        },
        "folder-uri": {
          type: "string[]",
          cat: "o",
          args: "uri"
        },
        "file-uri": {
          type: "string[]",
          cat: "o",
          args: "uri"
        },
        "locate-extension": {
          type: "string[]"
        },
        extensionDevelopmentPath: {
          type: "string[]"
        },
        extensionDevelopmentKind: {
          type: "string[]"
        },
        extensionTestsPath: {
          type: "string"
        },
        extensionEnvironment: {
          type: "string"
        },
        debugId: {
          type: "string"
        },
        debugRenderer: {
          type: "boolean"
        },
        "inspect-ptyhost": {
          type: "string",
          allowEmptyValue: true
        },
        "inspect-brk-ptyhost": {
          type: "string",
          allowEmptyValue: true
        },
        "inspect-search": {
          type: "string",
          deprecates: ["debugSearch"],
          allowEmptyValue: true
        },
        "inspect-brk-search": {
          type: "string",
          deprecates: ["debugBrkSearch"],
          allowEmptyValue: true
        },
        "inspect-sharedprocess": {
          type: "string",
          allowEmptyValue: true
        },
        "inspect-brk-sharedprocess": {
          type: "string",
          allowEmptyValue: true
        },
        "export-default-configuration": {
          type: "string"
        },
        "install-source": {
          type: "string"
        },
        "enable-smoke-test-driver": {
          type: "boolean"
        },
        logExtensionHostCommunication: {
          type: "boolean"
        },
        "skip-release-notes": {
          type: "boolean"
        },
        "skip-welcome": {
          type: "boolean"
        },
        "skip-onboarding": {
          type: "boolean"
        },
        "override-cursor-auth-token": {
          type: "string"
        },
        "disable-telemetry": {
          type: "boolean"
        },
        "disable-updates": {
          type: "boolean"
        },
        "use-inmemory-secretstorage": {
          type: "boolean",
          deprecates: ["disable-keytar"]
        },
        "password-store": {
          type: "string"
        },
        "disable-workspace-trust": {
          type: "boolean"
        },
        "disable-crash-reporter": {
          type: "boolean"
        },
        "crash-reporter-directory": {
          type: "string"
        },
        "crash-reporter-id": {
          type: "string"
        },
        "skip-add-to-recently-opened": {
          type: "boolean"
        },
        "open-url": {
          type: "boolean"
        },
        "file-write": {
          type: "boolean"
        },
        "file-chmod": {
          type: "boolean"
        },
        "install-builtin-extension": {
          type: "string[]"
        },
        force: {
          type: "boolean"
        },
        "do-not-sync": {
          type: "boolean"
        },
        trace: {
          type: "boolean"
        },
        "trace-memory-infra": {
          type: "boolean"
        },
        "trace-category-filter": {
          type: "string"
        },
        "trace-options": {
          type: "string"
        },
        "preserve-env": {
          type: "boolean"
        },
        "force-user-env": {
          type: "boolean"
        },
        "force-disable-user-env": {
          type: "boolean"
        },
        "open-devtools": {
          type: "boolean"
        },
        "shadow-window-for-workspace-id": {
          type: "string"
        },
        "disable-gpu-sandbox": {
          type: "boolean"
        },
        logsPath: {
          type: "string"
        },
        "__enable-file-policy": {
          type: "boolean"
        },
        editSessionId: {
          type: "string"
        },
        continueOn: {
          type: "string"
        },
        "locate-shell-integration-path": {
          type: "string",
          args: ["bash", "pwsh", "zsh", "fish"]
        },
        "enable-coi": {
          type: "boolean"
        },
        "unresponsive-sample-interval": {
          type: "string"
        },
        "unresponsive-sample-period": {
          type: "string"
        },
        "no-proxy-server": {
          type: "boolean"
        },
        "no-sandbox": {
          type: "boolean",
          alias: "sandbox"
        },
        "proxy-server": {
          type: "string"
        },
        "proxy-bypass-list": {
          type: "string"
        },
        "proxy-pac-url": {
          type: "string"
        },
        "js-flags": {
          type: "string"
        },
        inspect: {
          type: "string",
          allowEmptyValue: true
        },
        "inspect-brk": {
          type: "string",
          allowEmptyValue: true
        },
        nolazy: {
          type: "boolean"
        },
        "force-device-scale-factor": {
          type: "string"
        },
        "force-renderer-accessibility": {
          type: "boolean"
        },
        "ignore-certificate-errors": {
          type: "boolean"
        },
        "allow-insecure-localhost": {
          type: "boolean"
        },
        "log-net-log": {
          type: "string"
        },
        vmodule: {
          type: "string"
        },
        _urls: {
          type: "string[]"
        },
        "disable-dev-shm-usage": {
          type: "boolean"
        },
        "profile-temp": {
          type: "boolean"
        },
        "ozone-platform": {
          type: "string"
        },
        "enable-tracing": {
          type: "string"
        },
        "trace-startup-format": {
          type: "string"
        },
        "trace-startup-file": {
          type: "string"
        },
        "trace-startup-duration": {
          type: "string"
        },
        "xdg-portal-required-version": {
          type: "string"
        },
        hmr: {
          type: "boolean"
        },
        _: {
          type: "string[]"
        }
      };
      J4 = {
        onUnknownOption: () => {},
        onMultipleValues: () => {},
        onEmptyValue: () => {},
        onDeprecatedOption: () => {}
      };
    }
  });
  import { createServer as yD } from "net";
  var Z4;
  var SD = g({
    "out-build/vs/platform/debug/electron-main/extensionHostDebugIpc.js"() {
      "use strict";
  
      vD();
      K4();
      Z4 = class extends V4 {
        constructor(t) {
          super();
          this.f = t;
        }
        call(t, e, i) {
          if (e === "openExtensionDevelopmentHostWindow") {
            return this.g(i[0], i[1]);
          } else {
            return super.call(t, e, i);
          }
        }
        async g(t, e) {
          const i = z1(t, V1);
          i.debugRenderer = e;
          const s = i.extensionDevelopmentPath;
          if (!s) {
            return {
              success: false
            };
          }
          const [r] = await this.f.openExtensionDevelopmentHostWindow(s, {
            context: 5,
            cli: i,
            forceProfile: i.profile,
            forceTempProfile: i["profile-temp"]
          });
          if (!e) {
            return {
              success: true
            };
          }
          const n = r.win;
          if (!n) {
            return {
              success: true
            };
          }
          const o = n.webContents.debugger;
          let a = o.isAttached() ? Infinity : 0;
          const c = yD(l => {
            if (a++ === 0) {
              o.attach();
            }
            let u = false;
            const d = w => {
              if (!u) {
                l.write(JSON.stringify(w) + "\0");
              }
            };
            const f = (w, m, y, b) => d({
              method: m,
              params: y,
              sessionId: b
            });
            n.on("close", () => {
              o.removeListener("message", f);
              l.end();
              u = true;
            });
            o.addListener("message", f);
            let p = Buffer.alloc(0);
            l.on("data", w => {
              p = Buffer.concat([p, w]);
              for (let m = p.indexOf(0); m !== -1; m = p.indexOf(0)) {
                let y;
                try {
                  const b = p.slice(0, m).toString("utf8");
                  p = p.slice(m + 1);
                  y = JSON.parse(b);
                } catch (b) {
                  console.error("error reading cdp line", b);
                }
                o.sendCommand(y.method, y.params, y.sessionId).then(b => d({
                  id: y.id,
                  sessionId: y.sessionId,
                  result: b
                })).catch(b => d({
                  id: y.id,
                  sessionId: y.sessionId,
                  error: {
                    code: 0,
                    message: b.message
                  }
                }));
              }
            });
            l.on("error", w => {
              console.error("error on cdp pipe:", w);
            });
            l.on("close", () => {
              u = true;
              if (--a === 0) {
                o.detach();
              }
            });
          });
          await new Promise(l => c.listen(0, l));
          n.on("close", () => c.close());
          return {
            rendererDebugPort: c.address().port,
            success: true
          };
        }
      };
    }
  });
  function G1(t) {
    return !!t.hostName && !!t.errorMessage;
  }
  var Y4;
  var J1;
  var K1 = g({
    "out-build/vs/platform/diagnostics/common/diagnostics.js"() {
      "use strict";
  
      Y();
      Y4 = "diagnosticsService";
      J1 = q(Y4);
    }
  });
  function X4(t, e = false) {
    let i = 0;
    const s = t.length;
    let r = "";
    let n = 0;
    let o = 16;
    let a = 0;
    function c(m) {
      let y = 0;
      let b = 0;
      while (y < m) {
        const k = t.charCodeAt(i);
        if (k >= 48 && k <= 57) {
          b = b * 16 + k - 48;
        } else if (k >= 65 && k <= 70) {
          b = b * 16 + k - 65 + 10;
        } else if (k >= 97 && k <= 102) {
          b = b * 16 + k - 97 + 10;
        } else {
          break;
        }
        i++;
        y++;
      }
      if (y < m) {
        b = -1;
      }
      return b;
    }
    function l(m) {
      i = m;
      r = "";
      n = 0;
      o = 16;
      a = 0;
    }
    function u() {
      const m = i;
      if (t.charCodeAt(i) === 48) {
        i++;
      } else {
        for (i++; i < t.length && Do(t.charCodeAt(i));) {
          i++;
        }
      }
      if (i < t.length && t.charCodeAt(i) === 46) {
        i++;
        if (i < t.length && Do(t.charCodeAt(i))) {
          for (i++; i < t.length && Do(t.charCodeAt(i));) {
            i++;
          }
        } else {
          a = 3;
          return t.substring(m, i);
        }
      }
      let y = i;
      if (i < t.length && (t.charCodeAt(i) === 69 || t.charCodeAt(i) === 101)) {
        i++;
        if (i < t.length && t.charCodeAt(i) === 43 || t.charCodeAt(i) === 45) {
          i++;
        }
        if (i < t.length && Do(t.charCodeAt(i))) {
          for (i++; i < t.length && Do(t.charCodeAt(i));) {
            i++;
          }
          y = i;
        } else {
          a = 3;
        }
      }
      return t.substring(m, y);
    }
    function d() {
      let m = "";
      let y = i;
      while (true) {
        if (i >= s) {
          m += t.substring(y, i);
          a = 2;
          break;
        }
        const b = t.charCodeAt(i);
        if (b === 34) {
          m += t.substring(y, i);
          i++;
          break;
        }
        if (b === 92) {
          m += t.substring(y, i);
          i++;
          if (i >= s) {
            a = 2;
            break;
          }
          switch (t.charCodeAt(i++)) {
            case 34:
              m += "\"";
              break;
            case 92:
              m += "\\";
              break;
            case 47:
              m += "/";
              break;
            case 98:
              m += "\b";
              break;
            case 102:
              m += "\f";
              break;
            case 110:
              m += `
  `;
              break;
            case 114:
              m += "\r";
              break;
            case 116:
              m += "\t";
              break;
            case 117:
              {
                const A = c(4);
                if (A >= 0) {
                  m += String.fromCharCode(A);
                } else {
                  a = 4;
                }
                break;
              }
            default:
              a = 5;
          }
          y = i;
          continue;
        }
        if (b >= 0 && b <= 31) {
          if (uh(b)) {
            m += t.substring(y, i);
            a = 2;
            break;
          } else {
            a = 6;
          }
        }
        i++;
      }
      return m;
    }
    function f() {
      r = "";
      a = 0;
      n = i;
      if (i >= s) {
        n = s;
        return o = 17;
      }
      let m = t.charCodeAt(i);
      if (Z1(m)) {
        do {
          i++;
          r += String.fromCharCode(m);
          m = t.charCodeAt(i);
        } while (Z1(m));
        return o = 15;
      }
      if (uh(m)) {
        i++;
        r += String.fromCharCode(m);
        if (m === 13 && t.charCodeAt(i) === 10) {
          i++;
          r += `
  `;
        }
        return o = 14;
      }
      switch (m) {
        case 123:
          i++;
          return o = 1;
        case 125:
          i++;
          return o = 2;
        case 91:
          i++;
          return o = 3;
        case 93:
          i++;
          return o = 4;
        case 58:
          i++;
          return o = 6;
        case 44:
          i++;
          return o = 5;
        case 34:
          i++;
          r = d();
          return o = 10;
        case 47:
          {
            const y = i - 1;
            if (t.charCodeAt(i + 1) === 47) {
              for (i += 2; i < s && !uh(t.charCodeAt(i));) {
                i++;
              }
              r = t.substring(y, i);
              return o = 12;
            }
            if (t.charCodeAt(i + 1) === 42) {
              i += 2;
              const b = s - 1;
              let k = false;
              while (i < b) {
                if (t.charCodeAt(i) === 42 && t.charCodeAt(i + 1) === 47) {
                  i += 2;
                  k = true;
                  break;
                }
                i++;
              }
              if (!k) {
                i++;
                a = 1;
              }
              r = t.substring(y, i);
              return o = 13;
            }
            r += String.fromCharCode(m);
            i++;
            return o = 16;
          }
        case 45:
          r += String.fromCharCode(m);
          i++;
          if (i === s || !Do(t.charCodeAt(i))) {
            return o = 16;
          }
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          r += u();
          return o = 11;
        default:
          while (i < s && p(m)) {
            i++;
            m = t.charCodeAt(i);
          }
          if (n !== i) {
            r = t.substring(n, i);
            switch (r) {
              case "true":
                return o = 8;
              case "false":
                return o = 9;
              case "null":
                return o = 7;
            }
            return o = 16;
          }
          r += String.fromCharCode(m);
          i++;
          return o = 16;
      }
    }
    function p(m) {
      if (Z1(m) || uh(m)) {
        return false;
      }
      switch (m) {
        case 125:
        case 93:
        case 123:
        case 91:
        case 34:
        case 58:
        case 44:
        case 47:
          return false;
      }
      return true;
    }
    function w() {
      let m;
      do {
        m = f();
      } while (m >= 12 && m <= 15);
      return m;
    }
    return {
      setPosition: l,
      getPosition: () => i,
      scan: e ? w : f,
      getToken: () => o,
      getTokenValue: () => r,
      getTokenOffset: () => n,
      getTokenLength: () => i - n,
      getTokenError: () => a
    };
  }
  function Z1(t) {
    return t === 32 || t === 9 || t === 11 || t === 12 || t === 160 || t === 5760 || t >= 8192 && t <= 8203 || t === 8239 || t === 8287 || t === 12288 || t === 65279;
  }
  function uh(t) {
    return t === 10 || t === 13 || t === 8232 || t === 8233;
  }
  function Do(t) {
    return t >= 48 && t <= 57;
  }
  function gn(t, e = [], i = vc.DEFAULT) {
    let s = null;
    let r = [];
    const n = [];
    function o(c) {
      if (Array.isArray(r)) {
        r.push(c);
      } else if (s !== null) {
        r[s] = c;
      }
    }
    hh(t, {
      onObjectBegin: () => {
        const c = {};
        o(c);
        n.push(r);
        r = c;
        s = null;
      },
      onObjectProperty: c => {
        s = c;
      },
      onObjectEnd: () => {
        r = n.pop();
      },
      onArrayBegin: () => {
        const c = [];
        o(c);
        n.push(r);
        r = c;
        s = null;
      },
      onArrayEnd: () => {
        r = n.pop();
      },
      onLiteralValue: o,
      onError: (c, l, u) => {
        e.push({
          error: c,
          offset: l,
          length: u
        });
      }
    }, i);
    return r[0];
  }
  function ED(t, e = [], i = vc.DEFAULT) {
    let s = {
      type: "array",
      offset: -1,
      length: -1,
      children: [],
      parent: undefined
    };
    function r(c) {
      if (s.type === "property") {
        s.length = c - s.offset;
        s = s.parent;
      }
    }
    function n(c) {
      s.children.push(c);
      return c;
    }
    hh(t, {
      onObjectBegin: c => {
        s = n({
          type: "object",
          offset: c,
          length: -1,
          parent: s,
          children: []
        });
      },
      onObjectProperty: (c, l, u) => {
        s = n({
          type: "property",
          offset: l,
          length: -1,
          parent: s,
          children: []
        });
        s.children.push({
          type: "string",
          value: c,
          offset: l,
          length: u,
          parent: s
        });
      },
      onObjectEnd: (c, l) => {
        s.length = c + l - s.offset;
        s = s.parent;
        r(c + l);
      },
      onArrayBegin: (c, l) => {
        s = n({
          type: "array",
          offset: c,
          length: -1,
          parent: s,
          children: []
        });
      },
      onArrayEnd: (c, l) => {
        s.length = c + l - s.offset;
        s = s.parent;
        r(c + l);
      },
      onLiteralValue: (c, l, u) => {
        n({
          type: Po(c),
          offset: l,
          length: u,
          parent: s,
          value: c
        });
        r(l + u);
      },
      onSeparator: (c, l, u) => {
        if (s.type === "property") {
          if (c === ":") {
            s.colonOffset = l;
          } else if (c === ",") {
            r(l);
          }
        }
      },
      onError: (c, l, u) => {
        e.push({
          error: c,
          offset: l,
          length: u
        });
      }
    }, i);
    const a = s.children[0];
    if (a) {
      delete a.parent;
    }
    return a;
  }
  function Q4(t, e) {
    if (!t) {
      return;
    }
    let i = t;
    for (const s of e) {
      if (typeof s == "string") {
        if (i.type !== "object" || !Array.isArray(i.children)) {
          return;
        }
        let r = false;
        for (const n of i.children) {
          if (Array.isArray(n.children) && n.children[0].value === s) {
            i = n.children[1];
            r = true;
            break;
          }
        }
        if (!r) {
          return;
        }
      } else {
        const r = s;
        if (i.type !== "array" || r < 0 || !Array.isArray(i.children) || r >= i.children.length) {
          return;
        }
        i = i.children[r];
      }
    }
    return i;
  }
  function hh(t, e, i = vc.DEFAULT) {
    const s = X4(t, false);
    function r(W) {
      if (W) {
        return () => W(s.getTokenOffset(), s.getTokenLength());
      } else {
        return () => true;
      }
    }
    function n(W) {
      if (W) {
        return Ee => W(Ee, s.getTokenOffset(), s.getTokenLength());
      } else {
        return () => true;
      }
    }
    const o = r(e.onObjectBegin);
    const a = n(e.onObjectProperty);
    const c = r(e.onObjectEnd);
    const l = r(e.onArrayBegin);
    const u = r(e.onArrayEnd);
    const d = n(e.onLiteralValue);
    const f = n(e.onSeparator);
    const p = r(e.onComment);
    const w = n(e.onError);
    const m = i && i.disallowComments;
    const y = i && i.allowTrailingComma;
    function b() {
      while (true) {
        const W = s.scan();
        switch (s.getTokenError()) {
          case 4:
            k(14);
            break;
          case 5:
            k(15);
            break;
          case 3:
            k(13);
            break;
          case 1:
            if (!m) {
              k(11);
            }
            break;
          case 2:
            k(12);
            break;
          case 6:
            k(16);
            break;
        }
        switch (W) {
          case 12:
          case 13:
            if (m) {
              k(10);
            } else {
              p();
            }
            break;
          case 16:
            k(1);
            break;
          case 15:
          case 14:
            break;
          default:
            return W;
        }
      }
    }
    function k(W, Ee = [], Ye = []) {
      w(W);
      if (Ee.length + Ye.length > 0) {
        let re = s.getToken();
        while (re !== 17) {
          if (Ee.indexOf(re) !== -1) {
            b();
            break;
          } else if (Ye.indexOf(re) !== -1) {
            break;
          }
          re = b();
        }
      }
    }
    function A(W) {
      const Ee = s.getTokenValue();
      if (W) {
        d(Ee);
      } else {
        a(Ee);
      }
      b();
      return true;
    }
    function C() {
      switch (s.getToken()) {
        case 11:
          {
            let W = 0;
            try {
              W = JSON.parse(s.getTokenValue());
              if (typeof W != "number") {
                k(2);
                W = 0;
              }
            } catch {
              k(2);
            }
            d(W);
            break;
          }
        case 7:
          d(null);
          break;
        case 8:
          d(true);
          break;
        case 9:
          d(false);
          break;
        default:
          return false;
      }
      b();
      return true;
    }
    function _() {
      if (s.getToken() !== 10) {
        k(3, [], [2, 5]);
        return false;
      } else {
        A(false);
        if (s.getToken() === 6) {
          f(":");
          b();
          if (!me()) {
            k(4, [], [2, 5]);
          }
        } else {
          k(5, [], [2, 5]);
        }
        return true;
      }
    }
    function Z() {
      o();
      b();
      let W = false;
      while (s.getToken() !== 2 && s.getToken() !== 17) {
        if (s.getToken() === 5) {
          if (!W) {
            k(4, [], []);
          }
          f(",");
          b();
          if (s.getToken() === 2 && y) {
            break;
          }
        } else if (W) {
          k(6, [], []);
        }
        if (!_()) {
          k(4, [], [2, 5]);
        }
        W = true;
      }
      c();
      if (s.getToken() !== 2) {
        k(7, [2], []);
      } else {
        b();
      }
      return true;
    }
    function ie() {
      l();
      b();
      let W = false;
      while (s.getToken() !== 4 && s.getToken() !== 17) {
        if (s.getToken() === 5) {
          if (!W) {
            k(4, [], []);
          }
          f(",");
          b();
          if (s.getToken() === 4 && y) {
            break;
          }
        } else if (W) {
          k(6, [], []);
        }
        if (!me()) {
          k(4, [], [4, 5]);
        }
        W = true;
      }
      u();
      if (s.getToken() !== 4) {
        k(8, [4], []);
      } else {
        b();
      }
      return true;
    }
    function me() {
      switch (s.getToken()) {
        case 3:
          return ie();
        case 1:
          return Z();
        case 10:
          return A(true);
        default:
          return C();
      }
    }
    b();
    if (s.getToken() === 17) {
      if (i.allowEmptyContent) {
        return true;
      } else {
        k(4, [], []);
        return false;
      }
    } else if (me()) {
      if (s.getToken() !== 17) {
        k(9, [], []);
      }
      return true;
    } else {
      k(4, [], []);
      return false;
    }
  }
  function Po(t) {
    switch (typeof t) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
      case "object":
        {
          if (t) {
            if (Array.isArray(t)) {
              return "array";
            }
          } else {
            return "null";
          }
          return "object";
        }
      default:
        return "null";
    }
  }
  var e5;
  var t5;
  var i5;
  var vc;
  var s5;
  var rr = g({
    "out-build/vs/base/common/json.js"() {
      "use strict";
  
      (function (t) {
        t[t.None = 0] = "None";
        t[t.UnexpectedEndOfComment = 1] = "UnexpectedEndOfComment";
        t[t.UnexpectedEndOfString = 2] = "UnexpectedEndOfString";
        t[t.UnexpectedEndOfNumber = 3] = "UnexpectedEndOfNumber";
        t[t.InvalidUnicode = 4] = "InvalidUnicode";
        t[t.InvalidEscapeCharacter = 5] = "InvalidEscapeCharacter";
        t[t.InvalidCharacter = 6] = "InvalidCharacter";
      })(e5 ||= {});
      (function (t) {
        t[t.OpenBraceToken = 1] = "OpenBraceToken";
        t[t.CloseBraceToken = 2] = "CloseBraceToken";
        t[t.OpenBracketToken = 3] = "OpenBracketToken";
        t[t.CloseBracketToken = 4] = "CloseBracketToken";
        t[t.CommaToken = 5] = "CommaToken";
        t[t.ColonToken = 6] = "ColonToken";
        t[t.NullKeyword = 7] = "NullKeyword";
        t[t.TrueKeyword = 8] = "TrueKeyword";
        t[t.FalseKeyword = 9] = "FalseKeyword";
        t[t.StringLiteral = 10] = "StringLiteral";
        t[t.NumericLiteral = 11] = "NumericLiteral";
        t[t.LineCommentTrivia = 12] = "LineCommentTrivia";
        t[t.BlockCommentTrivia = 13] = "BlockCommentTrivia";
        t[t.LineBreakTrivia = 14] = "LineBreakTrivia";
        t[t.Trivia = 15] = "Trivia";
        t[t.Unknown = 16] = "Unknown";
        t[t.EOF = 17] = "EOF";
      })(t5 ||= {});
      (function (t) {
        t[t.InvalidSymbol = 1] = "InvalidSymbol";
        t[t.InvalidNumberFormat = 2] = "InvalidNumberFormat";
        t[t.PropertyNameExpected = 3] = "PropertyNameExpected";
        t[t.ValueExpected = 4] = "ValueExpected";
        t[t.ColonExpected = 5] = "ColonExpected";
        t[t.CommaExpected = 6] = "CommaExpected";
        t[t.CloseBraceExpected = 7] = "CloseBraceExpected";
        t[t.CloseBracketExpected = 8] = "CloseBracketExpected";
        t[t.EndOfFileExpected = 9] = "EndOfFileExpected";
        t[t.InvalidCommentToken = 10] = "InvalidCommentToken";
        t[t.UnexpectedEndOfComment = 11] = "UnexpectedEndOfComment";
        t[t.UnexpectedEndOfString = 12] = "UnexpectedEndOfString";
        t[t.UnexpectedEndOfNumber = 13] = "UnexpectedEndOfNumber";
        t[t.InvalidUnicode = 14] = "InvalidUnicode";
        t[t.InvalidEscapeCharacter = 15] = "InvalidEscapeCharacter";
        t[t.InvalidCharacter = 16] = "InvalidCharacter";
      })(i5 ||= {});
      (function (t) {
        t.DEFAULT = {
          allowTrailingComma: true
        };
      })(vc ||= {});
      (function (t) {
        t[t.nullCharacter = 0] = "nullCharacter";
        t[t.maxAsciiCharacter = 127] = "maxAsciiCharacter";
        t[t.lineFeed = 10] = "lineFeed";
        t[t.carriageReturn = 13] = "carriageReturn";
        t[t.lineSeparator = 8232] = "lineSeparator";
        t[t.paragraphSeparator = 8233] = "paragraphSeparator";
        t[t.nextLine = 133] = "nextLine";
        t[t.space = 32] = "space";
        t[t.nonBreakingSpace = 160] = "nonBreakingSpace";
        t[t.enQuad = 8192] = "enQuad";
        t[t.emQuad = 8193] = "emQuad";
        t[t.enSpace = 8194] = "enSpace";
        t[t.emSpace = 8195] = "emSpace";
        t[t.threePerEmSpace = 8196] = "threePerEmSpace";
        t[t.fourPerEmSpace = 8197] = "fourPerEmSpace";
        t[t.sixPerEmSpace = 8198] = "sixPerEmSpace";
        t[t.figureSpace = 8199] = "figureSpace";
        t[t.punctuationSpace = 8200] = "punctuationSpace";
        t[t.thinSpace = 8201] = "thinSpace";
        t[t.hairSpace = 8202] = "hairSpace";
        t[t.zeroWidthSpace = 8203] = "zeroWidthSpace";
        t[t.narrowNoBreakSpace = 8239] = "narrowNoBreakSpace";
        t[t.ideographicSpace = 12288] = "ideographicSpace";
        t[t.mathematicalSpace = 8287] = "mathematicalSpace";
        t[t.ogham = 5760] = "ogham";
        t[t._ = 95] = "_";
        t[t.$ = 36] = "$";
        t[t._0 = 48] = "_0";
        t[t._1 = 49] = "_1";
        t[t._2 = 50] = "_2";
        t[t._3 = 51] = "_3";
        t[t._4 = 52] = "_4";
        t[t._5 = 53] = "_5";
        t[t._6 = 54] = "_6";
        t[t._7 = 55] = "_7";
        t[t._8 = 56] = "_8";
        t[t._9 = 57] = "_9";
        t[t.a = 97] = "a";
        t[t.b = 98] = "b";
        t[t.c = 99] = "c";
        t[t.d = 100] = "d";
        t[t.e = 101] = "e";
        t[t.f = 102] = "f";
        t[t.g = 103] = "g";
        t[t.h = 104] = "h";
        t[t.i = 105] = "i";
        t[t.j = 106] = "j";
        t[t.k = 107] = "k";
        t[t.l = 108] = "l";
        t[t.m = 109] = "m";
        t[t.n = 110] = "n";
        t[t.o = 111] = "o";
        t[t.p = 112] = "p";
        t[t.q = 113] = "q";
        t[t.r = 114] = "r";
        t[t.s = 115] = "s";
        t[t.t = 116] = "t";
        t[t.u = 117] = "u";
        t[t.v = 118] = "v";
        t[t.w = 119] = "w";
        t[t.x = 120] = "x";
        t[t.y = 121] = "y";
        t[t.z = 122] = "z";
        t[t.A = 65] = "A";
        t[t.B = 66] = "B";
        t[t.C = 67] = "C";
        t[t.D = 68] = "D";
        t[t.E = 69] = "E";
        t[t.F = 70] = "F";
        t[t.G = 71] = "G";
        t[t.H = 72] = "H";
        t[t.I = 73] = "I";
        t[t.J = 74] = "J";
        t[t.K = 75] = "K";
        t[t.L = 76] = "L";
        t[t.M = 77] = "M";
        t[t.N = 78] = "N";
        t[t.O = 79] = "O";
        t[t.P = 80] = "P";
        t[t.Q = 81] = "Q";
        t[t.R = 82] = "R";
        t[t.S = 83] = "S";
        t[t.T = 84] = "T";
        t[t.U = 85] = "U";
        t[t.V = 86] = "V";
        t[t.W = 87] = "W";
        t[t.X = 88] = "X";
        t[t.Y = 89] = "Y";
        t[t.Z = 90] = "Z";
        t[t.ampersand = 38] = "ampersand";
        t[t.asterisk = 42] = "asterisk";
        t[t.at = 64] = "at";
        t[t.backslash = 92] = "backslash";
        t[t.bar = 124] = "bar";
        t[t.caret = 94] = "caret";
        t[t.closeBrace = 125] = "closeBrace";
        t[t.closeBracket = 93] = "closeBracket";
        t[t.closeParen = 41] = "closeParen";
        t[t.colon = 58] = "colon";
        t[t.comma = 44] = "comma";
        t[t.dot = 46] = "dot";
        t[t.doubleQuote = 34] = "doubleQuote";
        t[t.equals = 61] = "equals";
        t[t.exclamation = 33] = "exclamation";
        t[t.greaterThan = 62] = "greaterThan";
        t[t.lessThan = 60] = "lessThan";
        t[t.minus = 45] = "minus";
        t[t.openBrace = 123] = "openBrace";
        t[t.openBracket = 91] = "openBracket";
        t[t.openParen = 40] = "openParen";
        t[t.percent = 37] = "percent";
        t[t.plus = 43] = "plus";
        t[t.question = 63] = "question";
        t[t.semicolon = 59] = "semicolon";
        t[t.singleQuote = 39] = "singleQuote";
        t[t.slash = 47] = "slash";
        t[t.tilde = 126] = "tilde";
        t[t.backspace = 8] = "backspace";
        t[t.formFeed = 12] = "formFeed";
        t[t.byteOrderMark = 65279] = "byteOrderMark";
        t[t.tab = 9] = "tab";
        t[t.verticalTab = 11] = "verticalTab";
      })(s5 ||= {});
    }
  });
  var bc;
  var Pe;
  var dh = g({
    "out-build/vs/base/common/severity.js"() {
      "use strict";
  
      Wt();
      (function (t) {
        t[t.Ignore = 0] = "Ignore";
        t[t.Info = 1] = "Info";
        t[t.Warning = 2] = "Warning";
        t[t.Error = 3] = "Error";
        t[t.AI = 4] = "AI";
      })(bc ||= {});
      (function (t) {
        const e = "error";
        const i = "warning";
        const s = "warn";
        const r = "info";
        const n = "ignore";
        function o(c) {
          if (c) {
            if (br(e, c)) {
              return t.Error;
            } else if (br(i, c) || br(s, c)) {
              return t.Warning;
            } else if (br(r, c)) {
              return t.Info;
            } else {
              return t.Ignore;
            }
          } else {
            return t.Ignore;
          }
        }
        t.fromValue = o;
        function a(c) {
          switch (c) {
            case t.Error:
              return e;
            case t.Warning:
              return i;
            case t.Info:
              return r;
            default:
              return n;
          }
        }
        t.toString = a;
      })(bc ||= {});
      Pe = bc;
    }
  });
  function ls(t) {
    if (!t || typeof t != "object" || t instanceof RegExp) {
      return t;
    }
    const e = Array.isArray(t) ? [] : {};
    Object.entries(t).forEach(([i, s]) => {
      e[i] = s && typeof s == "object" ? ls(s) : s;
    });
    return e;
  }
  function kD(t) {
    if (!t || typeof t != "object") {
      return t;
    }
    const e = [t];
    while (e.length > 0) {
      const i = e.shift();
      Object.freeze(i);
      for (const s in i) {
        if (X1.call(i, s)) {
          const r = i[s];
          if (typeof r == "object" && !Object.isFrozen(r) && !aE(r)) {
            e.push(r);
          }
        }
      }
    }
    return t;
  }
  function xD(t, e) {
    return Y1(t, e, new Set());
  }
  function Y1(t, e, i) {
    if (Qt(t)) {
      return t;
    }
    const s = e(t);
    if (typeof s !== "undefined") {
      return s;
    }
    if (Array.isArray(t)) {
      const r = [];
      for (const n of t) {
        r.push(Y1(n, e, i));
      }
      return r;
    }
    if (Nt(t)) {
      if (i.has(t)) {
        throw new Error("Cannot clone recursive data-structure");
      }
      i.add(t);
      const r = {};
      for (const n in t) {
        if (X1.call(t, n)) {
          r[n] = Y1(t[n], e, i);
        }
      }
      i.delete(t);
      return r;
    }
    return t;
  }
  function yc(t, e, i = true) {
    if (Nt(t)) {
      if (Nt(e)) {
        Object.keys(e).forEach(s => {
          if (s in t) {
            if (i) {
              if (Nt(t[s]) && Nt(e[s])) {
                yc(t[s], e[s], i);
              } else {
                t[s] = e[s];
              }
            }
          } else {
            t[s] = e[s];
          }
        });
      }
      return t;
    } else {
      return e;
    }
  }
  function Os(t, e) {
    if (t === e) {
      return true;
    }
    if (t == null || e === null || e === undefined || typeof t != typeof e || typeof t != "object" || Array.isArray(t) !== Array.isArray(e)) {
      return false;
    }
    let i;
    let s;
    if (Array.isArray(t)) {
      if (t.length !== e.length) {
        return false;
      }
      for (i = 0; i < t.length; i++) {
        if (!Os(t[i], e[i])) {
          return false;
        }
      }
    } else {
      const r = [];
      for (s in t) {
        r.push(s);
      }
      r.sort();
      const n = [];
      for (s in e) {
        n.push(s);
      }
      n.sort();
      if (!Os(r, n)) {
        return false;
      }
      for (i = 0; i < r.length; i++) {
        if (!Os(t[r[i]], e[r[i]])) {
          return false;
        }
      }
    }
    return true;
  }
  function DD(t, e) {
    const i = e.toLowerCase();
    const s = Object.keys(t).find(r => r.toLowerCase() === i);
    if (s) {
      return t[s];
    } else {
      return t[e];
    }
  }
  var X1;
  var us = g({
    "out-build/vs/base/common/objects.js"() {
      "use strict";
  
      _e();
      X1 = Object.prototype.hasOwnProperty;
    }
  });
  function r5(t, e) {
    const i = ls(t);
    let s = (i.buttons ?? []).map(a => Yv(a));
    let r = (t.buttons || []).map((a, c) => c);
    let n = 0;
    let o = i.cancelId ?? s.length - 1;
    if (s.length > 1) {
      const a = typeof o == "number" ? s[o] : undefined;
      if (Se || N) {
        if (typeof a == "string" && s.length > 1 && o !== 1) {
          s.splice(o, 1);
          s.splice(1, 0, a);
          const c = r[o];
          r.splice(o, 1);
          r.splice(1, 0, c);
          o = 1;
        }
        if (Se && s.length > 1) {
          s = s.reverse();
          r = r.reverse();
          n = s.length - 1;
          if (typeof a == "string") {
            o = n - 1;
          }
        }
      } else if (j && typeof a == "string" && s.length > 1 && o !== s.length - 1) {
        s.splice(o, 1);
        s.push(a);
        const c = r[o];
        r.splice(o, 1);
        r.push(c);
        o = s.length - 1;
      }
    }
    i.buttons = s;
    i.defaultId = n;
    i.cancelId = o;
    i.noLink = true;
    i.title = i.title || e.nameLong;
    return {
      options: i,
      buttonIndeces: r
    };
  }
  var PD;
  var n5;
  var $D;
  var o5;
  var a5 = g({
    "out-build/vs/platform/dialogs/common/dialogs.js"() {
      "use strict";
  
      nt();
      dh();
      be();
      Y();
      Sr();
      H();
      us();
      PD = q("dialogService");
      (function (t) {
        t[t.Confirmation = 1] = "Confirmation";
        t[t.Prompt = 2] = "Prompt";
        t[t.Input = 3] = "Input";
      })(n5 ||= {});
      $D = q("fileDialogService");
      (function (t) {
        t[t.SAVE = 0] = "SAVE";
        t[t.DONT_SAVE = 1] = "DONT_SAVE";
        t[t.CANCEL = 2] = "CANCEL";
      })(o5 ||= {});
    }
  });
  import mn from "electron";
  var nr;
  var fh;
  var wn = g({
    "out-build/vs/platform/dialogs/electron-main/dialogMainService.js"() {
      "use strict";
  
      ce();
      er();
      Sr();
      M();
      ou();
      H();
      _t();
      be();
      a5();
      Y();
      X();
      ht();
      ri();
      nr = q("dialogMainService");
      fh = class {
        constructor(e, i) {
          this.d = e;
          this.e = i;
          this.a = new Map();
          this.b = new Map();
          this.c = new eo();
        }
        pickFileFolder(e, i) {
          return this.f({
            ...e,
            pickFolders: true,
            pickFiles: true,
            title: v(1742, null)
          }, i);
        }
        pickFolder(e, i) {
          return this.f({
            ...e,
            pickFolders: true,
            title: v(1743, null)
          }, i);
        }
        pickFile(e, i) {
          return this.f({
            ...e,
            pickFiles: true,
            title: v(1744, null)
          }, i);
        }
        pickWorkspace(e, i) {
          const s = v(1745, null);
          const r = Yv(v(1746, null));
          const n = Jy;
          return this.f({
            ...e,
            pickFiles: true,
            title: s,
            filters: n,
            buttonLabel: r
          }, i);
        }
        async f(e, i) {
          const s = {
            title: e.title,
            buttonLabel: e.buttonLabel,
            filters: e.filters,
            defaultPath: e.defaultPath
          };
          if (typeof e.pickFiles == "boolean" || typeof e.pickFolders == "boolean") {
            s.properties = undefined;
            if (e.pickFiles && e.pickFolders) {
              s.properties = ["multiSelections", "openDirectory", "openFile", "createDirectory"];
            }
          }
          s.properties ||= ["multiSelections", e.pickFolders ? "openDirectory" : "openFile", "createDirectory"];
          if (N) {
            s.properties.push("treatPackageAsDirectory");
          }
          const r = await this.showOpenDialog(s, (i || mn.BrowserWindow.getFocusedWindow()) ?? undefined);
          if (r && r.filePaths && r.filePaths.length > 0) {
            return r.filePaths;
          }
        }
        g(e) {
          if (e) {
            let i = this.b.get(e.id);
            if (!i) {
              i = new eo();
              this.b.set(e.id, i);
            }
            return i;
          } else {
            return this.c;
          }
        }
        showMessageBox(e, i) {
          return this.g(i).queue(async () => {
            const {
              options: s,
              buttonIndeces: r
            } = r5(e, this.e);
            let n;
            if (i) {
              n = await mn.dialog.showMessageBox(i, s);
            } else {
              n = await mn.dialog.showMessageBox(s);
            }
            return {
              response: r[n.response],
              checkboxChecked: n.checkboxChecked
            };
          });
        }
        async showSaveDialog(e, i) {
          const s = this.j(e, i);
          if (!s) {
            this.d.error("[DialogMainService]: file save dialog is already or will be showing for the window with the same configuration");
            return {
              canceled: true,
              filePath: ""
            };
          }
          try {
            return await this.g(i).queue(async () => {
              let r;
              if (i) {
                r = await mn.dialog.showSaveDialog(i, e);
              } else {
                r = await mn.dialog.showSaveDialog(e);
              }
              r.filePath = this.h(r.filePath);
              return r;
            });
          } finally {
            Et(s);
          }
        }
        h(e) {
          if (e && N) {
            e = io(e);
          }
          return e;
        }
        i(e) {
          return e.map(i => this.h(i));
        }
        async showOpenDialog(e, i) {
          if (e.defaultPath) {
            if (!(await ee.exists(e.defaultPath))) {
              e.defaultPath = undefined;
            }
          }
          const s = this.j(e, i);
          if (!s) {
            this.d.error("[DialogMainService]: file open dialog is already or will be showing for the window with the same configuration");
            return {
              canceled: true,
              filePaths: []
            };
          }
          try {
            return await this.g(i).queue(async () => {
              let r;
              if (i) {
                r = await mn.dialog.showOpenDialog(i, e);
              } else {
                r = await mn.dialog.showOpenDialog(e);
              }
              r.filePaths = this.i(r.filePaths);
              return r;
            });
          } finally {
            Et(s);
          }
        }
        j(e, i) {
          if (!i) {
            return T.None;
          }
          this.d.trace("[DialogMainService]: request to acquire file dialog lock", e);
          let s = this.a.get(i.id);
          if (!s) {
            s = new Set();
            this.a.set(i.id, s);
          }
          const r = Ds(e);
          if (!s.has(r)) {
            this.d.trace("[DialogMainService]: new file dialog lock created", e);
            s.add(r);
            return xe(() => {
              this.d.trace("[DialogMainService]: file dialog lock disposed", e);
              s?.delete(r);
              if (s?.size === 0) {
                this.a.delete(i.id);
              }
            });
          }
        }
      };
      fh = __decorate([__param(0, V), __param(1, Ve)], fh);
    }
  });
  async function ID(t, e, i) {
    for (const r of t) {
      const n = r.openedWorkspace;
      if (Kt(n)) {
        const o = await i(n);
        if (o) {
          if (o.folders.some(a => tt.isEqualOrParent(e, a.uri))) {
            return r;
          }
        } else if (tt.isEqualOrParent(e, n.configPath)) {
          return r;
        }
      }
    }
    const s = t.filter(r => Li(r.openedWorkspace) && tt.isEqualOrParent(e, r.openedWorkspace.uri));
    if (s.length) {
      return s.sort((r, n) => -(r.openedWorkspace.uri.path.length - n.openedWorkspace.uri.path.length))[0];
    }
  }
  function $o(t, e) {
    for (const i of t) {
      if (Kt(i.openedWorkspace) && tt.isEqual(i.openedWorkspace.configPath, e) || Li(i.openedWorkspace) && tt.isEqual(i.openedWorkspace.uri, e)) {
        return i;
      }
    }
  }
  function AD(t, e) {
    const i = s => e.some(r => tt.isEqual(P.file(r), P.file(s)));
    for (const s of t) {
      if (s.config?.extensionDevelopmentPath?.some(r => i(r))) {
        return s;
      }
    }
  }
  var c5 = g({
    "out-build/vs/platform/windows/electron-main/windowsFinder.js"() {
      "use strict";
  
      nt();
      se();
      ri();
    }
  });
  function CD(t, e, i) {
    let s;
    let r;
    let n;
    let o;
    let a;
    if (e) {
      o = e.offset;
      a = o + e.length;
      n = o;
      while (n > 0 && !ph(t, n - 1)) {
        n--;
      }
      let A = a;
      while (A < t.length && !ph(t, A)) {
        A++;
      }
      r = t.substring(n, A);
      s = _D(r, i);
    } else {
      r = t;
      s = 0;
      n = 0;
      o = 0;
      a = t.length;
    }
    const c = RD(i, t);
    let l = false;
    let u = 0;
    let d;
    if (i.insertSpaces) {
      d = Q1(" ", i.tabSize || 4);
    } else {
      d = "\t";
    }
    const f = X4(r, false);
    let p = false;
    function w() {
      return c + Q1(d, s + u);
    }
    function m() {
      let A = f.scan();
      for (l = false; A === 15 || A === 14;) {
        l = l || A === 14;
        A = f.scan();
      }
      p = A === 16 || f.getTokenError() !== 0;
      return A;
    }
    const y = [];
    function b(A, C, _) {
      if (!p && C < a && _ > o && t.substring(C, _) !== A) {
        y.push({
          offset: C,
          length: _ - C,
          content: A
        });
      }
    }
    let k = m();
    if (k !== 17) {
      const A = f.getTokenOffset() + n;
      const C = Q1(d, s);
      b(C, n, A);
    }
    while (k !== 17) {
      let A = f.getTokenOffset() + f.getTokenLength() + n;
      let C = m();
      let _ = "";
      while (!l && (C === 12 || C === 13)) {
        const ie = f.getTokenOffset() + n;
        b(" ", A, ie);
        A = f.getTokenOffset() + f.getTokenLength() + n;
        _ = C === 12 ? w() : "";
        C = m();
      }
      if (C === 2) {
        if (k !== 1) {
          u--;
          _ = w();
        }
      } else if (C === 4) {
        if (k !== 3) {
          u--;
          _ = w();
        }
      } else {
        switch (k) {
          case 3:
          case 1:
            u++;
            _ = w();
            break;
          case 5:
          case 12:
            _ = w();
            break;
          case 13:
            if (l) {
              _ = w();
            } else {
              _ = " ";
            }
            break;
          case 6:
            _ = " ";
            break;
          case 10:
            if (C === 6) {
              _ = "";
              break;
            }
          case 7:
          case 8:
          case 9:
          case 11:
          case 2:
          case 4:
            if (C === 12 || C === 13) {
              _ = " ";
            } else if (C !== 5 && C !== 17) {
              p = true;
            }
            break;
          case 16:
            p = true;
            break;
        }
        if (l && (C === 12 || C === 13)) {
          _ = w();
        }
      }
      const Z = f.getTokenOffset() + n;
      b(_, A, Z);
      k = C;
    }
    return y;
  }
  function Q1(t, e) {
    let i = "";
    for (let s = 0; s < e; s++) {
      i += t;
    }
    return i;
  }
  function _D(t, e) {
    let i = 0;
    let s = 0;
    const r = e.tabSize || 4;
    while (i < t.length) {
      const n = t.charAt(i);
      if (n === " ") {
        s++;
      } else if (n === "\t") {
        s += r;
      } else {
        break;
      }
      i++;
    }
    return Math.floor(s / r);
  }
  function RD(t, e) {
    for (let i = 0; i < e.length; i++) {
      const s = e.charAt(i);
      if (s === "\r") {
        if (i + 1 < e.length && e.charAt(i + 1) === `
  `) {
          return `\r
  `;
        } else {
          return "\r";
        }
      }
      if (s === `
  `) {
        return `
  `;
      }
    }
    return t && t.eol || `
  `;
  }
  function ph(t, e) {
    return `\r
  `.indexOf(t.charAt(e)) !== -1;
  }
  var OD = g({
    "out-build/vs/base/common/jsonFormatter.js"() {
      "use strict";
  
      rr();
    }
  });
  function LD(t, e, i, s, r) {
    const n = e.slice();
    const a = ED(t, []);
    let c;
    let l;
    while (n.length > 0 && (l = n.pop(), c = Q4(a, n), c === undefined && i !== undefined)) {
      if (typeof l == "string") {
        i = {
          [l]: i
        };
      } else {
        i = [i];
      }
    }
    if (c) {
      if (c.type === "object" && typeof l == "string" && Array.isArray(c.children)) {
        const u = Q4(c, [l]);
        if (u !== undefined) {
          if (i === undefined) {
            if (!u.parent) {
              throw new Error("Malformed AST");
            }
            const d = c.children.indexOf(u.parent);
            let f;
            let p = u.parent.offset + u.parent.length;
            if (d > 0) {
              const w = c.children[d - 1];
              f = w.offset + w.length;
            } else {
              f = c.offset + 1;
              if (c.children.length > 1) {
                p = c.children[1].offset;
              }
            }
            return Io(t, {
              offset: f,
              length: p - f,
              content: ""
            }, s);
          } else {
            return Io(t, {
              offset: u.offset,
              length: u.length,
              content: JSON.stringify(i)
            }, s);
          }
        } else {
          if (i === undefined) {
            return [];
          }
          const d = `${JSON.stringify(l)}: ${JSON.stringify(i)}`;
          const f = r ? r(c.children.map(w => w.children[0].value)) : c.children.length;
          let p;
          if (f > 0) {
            const w = c.children[f - 1];
            p = {
              offset: w.offset + w.length,
              length: 0,
              content: "," + d
            };
          } else if (c.children.length === 0) {
            p = {
              offset: c.offset + 1,
              length: 0,
              content: d
            };
          } else {
            p = {
              offset: c.offset + 1,
              length: 0,
              content: d + ","
            };
          }
          return Io(t, p, s);
        }
      } else if (c.type === "array" && typeof l == "number" && Array.isArray(c.children)) {
        if (i !== undefined) {
          const u = `${JSON.stringify(i)}`;
          let d;
          if (c.children.length === 0 || l === 0) {
            d = {
              offset: c.offset + 1,
              length: 0,
              content: c.children.length === 0 ? u : u + ","
            };
          } else {
            const f = l === -1 || l > c.children.length ? c.children.length : l;
            const p = c.children[f - 1];
            d = {
              offset: p.offset + p.length,
              length: 0,
              content: "," + u
            };
          }
          return Io(t, d, s);
        } else {
          const u = l;
          const d = c.children[u];
          let f;
          if (c.children.length === 1) {
            f = {
              offset: c.offset + 1,
              length: c.length - 2,
              content: ""
            };
          } else if (c.children.length - 1 === u) {
            const p = c.children[u - 1];
            const w = p.offset + p.length;
            const m = c.offset + c.length;
            f = {
              offset: w,
              length: m - 2 - w,
              content: ""
            };
          } else {
            f = {
              offset: d.offset,
              length: c.children[u + 1].offset - d.offset,
              content: ""
            };
          }
          return Io(t, f, s);
        }
      } else {
        throw new Error(`Can not add ${typeof l != "number" ? "index" : "property"} to parent of type ${c.type}`);
      }
    } else if (i === undefined) {
      return [];
    } else {
      return Io(t, {
        offset: a ? a.offset : 0,
        length: a ? a.length : 0,
        content: JSON.stringify(i)
      }, s);
    }
  }
  function Io(t, e, i) {
    let s = eg(t, e);
    let r = e.offset;
    let n = e.offset + e.content.length;
    if (e.length === 0 || e.content.length === 0) {
      while (r > 0 && !ph(s, r - 1)) {
        r--;
      }
      while (n < s.length && !ph(s, n)) {
        n++;
      }
    }
    const o = CD(s, {
      offset: r,
      length: n - r
    }, i);
    for (let c = o.length - 1; c >= 0; c--) {
      const l = o[c];
      s = eg(s, l);
      r = Math.min(r, l.offset);
      n = Math.max(n, l.offset + l.length);
      n += l.content.length - l.length;
    }
    const a = t.length - (s.length - n) - r;
    return [{
      offset: r,
      length: a,
      content: s.substring(r, n)
    }];
  }
  function eg(t, e) {
    return t.substring(0, e.offset) + e.content + t.substring(e.offset + e.length);
  }
  function MD(t, e) {
    const i = e.slice(0).sort((r, n) => {
      const o = r.offset - n.offset;
      if (o === 0) {
        return r.length - n.length;
      } else {
        return o;
      }
    });
    let s = t.length;
    for (let r = i.length - 1; r >= 0; r--) {
      const n = i[r];
      if (n.offset + n.length <= s) {
        t = eg(t, n);
      } else {
        throw new Error("Overlapping edit");
      }
      s = n.offset;
    }
    return t;
  }
  var l5 = g({
    "out-build/vs/base/common/jsonEdit.js"() {
      "use strict";
  
      rr();
      OD();
    }
  });
  function Ao(t) {
    if (t.scheme === R.vscodeRemote) {
      return t.authority;
    } else {
      return undefined;
    }
  }
  var Sc = g({
    "out-build/vs/platform/remote/common/remoteHosts.js"() {
      "use strict";
  
      Ie();
    }
  });
  function tg(t) {
    return t.hasOwnProperty("workspace");
  }
  function gh(t) {
    return t.hasOwnProperty("folderUri");
  }
  function FD(t) {
    return t.hasOwnProperty("fileUri");
  }
  function ND(t) {
    return u5(t) || h5(t);
  }
  function u5(t) {
    const e = t;
    return typeof e?.path == "string" && (!e.name || typeof e.name == "string");
  }
  function h5(t) {
    const e = t;
    return typeof e?.uri == "string" && (!e.name || typeof e.name == "string");
  }
  function WD(t, e, i, s, r) {
    if (t.scheme !== s.scheme) {
      return {
        name: i,
        uri: t.toString(true)
      };
    }
    let n = e ? undefined : r.relativePath(s, t);
    if (n !== undefined) {
      if (n.length === 0) {
        n = ".";
      } else if (j) {
        n = d5(n);
      }
    } else if (t.scheme === R.file) {
      n = t.fsPath;
      if (j) {
        n = d5(n);
      }
    } else if (r.isEqualAuthority(t.authority, s.authority)) {
      n = t.path;
    } else {
      return {
        name: i,
        uri: t.toString(true)
      };
    }
    return {
      name: i,
      path: n
    };
  }
  function d5(t) {
    t = Lp(t);
    if (!qE(t)) {
      t = Xn(t);
    }
    return t;
  }
  function TD(t, e, i) {
    const s = [];
    const r = new Set();
    const n = i.dirname(e);
    for (const o of t) {
      let a;
      if (u5(o)) {
        if (o.path) {
          a = i.resolvePath(n, o.path);
        }
      } else if (h5(o)) {
        try {
          a = P.parse(o.uri);
          if (a.path[0] !== ae.sep) {
            a = a.with({
              path: ae.sep + a.path
            });
          }
        } catch (c) {
          console.warn(c);
        }
      }
      if (a) {
        const c = i.getComparisonKey(a);
        if (!r.has(c)) {
          r.add(c);
          const l = o.name || i.basenameOrAuthority(a);
          s.push(new Vy({
            uri: a,
            name: l,
            index: s.length
          }, o));
        }
      }
    }
    return s;
  }
  function jD(t) {
    return t.workspace && typeof t.workspace == "object" && typeof t.workspace.id == "string" && typeof t.workspace.configPath == "string";
  }
  function UD(t) {
    return typeof t.folderUri == "string";
  }
  function BD(t) {
    return typeof t.fileUri == "string";
  }
  function qD(t, e) {
    const i = {
      workspaces: [],
      files: []
    };
    if (t) {
      const s = function (n, o) {
        for (let a = 0; a < n.length; a++) {
          try {
            o(n[a], a);
          } catch (c) {
            e.warn(`Error restoring recent entry ${JSON.stringify(n[a])}: ${c.toString()}. Skip entry.`);
          }
        }
      };
      const r = t;
      if (Array.isArray(r.entries)) {
        s(r.entries, n => {
          const o = n.label;
          const a = n.remoteAuthority;
          if (jD(n)) {
            i.workspaces.push({
              label: o,
              remoteAuthority: a,
              workspace: {
                id: n.workspace.id,
                configPath: P.parse(n.workspace.configPath)
              }
            });
          } else if (UD(n)) {
            i.workspaces.push({
              label: o,
              remoteAuthority: a,
              folderUri: P.parse(n.folderUri)
            });
          } else if (BD(n)) {
            i.files.push({
              label: o,
              remoteAuthority: a,
              fileUri: P.parse(n.fileUri)
            });
          }
        });
      }
    }
    return i;
  }
  function zD(t) {
    const e = {
      entries: []
    };
    for (const i of t.workspaces) {
      if (gh(i)) {
        e.entries.push({
          folderUri: i.folderUri.toString(),
          label: i.label,
          remoteAuthority: i.remoteAuthority
        });
      } else {
        e.entries.push({
          workspace: {
            id: i.workspace.id,
            configPath: i.workspace.configPath.toString()
          },
          label: i.label,
          remoteAuthority: i.remoteAuthority
        });
      }
    }
    for (const i of t.files) {
      e.entries.push({
        fileUri: i.fileUri.toString(),
        label: i.label,
        remoteAuthority: i.remoteAuthority
      });
    }
    return e;
  }
  var ig;
  var sg = g({
    "out-build/vs/platform/workspaces/common/workspaces.js"() {
      "use strict";
  
      gi();
      rr();
      l5();
      Sr();
      Ie();
      we();
      H();
      nt();
      se();
      Y();
      Sc();
      ri();
      ig = q("workspacesService");
    }
  });
  import * as f5 from "fs";
  import HD from "electron";
  var Cr;
  var mh;
  var vn = g({
    "out-build/vs/platform/workspaces/electron-main/workspacesManagementMainService.js"() {
      "use strict";
  
      B();
      rr();
      M();
      Ie();
      we();
      nt();
      _t();
      be();
      wc();
      wn();
      vt();
      Y();
      X();
      un();
      c5();
      ri();
      sg();
      q1();
      Cr = q("workspacesManagementMainService");
      mh = class extends T {
        constructor(e, i, s, r, n) {
          super();
          this.g = e;
          this.h = i;
          this.j = s;
          this.m = r;
          this.n = n;
          this.a = this.D(new $());
          this.onDidDeleteUntitledWorkspace = this.a.event;
          this.b = this.D(new $());
          this.onDidEnterWorkspace = this.b.event;
          this.c = this.g.untitledWorkspacesHome;
          this.f = [];
        }
        async initialize() {
          this.f = [];
          try {
            const e = (await ee.readdir(this.c.with({
              scheme: R.file
            }).fsPath)).map(i => he(this.c, i, g1));
            for (const i of e) {
              const s = pn(i);
              const r = await this.resolveLocalWorkspace(i);
              if (r) {
                this.f.push({
                  workspace: s,
                  remoteAuthority: r.remoteAuthority
                });
              } else {
                await this.deleteUntitledWorkspace(s);
              }
            }
          } catch (e) {
            if (e.code !== "ENOENT") {
              this.h.warn(`Unable to read folders in ${this.c} (${e}).`);
            }
          }
        }
        resolveLocalWorkspace(e) {
          return this.q(e, i => f5.promises.readFile(i, "utf8"));
        }
        q(e, i) {
          if (this.r(e) && e.scheme === R.file) {
            try {
              const s = i(e.fsPath);
              if (s instanceof Promise) {
                return s.then(r => this.s(e, r), r => {});
              } else {
                return this.s(e, s);
              }
            } catch {
              return;
            }
          }
        }
        r(e) {
          return By(e, this.g) || ln(e);
        }
        s(e, i) {
          try {
            const s = this.t(e, i);
            const r = pn(e);
            return {
              id: r.id,
              configPath: r.configPath,
              folders: TD(s.folders, r.configPath, tt),
              remoteAuthority: s.remoteAuthority,
              transient: s.transient
            };
          } catch (s) {
            this.h.warn(s.toString());
          }
        }
        t(e, i) {
          const s = gn(i);
          if (s && Array.isArray(s.folders)) {
            s.folders = s.folders.filter(r => ND(r));
          } else {
            throw new Error(`${e.toString(true)} looks like an invalid workspace file.`);
          }
          return s;
        }
        async createUntitledWorkspace(e, i) {
          const {
            workspace: s,
            storedWorkspace: r
          } = this.u(e, i);
          const n = s.configPath.fsPath;
          await f5.promises.mkdir(Xe(n), {
            recursive: true
          });
          await ee.writeFile(n, JSON.stringify(r, null, "\t"));
          this.f.push({
            workspace: s,
            remoteAuthority: i
          });
          return s;
        }
        u(e = [], i) {
          const s = (Date.now() + Math.round(Math.random() * 1000)).toString();
          const r = he(this.c, s);
          const n = he(r, g1);
          const o = [];
          for (const a of e) {
            o.push(WD(a.uri, true, a.name, r, tt));
          }
          return {
            workspace: pn(n),
            storedWorkspace: {
              folders: o,
              remoteAuthority: i
            }
          };
        }
        async getWorkspaceIdentifier(e) {
          return pn(e);
        }
        isUntitledWorkspace(e) {
          return By(e.configPath, this.g);
        }
        async deleteUntitledWorkspace(e) {
          if (this.isUntitledWorkspace(e)) {
            await this.w(e);
            this.j.unsetWorkspace(e);
            this.a.fire(e);
          }
        }
        async w(e) {
          const i = Ci(e.configPath);
          try {
            await ee.rm(Xe(i));
            const s = F(this.g.workspaceStorageHome.with({
              scheme: R.file
            }).fsPath, e.id);
            if (await ee.exists(s)) {
              await ee.writeFile(F(s, "obsolete"), "");
            }
            this.f = this.f.filter(r => r.workspace.id !== e.id);
          } catch (s) {
            this.h.warn(`Unable to delete untitled workspace ${i} (${s}).`);
          }
        }
        getUntitledWorkspaces() {
          return this.f;
        }
        async enterWorkspace(e, i, s) {
          if (!e || !e.win || !e.isReady || !(await this.y(e, i, s))) {
            return;
          }
          const n = await this.z(e, pn(s));
          if (n) {
            this.b.fire({
              window: e,
              workspace: n.workspace
            });
            return n;
          }
        }
        async y(e, i, s) {
          if (s) {
            if (Kt(e.openedWorkspace) && tt.isEqual(e.openedWorkspace.configPath, s)) {
              return false;
            } else if ($o(i, s)) {
              await this.n.showMessageBox({
                type: "info",
                buttons: [v(2544, null)],
                message: v(2545, null, ks(s)),
                detail: v(2546, null)
              }, HD.BrowserWindow.getFocusedWindow() ?? undefined);
              return false;
            } else {
              return true;
            }
          } else {
            return true;
          }
        }
        async z(e, i) {
          if (!e.config) {
            return;
          }
          e.focus();
          let s;
          if (!e.config.extensionDevelopmentPath) {
            if (e.config.backupPath) {
              s = await this.m.registerWorkspaceBackup({
                workspace: i,
                remoteAuthority: e.remoteAuthority
              }, e.config.backupPath);
            } else {
              s = this.m.registerWorkspaceBackup({
                workspace: i,
                remoteAuthority: e.remoteAuthority
              });
            }
          }
          if (Kt(e.openedWorkspace) && this.isUntitledWorkspace(e.openedWorkspace)) {
            await this.deleteUntitledWorkspace(e.openedWorkspace);
          }
          e.config.workspace = i;
          e.config.backupPath = s;
          return {
            workspace: i,
            backupPath: s
          };
        }
      };
      mh = __decorate([__param(0, ot), __param(1, V), __param(2, Rs), __param(3, xo), __param(4, nr)], mh);
    }
  });
  function VD(t, ...e) {
    const i = e.reduce((n, o) => {
      n[o] = true;
      return n;
    }, {});
    const s = [/^ELECTRON_.+$/, /^VSCODE_(?!(PORTABLE|SHELL_LOGIN|ENV_REPLACE|ENV_APPEND|ENV_PREPEND)).+$/, /^SNAP(|_.*)$/, /^GDK_PIXBUF_.+$/];
    Object.keys(t).filter(n => !i[n]).forEach(n => {
      for (let o = 0; o < s.length; o++) {
        if (n.search(s[o]) !== -1) {
          delete t[n];
          break;
        }
      }
    });
  }
  function p5(t) {
    if (t) {
      delete t.DEBUG;
      if (Se) {
        delete t.LD_PRELOAD;
      }
    }
  }
  var g5;
  var m5;
  var wh = g({
    "out-build/vs/base/common/processes.js"() {
      "use strict";
  
      H();
      (function (t) {
        t[t.stdout = 0] = "stdout";
        t[t.stderr = 1] = "stderr";
      })(g5 ||= {});
      (function (t) {
        t[t.Success = 0] = "Success";
        t[t.Unknown = 1] = "Unknown";
        t[t.AccessDenied = 2] = "AccessDenied";
        t[t.ProcessNotFound = 3] = "ProcessNotFound";
      })(m5 ||= {});
    }
  });
  import { MessageChannelMain as GD, app as JD, utilityProcess as KD } from "electron";
  import { StringDecoder as w5 } from "string_decoder";
  function ZD(t) {
    return typeof t.responseWindowId == "number";
  }
  var Co;
  var _r;
  var Ec;
  var _o = g({
    "out-build/vs/platform/utilityProcess/electron-main/utilityProcess.js"() {
      "use strict";
  
      M();
      B();
      X();
      ce();
      Ie();
      Lt();
      dh();
      xt();
      ct();
      wh();
      us();
      H();
      wa();
      _r = class extends T {
        static {
          Co = this;
        }
        static {
          this.a = 0;
        }
        static {
          this.b = new Map();
        }
        static getAll() {
          return Array.from(Co.b.values());
        }
        constructor(e, i, s) {
          super();
          this.t = e;
          this.u = i;
          this.w = s;
          this.c = String(++Co.a);
          this.f = this.D(new $());
          this.onStdout = this.f.event;
          this.g = this.D(new $());
          this.onStderr = this.g.event;
          this.h = this.D(new $());
          this.onMessage = this.h.event;
          this.j = this.D(new $());
          this.onSpawn = this.j.event;
          this.m = this.D(new $());
          this.onExit = this.m.event;
          this.n = this.D(new $());
          this.onCrash = this.n.event;
          this.q = undefined;
          this.r = undefined;
          this.s = undefined;
        }
        y(e, i) {
          let s;
          if (this.s?.correlationId) {
            s = `[UtilityProcess id: ${this.s?.correlationId}, type: ${this.s?.type}, pid: ${this.r ?? "<none>"}]: ${e}`;
          } else {
            s = `[UtilityProcess type: ${this.s?.type}, pid: ${this.r ?? "<none>"}]: ${e}`;
          }
          switch (i) {
            case Pe.Error:
              this.t.error(s);
              break;
            case Pe.Warning:
              this.t.warn(s);
              break;
            case Pe.Info:
              this.t.trace(s);
              break;
          }
        }
        z() {
          if (this.q) {
            this.y("Cannot start utility process because it is already running...", Pe.Error);
            return false;
          } else {
            return true;
          }
        }
        start(e) {
          const i = this.C(e);
          if (i && e.payload && this.postMessage(e.payload)) {
            this.y("payload sent via postMessage()", Pe.Info);
          }
          return i;
        }
        C(e) {
          if (!this.z()) {
            return false;
          }
          this.s = e;
          const i = `${this.s.type}-${this.c}`;
          const s = Ct.asFileUri("bootstrap-fork.js").fsPath;
          const r = this.s.args ?? [];
          const n = this.s.execArgv ?? [];
          const o = this.s.allowLoadingUnsignedLibraries;
          const a = this.s.respondToAuthRequestsFromMainProcess;
          const c = "pipe";
          const l = this.F(e);
          this.y("creating new...", Pe.Info);
          this.q = KD.fork(s, r, {
            serviceName: i,
            env: l,
            execArgv: n,
            allowLoadingUnsignedLibraries: o,
            respondToAuthRequestsFromMainProcess: a,
            stdio: c
          });
          this.G(this.q, this.s, i);
          return true;
        }
        F(e) {
          const i = e.env ? {
            ...e.env
          } : {
            ...ls(process.env)
          };
          i.VSCODE_PROCESS_TITLE = e.processTitle;
          i.VSCODE_ESM_ENTRYPOINT = e.entryPoint;
          if (typeof e.parentLifecycleBound == "number") {
            i.VSCODE_PARENT_PID = String(e.parentLifecycleBound);
          }
          i.VSCODE_CRASH_REPORTER_PROCESS_TYPE = e.type;
          if (j) {
            if (_S()) {
              i.NODE_DISABLE_UNC_ACCESS_CHECKS = "1";
            } else {
              i.NODE_UNC_HOST_ALLOWLIST = IS().join("\\");
            }
          }
          p5(i);
          for (const s of Object.keys(i)) {
            i[s] = String(i[s]);
          }
          return i;
        }
        G(e, i, s) {
          if (e.stdout) {
            const r = new w5("utf-8");
            this.D(x.fromNodeEventEmitter(e.stdout, "data")(n => this.f.fire(typeof n == "string" ? n : r.write(n))));
          }
          if (e.stderr) {
            const r = new w5("utf-8");
            this.D(x.fromNodeEventEmitter(e.stderr, "data")(n => this.g.fire(typeof n == "string" ? n : r.write(n))));
          }
          this.D(x.fromNodeEventEmitter(e, "message")(r => this.h.fire(r)));
          this.D(x.fromNodeEventEmitter(e, "spawn")(() => {
            this.r = e.pid;
            if (typeof e.pid == "number") {
              Co.b.set(e.pid, {
                pid: e.pid,
                name: ZD(i) ? `${i.type} [${i.responseWindowId}]` : i.type
              });
            }
            this.y("successfully created", Pe.Info);
            this.j.fire(e.pid);
          }));
          this.D(x.fromNodeEventEmitter(e, "exit")(r => {
            this.y(`received exit event with code ${r}`, Pe.Info);
            this.m.fire({
              pid: this.r,
              code: r,
              signal: "unknown"
            });
            this.H();
          }));
          this.D(x.fromNodeEventEmitter(e, "error", (r, n, o) => ({
            type: r,
            location: n,
            report: o
          }))(({
            type: r,
            location: n,
            report: o
          }) => {
            this.y(`crashed due to ${r} from V8 at ${n}`, Pe.Info);
            let a = [];
            try {
              a = JSON.parse(o).sharedObjects.filter(l => l.endsWith(".node")).map(l => {
                const u = l.indexOf("extensions") === -1 ? l.indexOf("node_modules") : l.indexOf("extensions");
                return l.substring(u);
              });
            } catch {}
            this.u.publicLog2("utilityprocessv8error", {
              processtype: i.type,
              error: r,
              location: n,
              addons: a
            });
          }));
          this.D(x.fromNodeEventEmitter(JD, "child-process-gone", (r, n) => ({
            event: r,
            details: n
          }))(({
            details: r
          }) => {
            if (r.type === "Utility" && r.name === s) {
              this.y(`crashed with code ${r.exitCode} and reason '${r.reason}'`, Pe.Error);
              this.u.publicLog2("utilityprocesscrash", {
                type: i.type,
                reason: r.reason,
                code: r.exitCode
              });
              this.n.fire({
                pid: this.r,
                code: r.exitCode,
                reason: r.reason
              });
              this.H();
            }
          }));
        }
        once(e, i) {
          const s = this.D(this.h.event(r => {
            if (r === e) {
              s.dispose();
              i();
            }
          }));
        }
        postMessage(e, i) {
          if (this.q) {
            this.q.postMessage(e, i);
            return true;
          } else {
            return false;
          }
        }
        connect(e) {
          const {
            port1: i,
            port2: s
          } = new GD();
          this.postMessage(e, [s]);
          return i;
        }
        enableInspectPort() {
          if (!this.q || typeof this.r != "number") {
            return false;
          }
          this.y("enabling inspect port", Pe.Info);
          const e = process;
          if (typeof e._debugProcess == "function") {
            e._debugProcess(this.r);
            return true;
          } else {
            return false;
          }
        }
        kill() {
          if (!this.q) {
            return;
          }
          this.y("attempting to kill the process...", Pe.Info);
          if (this.q.kill()) {
            this.y("successfully killed the process", Pe.Info);
            this.H();
          } else {
            this.y("unable to kill the process", Pe.Warning);
          }
        }
        H() {
          if (typeof this.r == "number") {
            Co.b.delete(this.r);
          }
          this.q = undefined;
        }
        async waitForExit(e) {
          if (this.q) {
            this.y("waiting to exit...", Pe.Info);
            await Promise.race([x.toPromise(this.onExit), wi(e)]);
            if (this.q) {
              this.y(`did not exit within ${e}ms, will kill it now...`, Pe.Info);
              this.kill();
            }
          }
        }
      };
      _r = Co = __decorate([__param(0, V), __param(1, Ot), __param(2, Te)], _r);
      Ec = class extends _r {
        constructor(e, i, s, r) {
          super(e, s, r);
          this.I = i;
        }
        start(e) {
          const i = this.I.getWindowById(e.responseWindowId);
          if (i === undefined || i.webContents === undefined || i?.win?.isDestroyed() === true || i?.webContents?.isDestroyed() === true) {
            this.y("Refusing to start utility process because requesting window cannot be found or is destroyed...", Pe.Error);
            return true;
          }
          if (!super.C(e)) {
            return false;
          }
          if (i?.win) {
            this.J(i.win, e);
          }
          const r = this.connect(e.payload);
          i.webContents.postMessage(e.responseChannel, e.responseNonce, [r]);
          return true;
        }
        J(e, i) {
          if (i.windowLifecycleBound) {
            this.D(x.filter(this.w.onWillLoadWindow, s => s.window.win === e)(() => this.kill()));
            this.D(x.fromNodeEventEmitter(e, "closed")(() => this.kill()));
          }
        }
      };
      Ec = __decorate([__param(0, V), __param(1, dt), __param(2, Ot), __param(3, Te)], Ec);
    }
  });
  import { app as v5, BrowserWindow as YD } from "electron";
  var b5;
  var vh;
  var bh;
  var y5 = g({
    "out-build/vs/platform/diagnostics/electron-main/diagnosticsMainService.js"() {
      "use strict";
  
      as();
      At();
      Y();
      Lt();
      ri();
      vn();
      _e();
      X();
      _o();
      b5 = "diagnosticsMainService";
      vh = q(b5);
      bh = class {
        constructor(e, i, s) {
          this.a = e;
          this.b = i;
          this.c = s;
        }
        async getRemoteDiagnostics(e) {
          const i = this.a.getWindows();
          return (await Promise.all(i.map(async r => {
            const n = r.remoteAuthority;
            if (!n) {
              return;
            }
            const o = `vscode:getDiagnosticInfoResponse${r.id}`;
            const a = {
              includeProcesses: e.includeProcesses,
              folders: e.includeWorkspaceMetadata ? await this.f(r) : undefined
            };
            return new Promise(c => {
              r.sendWhenReady("vscode:getDiagnosticInfo", We.None, {
                replyChannel: o,
                args: a
              });
              it.once(o, (l, u) => {
                if (!u) {
                  c({
                    hostName: n,
                    errorMessage: `Unable to resolve connection to '${n}'.`
                  });
                }
                c(u);
              });
              setTimeout(() => {
                c({
                  hostName: n,
                  errorMessage: `Connection to '${n}' could not be established`
                });
              }, 5000);
            });
          }))).filter(r => !!r);
        }
        async getMainDiagnostics() {
          this.c.trace("Received request for main process info from other instance.");
          const e = [];
          for (const s of YD.getAllWindows()) {
            const r = this.a.getWindowById(s.id);
            if (r) {
              e.push(await this.d(r));
            } else {
              e.push(this.e(s));
            }
          }
          const i = [];
          for (const {
            pid: s,
            name: r
          } of _r.getAll()) {
            i.push({
              pid: s,
              name: r
            });
          }
          return {
            mainPID: process.pid,
            mainArguments: process.argv.slice(1),
            windows: e,
            pidToNames: i,
            screenReader: !!v5.accessibilitySupportEnabled,
            gpuFeatureStatus: v5.getGPUFeatureStatus()
          };
        }
        async d(e) {
          const i = await this.f(e);
          const s = Vl(e.win);
          return this.e(s, i, e.remoteAuthority);
        }
        e(e, i = [], s) {
          return {
            id: e.id,
            pid: e.webContents.getOSProcessId(),
            title: e.getTitle(),
            folderURIs: i,
            remoteAuthority: s
          };
        }
        async f(e) {
          const i = [];
          const s = e.openedWorkspace;
          if (Li(s)) {
            i.push(s.uri);
          } else if (Kt(s)) {
            const r = await this.b.resolveLocalWorkspace(s.configPath);
            if (r) {
              r.folders.forEach(o => {
                i.push(o.uri);
              });
            }
          }
          return i;
        }
      };
      bh = __decorate([__param(0, dt), __param(1, Cr), __param(2, V)], bh);
    }
  });
  import { safeStorage as XD, app as QD } from "electron";
  var or;
  var yh;
  var eP = g({
    "out-build/vs/platform/encryption/electron-main/encryptionMainService.js"() {
      "use strict";
  
      H();
      X();
      or = XD;
      yh = class {
        constructor(e) {
          this.a = e;
          if (QD.commandLine.getSwitchValue("password-store") === "basic") {
            this.a.trace("[EncryptionMainService] setting usePlainTextEncryption to true...");
            or.setUsePlainTextEncryption?.(true);
            this.a.trace("[EncryptionMainService] set usePlainTextEncryption to true");
          }
        }
        async encrypt(e) {
          this.a.trace("[EncryptionMainService] Encrypting value...");
          try {
            const i = JSON.stringify(or.encryptString(e));
            this.a.trace("[EncryptionMainService] Encrypted value.");
            return i;
          } catch (i) {
            this.a.error(i);
            throw i;
          }
        }
        async decrypt(e) {
          let i;
          try {
            i = JSON.parse(e);
            if (!i.data) {
              throw new Error(`[EncryptionMainService] Invalid encrypted value: ${e}`);
            }
            const s = Buffer.from(i.data);
            this.a.trace("[EncryptionMainService] Decrypting value...");
            const r = or.decryptString(s);
            this.a.trace("[EncryptionMainService] Decrypted value.");
            return r;
          } catch (s) {
            this.a.error(s);
            throw s;
          }
        }
        isEncryptionAvailable() {
          this.a.trace("[EncryptionMainService] Checking if encryption is available...");
          const e = or.isEncryptionAvailable();
          this.a.trace("[EncryptionMainService] Encryption is available: ", e);
          return Promise.resolve(e);
        }
        getKeyStorageProvider() {
          if (j) {
            return Promise.resolve("dpapi");
          }
          if (N) {
            return Promise.resolve("keychain_access");
          }
          if (or.getSelectedStorageBackend) {
            try {
              this.a.trace("[EncryptionMainService] Getting selected storage backend...");
              const e = or.getSelectedStorageBackend();
              this.a.trace("[EncryptionMainService] Selected storage backend: ", e);
              return Promise.resolve(e);
            } catch (e) {
              this.a.error(e);
            }
          }
          return Promise.resolve("unknown");
        }
        async setUsePlainTextEncryption() {
          if (j) {
            throw new Error("Setting plain text encryption is not supported on Windows.");
          }
          if (N) {
            throw new Error("Setting plain text encryption is not supported on macOS.");
          }
          if (!or.setUsePlainTextEncryption) {
            throw new Error("Setting plain text encryption is not supported.");
          }
          this.a.trace("[EncryptionMainService] Setting usePlainTextEncryption to true...");
          or.setUsePlainTextEncryption(true);
          this.a.trace("[EncryptionMainService] Set usePlainTextEncryption to true");
        }
      };
      yh = __decorate([__param(0, V)], yh);
    }
  });
  import tP from "assert";
  function iP(t, e) {
    const i = (c, l) => {
      console.warn(v(1796, null, c, l));
    };
    const s = c => {
      console.warn(v(1797, null, c));
    };
    const r = (c, l) => {
      console.warn(v(1798, null, c, l));
    };
    const n = c => ({
      onUnknownOption: l => {
        if (!H1.includes(c)) {
          console.warn(v(1799, null, l, c));
        }
      },
      onMultipleValues: i,
      onEmptyValue: s,
      onDeprecatedOption: r,
      getSubcommandReporter: H1.includes(c) ? n : undefined
    });
    const a = z1(t, V1, e ? {
      onUnknownOption: c => {
        console.warn(v(1800, null, c));
      },
      onMultipleValues: i,
      onEmptyValue: s,
      onDeprecatedOption: r,
      getSubcommandReporter: n
    } : undefined);
    if (a.goto) {
      a._.forEach(c => tP(/^(\w:)?[^:]+(:\d*){0,2}:?$/.test(c), v(1801, null)));
    }
    return a;
  }
  function sP(t) {
    const e = t.findIndex(i => !/^-/.test(i));
    if (e > -1) {
      return [...t.slice(0, e), ...t.slice(e + 1)];
    }
  }
  function rP(t) {
    let [, ...e] = t;
    if (process.env.VSCODE_DEV) {
      e = sP(e) || [];
    }
    const i = !bn(process.env);
    return iP(e, i);
  }
  function nP(t, ...e) {
    const i = t.indexOf("--");
    if (i === -1) {
      t.push(...e);
    } else {
      t.splice(i, 0, ...e);
    }
    return t;
  }
  function bn(t) {
    return t.VSCODE_CLI === "1";
  }
  var kc = g({
    "out-build/vs/platform/environment/node/argvHelper.js"() {
      "use strict";
  
      be();
      K4();
    }
  });
  import * as oP from "os";
  function aP({
    useAlternateBitness: t = false
  } = {}) {
    if (t) {
      if (xc === 0) {
        return process.env["ProgramFiles(x86)"] || null;
      } else {
        return Ro === 0 && process.env.ProgramW6432 || null;
      }
    } else {
      return process.env.ProgramFiles || null;
    }
  }
  async function Sh({
    useAlternateBitness: t = false,
    findPreview: e = false
  } = {}) {
    const i = aP({
      useAlternateBitness: t
    });
    if (!i) {
      return null;
    }
    const s = F(i, "PowerShell");
    if (!(await jt.existsDirectory(s))) {
      return null;
    }
    let r = -1;
    let n = null;
    for (const c of await ee.readdir(s)) {
      let l = -1;
      if (e) {
        const d = c.indexOf("-");
        if (d < 0) {
          continue;
        }
        const f = c.substring(0, d);
        if (!rg.test(f) || c.substring(d + 1) !== "preview") {
          continue;
        }
        l = parseInt(f, 10);
      } else {
        if (!rg.test(c)) {
          continue;
        }
        l = parseInt(c, 10);
      }
      if (l <= r) {
        continue;
      }
      const u = F(s, c, "pwsh.exe");
      if (await jt.existsFile(u)) {
        n = u;
        r = l;
      }
    }
    if (!n) {
      return null;
    }
    const o = i.includes("x86") ? " (x86)" : "";
    const a = e ? " Preview" : "";
    return new Dc(n, `PowerShell${a}${o}`, true);
  }
  async function S5({
    findPreview: t
  } = {}) {
    if (!process.env.LOCALAPPDATA) {
      return null;
    }
    const e = F(process.env.LOCALAPPDATA, "Microsoft", "WindowsApps");
    if (!(await jt.existsDirectory(e))) {
      return null;
    }
    const {
      pwshMsixDirRegex: i,
      pwshMsixName: s
    } = t ? {
      pwshMsixDirRegex: x5,
      pwshMsixName: "PowerShell Preview (Store)"
    } : {
      pwshMsixDirRegex: k5,
      pwshMsixName: "PowerShell (Store)"
    };
    for (const r of await ee.readdir(e)) {
      if (i.test(r)) {
        const n = F(e, r, "pwsh.exe");
        return new Dc(n, s);
      }
    }
    return null;
  }
  function cP() {
    const t = F(oP.homedir(), ".dotnet", "tools", "pwsh.exe");
    return new Dc(t, ".NET Core PowerShell Global Tool");
  }
  function lP() {
    const t = F(process.env.windir, xc === 1 && Ro !== 1 ? "SysNative" : "System32", "WindowsPowerShell", "v1.0", "powershell.exe");
    return new Dc(t, "Windows PowerShell", true);
  }
  async function* uP() {
    let t = await Sh();
    if (t) {
      yield t;
    }
    t = await Sh({
      useAlternateBitness: true
    });
    if (t) {
      yield t;
    }
    t = await S5();
    if (t) {
      yield t;
    }
    t = cP();
    if (t) {
      yield t;
    }
    t = await Sh({
      findPreview: true
    });
    if (t) {
      yield t;
    }
    t = await S5({
      findPreview: true
    });
    if (t) {
      yield t;
    }
    t = await Sh({
      useAlternateBitness: true,
      findPreview: true
    });
    if (t) {
      yield t;
    }
    t = lP();
    if (t) {
      yield t;
    }
  }
  async function* E5() {
    for await (const t of uP()) {
      if (await t.exists()) {
        yield t;
      }
    }
  }
  async function hP() {
    for await (const t of E5()) {
      return t;
    }
    return null;
  }
  var rg;
  var k5;
  var x5;
  var D5;
  var xc;
  var Ro;
  var Dc;
  var P5 = g({
    "out-build/vs/base/node/powershell.js"() {
      "use strict";
  
      we();
      _t();
      rg = /^\d+$/;
      k5 = /^Microsoft.PowerShell_.*/;
      x5 = /^Microsoft.PowerShellPreview_.*/;
      (function (t) {
        t[t.x64 = 0] = "x64";
        t[t.x86 = 1] = "x86";
        t[t.ARM = 2] = "ARM";
      })(D5 ||= {});
      switch (process.arch) {
        case "ia32":
          xc = 1;
          break;
        case "arm":
        case "arm64":
          xc = 2;
          break;
        default:
          xc = 0;
          break;
      }
      if (process.env.PROCESSOR_ARCHITEW6432) {
        Ro = process.env.PROCESSOR_ARCHITEW6432 === "ARM64" ? 2 : 0;
      } else if (process.env.PROCESSOR_ARCHITECTURE === "ARM64") {
        Ro = 2;
      } else if (process.env.PROCESSOR_ARCHITECTURE === "X86") {
        Ro = 1;
      } else {
        Ro = 0;
      }
      Dc = class {
        constructor(t, e, i) {
          this.exePath = t;
          this.displayName = e;
          this.a = i;
        }
        async exists() {
          if (this.a === undefined) {
            this.a = await jt.existsFile(this.exePath);
          }
          return this.a;
        }
      };
    }
  });
  import { promises as $5 } from "fs";
  function I5(t = Ii) {
    return t.comspec || "cmd.exe";
  }
  function dP(t) {
    let e = [];
    let i = false;
    const s = function (r) {
      if (i) {
        e.push(r);
        return;
      }
      if (!t.send(r, o => {
        if (o) {
          console.error(o);
        }
        i = false;
        if (e.length > 0) {
          const a = e.slice(0);
          e = [];
          a.forEach(c => s(c));
        }
      }) || j) {
        i = true;
      }
    };
    return {
      send: s
    };
  }
  var ng;
  var og = g({
    "out-build/vs/base/node/processes.js"() {
      "use strict";
  
      we();
      H();
      ys();
      wh();
      _e();
      _t();
      (function (t) {
        async function e(i, s, r) {
          if (Zr(i)) {
            return i;
          }
          if (s === undefined) {
            s = bs();
          }
          if (Xe(i) !== "." || (r === undefined && wt(Ii.PATH) && (r = Ii.PATH.split(Zl)), r === undefined || r.length === 0)) {
            return F(s, i);
          }
          async function o(a) {
            if (await ee.exists(a)) {
              let c;
              try {
                c = await $5.stat(a);
              } catch (l) {
                if (l.message.startsWith("EACCES")) {
                  c = await $5.lstat(a);
                }
              }
              if (c) {
                return !c.isDirectory();
              } else {
                return false;
              }
            }
            return false;
          }
          for (const a of r) {
            let c;
            if (Zr(a)) {
              c = F(a, i);
            } else {
              c = F(s, a, i);
            }
            if (await o(c)) {
              return c;
            }
            let l = c + ".com";
            if ((await o(l)) || (l = c + ".exe", await o(l))) {
              return l;
            }
          }
          return F(s, i);
        }
        t.findExecutable = e;
      })(ng ||= {});
    }
  });
  import { userInfo as fP } from "os";
  async function A5(t, e) {
    if (t === 1) {
      if (j) {
        return gP();
      } else {
        return I5(e);
      }
    } else {
      return pP(t, e);
    }
  }
  function pP(t, e) {
    if (Se && t === 2 || N && t === 3) {
      return "/bin/bash";
    }
    if (!Eh) {
      let i;
      if (j) {
        i = "/bin/bash";
      } else {
        i = e.SHELL;
        if (!i) {
          try {
            i = fP().shell;
          } catch {}
        }
        i ||= "sh";
        if (i === "/bin/false") {
          i = "/bin/bash";
        }
      }
      Eh = i;
    }
    return Eh;
  }
  async function gP() {
    kh ||= (await hP()).exePath;
    return kh;
  }
  var Eh;
  var kh;
  var C5 = g({
    "out-build/vs/base/node/shell.js"() {
      "use strict";
  
      H();
      P5();
      og();
      Eh = null;
      kh = null;
    }
  });
  function mP(t, e, i) {
    return Math.min(Math.max(t, e), i);
  }
  var wP = g({
    "out-build/vs/base/common/numbers.js"() {
      "use strict";
    }
  });
  import { spawn as vP } from "child_process";
  async function ag(t, e, i, s) {
    if (i["force-disable-user-env"]) {
      e.trace("resolveShellEnv(): skipped (--force-disable-user-env)");
      return {};
    } else if (j) {
      e.trace("resolveShellEnv(): skipped (Windows)");
      return {};
    } else if (bn(s) && !i["force-user-env"]) {
      e.trace("resolveShellEnv(): skipped (VSCODE_CLI is set)");
      return {};
    } else {
      if (bn(s)) {
        e.trace("resolveShellEnv(): running (--force-user-env)");
      } else {
        e.trace("resolveShellEnv(): running (macOS/Linux)");
      }
      xh ||= Tt.withAsyncBody(async (r, n) => {
        const o = new ns();
        let a = 10000;
        const c = t.getValue("application.shellEnvironmentResolutionTimeout");
        if (typeof c == "number") {
          a = mP(c, 1, 120) * 1000;
        }
        const l = setTimeout(() => {
          o.dispose(true);
          n(new Error(v(2114, null)));
        }, a);
        try {
          r(await bP(e, o.token));
        } catch (u) {
          if (!Nl(u) && !o.token.isCancellationRequested) {
            n(new Error(v(2115, null, Ki(u))));
          } else {
            r({});
          }
        } finally {
          clearTimeout(l);
          o.dispose();
        }
      });
      return xh;
    }
  }
  async function bP(t, e) {
    const i = process.env.ELECTRON_RUN_AS_NODE;
    t.trace("getUnixShellEnvironment#runAsNode", i);
    const s = process.env.ELECTRON_NO_ATTACH_CONSOLE;
    t.trace("getUnixShellEnvironment#noAttach", s);
    const r = ti().replace(/-/g, "").substr(0, 12);
    const n = new RegExp(r + "({.*})" + r);
    const o = {
      ...process.env,
      ELECTRON_RUN_AS_NODE: "1",
      ELECTRON_NO_ATTACH_CONSOLE: "1",
      VSCODE_RESOLVING_ENVIRONMENT: "1"
    };
    t.trace("getUnixShellEnvironment#env", o);
    const a = await A5(Wi, o);
    t.trace("getUnixShellEnvironment#shell", a);
    return new Promise((c, l) => {
      if (e.isCancellationRequested) {
        return l(new hi());
      }
      const u = Ue(a);
      let d;
      let f;
      const p = "";
      if (/^pwsh(-preview)?$/.test(u)) {
        d = `& '${process.execPath}' ${p} -p '''${r}'' + JSON.stringify(process.env) + ''${r}'''`;
        f = ["-Login", "-Command"];
      } else if (u === "nu") {
        d = `^'${process.execPath}' ${p} -p '"${r}" + JSON.stringify(process.env) + "${r}"'`;
        f = ["-i", "-l", "-c"];
      } else if (u === "xonsh") {
        d = `import os, json; print("${r}", json.dumps(dict(os.environ)), "${r}")`;
        f = ["-i", "-l", "-c"];
      } else {
        d = `'${process.execPath}' ${p} -p '"${r}" + JSON.stringify(process.env) + "${r}"'`;
        if (u === "tcsh" || u === "csh") {
          f = ["-ic"];
        } else {
          f = ["-i", "-l", "-c"];
        }
      }
      t.trace("getUnixShellEnvironment#spawn", JSON.stringify(f), d);
      const w = vP(a, [...f, d], {
        detached: true,
        stdio: ["ignore", "pipe", "pipe"],
        env: o
      });
      e.onCancellationRequested(() => {
        w.kill();
        return l(new hi());
      });
      w.on("error", b => {
        t.error("getUnixShellEnvironment#errorChildProcess", Ki(b));
        l(b);
      });
      const m = [];
      w.stdout.on("data", b => m.push(b));
      const y = [];
      w.stderr.on("data", b => y.push(b));
      w.on("close", (b, k) => {
        const A = Buffer.concat(m).toString("utf8");
        t.trace("getUnixShellEnvironment#raw", A);
        const C = Buffer.concat(y).toString("utf8");
        if (C.trim()) {
          t.trace("getUnixShellEnvironment#stderr", C);
        }
        if (b || k) {
          return l(new Error(v(2116, null, b, k)));
        }
        const _ = n.exec(A);
        const Z = _ ? _[1] : "{}";
        try {
          const ie = JSON.parse(Z);
          if (i) {
            ie.ELECTRON_RUN_AS_NODE = i;
          } else {
            delete ie.ELECTRON_RUN_AS_NODE;
          }
          if (s) {
            ie.ELECTRON_NO_ATTACH_CONSOLE = s;
          } else {
            delete ie.ELECTRON_NO_ATTACH_CONSOLE;
          }
          delete ie.VSCODE_RESOLVING_ENVIRONMENT;
          delete ie.XDG_RUNTIME_DIR;
          t.trace("getUnixShellEnvironment#result", ie);
          c(ie);
        } catch (ie) {
          t.error("getUnixShellEnvironment#errorCaught", Ki(ie));
          l(ie);
        }
      });
    });
  }
  var xh;
  var cg = g({
    "out-build/vs/platform/shell/node/shellEnv.js"() {
      "use strict";
  
      we();
      be();
      At();
      en();
      $e();
      H();
      _i();
      C5();
      kc();
      ce();
      wP();
      xh = undefined;
    }
  });
  var lg;
  var _5;
  var yP = g({
    "out-build/vs/platform/extensions/common/extensionHostStarter.js"() {
      "use strict";
  
      Y();
      lg = q("extensionHostStarter");
      _5 = "extensionHostStarter";
    }
  });
  var ug;
  var Dh;
  var SP = g({
    "out-build/vs/platform/extensions/electron-main/extensionHostStarter.js"() {
      "use strict";
  
      ce();
      $e();
      B();
      M();
      ct();
      X();
      xt();
      _o();
      Lt();
      Dh = class extends T {
        static {
          ug = this;
        }
        static {
          this.a = 0;
        }
        constructor(e, i, s, r) {
          super();
          this.f = e;
          this.g = i;
          this.h = s;
          this.j = r;
          this.b = new Map();
          this.c = false;
          this.D(this.g.onWillShutdown(n => {
            this.c = true;
            n.join("extHostStarter", this._waitForAllExit(6000));
          }));
        }
        dispose() {
          super.dispose();
        }
        m(e) {
          const i = this.b.get(e);
          if (!i) {
            throw new Error("Unknown extension host!");
          }
          return i;
        }
        onDynamicStdout(e) {
          return this.m(e).onStdout;
        }
        onDynamicStderr(e) {
          return this.m(e).onStderr;
        }
        onDynamicMessage(e) {
          return this.m(e).onMessage;
        }
        onDynamicExit(e) {
          return this.m(e).onExit;
        }
        async createExtensionHost() {
          if (this.c) {
            throw Jn();
          }
          const e = String(++ug.a);
          const i = new Ec(this.f, this.h, this.j, this.g);
          this.b.set(e, i);
          const s = i.onExit(({
            pid: r,
            code: n,
            signal: o
          }) => {
            s.dispose();
            this.f.info(`Extension host with pid ${r} exited with code: ${n}, signal: ${o}.`);
            setTimeout(() => {
              i.dispose();
              this.b.delete(e);
            });
            setTimeout(() => {
              try {
                process.kill(r, 0);
                this.f.error(`Extension host with pid ${r} still exists, forcefully killing it...`);
                process.kill(r);
              } catch {}
            }, 1000);
          });
          return {
            id: e
          };
        }
        async start(e, i) {
          if (this.c) {
            throw Jn();
          }
          const s = this.m(e);
          s.start({
            ...i,
            processTitle: `extension-host [${i.responseWindowId}-${e}]`,
            type: "extensionHost",
            entryPoint: "vs/workbench/api/node/extensionHostProcess",
            args: ["--skipWorkspaceStorageLock"],
            execArgv: i.execArgv,
            allowLoadingUnsignedLibraries: true,
            respondToAuthRequestsFromMainProcess: true,
            correlationId: e
          });
          return {
            pid: await x.toPromise(s.onSpawn)
          };
        }
        async enableInspectPort(e) {
          if (this.c) {
            throw Jn();
          }
          const i = this.b.get(e);
          if (i) {
            return i.enableInspectPort();
          } else {
            return false;
          }
        }
        async kill(e) {
          if (this.c) {
            throw Jn();
          }
          const i = this.b.get(e);
          if (i) {
            i.kill();
          }
        }
        async _killAllNow() {
          for (const [, e] of this.b) {
            e.kill();
          }
        }
        async _waitForAllExit(e) {
          const i = [];
          for (const [, s] of this.b) {
            i.push(s.waitForExit(e));
          }
          return Tt.settled(i).then(() => {});
        }
      };
      Dh = ug = __decorate([__param(0, V), __param(1, Te), __param(2, dt), __param(3, Ot)], Dh);
    }
  });
  var Pc;
  var EP = g({
    "out-build/vs/platform/externalTerminal/electron-main/externalTerminal.js"() {
      "use strict";
  
      Y();
      Pc = q("externalTerminal");
    }
  });
  var kP;
  var $c;
  var xP = g({
    "out-build/vs/platform/externalTerminal/common/externalTerminal.js"() {
      "use strict";
  
      Y();
      kP = q("externalTerminal");
      $c = "Terminal.app";
    }
  });
  import * as Oo from "child_process";
  function Lo(t) {
    const e = {
      ...t.env
    };
    VD(e);
    return e;
  }
  function hg(t) {
    if ("errno" in t && t.errno === "ENOENT" && "path" in t && typeof t.path == "string") {
      return new Error(v(1905, null, t.path));
    } else {
      return t;
    }
  }
  function DP(t) {
    let e = "";
    for (const i of t) {
      if (i.indexOf(" ") >= 0) {
        e += "\"" + i + "\"";
      } else {
        e += i;
      }
      e += " ";
    }
    return e;
  }
  var dg;
  var Ph;
  var $h;
  var R5;
  var fg;
  var PP = g({
    "out-build/vs/platform/externalTerminal/node/externalTerminalService.js"() {
      "use strict";
  
      sn();
      Ie();
      we();
      H();
      wh();
      _t();
      og();
      be();
      xP();
      dg = v(1900, null);
      Ph = class {
        async getDefaultTerminalForPlatforms() {
          return {
            windows: $h.getDefaultTerminalWindows(),
            linux: await fg.getDefaultTerminalLinuxReady(),
            osx: "xterm"
          };
        }
      };
      $h = class ur extends Ph {
        static {
          this.CMD = "cmd.exe";
        }
        openTerminal(e, i) {
          return this.spawnTerminal(Oo, e, I5(), i);
        }
        spawnTerminal(e, i, s, r) {
          const n = i.windowsExec || ur.getDefaultTerminalWindows();
          if (r && r[1] === ":") {
            r = r[0].toUpperCase() + r.substr(1);
          }
          const o = Ue(n, ".exe").toLowerCase();
          if (o === "cmder") {
            e.spawn(n, r ? [r] : undefined);
            return Promise.resolve(undefined);
          }
          const a = ["/c", "start", "/wait"];
          if (n.indexOf(" ") >= 0) {
            a.push(n);
          }
          a.push(n);
          if (o === "wt") {
            a.push("-d .");
          }
          return new Promise((c, l) => {
            const u = Lo(process);
            const d = e.spawn(s, a, {
              cwd: r,
              env: u,
              detached: true
            });
            d.on("error", l);
            d.on("exit", () => c());
          });
        }
        async runInTerminal(e, i, s, r, n) {
          const o = "windowsExec" in n && n.windowsExec ? n.windowsExec : ur.getDefaultTerminalWindows();
          const a = await ur.getWtExePath();
          return new Promise((c, l) => {
            const u = `"${i} - ${dg}"`;
            const d = `"${s.join("\" \"")}" & pause`;
            const f = Object.assign({}, Lo(process), r);
            Object.keys(f).filter(b => f[b] === null).forEach(b => delete f[b]);
            const p = {
              cwd: i,
              env: f,
              windowsVerbatimArguments: true
            };
            let w;
            let m;
            if (Ue(o, ".exe") === "wt") {
              w = o;
              m = ["-d", ".", ur.CMD, "/c", d];
            } else if (a) {
              w = a;
              m = ["-d", ".", o, "/c", d];
            } else {
              w = ur.CMD;
              m = ["/c", "start", u, "/wait", o, "/c", `"${d}"`];
            }
            Oo.spawn(w, m, p).on("error", b => {
              l(hg(b));
            });
            c(undefined);
          });
        }
        static getDefaultTerminalWindows() {
          if (!ur._DEFAULT_TERMINAL_WINDOWS) {
            const e = !!process.env.hasOwnProperty("PROCESSOR_ARCHITEW6432");
            ur._DEFAULT_TERMINAL_WINDOWS = `${process.env.windir ? process.env.windir : "C:\\Windows"}\\${e ? "Sysnative" : "System32"}\\cmd.exe`;
          }
          return ur._DEFAULT_TERMINAL_WINDOWS;
        }
        static async getWtExePath() {
          try {
            const e = await ng.findExecutable("wt");
            if (await ee.exists(e)) {
              return e;
            } else {
              return undefined;
            }
          } catch {
            return;
          }
        }
      };
      __decorate([de], $h, "getWtExePath", null);
      R5 = class oS extends Ph {
        static {
          this.OSASCRIPT = "/usr/bin/osascript";
        }
        openTerminal(e, i) {
          return this.spawnTerminal(Oo, e, i);
        }
        runInTerminal(e, i, s, r, n) {
          const o = n.osxExec || $c;
          return new Promise((a, c) => {
            if (o === $c || o === "iTerm.app") {
              const l = o === $c ? "TerminalHelper" : "iTermHelper";
              const d = [Ct.asFileUri(`vs/workbench/contrib/externalTerminal/node/${l}.scpt`).fsPath, "-t", e || dg, "-w", i];
              for (const w of s) {
                d.push("-a");
                d.push(w);
              }
              if (r) {
                const w = Object.assign({}, Lo(process), r);
                for (const m in w) {
                  const y = w[m];
                  if (y === null) {
                    d.push("-u");
                    d.push(m);
                  } else {
                    d.push("-e");
                    d.push(`${m}=${y}`);
                  }
                }
              }
              let f = "";
              const p = Oo.spawn(oS.OSASCRIPT, d);
              p.on("error", w => {
                c(hg(w));
              });
              p.stderr.on("data", w => {
                f += w.toString();
              });
              p.on("exit", w => {
                if (w === 0) {
                  a(undefined);
                } else if (f) {
                  const m = f.split(`
  `, 1);
                  c(new Error(m[0]));
                } else {
                  c(new Error(v(1901, null, l, w)));
                }
              });
            } else {
              c(new Error(v(1902, null, o)));
            }
          });
        }
        spawnTerminal(e, i, s) {
          const r = i.osxExec || $c;
          return new Promise((n, o) => {
            const a = ["-a", r];
            if (s) {
              a.push(s);
            }
            const c = Lo(process);
            const l = e.spawn("/usr/bin/open", a, {
              cwd: s,
              env: c
            });
            l.on("error", o);
            l.on("exit", () => n());
          });
        }
      };
      fg = class Ur extends Ph {
        static {
          this.WAIT_MESSAGE = v(1903, null);
        }
        openTerminal(e, i) {
          return this.spawnTerminal(Oo, e, i);
        }
        runInTerminal(e, i, s, r, n) {
          const o = n.linuxExec ? Promise.resolve(n.linuxExec) : Ur.getDefaultTerminalLinuxReady();
          return new Promise((a, c) => {
            const l = [];
            o.then(u => {
              if (u.indexOf("gnome-terminal") >= 0) {
                l.push("-x");
              } else {
                l.push("-e");
              }
              l.push("bash");
              l.push("-c");
              const d = `${DP(s)}; echo; read -p "${Ur.WAIT_MESSAGE}" -n1;`;
              l.push(`''${d}''`);
              const f = Object.assign({}, Lo(process), r);
              Object.keys(f).filter(y => f[y] === null).forEach(y => delete f[y]);
              const p = {
                cwd: i,
                env: f
              };
              let w = "";
              const m = Oo.spawn(u, l, p);
              m.on("error", y => {
                c(hg(y));
              });
              m.stderr.on("data", y => {
                w += y.toString();
              });
              m.on("exit", y => {
                if (y === 0) {
                  a(undefined);
                } else if (w) {
                  const b = w.split(`
  `, 1);
                  c(new Error(b[0]));
                } else {
                  c(new Error(v(1904, null, u, y)));
                }
              });
            });
          });
        }
        static async getDefaultTerminalLinuxReady() {
          if (!Ur._DEFAULT_TERMINAL_LINUX_READY) {
            if (!Se) {
              Ur._DEFAULT_TERMINAL_LINUX_READY = Promise.resolve("xterm");
            } else {
              const e = await ee.exists("/etc/debian_version");
              Ur._DEFAULT_TERMINAL_LINUX_READY = new Promise(i => {
                if (e) {
                  i("x-terminal-emulator");
                } else if (process.env.DESKTOP_SESSION === "gnome" || process.env.DESKTOP_SESSION === "gnome-classic") {
                  i("gnome-terminal");
                } else if (process.env.DESKTOP_SESSION === "kde-plasma") {
                  i("konsole");
                } else if (process.env.COLORTERM) {
                  i(process.env.COLORTERM);
                } else if (process.env.TERM) {
                  i(process.env.TERM);
                } else {
                  i("xterm");
                }
              });
            }
          }
          return Ur._DEFAULT_TERMINAL_LINUX_READY;
        }
        spawnTerminal(e, i, s) {
          const r = i.linuxExec ? Promise.resolve(i.linuxExec) : Ur.getDefaultTerminalLinuxReady();
          return new Promise((n, o) => {
            r.then(a => {
              const c = Lo(process);
              const l = e.spawn(a, [], {
                cwd: s,
                env: c
              });
              l.on("error", o);
              l.on("exit", () => n());
            });
          });
        }
      };
    }
  });
  function O5(t, e) {
    switch (t) {
      case 0:
        return "";
      case 1:
        return `${Ac}*?`;
      default:
        return `(?:${Ic}|${Ac}+${Ic}${e ? `|${Ic}${Ac}+` : ""})*?`;
    }
  }
  function L5(t, e) {
    if (!t) {
      return [];
    }
    const i = [];
    let s = false;
    let r = false;
    let n = "";
    for (const o of t) {
      switch (o) {
        case e:
          if (!s && !r) {
            i.push(n);
            n = "";
            continue;
          }
          break;
        case "{":
          s = true;
          break;
        case "}":
          s = false;
          break;
        case "[":
          r = true;
          break;
        case "]":
          r = false;
          break;
      }
      n += o;
    }
    if (n) {
      i.push(n);
    }
    return i;
  }
  function M5(t) {
    if (!t) {
      return "";
    }
    let e = "";
    const i = L5(t, mg);
    if (i.every(s => s === Mo)) {
      e = ".*";
    } else {
      let s = false;
      i.forEach((r, n) => {
        if (r === Mo) {
          if (s) {
            return;
          }
          e += O5(2, n === i.length - 1);
        } else {
          let o = false;
          let a = "";
          let c = false;
          let l = "";
          for (const u of r) {
            if (u !== "}" && o) {
              a += u;
              continue;
            }
            if (c && (u !== "]" || !l)) {
              let d;
              if (u === "-") {
                d = u;
              } else if ((u === "^" || u === "!") && !l) {
                d = "^";
              } else if (u === mg) {
                d = "";
              } else {
                d = ja(u);
              }
              l += d;
              continue;
            }
            switch (u) {
              case "{":
                o = true;
                continue;
              case "[":
                c = true;
                continue;
              case "}":
                {
                  const f = `(?:${L5(a, ",").map(p => M5(p)).join("|")})`;
                  e += f;
                  o = false;
                  a = "";
                  break;
                }
              case "]":
                {
                  e += "[" + l + "]";
                  c = false;
                  l = "";
                  break;
                }
              case "?":
                e += Ac;
                continue;
              case "*":
                e += O5(1);
                continue;
              default:
                e += ja(u);
            }
          }
          if (n < i.length - 1 && (i[n + 1] !== Mo || n + 2 < i.length)) {
            e += Ic;
          }
        }
        s = r === Mo;
      });
    }
    return e;
  }
  function pg(t, e) {
    if (!t) {
      return hs;
    }
    let i;
    if (typeof t != "string") {
      i = t.pattern;
    } else {
      i = t;
    }
    i = i.trim();
    const s = `${i}_${!!e.trimForExclusions}`;
    let r = wg.get(s);
    if (r) {
      return F5(r, t);
    }
    let n;
    if (U5.test(i)) {
      r = $P(i.substr(4), i);
    } else if (n = B5.exec(gg(i, e))) {
      r = IP(n[1], i);
    } else if ((e.trimForExclusions ? z5 : q5).test(i)) {
      r = AP(i, e);
    } else if (n = H5.exec(gg(i, e))) {
      r = N5(n[1].substr(1), i, true);
    } else if (n = V5.exec(gg(i, e))) {
      r = N5(n[1], i, false);
    } else {
      r = CP(i);
    }
    wg.set(s, r);
    return F5(r, t);
  }
  function F5(t, e) {
    if (typeof e == "string") {
      return t;
    }
    const i = function (s, r) {
      if (Ba(s, e.base, !Se)) {
        return t(gv(s.substr(e.base.length), Vt), r);
      } else {
        return null;
      }
    };
    i.allBasenames = t.allBasenames;
    i.allPaths = t.allPaths;
    i.basenames = t.basenames;
    i.patterns = t.patterns;
    return i;
  }
  function gg(t, e) {
    if (e.trimForExclusions && t.endsWith("/**")) {
      return t.substr(0, t.length - 2);
    } else {
      return t;
    }
  }
  function $P(t, e) {
    return function (i, s) {
      if (typeof i == "string" && i.endsWith(t)) {
        return e;
      } else {
        return null;
      }
    };
  }
  function IP(t, e) {
    const i = `/${t}`;
    const s = `\\${t}`;
    const r = function (o, a) {
      if (typeof o != "string") {
        return null;
      } else if (a) {
        if (a === t) {
          return e;
        } else {
          return null;
        }
      } else if (o === t || o.endsWith(i) || o.endsWith(s)) {
        return e;
      } else {
        return null;
      }
    };
    const n = [t];
    r.basenames = n;
    r.patterns = [e];
    r.allBasenames = n;
    return r;
  }
  function AP(t, e) {
    const i = W5(t.slice(1, -1).split(",").map(a => pg(a, e)).filter(a => a !== hs), t);
    const s = i.length;
    if (!s) {
      return hs;
    }
    if (s === 1) {
      return i[0];
    }
    const r = function (a, c) {
      for (let l = 0, u = i.length; l < u; l++) {
        if (i[l](a, c)) {
          return t;
        }
      }
      return null;
    };
    const n = i.find(a => !!a.allBasenames);
    if (n) {
      r.allBasenames = n.allBasenames;
    }
    const o = i.reduce((a, c) => c.allPaths ? a.concat(c.allPaths) : a, []);
    if (o.length) {
      r.allPaths = o;
    }
    return r;
  }
  function N5(t, e, i) {
    const s = Vt === ae.sep;
    const r = s ? t : t.replace(j5, Vt);
    const n = Vt + r;
    const o = ae.sep + t;
    let a;
    if (i) {
      a = function (c, l) {
        if (typeof c == "string" && (c === r || c.endsWith(n) || !s && (c === t || c.endsWith(o)))) {
          return e;
        } else {
          return null;
        }
      };
    } else {
      a = function (c, l) {
        if (typeof c == "string" && (c === r || !s && c === t)) {
          return e;
        } else {
          return null;
        }
      };
    }
    a.allPaths = [(i ? "*/" : "./") + t];
    return a;
  }
  function CP(t) {
    try {
      const e = new RegExp(`^${M5(t)}$`);
      return function (i) {
        e.lastIndex = 0;
        if (typeof i == "string" && e.test(i)) {
          return t;
        } else {
          return null;
        }
      };
    } catch {
      return hs;
    }
  }
  function _P(t, e = {}) {
    if (!t) {
      return vg;
    }
    if (typeof t == "string" || RP(t)) {
      const i = pg(t, e);
      if (i === hs) {
        return vg;
      }
      const s = function (r, n) {
        return !!i(r, n);
      };
      if (i.allBasenames) {
        s.allBasenames = i.allBasenames;
      }
      if (i.allPaths) {
        s.allPaths = i.allPaths;
      }
      return s;
    }
    return OP(t, e);
  }
  function RP(t) {
    const e = t;
    if (e) {
      return typeof e.base == "string" && typeof e.pattern == "string";
    } else {
      return false;
    }
  }
  function OP(t, e) {
    const i = W5(Object.getOwnPropertyNames(t).map(a => LP(a, t[a], e)).filter(a => a !== hs));
    const s = i.length;
    if (!s) {
      return hs;
    }
    if (!i.some(a => !!a.requiresSiblings)) {
      if (s === 1) {
        return i[0];
      }
      const a = function (u, d) {
        let f;
        for (let p = 0, w = i.length; p < w; p++) {
          const m = i[p](u, d);
          if (typeof m == "string") {
            return m;
          }
          if (Ip(m)) {
            f ||= [];
            f.push(m);
          }
        }
        if (f) {
          return (async () => {
            for (const p of f) {
              const w = await p;
              if (typeof w == "string") {
                return w;
              }
            }
            return null;
          })();
        } else {
          return null;
        }
      };
      const c = i.find(u => !!u.allBasenames);
      if (c) {
        a.allBasenames = c.allBasenames;
      }
      const l = i.reduce((u, d) => d.allPaths ? u.concat(d.allPaths) : u, []);
      if (l.length) {
        a.allPaths = l;
      }
      return a;
    }
    const r = function (a, c, l) {
      let u;
      let d;
      for (let f = 0, p = i.length; f < p; f++) {
        const w = i[f];
        if (w.requiresSiblings && l) {
          c ||= Ue(a);
          u ||= c.substr(0, c.length - Kl(a).length);
        }
        const m = w(a, c, u, l);
        if (typeof m == "string") {
          return m;
        }
        if (Ip(m)) {
          d ||= [];
          d.push(m);
        }
      }
      if (d) {
        return (async () => {
          for (const f of d) {
            const p = await f;
            if (typeof p == "string") {
              return p;
            }
          }
          return null;
        })();
      } else {
        return null;
      }
    };
    const n = i.find(a => !!a.allBasenames);
    if (n) {
      r.allBasenames = n.allBasenames;
    }
    const o = i.reduce((a, c) => c.allPaths ? a.concat(c.allPaths) : a, []);
    if (o.length) {
      r.allPaths = o;
    }
    return r;
  }
  function LP(t, e, i) {
    if (e === false) {
      return hs;
    }
    const s = pg(t, i);
    if (s === hs) {
      return hs;
    }
    if (typeof e == "boolean") {
      return s;
    }
    if (e) {
      const r = e.when;
      if (typeof r == "string") {
        const n = (o, a, c, l) => {
          if (!l || !s(o, a)) {
            return null;
          }
          const u = r.replace("$(basename)", () => c);
          const d = l(u);
          if (Ip(d)) {
            return d.then(f => f ? t : null);
          } else if (d) {
            return t;
          } else {
            return null;
          }
        };
        n.requiresSiblings = true;
        return n;
      }
    }
    return s;
  }
  function W5(t, e) {
    const i = t.filter(a => !!a.basenames);
    if (i.length < 2) {
      return t;
    }
    const s = i.reduce((a, c) => {
      const l = c.basenames;
      if (l) {
        return a.concat(l);
      } else {
        return a;
      }
    }, []);
    let r;
    if (e) {
      r = [];
      for (let a = 0, c = s.length; a < c; a++) {
        r.push(e);
      }
    } else {
      r = i.reduce((a, c) => {
        const l = c.patterns;
        if (l) {
          return a.concat(l);
        } else {
          return a;
        }
      }, []);
    }
    const n = function (a, c) {
      if (typeof a != "string") {
        return null;
      }
      if (!c) {
        let u;
        for (u = a.length; u > 0; u--) {
          const d = a.charCodeAt(u - 1);
          if (d === 47 || d === 92) {
            break;
          }
        }
        c = a.substr(u);
      }
      const l = s.indexOf(c);
      if (l !== -1) {
        return r[l];
      } else {
        return null;
      }
    };
    n.basenames = s;
    n.patterns = r;
    n.allBasenames = s;
    const o = t.filter(a => !a.basenames);
    o.push(n);
    return o;
  }
  function T5(t, e) {
    return xa(t, e, (i, s) => typeof i == "string" && typeof s == "string" ? i === s : typeof i != "string" && typeof s != "string" ? i.base === s.base && i.pattern === s.pattern : false);
  }
  var Mo;
  var mg;
  var Ic;
  var Ac;
  var j5;
  var U5;
  var B5;
  var q5;
  var z5;
  var H5;
  var V5;
  var wg;
  var vg;
  var hs;
  var G5 = g({
    "out-build/vs/base/common/glob.js"() {
      "use strict";
  
      zt();
      ce();
      gi();
      $i();
      we();
      H();
      Wt();
      Mo = "**";
      mg = "/";
      Ic = "[/\\\\]";
      Ac = "[^/\\\\]";
      j5 = /\//g;
      U5 = /^\*\*\/\*\.[\w\.-]+$/;
      B5 = /^\*\*\/([\w\.-]+)\/?$/;
      q5 = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/;
      z5 = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/;
      H5 = /^\*\*((\/[\w\.-]+)+)\/?$/;
      V5 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/;
      wg = new Da(10000);
      vg = function () {
        return false;
      };
      hs = function () {
        return null;
      };
    }
  });
  function J5(t) {
    return typeof t.correlationId == "number";
  }
  function MP(t) {
    return t.recursive === true;
  }
  function K5(t) {
    return t.map(e => ({
      type: e.type,
      resource: P.revive(e.resource),
      cId: e.cId
    }));
  }
  function FP(t) {
    const e = new Q5();
    for (const i of t) {
      e.processEvent(i);
    }
    return e.coalesce();
  }
  function NP(t, e) {
    if (typeof e == "string" && !e.startsWith(Mo) && !Zr(e)) {
      return {
        base: t,
        pattern: e
      };
    } else {
      return e;
    }
  }
  function Z5(t, e) {
    const i = [];
    for (const s of e) {
      i.push(_P(NP(t, s)));
    }
    return i;
  }
  function WP(t, e) {
    if (typeof e == "number") {
      switch (t.type) {
        case 1:
          return (e & 4) === 0;
        case 2:
          return (e & 8) === 0;
        case 0:
          return (e & 2) === 0;
      }
    }
    return false;
  }
  function TP(t) {
    if (typeof t == "number") {
      const e = [];
      if (t & 4) {
        e.push("Added");
      }
      if (t & 8) {
        e.push("Deleted");
      }
      if (t & 2) {
        e.push("Updated");
      }
      if (e.length === 0) {
        return "<all>";
      } else {
        return `[${e.join(", ")}]`;
      }
    }
    return "<none>";
  }
  var bg;
  var Y5;
  var X5;
  var Q5;
  var Fo = g({
    "out-build/vs/platform/files/common/watcher.js"() {
      "use strict";
  
      G5();
      M();
      we();
      H();
      se();
      He();
      bg = class aS extends T {
        static {
          this.a = 5;
        }
        constructor(e, i, s, r) {
          super();
          this.h = e;
          this.j = i;
          this.m = s;
          this.n = r;
          this.c = this.D(new pr());
          this.f = undefined;
          this.g = 0;
        }
        r() {
          const e = new De();
          this.c.value = e;
          this.b = this.q(e);
          this.b.setVerboseLogging(this.m);
          e.add(this.b.onDidChangeFile(i => this.h(i)));
          e.add(this.b.onDidLogMessage(i => this.j(i)));
          e.add(this.b.onDidError(i => this.s(i.error, i.request)));
        }
        s(e, i) {
          if (this.t(e, i)) {
            if (this.g < aS.a && this.f) {
              this.w(`restarting watcher after unexpected error: ${e}`);
              this.u(this.f);
            } else {
              this.w(`gave up attempting to restart watcher after unexpected error: ${e}`);
            }
          } else {
            this.w(e);
          }
        }
        t(e, i) {
          return !!this.n.restartOnError && !i && e.indexOf("No space left on device") === -1 && e.indexOf("EMFILE") === -1;
        }
        u(e) {
          this.g++;
          this.r();
          this.watch(e);
        }
        async watch(e) {
          this.f = e;
          await this.b?.watch(e);
        }
        async setVerboseLogging(e) {
          this.m = e;
          await this.b?.setVerboseLogging(e);
        }
        w(e) {
          this.j({
            type: "error",
            message: `[File Watcher (${this.n.type})] ${e}`
          });
        }
        y(e) {
          this.j({
            type: "trace",
            message: `[File Watcher (${this.n.type})] ${e}`
          });
        }
        dispose() {
          this.b = undefined;
          return super.dispose();
        }
      };
      Y5 = class extends bg {
        constructor(t, e, i) {
          super(t, e, i, {
            type: "node.js",
            restartOnError: false
          });
        }
      };
      X5 = class extends bg {
        constructor(t, e, i) {
          super(t, e, i, {
            type: "universal",
            restartOnError: true
          });
        }
      };
      Q5 = class {
        constructor() {
          this.a = new Set();
          this.b = new Map();
        }
        c(t) {
          if (Se) {
            return t.resource.fsPath;
          } else {
            return t.resource.fsPath.toLowerCase();
          }
        }
        processEvent(t) {
          const e = this.b.get(this.c(t));
          let i = false;
          if (e) {
            const s = e.type;
            const r = t.type;
            if (e.resource.fsPath !== t.resource.fsPath && (t.type === 2 || t.type === 1)) {
              i = true;
            } else if (s === 1 && r === 2) {
              this.b.delete(this.c(t));
              this.a.delete(e);
            } else if (s === 2 && r === 1) {
              e.type = 0;
            } else if (s !== 1 || r !== 0) {
              e.type = r;
            }
          } else {
            i = true;
          }
          if (i) {
            this.a.add(t);
            this.b.set(this.c(t), t);
          }
        }
        coalesce() {
          const t = [];
          const e = [];
          return Array.from(this.a).filter(i => i.type !== 2 ? (t.push(i), false) : true).sort((i, s) => i.resource.fsPath.length - s.resource.fsPath.length).filter(i => e.some(s => Ox(i.resource.fsPath, s, !Se)) ? false : (e.push(i.resource.fsPath), true)).concat(t);
        }
      };
    }
  });
  var yg;
  var jP = g({
    "out-build/vs/platform/files/common/diskFileSystemProviderClient.js"() {
      "use strict";
  
      Ze();
      en();
      $e();
      B();
      M();
      Ka();
      _i();
      He();
      Fo();
      yg = "localFilesystem";
    }
  });
  async function e2(t, e, i, s, r, n) {
    let o;
    try {
      await UP(t, e, i, s, r, n);
    } catch (a) {
      o = a;
    } finally {
      if (o && r.errorTransformer) {
        o = r.errorTransformer(o);
      }
      if (typeof o !== "undefined") {
        i.error(o);
      }
      i.end();
    }
  }
  async function UP(t, e, i, s, r, n) {
    Sg(n);
    const o = await t.open(e, {
      create: false
    });
    try {
      Sg(n);
      let a = 0;
      let c = 0;
      let l = r && typeof r.length == "number" ? r.length : undefined;
      let u = z.alloc(Math.min(r.bufferSize, typeof l == "number" ? l : r.bufferSize));
      let d = r && typeof r.position == "number" ? r.position : 0;
      let f = 0;
      do {
        c = await t.read(o, d, u.buffer, f, u.byteLength - f);
        d += c;
        f += c;
        a += c;
        if (typeof l == "number") {
          l -= c;
        }
        if (f === u.byteLength) {
          await i.write(s(u));
          u = z.alloc(Math.min(r.bufferSize, typeof l == "number" ? l : r.bufferSize));
          f = 0;
        }
      } while (c > 0 && (typeof l != "number" || l > 0) && Sg(n) && BP(a, r));
      if (f > 0) {
        let p = f;
        if (typeof l == "number") {
          p = Math.min(f, l);
        }
        i.write(s(u.slice(0, p)));
      }
    } catch (a) {
      throw on(a);
    } finally {
      await t.close(o);
    }
  }
  function Sg(t) {
    if (t.isCancellationRequested) {
      throw Jn();
    }
    return true;
  }
  function BP(t, e) {
    if (typeof e?.limits?.size == "number" && t > e.limits.size) {
      throw cs(v(1947, null), oe.FileTooLarge);
    }
    return true;
  }
  var t2 = g({
    "out-build/vs/platform/files/common/io.js"() {
      "use strict";
  
      Ze();
      $e();
      be();
      He();
    }
  });
  var i2;
  var qP = g({
    "out-build/vs/platform/files/common/diskFileSystemProvider.js"() {
      "use strict";
  
      zt();
      ce();
      $e();
      B();
      gi();
      M();
      we();
      Fo();
      X();
      i2 = class extends T {
        constructor(t, e) {
          super();
          this.a = t;
          this.b = e;
          this.c = this.D(new $());
          this.onDidChangeFile = this.c.event;
          this.g = this.D(new $());
          this.onDidWatchError = this.g.event;
          this.j = [];
          this.m = this.D(new Ys(0));
          this.w = [];
          this.y = this.D(new Ys(0));
        }
        watch(t, e) {
          if (e.recursive || this.b?.watcher?.forceUniversal) {
            return this.n(t, e);
          } else {
            return this.z(t, e);
          }
        }
        n(t, e) {
          const i = this.q(t, e);
          const s = dw(this.j, i);
          this.r();
          return xe(() => {
            s();
            this.r();
          });
        }
        q(t, e) {
          const i = {
            path: this.L(t),
            excludes: e.excludes,
            includes: e.includes,
            recursive: e.recursive,
            filter: e.filter,
            correlationId: e.correlationId
          };
          if (MP(i)) {
            const s = this.b?.watcher?.recursive?.usePolling;
            if (s === true) {
              i.pollingInterval = this.b?.watcher?.recursive?.pollingInterval ?? 5000;
            } else if (Array.isArray(s) && s.includes(i.path)) {
              i.pollingInterval = this.b?.watcher?.recursive?.pollingInterval ?? 5000;
            }
          }
          return i;
        }
        r() {
          this.m.trigger(() => this.s()).catch(t => Ft(t));
        }
        s() {
          if (!this.h) {
            this.h = this.D(this.t(t => this.c.fire(K5(t)), t => this.H(t), this.a.getLevel() === J.Trace));
            this.D(this.a.onDidChangeLogLevel(() => {
              this.h?.setVerboseLogging(this.a.getLevel() === J.Trace);
            }));
          }
          return this.h.watch(this.j);
        }
        z(t, e) {
          const i = {
            path: this.L(t),
            excludes: e.excludes,
            includes: e.includes,
            recursive: false,
            filter: e.filter,
            correlationId: e.correlationId
          };
          const s = dw(this.w, i);
          this.C();
          return xe(() => {
            s();
            this.C();
          });
        }
        C() {
          this.y.trigger(() => this.F()).catch(t => Ft(t));
        }
        F() {
          if (!this.u) {
            this.u = this.D(this.G(t => this.c.fire(K5(t)), t => this.H(t), this.a.getLevel() === J.Trace));
            this.D(this.a.onDidChangeLogLevel(() => {
              this.u?.setVerboseLogging(this.a.getLevel() === J.Trace);
            }));
          }
          return this.u.watch(this.w);
        }
        H(t) {
          if (t.type === "error") {
            this.g.fire(t.message);
          }
          this.I(t);
        }
        I(t) {
          this.a[t.type](t.message);
        }
        J(t) {
          return pi(t.fsPath);
        }
        L(t) {
          const e = this.J(t);
          return kv(e);
        }
      };
    }
  });
  function zP(t) {
    const e = t;
    return e && typeof e.type == "string" && typeof e.severity == "string";
  }
  function HP(t) {
    const e = [];
    let i;
    try {
      const s = JSON.parse(t.arguments);
      const r = s[s.length - 1];
      if (r && r.__$stack) {
        s.pop();
        i = r.__$stack;
      }
      e.push(...s);
    } catch {
      e.push("Unable to log remote console arguments", t.arguments);
    }
    return {
      args: e,
      stack: i
    };
  }
  function VP(t) {
    if (!t) {
      return t;
    }
    const e = t.indexOf(`
  `);
    if (e === -1) {
      return t;
    } else {
      return t.substring(0, e);
    }
  }
  function GP(t, e) {
    const {
      args: i,
      stack: s
    } = HP(t);
    const r = typeof i[0] == "string" && i.length === 1;
    let n = VP(s);
    n &&= `(${n.trim()})`;
    let o = [];
    if (typeof i[0] == "string") {
      if (n && r) {
        o = [`%c[${e}] %c${i[0]} %c${n}`, No("blue"), No(""), No("grey")];
      } else {
        o = [`%c[${e}] %c${i[0]}`, No("blue"), No(""), ...i.slice(1)];
      }
    } else {
      o = [`%c[${e}]%`, No("blue"), ...i];
    }
    if (n && !r) {
      o.push(n);
    }
    if (typeof console[t.severity] != "function") {
      throw new Error("Unknown console method");
    }
    console[t.severity].apply(console, o);
  }
  function No(t) {
    return `color: ${t}`;
  }
  var JP = g({
    "out-build/vs/base/common/console.js"() {
      "use strict";
  
      se();
    }
  });
  import { fork as KP } from "child_process";
  var s2;
  var ZP = g({
    "out-build/vs/base/parts/ipc/node/ipc.cp.js"() {
      "use strict";
  
      ce();
      Ze();
      At();
      JP();
      $e();
      B();
      M();
      us();
      og();
      wh();
      xs();
      s2 = class {
        constructor(t, e) {
          this.i = t;
          this.j = e;
          this.c = new Set();
          this.g = new Map();
          this.h = new $();
          this.onDidProcessExit = this.h.event;
          const i = e && e.timeout ? e.timeout : 60000;
          this.b = new su(i);
          this.d = null;
          this.f = null;
        }
        getChannel(t) {
          const e = this;
          return {
            call(i, s, r) {
              return e.k(t, i, s, r);
            },
            listen(i, s) {
              return e.l(t, i, s);
            }
          };
        }
        k(t, e, i, s = We.None) {
          if (!this.b) {
            return Promise.reject(new Error("disposed"));
          }
          if (s.isCancellationRequested) {
            return Promise.reject(Jn());
          }
          this.b.cancel();
          const r = this.n(t);
          const n = Qn(c => r.call(e, i, c));
          const o = s.onCancellationRequested(() => n.cancel());
          const a = xe(() => n.cancel());
          this.c.add(a);
          n.finally(() => {
            o.dispose();
            this.c.delete(a);
            if (this.c.size === 0 && this.b) {
              this.b.trigger(() => this.o());
            }
          });
          return n;
        }
        l(t, e, i) {
          if (!this.b) {
            return x.None;
          }
          this.b.cancel();
          let s;
          const r = new $({
            onWillAddFirstListener: () => {
              s = this.n(t).listen(e, i)(r.fire, r);
              this.c.add(s);
            },
            onDidRemoveLastListener: () => {
              this.c.delete(s);
              s.dispose();
              if (this.c.size === 0 && this.b) {
                this.b.trigger(() => this.o());
              }
            }
          });
          return r.event;
        }
        get m() {
          if (!this.f) {
            const t = this.j && this.j.args ? this.j.args : [];
            const e = Object.create(null);
            e.env = {
              ...ls(process.env),
              VSCODE_PARENT_PID: String(process.pid)
            };
            if (this.j && this.j.env) {
              e.env = {
                ...e.env,
                ...this.j.env
              };
            }
            if (this.j && this.j.freshExecArgv) {
              e.execArgv = [];
            }
            if (this.j && typeof this.j.debug == "number") {
              e.execArgv = ["--nolazy", "--inspect=" + this.j.debug];
            }
            if (this.j && typeof this.j.debugBrk == "number") {
              e.execArgv = ["--nolazy", "--inspect-brk=" + this.j.debugBrk];
            }
            if (e.execArgv === undefined) {
              e.execArgv = process.execArgv.filter(u => !/^--inspect(-brk)?=/.test(u)).filter(u => !u.startsWith("--vscode-"));
            }
            p5(e.env);
            this.d = KP(this.i, t, e);
            const i = new $();
            const r = x.fromNodeEventEmitter(this.d, "message", u => u)(u => {
              if (zP(u)) {
                GP(u, `IPC Library: ${this.j.serverName}`);
                return;
              }
              i.fire(z.wrap(Buffer.from(u, "base64")));
            });
            const n = this.j.useQueue ? dP(this.d) : this.d;
            const o = u => this.d && this.d.connected && n.send(u.buffer.toString("base64"));
            const a = i.event;
            const c = {
              send: o,
              onMessage: a
            };
            this.f = new Xa(c);
            const l = () => this.o();
            process.once("exit", l);
            this.d.on("error", u => console.warn("IPC \"" + this.j.serverName + "\" errored with " + u));
            this.d.on("exit", (u, d) => {
              process.removeListener("exit", l);
              r.dispose();
              this.c.forEach(f => Et(f));
              this.c.clear();
              if (u !== 0 && d !== "SIGTERM") {
                console.warn("IPC \"" + this.j.serverName + "\" crashed with exit code " + u + " and signal " + d);
              }
              this.b?.cancel();
              this.o();
              this.h.fire({
                code: u,
                signal: d
              });
            });
          }
          return this.f;
        }
        n(t) {
          let e = this.g.get(t);
          if (!e) {
            e = this.m.getChannel(t);
            this.g.set(t, e);
          }
          return e;
        }
        o() {
          if (this.f) {
            if (this.d) {
              this.d.kill();
              this.d = null;
            }
            this.f = null;
            this.g.clear();
          }
        }
        dispose() {
          this.h.dispose();
          this.b?.cancel();
          this.b = undefined;
          this.o();
          this.c.clear();
        }
      };
    }
  });
  var r2;
  var YP = g({
    "out-build/vs/platform/files/node/watcher/watcherClient.js"() {
      "use strict";
  
      Ie();
      xs();
      ZP();
      Fo();
      r2 = class extends X5 {
        constructor(t, e, i) {
          super(t, e, i);
          this.r();
        }
        q(t) {
          const e = t.add(new s2(Ct.asFileUri("bootstrap-fork").fsPath, {
            serverName: "File Watcher",
            args: ["--type=fileWatcher"],
            env: {
              VSCODE_ESM_ENTRYPOINT: "vs/platform/files/node/watcher/watcherMain",
              VSCODE_PIPE_LOGGING: "true",
              VSCODE_VERBOSE_LOGGING: "true"
            }
          }));
          t.add(e.onDidProcessExit(({
            code: i,
            signal: s
          }) => this.s(`terminated by itself with code ${i}, signal: ${s} (ETERM)`)));
          return ze.toService(Hk(e.getChannel("watcher")));
        }
      };
    }
  });
  import { watchFile as XP, unwatchFile as QP } from "fs";
  var n2;
  var e$ = g({
    "out-build/vs/platform/files/node/watcher/baseWatcher.js"() {
      "use strict";
  
      M();
      Fo();
      B();
      se();
      ce();
      er();
      $e();
      n2 = class extends T {
        constructor() {
          super();
          this.a = this.D(new $());
          this.onDidChangeFile = this.a.event;
          this.b = this.D(new $());
          this.onDidLogMessage = this.b.event;
          this.c = this.D(new $());
          this.f = this.c.event;
          this.g = new Map();
          this.h = new Map();
          this.j = this.D(new Xf());
          this.m = new Set();
          this.n = this.D(new Ys(this.w()));
          this.q = 5007;
          this.r = new Xs();
          this.R = false;
          this.D(this.f(t => this.y({
            id: this.t(t),
            correlationId: this.s(t) ? t.correlationId : undefined,
            path: t.path
          })));
        }
        s(t) {
          return J5(t);
        }
        t(t) {
          if (this.s(t)) {
            return t.correlationId;
          } else {
            return Ds(t);
          }
        }
        async watch(t) {
          if (!this.r.isSettled) {
            this.r.complete();
          }
          this.r = new Xs();
          try {
            this.g.clear();
            this.h.clear();
            for (const e of t) {
              if (this.s(e)) {
                this.g.set(e.correlationId, e);
              } else {
                this.h.set(this.t(e), e);
              }
            }
            for (const [e] of this.j) {
              if (!this.h.has(e) && !this.g.has(e)) {
                this.j.deleteAndDispose(e);
                this.m.delete(e);
              }
            }
            return await this.u(false);
          } finally {
            this.r.complete();
          }
        }
        u(t) {
          const e = [];
          for (const [i, s] of [...this.h, ...this.g]) {
            if (!this.j.has(i)) {
              e.push(s);
            }
          }
          return this.n.trigger(() => this.N(e), t ? this.w() : 0).catch(i => Ft(i));
        }
        w() {
          return 800;
        }
        isSuspended(t) {
          const e = this.t(t);
          if (this.m.has(e)) {
            return "polling";
          } else {
            return this.j.has(e);
          }
        }
        async y(t) {
          if (this.j.has(t.id)) {
            return;
          }
          const e = new De();
          this.j.set(t.id, e);
          await this.r.p;
          if (!e.isDisposed) {
            this.C(t, e);
            this.u(true);
          }
        }
        z(t) {
          this.j.deleteAndDispose(t.id);
          this.m.delete(t.id);
          this.u(false);
        }
        C(t, e) {
          if (this.F(t, e)) {
            this.P(`reusing an existing recursive watcher to monitor ${t.path}`);
            this.m.delete(t.id);
          } else {
            this.G(t, e);
            this.m.add(t.id);
          }
        }
        F(t, e) {
          const i = this.O?.subscribe(t.path, (s, r) => {
            if (!e.isDisposed) {
              if (s) {
                this.C(t, e);
              } else if (r?.type === 1) {
                this.H(t);
              }
            }
          });
          if (i) {
            e.add(i);
            return true;
          } else {
            return false;
          }
        }
        G(t, e) {
          let i = false;
          const s = (r, n) => {
            if (e.isDisposed) {
              return;
            }
            const o = this.I(r);
            const a = this.I(n);
            const c = i;
            i = o;
            if (!o && (a || c)) {
              this.H(t);
            }
          };
          this.P(`starting fs.watchFile() on ${t.path} (correlationId: ${t.correlationId})`);
          try {
            XP(t.path, {
              persistent: false,
              interval: this.q
            }, s);
          } catch (r) {
            this.Q(`fs.watchFile() failed with error ${r} on path ${t.path} (correlationId: ${t.correlationId})`);
          }
          e.add(xe(() => {
            this.P(`stopping fs.watchFile() on ${t.path} (correlationId: ${t.correlationId})`);
            try {
              QP(t.path, s);
            } catch (r) {
              this.Q(`fs.unwatchFile() failed with error ${r} on path ${t.path} (correlationId: ${t.correlationId})`);
            }
          }));
        }
        H(t) {
          this.P(`detected ${t.path} exists again, resuming watcher (correlationId: ${t.correlationId})`);
          const e = {
            resource: P.file(t.path),
            type: 1,
            cId: t.correlationId
          };
          this.a.fire([e]);
          this.J(e, t);
          this.z(t);
        }
        I(t) {
          return t.ctimeMs === 0 && t.ino === 0;
        }
        async stop() {
          this.j.clearAndDisposeAll();
          this.m.clear();
        }
        J(t, e) {
          if (this.R) {
            const i = ` >> normalized ${t.type === 1 ? "[ADDED]" : t.type === 2 ? "[DELETED]" : "[CHANGED]"} ${t.resource.fsPath}`;
            this.L(i, e);
          }
        }
        L(t, e) {
          if (this.R) {
            this.P(`${t}${typeof e.correlationId == "number" ? ` <${e.correlationId}> ` : ""}`);
          }
        }
        M(t) {
          return `${t.path} (excludes: ${t.excludes.length > 0 ? t.excludes : "<none>"}, includes: ${t.includes && t.includes.length > 0 ? JSON.stringify(t.includes) : "<all>"}, filter: ${TP(t.filter)}, correlationId: ${typeof t.correlationId == "number" ? t.correlationId : "<none>"})`;
        }
        async setVerboseLogging(t) {
          this.R = t;
        }
      };
    }
  });
  import * as o2 from "fs";
  async function Eg(t, e) {
    if (Se) {
      return t;
    }
    const i = Xe(t);
    if (t === i) {
      return t;
    }
    const s = (Ue(t) || t).toLowerCase();
    try {
      if (e?.isCancellationRequested) {
        return null;
      }
      const n = (await ee.readdir(i)).filter(o => o.toLowerCase() === s);
      if (n.length === 1) {
        const o = await Eg(i, e);
        if (o) {
          return F(o, n[0]);
        }
      } else if (n.length > 1) {
        const o = n.indexOf(s);
        if (o >= 0) {
          const a = await Eg(i, e);
          if (a) {
            return F(a, n[o]);
          }
        }
      }
    } catch {}
    return null;
  }
  async function a2(t) {
    try {
      return await ee.realpath(t);
    } catch {
      const i = t$(t);
      await o2.promises.access(i, o2.constants.R_OK);
      return i;
    }
  }
  function t$(t) {
    return Qr(pi(t), Vt);
  }
  var c2 = g({
    "out-build/vs/base/node/extpath.js"() {
      "use strict";
  
      we();
      H();
      Wt();
      _t();
    }
  });
  import { watch as i$, promises as s$ } from "fs";
  var l2;
  var r$ = g({
    "out-build/vs/platform/files/node/watcher/nodejs/nodejsWatcherLib.js"() {
      "use strict";
  
      ce();
      At();
      gi();
      M();
      ou();
      we();
      H();
      nt();
      se();
      c2();
      _t();
      Fo();
      l2 = class If extends T {
        static {
          this.a = 100;
        }
        static {
          this.b = 75;
        }
        get isReusingRecursiveWatcher() {
          return this.n;
        }
        get failed() {
          return this.q;
        }
        constructor(e, i, s, r, n, o) {
          super();
          this.r = e;
          this.s = i;
          this.t = s;
          this.u = r;
          this.w = n;
          this.y = o;
          this.c = this.D(new _p({
            maxWorkChunkSize: 100,
            throttleDelay: 200,
            maxBufferedWork: 10000
          }, a => this.t(a)));
          this.f = this.D(new zv(a => this.M(a), If.b));
          this.g = Z5(this.r.path, this.r.excludes);
          this.h = this.r.includes ? Z5(this.r.path, this.r.includes) : undefined;
          this.j = J5(this.r) ? this.r.filter : undefined;
          this.m = new ns();
          this.ready = this.z();
          this.n = false;
          this.q = false;
        }
        async z() {
          try {
            const e = await this.F(this.r);
            if (this.m.token.isCancellationRequested) {
              return;
            }
            const i = await s$.stat(e);
            if (this.m.token.isCancellationRequested) {
              return;
            }
            this.D(await this.G(e, i.isDirectory()));
          } catch (e) {
            if (e.code !== "ENOENT") {
              this.O(e);
            } else {
              this.Q(`ignoring a path for watching who's stat info failed to resolve: ${this.r.path} (error: ${e})`);
            }
            this.C();
          }
        }
        C() {
          this.q = true;
          this.u?.();
        }
        async F(e) {
          let i = e.path;
          try {
            i = await ee.realpath(e.path);
            if (e.path === i) {
              i = (await Eg(e.path, this.m.token)) ?? e.path;
            }
            if (e.path !== i) {
              this.Q(`correcting a path to watch that seems to be a symbolic link or wrong casing (original: ${e.path}, real: ${i})`);
            }
          } catch {}
          return i;
        }
        async G(e, i) {
          const s = new De();
          if (this.H(e, i, s)) {
            this.Q(`reusing an existing recursive watcher for ${this.r.path}`);
            this.n = true;
          } else {
            this.n = false;
            await this.I(e, i, s);
          }
          return s;
        }
        H(e, i, s) {
          if (i) {
            return false;
          }
          const r = P.file(this.r.path);
          const n = this.s?.subscribe(this.r.path, async (o, a) => {
            if (!s.isDisposed) {
              if (o) {
                const c = await this.G(e, i);
                if (s.isDisposed) {
                  c.dispose();
                } else {
                  s.add(c);
                }
              } else if (a && (typeof a.cId == "number" || typeof this.r.correlationId == "number")) {
                this.L({
                  resource: r,
                  type: a.type,
                  cId: this.r.correlationId
                }, true);
              }
            }
          });
          if (n) {
            s.add(n);
            return true;
          } else {
            return false;
          }
        }
        async I(e, i, s) {
          if (this.m.token.isCancellationRequested) {
            return;
          }
          if (N && Ba(e, "/Volumes/", true)) {
            this.O(`Refusing to watch ${e} for changes using fs.watch() for possibly being a network share where watching is unreliable and unstable.`);
            return;
          }
          const r = new ns(this.m.token);
          s.add(xe(() => r.dispose(true)));
          const n = new De();
          s.add(n);
          try {
            const o = P.file(this.r.path);
            const a = Ue(e);
            const c = i$(e);
            n.add(xe(() => {
              c.removeAllListeners();
              c.close();
            }));
            this.Q(`Started watching: '${e}'`);
            const l = new Set();
            if (i) {
              try {
                for (const d of await ee.readdir(e)) {
                  l.add(d);
                }
              } catch (d) {
                this.O(d);
              }
            }
            if (r.token.isCancellationRequested) {
              return;
            }
            const u = new Map();
            n.add(xe(() => {
              for (const [, d] of u) {
                d.dispose();
              }
              u.clear();
            }));
            c.on("error", (d, f) => {
              if (!r.token.isCancellationRequested) {
                this.O(`Failed to watch ${e} for changes using fs.watch() (${d}, ${f})`);
                this.C();
              }
            });
            c.on("change", (d, f) => {
              if (r.token.isCancellationRequested) {
                return;
              }
              if (this.y) {
                this.R(`[raw] ["${d}"] ${f}`);
              }
              let p = "";
              if (f) {
                p = f.toString();
                if (N) {
                  p = io(p);
                }
              }
              if (!!p && (d === "change" || d === "rename")) {
                if (i) {
                  if (d === "rename") {
                    u.get(p)?.dispose();
                    const w = setTimeout(async () => {
                      u.delete(p);
                      if (p === a && !(await ee.exists(e))) {
                        this.J(o);
                        return;
                      }
                      if (r.token.isCancellationRequested) {
                        return;
                      }
                      const m = await this.N(F(e, p));
                      if (r.token.isCancellationRequested) {
                        return;
                      }
                      let y;
                      if (m) {
                        if (l.has(p)) {
                          y = 0;
                        } else {
                          y = 1;
                          l.add(p);
                        }
                      } else {
                        l.delete(p);
                        y = 2;
                      }
                      this.L({
                        resource: he(o, p),
                        type: y,
                        cId: this.r.correlationId
                      });
                    }, If.a);
                    u.set(p, xe(() => clearTimeout(w)));
                  } else {
                    let w;
                    if (l.has(p)) {
                      w = 0;
                    } else {
                      w = 1;
                      l.add(p);
                    }
                    this.L({
                      resource: he(o, p),
                      type: w,
                      cId: this.r.correlationId
                    });
                  }
                } else if (d === "rename" || p !== a) {
                  const w = setTimeout(async () => {
                    const m = await ee.exists(e);
                    if (!r.token.isCancellationRequested) {
                      if (m) {
                        this.L({
                          resource: o,
                          type: 0,
                          cId: this.r.correlationId
                        }, true);
                        n.add(await this.G(e, false));
                      } else {
                        this.J(o);
                      }
                    }
                  }, If.a);
                  n.clear();
                  n.add(xe(() => clearTimeout(w)));
                } else {
                  this.L({
                    resource: o,
                    type: 0,
                    cId: this.r.correlationId
                  }, true);
                }
              }
            });
          } catch (o) {
            if (r.token.isCancellationRequested) {
              return;
            }
            this.O(`Failed to watch ${e} for changes using fs.watch() (${o.toString()})`);
            this.C();
          }
        }
        J(e) {
          this.P("Watcher shutdown because watched path got deleted");
          this.L({
            resource: e,
            type: 2,
            cId: this.r.correlationId
          }, true);
          this.f.flush();
          this.C();
        }
        L(e, i = false) {
          if (!this.m.token.isCancellationRequested) {
            if (this.y) {
              this.R(`${e.type === 1 ? "[ADDED]" : e.type === 2 ? "[DELETED]" : "[CHANGED]"} ${e.resource.fsPath}`);
            }
            if (!i && this.g.some(s => s(e.resource.fsPath))) {
              if (this.y) {
                this.R(` >> ignored (excluded) ${e.resource.fsPath}`);
              }
            } else if (!i && this.h && this.h.length > 0 && !this.h.some(s => s(e.resource.fsPath))) {
              if (this.y) {
                this.R(` >> ignored (not included) ${e.resource.fsPath}`);
              }
            } else {
              this.f.work(e);
            }
          }
        }
        M(e) {
          const i = FP(e);
          const s = [];
          for (const n of i) {
            if (WP(n, this.j)) {
              if (this.y) {
                this.R(` >> ignored (filtered) ${n.resource.fsPath}`);
              }
              continue;
            }
            s.push(n);
          }
          if (s.length === 0) {
            return;
          }
          if (this.y) {
            for (const n of s) {
              this.R(` >> normalized ${n.type === 1 ? "[ADDED]" : n.type === 2 ? "[DELETED]" : "[CHANGED]"} ${n.resource.fsPath}`);
            }
          }
          if (this.c.work(s)) {
            if (this.c.pending > 0) {
              this.Q(`started throttling events due to large amount of file change events at once (pending: ${this.c.pending}, most recent change: ${s[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);
            }
          } else {
            this.P(`started ignoring events due to too many file change events at once (incoming: ${s.length}, most recent change: ${s[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);
          }
        }
        async N(e) {
          if (Se) {
            return ee.exists(e);
          }
          try {
            const i = Ue(e);
            return (await ee.readdir(Xe(e))).some(r => r === i);
          } catch (i) {
            this.Q(i);
            return false;
          }
        }
        setVerboseLogging(e) {
          this.y = e;
        }
        O(e) {
          if (!this.m.token.isCancellationRequested) {
            this.w?.({
              type: "error",
              message: `[File Watcher (node.js)] ${e}`
            });
          }
        }
        P(e) {
          if (!this.m.token.isCancellationRequested) {
            this.w?.({
              type: "warn",
              message: `[File Watcher (node.js)] ${e}`
            });
          }
        }
        Q(e) {
          if (!this.m.token.isCancellationRequested && this.y) {
            this.w?.({
              type: "trace",
              message: `[File Watcher (node.js)] ${e}`
            });
          }
        }
        R(e) {
          if (!this.m.token.isCancellationRequested && this.y) {
            this.Q(`${e}${typeof this.r.correlationId == "number" ? ` <${this.r.correlationId}> ` : ""}`);
          }
        }
        dispose() {
          this.m.dispose(true);
          super.dispose();
        }
      };
    }
  });
  var u2;
  var n$ = g({
    "out-build/vs/platform/files/node/watcher/nodejs/nodejsWatcher.js"() {
      "use strict";
  
      B();
      G5();
      e$();
      H();
      r$();
      gi();
      ce();
      M();
      u2 = class extends n2 {
        constructor(t) {
          super();
          this.O = t;
          this.onDidError = x.None;
          this.watchers = new Set();
          this.S = this.D(new pr());
        }
        async N(t) {
          t = this.ab(t);
          const e = [];
          const i = new Set(Array.from(this.watchers));
          for (const s of t) {
            const r = this.Y(s);
            if (r && T5(r.request.excludes, s.excludes) && T5(r.request.includes, s.includes)) {
              i.delete(r);
            } else {
              e.push(s);
            }
          }
          if (e.length) {
            this.P(`Request to start watching: ${e.map(s => this.M(s)).join(",")}`);
          }
          if (i.size) {
            this.P(`Request to stop watching: ${Array.from(i).map(s => this.M(s.request)).join(",")}`);
          }
          this.S.clear();
          for (const s of i) {
            this.$(s);
          }
          this.X().work(e);
        }
        X() {
          this.S.value = new _p({
            maxWorkChunkSize: 100,
            throttleDelay: 100,
            maxBufferedWork: Number.MAX_VALUE
          }, t => {
            for (const e of t) {
              this.Z(e);
            }
          });
          return this.S.value;
        }
        Y(t) {
          for (const e of this.watchers) {
            if (typeof t.correlationId == "number" || typeof e.request.correlationId == "number") {
              if (e.request.correlationId === t.correlationId) {
                return e;
              }
            } else if (tu(e.request.path, t.path, !Se)) {
              return e;
            }
          }
        }
        Z(t) {
          const e = new l2(t, this.O, s => this.a.fire(s), () => this.c.fire(t), s => this.b.fire(s), this.R);
          const i = {
            request: t,
            instance: e
          };
          this.watchers.add(i);
        }
        async stop() {
          await super.stop();
          for (const t of this.watchers) {
            this.$(t);
          }
        }
        $(t) {
          this.P("stopping file watcher", t);
          this.watchers.delete(t);
          t.instance.dispose();
        }
        ab(t) {
          const e = new Map();
          for (const i of t) {
            const s = Se ? i.path : i.path.toLowerCase();
            let r = e.get(i.correlationId);
            if (!r) {
              r = new Map();
              e.set(i.correlationId, r);
            }
            if (r.has(s)) {
              this.P(`ignoring a request for watching who's path is already watched: ${this.M(i)}`);
            }
            r.set(s, i);
          }
          return Array.from(e.values()).map(i => Array.from(i.values())).flat();
        }
        async setVerboseLogging(t) {
          super.setVerboseLogging(t);
          for (const e of this.watchers) {
            e.instance.setVerboseLogging(t);
          }
        }
        P(t, e) {
          if (this.R) {
            this.b.fire({
              type: "trace",
              message: this.db(t, e)
            });
          }
        }
        Q(t) {
          this.b.fire({
            type: "warn",
            message: this.db(t)
          });
        }
        db(t, e) {
          if (e) {
            return `[File Watcher (node.js)] ${t} (${this.M(e.request)})`;
          } else {
            return `[File Watcher (node.js)] ${t}`;
          }
        }
      };
    }
  });
  var h2;
  var o$ = g({
    "out-build/vs/platform/files/node/watcher/nodejs/nodejsClient.js"() {
      "use strict";
  
      Fo();
      n$();
      h2 = class extends Y5 {
        constructor(t, e, i) {
          super(t, e, i);
          this.r();
        }
        q(t) {
          return t.add(new u2(undefined));
        }
      };
    }
  });
  import { promises as yn } from "fs";
  var Ih;
  var kg = g({
    "out-build/vs/platform/files/node/diskFileSystemProvider.js"() {
      "use strict";
  
      ce();
      $i();
      Ze();
      B();
      gi();
      M();
      we();
      H();
      nt();
      Ka();
      _t();
      be();
      He();
      t2();
      qP();
      YP();
      o$();
      Ih = class $l extends i2 {
        static {
          this.M = false;
        }
        constructor(e, i) {
          super(e, i);
          this.onDidChangeCapabilities = x.None;
          this.Q = new Ht(s => tt.getComparisonKey(s));
          this.Y = new Map();
          this.Z = new Map();
          this.$ = new Map();
        }
        get capabilities() {
          if (!this.N) {
            this.N = 253982;
            if (Se) {
              this.N |= 1024;
            }
          }
          return this.N;
        }
        async stat(e) {
          try {
            const {
              stat: i,
              symbolicLink: s
            } = await jt.stat(this.J(e));
            return {
              type: this.P(i, s),
              ctime: i.birthtime.getTime(),
              mtime: i.mtime.getTime(),
              size: i.size,
              permissions: i.mode & 128 ? undefined : wo.Locked
            };
          } catch (i) {
            throw this.ib(i);
          }
        }
        async O(e) {
          try {
            return await this.stat(e);
          } catch {
            return;
          }
        }
        async readdir(e) {
          try {
            const i = await ee.readdir(this.J(e), {
              withFileTypes: true
            });
            const s = [];
            await Promise.all(i.map(async r => {
              try {
                let n;
                if (r.isSymbolicLink()) {
                  n = (await this.stat(he(e, r.name))).type;
                } else {
                  n = this.P(r);
                }
                s.push([r.name, n]);
              } catch (n) {
                this.a.trace(n);
              }
            }));
            return s;
          } catch (i) {
            throw this.ib(i);
          }
        }
        P(e, i) {
          let s;
          if (i?.dangling) {
            s = Rt.Unknown;
          } else if (e.isFile()) {
            s = Rt.File;
          } else if (e.isDirectory()) {
            s = Rt.Directory;
          } else {
            s = Rt.Unknown;
          }
          if (i) {
            s |= Rt.SymbolicLink;
          }
          return s;
        }
        async R(e) {
          const i = this.J(e);
          this.S(`[Disk FileSystemProvider]: createResourceLock() - request to acquire resource lock (${i})`);
          let s;
          while (s = this.Q.get(e)) {
            this.S(`[Disk FileSystemProvider]: createResourceLock() - waiting for resource lock to be released (${i})`);
            await s.wait();
          }
          const r = new Ga();
          this.Q.set(e, r);
          this.S(`[Disk FileSystemProvider]: createResourceLock() - new resource lock created (${i})`);
          return xe(() => {
            this.S(`[Disk FileSystemProvider]: createResourceLock() - resource lock dispose() (${i})`);
            if (this.Q.get(e) === r) {
              this.S(`[Disk FileSystemProvider]: createResourceLock() - resource lock removed from resource-lock map (${i})`);
              this.Q.delete(e);
            }
            this.S(`[Disk FileSystemProvider]: createResourceLock() - resource lock barrier open() (${i})`);
            r.open();
          });
        }
        async readFile(e, i) {
          let s;
          try {
            if (i?.atomic) {
              this.S(`[Disk FileSystemProvider]: atomic read operation started (${this.J(e)})`);
              s = await this.R(e);
            }
            const r = this.J(e);
            return await yn.readFile(r);
          } catch (r) {
            throw this.ib(r);
          } finally {
            s?.dispose();
          }
        }
        S(e) {
          if ($l.M) {
            this.a.trace(e);
          }
        }
        readFileStream(e, i, s) {
          const r = lu(n => z.concat(n.map(o => z.wrap(o))).buffer);
          e2(this, e, r, n => n.buffer, {
            ...i,
            bufferSize: 262144
          }, s);
          return r;
        }
        async writeFile(e, i, s) {
          if (s?.atomic !== false && s?.atomic?.postfix && (await this.U(e))) {
            return this.W(e, he(Fv(e), `${ks(e)}${s.atomic.postfix}`), i, s);
          } else {
            return this.X(e, i, s);
          }
        }
        async U(e) {
          try {
            const i = this.J(e);
            const {
              symbolicLink: s
            } = await jt.stat(i);
            if (s) {
              return false;
            }
          } catch {}
          return true;
        }
        async W(e, i, s, r) {
          const n = new De();
          try {
            n.add(await this.R(e));
            n.add(await this.R(i));
            await this.X(i, s, r, true);
            try {
              await this.rename(i, e, {
                overwrite: true
              });
            } catch (o) {
              try {
                await this.delete(i, {
                  recursive: false,
                  useTrash: false,
                  atomic: false
                });
              } catch {}
              throw o;
            }
          } finally {
            n.dispose();
          }
        }
        async X(e, i, s, r) {
          let n;
          try {
            const o = this.J(e);
            if (!s.create || !s.overwrite) {
              if (await ee.exists(o)) {
                if (!s.overwrite) {
                  throw cs(v(1950, null), oe.FileExists);
                }
              } else if (!s.create) {
                throw cs(v(1951, null), oe.FileNotFound);
              }
            }
            n = await this.open(e, {
              create: true,
              unlock: s.unlock
            }, r);
            await this.write(n, 0, i, 0, i.byteLength);
          } catch (o) {
            throw await this.jb(e, o);
          } finally {
            if (typeof n == "number") {
              await this.close(n);
            }
          }
        }
        static {
          this.ab = true;
        }
        static configureFlushOnWrite(e) {
          $l.ab = e;
        }
        async open(e, i, s) {
          const r = this.J(e);
          let n;
          if (mo(i) && !s) {
            n = await this.R(e);
          }
          let o;
          try {
            if (mo(i) && i.unlock) {
              try {
                const {
                  stat: a
                } = await jt.stat(r);
                if (!(a.mode & 128)) {
                  await yn.chmod(r, a.mode | 128);
                }
              } catch (a) {
                if (a.code !== "ENOENT") {
                  this.a.trace(a);
                }
              }
            }
            if (j && mo(i)) {
              try {
                o = await ee.open(r, "r+");
                await ee.ftruncate(o, 0);
              } catch (a) {
                if (a.code !== "ENOENT") {
                  this.a.trace(a);
                }
                if (typeof o == "number") {
                  try {
                    await ee.close(o);
                  } catch (c) {
                    this.a.trace(c);
                  }
                  o = undefined;
                }
              }
            }
            if (typeof o != "number") {
              o = await ee.open(r, mo(i) ? "w" : "r");
            }
          } catch (a) {
            n?.dispose();
            throw mo(i) ? await this.jb(e, a) : this.ib(a);
          }
          this.Y.set(o, 0);
          if (mo(i)) {
            this.$.set(o, e);
          }
          if (n) {
            const a = this.Z.get(o);
            this.S(`[Disk FileSystemProvider]: open() - storing lock for handle ${o} (${r})`);
            this.Z.set(o, n);
            if (a) {
              this.S(`[Disk FileSystemProvider]: open() - disposing a previous lock that was still stored on same handle ${o} (${r})`);
              a.dispose();
            }
          }
          return o;
        }
        async close(e) {
          const i = this.Z.get(e);
          try {
            this.Y.delete(e);
            if (this.$.delete(e) && $l.ab) {
              try {
                await ee.fdatasync(e);
              } catch (s) {
                $l.configureFlushOnWrite(false);
                this.a.error(s);
              }
            }
            return await ee.close(e);
          } catch (s) {
            throw this.ib(s);
          } finally {
            if (i) {
              if (this.Z.get(e) === i) {
                this.S(`[Disk FileSystemProvider]: close() - resource lock removed from handle-lock map ${e}`);
                this.Z.delete(e);
              }
              this.S(`[Disk FileSystemProvider]: close() - disposing lock for handle ${e}`);
              i.dispose();
            }
          }
        }
        async read(e, i, s, r, n) {
          const o = this.bb(e, i);
          let a = null;
          try {
            a = (await ee.read(e, s, r, n, o)).bytesRead;
          } catch (c) {
            throw this.ib(c);
          } finally {
            this.cb(e, o, a);
          }
          return a;
        }
        bb(e, i) {
          if (i === this.Y.get(e)) {
            return null;
          } else {
            return i;
          }
        }
        cb(e, i, s) {
          const r = this.Y.get(e);
          if (typeof r == "number") {
            if (typeof i != "number") {
              if (typeof s == "number") {
                this.Y.set(e, r + s);
              } else {
                this.Y.delete(e);
              }
            }
          }
        }
        async write(e, i, s, r, n) {
          return rk(() => this.db(e, i, s, r, n), 100, 3);
        }
        async db(e, i, s, r, n) {
          const o = this.bb(e, i);
          let a = null;
          try {
            a = (await ee.write(e, s, r, n, o)).bytesWritten;
          } catch (c) {
            throw await this.jb(this.$.get(e), c);
          } finally {
            this.cb(e, o, a);
          }
          return a;
        }
        async mkdir(e) {
          try {
            await yn.mkdir(this.J(e));
          } catch (i) {
            throw this.ib(i);
          }
        }
        async delete(e, i) {
          try {
            const s = this.J(e);
            if (i.recursive) {
              let r;
              if (i?.atomic !== false && i.atomic.postfix) {
                r = F(Xe(s), `${Ue(s)}${i.atomic.postfix}`);
              }
              await ee.rm(s, tn.MOVE, r);
            } else {
              try {
                await yn.unlink(s);
              } catch (r) {
                if (r.code === "EPERM" || r.code === "EISDIR") {
                  let n = false;
                  try {
                    const {
                      stat: o,
                      symbolicLink: a
                    } = await jt.stat(s);
                    n = o.isDirectory() && !a;
                  } catch {}
                  if (n) {
                    await yn.rmdir(s);
                  } else {
                    throw r;
                  }
                } else {
                  throw r;
                }
              }
            }
          } catch (s) {
            throw this.ib(s);
          }
        }
        async rename(e, i, s) {
          const r = this.J(e);
          const n = this.J(i);
          if (r !== n) {
            try {
              await this.eb(e, i, "move", s.overwrite);
              await ee.rename(r, n);
            } catch (o) {
              if (o.code === "EINVAL" || o.code === "EBUSY" || o.code === "ENAMETOOLONG") {
                o = new Error(v(1952, null, Ue(r), Ue(Xe(n)), o.toString()));
              }
              throw this.ib(o);
            }
          }
        }
        async copy(e, i, s) {
          const r = this.J(e);
          const n = this.J(i);
          if (r !== n) {
            try {
              await this.eb(e, i, "copy", s.overwrite);
              await ee.copy(r, n, {
                preserveSymlinks: true
              });
            } catch (o) {
              if (o.code === "EINVAL" || o.code === "EBUSY" || o.code === "ENAMETOOLONG") {
                o = new Error(v(1953, null, Ue(r), Ue(Xe(n)), o.toString()));
              }
              throw this.ib(o);
            }
          }
        }
        async eb(e, i, s, r) {
          const n = this.J(e);
          const o = this.J(i);
          let a = false;
          if (!(this.capabilities & 1024)) {
            a = tu(n, o, true);
          }
          if (a) {
            if (s === "copy") {
              throw cs(v(1954, null), oe.FileExists);
            }
            if (s === "move") {
              return;
            }
          }
          const l = await this.O(e);
          if (!l) {
            throw cs(v(1955, null), oe.FileNotFound);
          }
          const u = await this.O(i);
          if (u) {
            if (!r) {
              throw cs(v(1956, null), oe.FileExists);
            }
            if (!(l.type & Rt.File) || !(u.type & Rt.File)) {
              await this.delete(i, {
                recursive: true,
                useTrash: false,
                atomic: false
              });
            }
          }
        }
        async cloneFile(e, i) {
          return this.fb(e, i, false);
        }
        async fb(e, i, s) {
          const r = this.J(e);
          const n = this.J(i);
          const o = !!(this.capabilities & 1024);
          if (tu(r, n, !o)) {
            return;
          }
          const a = new De();
          try {
            a.add(await this.R(e));
            a.add(await this.R(i));
            if (s) {
              await yn.mkdir(Xe(n), {
                recursive: true
              });
            }
            await yn.copyFile(r, n);
          } catch (c) {
            if (c.code === "ENOENT" && !s) {
              return this.fb(e, i, true);
            }
            throw this.ib(c);
          } finally {
            a.dispose();
          }
        }
        t(e, i, s) {
          return new r2(r => e(r), r => i(r), s);
        }
        G(e, i, s) {
          return new h2(r => e(r), r => i(r), s);
        }
        ib(e) {
          if (e instanceof Lu) {
            return e;
          }
          let i = e;
          let s;
          switch (e.code) {
            case "ENOENT":
              s = oe.FileNotFound;
              break;
            case "EISDIR":
              s = oe.FileIsADirectory;
              break;
            case "ENOTDIR":
              s = oe.FileNotADirectory;
              break;
            case "EEXIST":
              s = oe.FileExists;
              break;
            case "EPERM":
            case "EACCES":
              s = oe.NoPermissions;
              break;
            case "ERR_UNC_HOST_NOT_ALLOWED":
              i = `${e.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`;
              s = oe.Unknown;
              break;
            default:
              s = oe.Unknown;
          }
          return cs(i, s);
        }
        async jb(e, i) {
          let s = this.ib(i);
          if (e && s.code === oe.NoPermissions) {
            try {
              const {
                stat: r
              } = await jt.stat(this.J(e));
              if (!(r.mode & 128)) {
                s = cs(i, oe.FileWriteLocked);
              }
            } catch (r) {
              this.a.trace(r);
            }
          }
          return s;
        }
      };
    }
  });
  var d2;
  var f2;
  var a$ = g({
    "out-build/vs/platform/files/node/diskFileSystemProviderServer.js"() {
      "use strict";
  
      B();
      kg();
      M();
      Ze();
      Ka();
      At();
      d2 = class extends T {
        constructor(t, e) {
          super();
          this.a = t;
          this.b = e;
          this.F = new Map();
          this.G = new Map();
        }
        call(t, e, i) {
          const s = this.c(t);
          switch (e) {
            case "stat":
              return this.g(s, i[0]);
            case "readdir":
              return this.h(s, i[0]);
            case "open":
              return this.q(s, i[0], i[1]);
            case "close":
              return this.r(i[0]);
            case "read":
              return this.s(i[0], i[1], i[2]);
            case "readFile":
              return this.j(s, i[0], i[1]);
            case "write":
              return this.t(i[0], i[1], i[2], i[3], i[4]);
            case "writeFile":
              return this.n(s, i[0], i[1], i[2]);
            case "rename":
              return this.y(s, i[0], i[1], i[2]);
            case "copy":
              return this.z(s, i[0], i[1], i[2]);
            case "cloneFile":
              return this.C(s, i[0], i[1]);
            case "mkdir":
              return this.u(s, i[0]);
            case "delete":
              return this.w(s, i[0], i[1]);
            case "watch":
              return this.I(s, i[0], i[1], i[2], i[3]);
            case "unwatch":
              return this.J(i[0], i[1]);
          }
          throw new Error(`IPC Command ${e} not found`);
        }
        listen(t, e, i) {
          const s = this.c(t);
          switch (e) {
            case "fileChange":
              return this.H(s, i[0]);
            case "readFileStream":
              return this.m(s, i[0], i[1]);
          }
          throw new Error(`Unknown event ${e}`);
        }
        g(t, e) {
          const i = this.f(t, e, true);
          return this.a.stat(i);
        }
        h(t, e) {
          const i = this.f(t, e);
          return this.a.readdir(i);
        }
        async j(t, e, i) {
          const s = this.f(t, e, true);
          const r = await this.a.readFile(s, i);
          return z.wrap(r);
        }
        m(t, e, i) {
          const s = this.f(t, e, true);
          const r = new ns();
          const n = new $({
            onDidRemoveLastListener: () => {
              r.cancel();
            }
          });
          const o = this.a.readFileStream(s, i, r.token);
          uu(o, {
            onData: a => n.fire(z.wrap(a)),
            onError: a => n.fire(a),
            onEnd: () => {
              n.fire("end");
              n.dispose();
              r.dispose();
            }
          });
          return n.event;
        }
        n(t, e, i, s) {
          const r = this.f(t, e);
          return this.a.writeFile(r, i.buffer, s);
        }
        q(t, e, i) {
          const s = this.f(t, e, true);
          return this.a.open(s, i);
        }
        r(t) {
          return this.a.close(t);
        }
        async s(t, e, i) {
          const s = z.alloc(i);
          const n = await this.a.read(t, e, s.buffer, 0, i);
          return [s, n];
        }
        t(t, e, i, s, r) {
          return this.a.write(t, e, i.buffer, s, r);
        }
        u(t, e) {
          const i = this.f(t, e);
          return this.a.mkdir(i);
        }
        w(t, e, i) {
          const s = this.f(t, e);
          return this.a.delete(s, i);
        }
        y(t, e, i, s) {
          const r = this.f(t, e);
          const n = this.f(t, i);
          return this.a.rename(r, n, s);
        }
        z(t, e, i, s) {
          const r = this.f(t, e);
          const n = this.f(t, i);
          return this.a.copy(r, n, s);
        }
        C(t, e, i) {
          const s = this.f(t, e);
          const r = this.f(t, i);
          return this.a.cloneFile(s, r);
        }
        H(t, e) {
          const i = new $({
            onWillAddFirstListener: () => {
              this.F.set(e, this.L(t, i));
            },
            onDidRemoveLastListener: () => {
              Et(this.F.get(e));
              this.F.delete(e);
            }
          });
          return i.event;
        }
        async I(t, e, i, s, r) {
          const n = this.F.get(e);
          if (n) {
            const o = this.f(t, s);
            const a = n.watch(i, o, r);
            this.G.set(e + i, a);
          }
        }
        async J(t, e) {
          const i = t + e;
          const s = this.G.get(i);
          if (s) {
            Et(s);
            this.G.delete(i);
          }
        }
        dispose() {
          super.dispose();
          for (const [, t] of this.G) {
            t.dispose();
          }
          this.G.clear();
          for (const [, t] of this.F) {
            t.dispose();
          }
          this.F.clear();
        }
      };
      f2 = class extends T {
        constructor(t, e, i, s) {
          super();
          this.c = t;
          this.f = i;
          this.g = s;
          this.a = new Map();
          this.b = this.D(new Ih(this.f));
          this.h(e);
        }
        h(t) {
          const e = this.D(new $());
          this.D(e.event(i => {
            t.fire(i.map(s => ({
              resource: this.c.transformOutgoingURI(s.resource),
              type: s.type,
              cId: s.cId
            })));
          }));
          this.D(this.b.onDidChangeFile(i => e.fire(i)));
          this.D(this.b.onDidWatchError(i => t.fire(i)));
        }
        j(t) {}
        m(t) {}
        watch(t, e, i) {
          const s = this.m(this.g);
          if (Array.isArray(s)) {
            i.excludes = [...i.excludes, ...s];
          }
          this.a.set(t, this.b.watch(e, i));
          return xe(() => {
            Et(this.a.get(t));
            this.a.delete(t);
          });
        }
        dispose() {
          for (const [, t] of this.a) {
            t.dispose();
          }
          this.a.clear();
          super.dispose();
        }
      };
    }
  });
  var p2;
  var c$ = g({
    "out-build/vs/base/common/uriIpc.js"() {
      "use strict";
  
      Ze();
      se();
      p2 = new class {
        transformIncoming(t) {
          return t;
        }
        transformOutgoing(t) {
          return t;
        }
        transformOutgoingURI(t) {
          return t;
        }
        transformOutgoingScheme(t) {
          return t;
        }
      }();
    }
  });
  import { shell as l$ } from "electron";
  var g2;
  var m2;
  var u$ = g({
    "out-build/vs/platform/files/electron-main/diskFileSystemProviderServer.js"() {
      "use strict";
  
      be();
      H();
      se();
      He();
      we();
      a$();
      c$();
      en();
      g2 = class extends d2 {
        constructor(t, e, i) {
          super(t, e);
          this.M = i;
        }
        c(t) {
          return p2;
        }
        f(t, e) {
          return P.revive(e);
        }
        async w(t, e, i) {
          if (!i.useTrash) {
            return super.w(t, e, i);
          }
          const s = this.f(t, e);
          const r = pi(s.fsPath);
          try {
            await l$.trashItem(r);
          } catch (n) {
            throw cs(v(j ? 1948 : 1949, null, Ue(r), Ki(n)), oe.Unknown);
          }
        }
        L(t, e) {
          return new m2(t, e, this.b, this.M);
        }
      };
      m2 = class extends f2 {
        watch(t, e, i) {
          if (i.recursive) {
            throw cs("Recursive file watching is not supported from main process for performance reasons.", oe.Unavailable);
          }
          return super.watch(t, e, i);
        }
      };
    }
  });
  var ue;
  var Ah = g({
    "out-build/vs/platform/instantiation/common/descriptors.js"() {
      "use strict";
  
      ue = class {
        constructor(t, e = [], i = false) {
          this.ctor = t;
          this.staticArguments = e;
          this.supportsDelayedInstantiation = i;
        }
      };
    }
  });
  var Ch;
  var xg = g({
    "out-build/vs/platform/instantiation/common/serviceCollection.js"() {
      "use strict";
  
      Ch = class {
        constructor(...t) {
          this.a = new Map();
          for (const [e, i] of t) {
            this.set(e, i);
          }
        }
        set(t, e) {
          const i = this.a.get(t);
          this.a.set(t, e);
          return i;
        }
        has(t) {
          return this.a.has(t);
        }
        get(t) {
          return this.a.get(t);
        }
      };
    }
  });
  var w2;
  var Dg;
  var h$ = g({
    "out-build/vs/platform/process/common/process.js"() {
      "use strict";
  
      Y();
      (function (t) {
        t.VSCode = "vscode";
        t.Extension = "extension";
        t.Marketplace = "marketplace";
      })(w2 ||= {});
      Dg = q("processService");
    }
  });
  import { exec as _h } from "child_process";
  function Pg(t) {
    return new Promise((e, i) => {
      let s;
      const r = new Map();
      function n(c, l, u, d, f) {
        const p = r.get(l);
        if (c === t || p) {
          const w = {
            name: o(u),
            cmd: u,
            pid: c,
            ppid: l,
            load: d,
            mem: f
          };
          r.set(c, w);
          if (c === t) {
            s = w;
          }
          if (p) {
            p.children ||= [];
            p.children.push(w);
            if (p.children.length > 1) {
              p.children = p.children.sort((m, y) => m.pid - y.pid);
            }
          }
        }
      }
      function o(c) {
        const l = /--utility-sub-type=network/i;
        const u = /--crashes-directory/i;
        const d = /\\pipe\\winpty-control/i;
        const f = /conhost\.exe.+--headless/i;
        const p = /--type=([a-zA-Z-]+)/;
        if (u.exec(c)) {
          return "electron-crash-reporter";
        }
        if (d.exec(c)) {
          return "winpty-agent";
        }
        if (f.exec(c)) {
          return "conpty-agent";
        }
        let w = p.exec(c);
        if (w && w.length === 2) {
          if (w[1] === "renderer") {
            return "window";
          } else if (w[1] === "utility") {
            if (l.exec(c)) {
              return "utility-network-service";
            } else {
              return "utility-process";
            }
          } else if (w[1] === "extensionHost") {
            return "extension-host";
          } else {
            return w[1];
          }
        }
        const m = /[a-zA-Z-]+\.js/g;
        let y = "";
        do {
          w = m.exec(c);
          if (w) {
            y += w + " ";
          }
        } while (w);
        if (y && c.indexOf("node ") < 0 && c.indexOf("node.exe") < 0) {
          return `electron-nodejs (${y})`;
        } else {
          return c;
        }
      }
      if (process.platform === "win32") {
        const c = l => l.indexOf("\\\\?\\") === 0 || l.indexOf("\\??\\") === 0 ? l.substring(4) : l.indexOf("\"\\\\?\\") === 0 || l.indexOf("\"\\??\\") === 0 ? "\"" + l.substring(5) : l;
        import("@vscode/windows-process-tree").then(l => {
          l.getProcessList(t, u => {
            if (!u) {
              i(new Error(`Root process ${t} not found`));
              return;
            }
            l.getProcessCpuUsage(u, d => {
              const f = new Map();
              d.forEach(p => {
                const w = c(p.commandLine || "");
                f.set(p.pid, {
                  name: o(w),
                  cmd: w,
                  pid: p.pid,
                  ppid: p.ppid,
                  load: p.cpu || 0,
                  mem: p.memory || 0
                });
              });
              s = f.get(t);
              if (s) {
                f.forEach(p => {
                  const w = f.get(p.ppid);
                  if (w) {
                    w.children ||= [];
                    w.children.push(p);
                  }
                });
                f.forEach(p => {
                  p.children &&= p.children.sort((w, m) => w.pid - m.pid);
                });
                e(s);
              } else {
                i(new Error(`Root process ${t} not found`));
              }
            });
          }, l.ProcessDataFlag.CommandLine | l.ProcessDataFlag.Memory);
        });
      } else {
        let c = function () {
          let l = [s];
          const u = [];
          while (l.length) {
            const f = l.shift();
            if (f) {
              u.push(f.pid);
              if (f.children) {
                l = l.concat(f.children);
              }
            }
          }
          let d = JSON.stringify(Ct.asFileUri("vs/base/node/cpuUsage.sh").fsPath);
          d += " " + u.join(" ");
          _h(d, {}, (f, p, w) => {
            if (f || w) {
              i(f || new Error(w.toString()));
            } else {
              const m = p.toString().split(`
  `);
              for (let y = 0; y < u.length; y++) {
                const b = r.get(u[y]);
                b.load = parseFloat(m[y]);
              }
              if (!s) {
                i(new Error(`Root process ${t} not found`));
                return;
              }
              e(s);
            }
          });
        };
        var a = c;
        _h("which ps", {}, (l, u, d) => {
          if (l || d) {
            if (process.platform !== "linux") {
              i(l || new Error(d.toString()));
            } else {
              const f = JSON.stringify(Ct.asFileUri("vs/base/node/ps.sh").fsPath);
              _h(f, {}, (p, w, m) => {
                if (p || m) {
                  i(p || new Error(m.toString()));
                } else {
                  v2(w, n);
                  c();
                }
              });
            }
          } else {
            const f = u.toString().trim();
            _h(`${f} -ax -o pid=,ppid=,pcpu=,pmem=,command=`, {
              maxBuffer: 1024000,
              env: {
                LC_NUMERIC: "en_US.UTF-8"
              }
            }, (w, m, y) => {
              if (w || y && !y.includes("screen size is bogus")) {
                i(w || new Error(y.toString()));
              } else {
                v2(m, n);
                if (process.platform === "linux") {
                  c();
                } else if (s) {
                  e(s);
                } else {
                  i(new Error(`Root process ${t} not found`));
                }
              }
            });
          }
        });
      }
    });
  }
  function v2(t, e) {
    const i = /^\s*([0-9]+)\s+([0-9]+)\s+([0-9]+\.[0-9]+)\s+([0-9]+\.[0-9]+)\s+(.+)$/;
    const s = t.toString().split(`
  `);
    for (const r of s) {
      const n = i.exec(r.trim());
      if (n && n.length === 6) {
        e(parseInt(n[1]), parseInt(n[2]), n[5], parseFloat(n[3]), parseFloat(n[4]));
      }
    }
  }
  var b2 = g({
    "out-build/vs/base/node/ps.js"() {
      "use strict";
  
      Ie();
    }
  });
  import { spawn as d$ } from "child_process";
  import { relative as y2, join as S2 } from "path";
  import { createHash as E2 } from "crypto";
  import { promises as k2 } from "fs";
  var Wo;
  var Rh;
  var Cc = g({
    "out-build/vs/platform/cssDev/node/cssDevService.js"() {
      "use strict";
  
      Ie();
      Kn();
      Ri();
      Y();
      X();
      B();
      M();
      He();
      se();
      Wo = q("ICSSDevelopmentService");
      Rh = class extends T {
        constructor(e, i, s) {
          super();
          this.f = e;
          this.g = i;
          this.h = s;
          this.b = new Set();
          this.c = this.D(new $());
          this.onDidChangeCssModules = this.c.event;
          if (this.isEnabled) {
            this.D(this.h.onDidFilesChange(this.n.bind(this)));
            this.m();
          }
        }
        get isEnabled() {
          return !this.f.isBuilt;
        }
        getCssModules(e) {
          if (e) {
            this.a = undefined;
          }
          this.a ??= this.j();
          return this.a;
        }
        async j() {
          if (!this.isEnabled) {
            return new Map();
          }
          const e = await import("@vscode/ripgrep");
          return await new Promise(i => {
            const s = Jr.create();
            const r = [];
            const n = new TextDecoder();
            const o = Ct.asFileUri("").fsPath;
            const a = d$(e.rgPath, ["-g", "**/*.css", "-g", "!**/fixtures/**", "--files", "--no-ignore", o], {});
            a.stdout.on("data", c => {
              const l = n.decode(c, {
                stream: true
              });
              r.push(l.split(`
  `).filter(Boolean));
            });
            a.on("error", c => {
              i(new Map());
            });
            a.on("close", async () => {
              const c = r.flat().map(u => y2(o, u).replace(/\\/g, "/")).filter(Boolean).sort();
              const l = new Map();
              for (const u of c) {
                try {
                  const d = S2(o, u);
                  const f = await k2.readFile(d);
                  const p = E2("sha256").update(f).digest("hex");
                  l.set(u, p);
                } catch {
                  l.set(u, Date.now().toString());
                }
              }
              i(l);
            });
          });
        }
        async m() {
          const e = await this.getCssModules();
          for (const [i] of e) {
            const s = P.file(S2(Ct.asFileUri("").fsPath, i));
            this.b.add(i);
            this.D(this.h.watch(s));
          }
        }
        async n(e) {
          if (!this.isEnabled) {
            return;
          }
          const i = Ct.asFileUri("").fsPath;
          const s = [];
          for (const r of e.rawUpdated) {
            const n = y2(i, r.fsPath).replace(/\\/g, "/");
            if (this.b.has(n)) {
              let o;
              try {
                const a = await k2.readFile(r.fsPath);
                o = E2("sha256").update(a).digest("hex");
              } catch {
                continue;
              }
              s.push({
                path: n,
                newHash: o
              });
            }
          }
          if (s.length > 0) {
            this.c.fire(new Map(s.map(r => [r.path, r.newHash])));
            this.a = undefined;
          }
        }
      };
      Rh = __decorate([__param(0, Yi), __param(1, V), __param(2, at)], Rh);
    }
  });
  import { networkInterfaces as f$ } from "os";
  function p$(t) {
    const e = t.replace(/\-/g, ":").toLowerCase();
    return !x2.has(e);
  }
  function g$() {
    const t = f$();
    for (const e in t) {
      const i = t[e];
      if (i) {
        for (const {
          mac: s
        } of i) {
          if (p$(s)) {
            return s;
          }
        }
      }
    }
    throw new Error("Unable to retrieve mac address (unexpected format)");
  }
  var x2;
  var m$ = g({
    "out-build/vs/base/node/macAddress.js"() {
      "use strict";
  
      x2 = new Set(["00:00:00:00:00:00", "ff:ff:ff:ff:ff:ff", "ac:de:48:00:11:22"]);
    }
  });
  import { networkInterfaces as w$ } from "os";
  import { platform as $g } from "process";
  import { execSync as v$ } from "child_process";
  async function b$(t) {
    Ig ||= (async () => {
      let e;
      try {
        e = await P2(false);
      } catch (i) {
        t(i);
      }
      return e || ti();
    })();
    return Ig;
  }
  async function D2(t) {
    try {
      const e = await import("crypto");
      const i = g$();
      return e.createHash("sha256").update(i, "utf8").digest("hex");
    } catch (e) {
      t(e);
      return;
    }
  }
  function y$() {
    if ($g !== "win32") {
      return "notdefined";
    } else if (process.arch === "ia32" && process.env.hasOwnProperty("PROCESSOR_ARCHITEW6432")) {
      return "mixed";
    } else {
      return "native";
    }
  }
  function S$(t) {
    switch ($g) {
      case "darwin":
        return t.split("IOPlatformUUID")[1].split(`
  `)[0].replace(/\=|\s+|\"/ig, "").toLowerCase();
      case "win32":
        return t.toString().split("REG_SZ")[1].replace(/\r+|\n+|\s+/ig, "").toLowerCase();
      case "linux":
        return t.toString().replace(/\r+|\n+|\s+/ig, "").toLowerCase();
      case "freebsd":
        return t.toString().replace(/\r+|\n+|\s+/ig, "").toLowerCase();
      default:
        throw new Error(`Unsupported platform: ${process.platform}`);
    }
  }
  async function P2(t) {
    let e = S$(v$(A2[$g], {
      timeout: 5000
    }).toString());
    let i;
    try {
      i = (await import("crypto")).createHash("sha256").update(e, "utf8").digest("hex");
    } catch {
      i = ti();
    }
    if (t) {
      return e;
    } else {
      return i;
    }
  }
  async function E$(t) {
    if (j) {
      const e = await import("@vscode/windows-registry");
      try {
        return e.GetStringRegKey("HKEY_LOCAL_MACHINE", C2, "MachineId") || "";
      } catch (i) {
        t(i);
        return "";
      }
    }
    return "";
  }
  async function $2(t) {
    try {
      return await (await import("@vscode/deviceid")).getDeviceId();
    } catch (e) {
      t(e);
      return ti();
    }
  }
  var Oh;
  var Ig;
  var I2;
  var A2;
  var C2;
  var _c = g({
    "out-build/vs/base/node/id.js"() {
      "use strict";
  
      go();
      _i();
      m$();
      H();
      Oh = new class {
        c(t) {
          if (!this.a) {
            this.a = Pr.forStrings();
            this.a.set("00-50-56", true);
            this.a.set("00-0C-29", true);
            this.a.set("00-05-69", true);
            this.a.set("00-03-FF", true);
            this.a.set("00-1C-42", true);
            this.a.set("00-16-3E", true);
            this.a.set("08-00-27", true);
            this.a.set("00:50:56", true);
            this.a.set("00:0C:29", true);
            this.a.set("00:05:69", true);
            this.a.set("00:03:FF", true);
            this.a.set("00:1C:42", true);
            this.a.set("00:16:3E", true);
            this.a.set("08:00:27", true);
          }
          return !!this.a.findSubstr(t);
        }
        value() {
          if (this.b === undefined) {
            let t = 0;
            let e = 0;
            const i = w$();
            for (const s in i) {
              const r = i[s];
              if (r) {
                for (const {
                  mac: n,
                  internal: o
                } of r) {
                  if (!o) {
                    e += 1;
                    if (this.c(n.toUpperCase())) {
                      t += 1;
                    }
                  }
                }
              }
            }
            this.b = e > 0 ? t / e : 0;
          }
          return this.b;
        }
      }();
      I2 = {
        native: "%windir%\\System32",
        mixed: "%windir%\\sysnative\\cmd.exe /c %windir%\\System32",
        notdefined: ""
      };
      A2 = {
        darwin: "ioreg -rd1 -c IOPlatformExpertDevice",
        win32: `${I2[y$()]}\\REG.exe QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid`,
        linux: "( cat /var/lib/dbus/machine-id /etc/machine-id 2> /dev/null || hostname ) | head -n 1 || :",
        freebsd: "kenv -q smbios.system.uuid || sysctl -n kern.hostuuid"
      };
      C2 = "Software\\Microsoft\\SQMClient";
    }
  });
  import * as _2 from "net";
  function k$(t, e, i, s = 1) {
    let r = false;
    return new Promise(n => {
      const o = setTimeout(() => {
        if (!r) {
          r = true;
          return n(0);
        }
      }, i);
      Ag(t, e, s, a => {
        if (!r) {
          r = true;
          clearTimeout(o);
          return n(a);
        }
      });
    });
  }
  function Ag(t, e, i, s) {
    if (e === 0) {
      return s(0);
    }
    const r = new _2.Socket();
    r.once("connect", () => {
      R2(r);
      return Ag(t + i, e - 1, i, s);
    });
    r.once("data", () => {});
    r.once("error", n => {
      R2(r);
      if (n.code !== "ECONNREFUSED") {
        return Ag(t + i, e - 1, i, s);
      } else {
        return s(t);
      }
    });
    r.connect(t, "127.0.0.1");
  }
  function x$(t, e, i, s = "127.0.0.1") {
    let r = false;
    let n;
    let o = 1;
    const a = _2.createServer({
      pauseOnConnect: true
    });
    function c(l, u) {
      if (!r) {
        r = true;
        a.removeAllListeners();
        a.close();
        if (n) {
          clearTimeout(n);
        }
        u(l);
      }
    }
    return new Promise(l => {
      n = setTimeout(() => {
        c(0, l);
      }, i);
      a.on("listening", () => {
        c(t, l);
      });
      a.on("error", u => {
        if (u && (u.code === "EADDRINUSE" || u.code === "EACCES") && o < e) {
          t++;
          o++;
          a.listen(t, s);
        } else {
          c(0, l);
        }
      });
      a.on("close", () => {
        c(0, l);
      });
      a.listen(t, s);
    });
  }
  function R2(t) {
    try {
      t.removeAllListeners("connect");
      t.removeAllListeners("error");
      t.end();
      t.destroy();
      t.unref();
    } catch (e) {
      console.error(e);
    }
  }
  var Cg;
  var O2 = g({
    "out-build/vs/base/node/ports.js"() {
      "use strict";
  
      Cg = {
        1: true,
        7: true,
        9: true,
        11: true,
        13: true,
        15: true,
        17: true,
        19: true,
        20: true,
        21: true,
        22: true,
        23: true,
        25: true,
        37: true,
        42: true,
        43: true,
        53: true,
        69: true,
        77: true,
        79: true,
        87: true,
        95: true,
        101: true,
        102: true,
        103: true,
        104: true,
        109: true,
        110: true,
        111: true,
        113: true,
        115: true,
        117: true,
        119: true,
        123: true,
        135: true,
        137: true,
        139: true,
        143: true,
        161: true,
        179: true,
        389: true,
        427: true,
        465: true,
        512: true,
        513: true,
        514: true,
        515: true,
        526: true,
        530: true,
        531: true,
        532: true,
        540: true,
        548: true,
        554: true,
        556: true,
        563: true,
        587: true,
        601: true,
        636: true,
        989: true,
        990: true,
        993: true,
        995: true,
        1719: true,
        1720: true,
        1723: true,
        2049: true,
        3659: true,
        4045: true,
        5060: true,
        5061: true,
        6000: true,
        6566: true,
        6665: true,
        6666: true,
        6667: true,
        6668: true,
        6669: true,
        6697: true,
        10080: true
      };
    }
  });
  import * as D$ from "fs";
  import * as P$ from "os";
  import * as $$ from "child_process";
  import * as I$ from "path";
  async function A$(t = false) {
    if (_g === undefined || t) {
      _g = C$();
    }
    return _g;
  }
  async function C$() {
    const t = _$();
    if (t === undefined) {
      return false;
    }
    if (t >= 22000) {
      const e = R$();
      if (e) {
        return new Promise(i => {
          try {
            $$.execFile(e, ["--status"], s => i(!s));
          } catch {
            i(false);
          }
        });
      }
    } else {
      const e = O$();
      if (e) {
        try {
          if ((await D$.promises.stat(e)).isFile()) {
            return true;
          }
        } catch {}
      }
    }
    return false;
  }
  function _$() {
    const t = /(\d+)\.(\d+)\.(\d+)/g.exec(P$.release());
    if (t) {
      return parseInt(t[3]);
    }
  }
  function L2(t) {
    const e = process.env.SystemRoot;
    if (e) {
      const i = process.env.hasOwnProperty("PROCESSOR_ARCHITEW6432");
      return I$.join(e, i ? "Sysnative" : "System32", t);
    }
  }
  function R$() {
    return L2("wsl.exe");
  }
  function O$() {
    return L2("lxss\\LxssManager.dll");
  }
  var _g;
  var L$ = g({
    "out-build/vs/platform/remote/node/wsl.js"() {
      "use strict";
    }
  });
  var Lh;
  var M$ = g({
    "out-build/vs/platform/profiling/electron-main/windowProfiling.js"() {
      "use strict";
  
      ce();
      X();
      Lh = class {
        constructor(e, i, s) {
          this.a = e;
          this.b = i;
          this.c = s;
        }
        async inspect(e) {
          await this.d();
          const i = this.a.webContents.debugger;
          await i.sendCommand("Profiler.start");
          this.c.warn("[perf] profiling STARTED", this.b);
          await wi(e);
          const s = await i.sendCommand("Profiler.stop");
          this.c.warn("[perf] profiling DONE", this.b);
          await this.e();
          return s.profile;
        }
        async d() {
          const e = this.a.webContents.debugger;
          e.attach();
          await e.sendCommand("Profiler.enable");
        }
        async e() {
          const e = this.a.webContents.debugger;
          await e.sendCommand("Profiler.disable");
          e.detach();
        }
      };
      Lh = __decorate([__param(2, V)], Lh);
    }
  });
  var To;
  var Mh = g({
    "out-build/vs/platform/auxiliaryWindow/electron-main/auxiliaryWindows.js"() {
      "use strict";
  
      Y();
      To = q("auxiliaryWindowsMainService");
    }
  });
  function Fh(t) {
    return t.res.statusCode && t.res.statusCode >= 200 && t.res.statusCode < 300 || t.res.statusCode === 1223;
  }
  function M2(t) {
    return t.res.statusCode === 204;
  }
  async function Rc(t) {
    if (!Fh(t)) {
      throw new Error("Server returned " + t.res.statusCode);
    }
    if (M2(t)) {
      return null;
    }
    const i = (await Za(t.stream)).toString();
    try {
      return JSON.parse(i);
    } catch (s) {
      s.message += `:
  ${i}`;
      throw s;
    }
  }
  function F$(t) {
    const e = Gt.as(Ai.Configuration);
    const i = Rg;
    Rg = {
      id: "http",
      order: 15,
      title: v(2099, null),
      type: "object",
      scope: t,
      properties: {
        "http.proxy": {
          type: "string",
          pattern: "^(https?|socks|socks4a?|socks5h?)://([^:]*(:[^@]*)?@)?([^:]+|\\[[:0-9a-fA-F]+\\])(:\\d+)?/?$|^$",
          markdownDescription: v(2100, null),
          restricted: true
        },
        "http.proxyStrictSSL": {
          type: "boolean",
          default: true,
          description: v(2101, null),
          restricted: true
        },
        "http.proxyKerberosServicePrincipal": {
          type: "string",
          markdownDescription: v(2102, null),
          restricted: true
        },
        "http.noProxy": {
          type: "array",
          items: {
            type: "string"
          },
          markdownDescription: v(2103, null),
          restricted: true
        },
        "http.proxyAuthorization": {
          type: ["null", "string"],
          default: null,
          markdownDescription: v(2104, null),
          restricted: true
        },
        "http.proxySupport": {
          type: "string",
          enum: ["off", "on", "fallback", "override"],
          enumDescriptions: [v(2105, null), v(2106, null), v(2107, null), v(2108, null)],
          default: "override",
          description: v(2109, null),
          restricted: true
        },
        "http.systemCertificates": {
          type: "boolean",
          default: true,
          description: v(2110, null),
          restricted: true
        },
        "http.experimental.systemCertificatesV2": {
          type: "boolean",
          tags: ["experimental"],
          default: false,
          description: v(2111, null),
          restricted: true
        },
        "http.electronFetch": {
          type: "boolean",
          default: false,
          description: v(2112, null),
          restricted: true
        },
        "http.fetchAdditionalSupport": {
          type: "boolean",
          default: true,
          markdownDescription: v(2113, null, "`#http.proxySupport#`", "`#http.systemCertificates#`"),
          restricted: true
        }
      }
    };
    e.updateConfigurations({
      add: [Rg],
      remove: i ? [i] : []
    });
  }
  var Sn;
  var F2;
  var N2;
  var Rg;
  var En = g({
    "out-build/vs/platform/request/common/request.js"() {
      "use strict";
  
      Ze();
      $e();
      M();
      be();
      Xr();
      Y();
      Zs();
      Sn = q("requestService");
      F2 = class {
        constructor(t) {
          this.b = t;
        }
        toJSON() {
          if (!this.a) {
            const t = Object.create(null);
            for (const e in this.b) {
              if (e.toLowerCase() === "authorization" || e.toLowerCase() === "proxy-authorization") {
                t[e] = "*****";
              } else {
                t[e] = this.b[e];
              }
            }
            this.a = t;
          }
          return this.a;
        }
      };
      N2 = class extends T {
        constructor(t) {
          super();
          this.b = t;
          this.a = 0;
        }
        async c(t, e) {
          const i = `[network] #${++this.a}: ${t.url}`;
          this.b.trace(`${i} - begin`, t.type, new F2(t.headers ?? {}));
          try {
            const s = await e();
            this.b.trace(`${i} - end`, t.type, s.res.statusCode, s.res.headers);
            return s;
          } catch (s) {
            this.b.error(`${i} - error`, t.type, Vi(s));
            throw s;
          }
        }
      };
      F$(1);
    }
  });
  import { Readable as N$ } from "stream";
  import * as jo from "fs";
  import { exec as Uo, spawn as W$ } from "child_process";
  import { app as Oc, BrowserWindow as Nh, clipboard as Rr, Menu as Lc, powerMonitor as T$, screen as Mc, shell as kn, webContents as j$ } from "electron";
  import { arch as U$, cpus as B$, freemem as q$, loadavg as z$, platform as H$, release as V$, totalmem as G$, type as J$ } from "os";
  import { promisify as Bo } from "util";
  var Or;
  var Fc;
  var Nc = g({
    "out-build/vs/platform/native/electron-main/nativeHostMainService.js"() {
      "use strict";
  
      sn();
      B();
      M();
      Ie();
      we();
      H();
      se();
      c2();
      _c();
      _t();
      O2();
      be();
      wn();
      vt();
      Y();
      ct();
      X();
      ht();
      pc();
      mc();
      Lt();
      ri();
      vn();
      Ze();
      L$();
      M$();
      Mh();
      $e();
      Ke();
      H4();
      En();
      gi();
      Cc();
      b1();
      At();
      Or = q("nativeHostMainService");
      Fc = class extends T {
        constructor(e, i, s, r, n, o, a, c, l, u, d, f, p, w) {
          super();
          this.b = e;
          this.c = i;
          this.f = s;
          this.g = r;
          this.h = n;
          this.j = o;
          this.m = a;
          this.n = c;
          this.q = l;
          this.r = u;
          this.s = d;
          this.t = f;
          this.u = p;
          this.z = w;
          this.a = this.D(new $());
          this.onDidChangeCssModules = this.a.event;
          this.onDidOpenMainWindow = x.map(this.b.onDidOpenWindow, m => m.id);
          this.onDidTriggerWindowSystemContextMenu = x.any(x.map(this.b.onDidTriggerSystemContextMenu, ({
            window: m,
            x: y,
            y: b
          }) => ({
            windowId: m.id,
            x: y,
            y: b
          })), x.map(this.c.onDidTriggerSystemContextMenu, ({
            window: m,
            x: y,
            y: b
          }) => ({
            windowId: m.id,
            x: y,
            y: b
          })));
          this.onDidMaximizeWindow = x.any(x.map(this.b.onDidMaximizeWindow, m => m.id), x.map(this.c.onDidMaximizeWindow, m => m.id));
          this.onDidUnmaximizeWindow = x.any(x.map(this.b.onDidUnmaximizeWindow, m => m.id), x.map(this.c.onDidUnmaximizeWindow, m => m.id));
          this.onDidChangeWindowFullScreen = x.any(x.map(this.b.onDidChangeFullScreen, m => ({
            windowId: m.window.id,
            fullscreen: m.fullscreen
          })), x.map(this.c.onDidChangeFullScreen, m => ({
            windowId: m.window.id,
            fullscreen: m.fullscreen
          })));
          this.onDidBlurMainWindow = x.filter(x.fromNodeEventEmitter(Oc, "browser-window-blur", (m, y) => y.id), m => !!this.b.getWindowById(m));
          this.onDidFocusMainWindow = x.any(x.map(x.filter(x.map(this.b.onDidChangeWindowsCount, () => this.b.getLastActiveWindow()), m => !!m), m => m.id), x.filter(x.fromNodeEventEmitter(Oc, "browser-window-focus", (m, y) => y.id), m => !!this.b.getWindowById(m)));
          this.onDidBlurMainOrAuxiliaryWindow = x.any(this.onDidBlurMainWindow, x.map(x.filter(x.fromNodeEventEmitter(Oc, "browser-window-blur", (m, y) => this.c.getWindowByWebContents(y.webContents)), m => !!m), m => m.id));
          this.onDidFocusMainOrAuxiliaryWindow = x.any(this.onDidFocusMainWindow, x.map(x.filter(x.fromNodeEventEmitter(Oc, "browser-window-focus", (m, y) => this.c.getWindowByWebContents(y.webContents)), m => !!m), m => m.id));
          this.onDidResumeOS = x.fromNodeEventEmitter(T$, "resume");
          this.onDidChangeColorScheme = this.n.onDidChangeColorScheme;
          this.C = this.D(new $());
          this.onDidChangePassword = this.C.event;
          this.onDidChangeDisplay = x.debounce(x.any(x.filter(x.fromNodeEventEmitter(Mc, "display-metrics-changed", (m, y, b) => b), m => !Array.isArray(m) || m.length !== 1 || m[0] !== "workArea"), x.fromNodeEventEmitter(Mc, "display-added"), x.fromNodeEventEmitter(Mc, "display-removed")), () => {}, 100);
          if (w.isEnabled) {
            this.D(w.onDidChangeCssModules(m => {
              this.a.fire(Object.fromEntries(m));
            }));
          }
        }
        get windowId() {
          throw new Error("Not implemented in electron-main");
        }
        async getWindows(e, i) {
          const s = this.b.getWindows().map(n => ({
            id: n.id,
            workspace: n.openedWorkspace ?? ju(n.backupPath, n.isExtensionDevelopmentHost),
            title: n.win?.getTitle() ?? "",
            filename: n.getRepresentedFilename(),
            dirty: n.isDocumentEdited(),
            parentWindowId: n.parentWindowId,
            remoteAuthority: n.remoteAuthority
          }));
          const r = [];
          if (i.includeAuxiliaryWindows) {
            r.push(...this.c.getWindows().map(n => ({
              id: n.id,
              parentId: n.parentId,
              title: n.win?.getTitle() ?? "",
              filename: n.getRepresentedFilename()
            })));
          }
          return [...s, ...r];
        }
        async getWindowCount(e) {
          return this.b.getWindowCount();
        }
        async getActiveWindowId(e) {
          const i = this.b.getFocusedWindow() || this.b.getLastActiveWindow();
          if (i) {
            return i.id;
          }
        }
        async getActiveWindowPosition() {
          const e = this.b.getFocusedWindow() || this.b.getLastActiveWindow();
          if (e) {
            return e.getBounds();
          }
        }
        async getNativeWindowHandle(e, i) {
          const s = this.N(i, e);
          if (s?.win) {
            return z.wrap(s.win.getNativeWindowHandle());
          }
        }
        openWindow(e, i, s) {
          if (Array.isArray(i)) {
            return this.F(e, i, s);
          } else {
            return this.G(e, i);
          }
        }
        exec2(e, i, s) {
          this.j.debug("NativeHostMainService:exec2 called with command", i);
          return new Promise((r, n) => {
            try {
              Uo(i, {
                ...s,
                encoding: "utf8"
              }, (o, a, c) => {
                r({
                  stdout: a,
                  stderr: c,
                  error: o ?? undefined
                });
              });
            } catch {
              r({
                stdout: "",
                stderr: "",
                error: {
                  name: "unknown-error",
                  message: "Unknown error running command"
                }
              });
            }
          });
        }
        async exec4(e, i, s) {
          this.j.debug("NativeHostMainService:exec4 called with command", i);
          return new Promise((r, n) => {
            try {
              const o = process.env.SHELL || "/bin/sh";
              const a = W$(o, ["-c", i], s);
              let c = "";
              let l = "";
              a.stdout.on("data", u => {
                c += u;
              });
              a.stderr.on("data", u => {
                l += u;
              });
              a.on("error", u => {
                r({
                  stdout: c,
                  stderr: l,
                  error: u
                });
              });
              a.on("close", u => {
                r({
                  stdout: c,
                  stderr: l,
                  error: u !== 0 ? new Error(`Command exited with code ${u}`) : undefined
                });
              });
            } catch {
              r({
                stdout: "",
                stderr: "",
                error: {
                  name: "unknown-error",
                  message: "Unknown error running command"
                }
              });
            }
          });
        }
        async *exec3(e) {
          this.j.debug("NativeHostMainService:exec3 called with command", e);
          const i = Uo(e);
          const s = new N$({
            read() {}
          });
          i.stdout?.on("data", r => {
            s.push(r);
          });
          i.on("exit", () => {
            s.push(null);
          });
          for await (const r of s) {
            if (r !== null) {
              yield r;
            }
          }
        }
        async F(e, i, s = Object.create(null)) {
          if (i.length > 0) {
            return (await this.b.open({
              context: 5,
              contextWindowId: e,
              urisToOpen: i,
              cli: this.h.args,
              forceNewWindow: s.forceNewWindow,
              forceReuseWindow: s.forceReuseWindow,
              preferNewWindow: s.preferNewWindow,
              diffMode: s.diffMode,
              mergeMode: s.mergeMode,
              addMode: s.addMode,
              gotoLineMode: s.gotoLineMode,
              noRecentEntry: s.noRecentEntry,
              waitMarkerFileURI: s.waitMarkerFileURI,
              remoteAuthority: s.remoteAuthority || undefined,
              forceProfile: s.forceProfile,
              forceTempProfile: s.forceTempProfile,
              windowInWindow: s.windowInWindow ? this.potentiallyGetParentWindowId(e) : undefined,
              windowInWindowBodyClass: s.windowInWindowBodyClass,
              shadowWindowForWorkspaceId: s.shadowWindowForWorkspaceId
            })).map(r => ({
              windowId: r.id,
              parentWindowId: r.parentWindowId
            }));
          } else {
            return [];
          }
        }
        async G(e, i) {
          return (await this.b.openEmptyWindow({
            context: 5,
            contextWindowId: e
          }, i)).map(s => ({
            windowId: s.id,
            parentWindowId: s.parentWindowId
          }));
        }
        async isFullScreen(e, i) {
          return this.N(i?.targetWindowId, e)?.isFullScreen ?? false;
        }
        async toggleFullScreen(e, i) {
          this.N(i?.targetWindowId, e)?.toggleFullScreen();
        }
        async handleTitleDoubleClick(e, i) {
          this.N(i?.targetWindowId, e)?.handleTitleDoubleClick();
        }
        async getCursorScreenPoint(e) {
          const i = Mc.getCursorScreenPoint();
          const s = Mc.getDisplayNearestPoint(i);
          return {
            point: i,
            display: s.bounds
          };
        }
        async isMaximized(e, i) {
          return this.N(i?.targetWindowId, e)?.win?.isMaximized() ?? false;
        }
        async maximizeWindow(e, i) {
          this.N(i?.targetWindowId, e)?.win?.maximize();
        }
        async unmaximizeWindow(e, i) {
          this.N(i?.targetWindowId, e)?.win?.unmaximize();
        }
        async minimizeWindow(e, i) {
          this.N(i?.targetWindowId, e)?.win?.minimize();
        }
        async moveWindowTop(e, i) {
          this.N(i?.targetWindowId, e)?.win?.moveTop();
        }
        async positionWindow(e, i, s) {
          const r = this.N(s?.targetWindowId, e);
          if (r?.win) {
            if (r.win.isFullScreen()) {
              const n = x.toPromise(x.once(x.fromNodeEventEmitter(r.win, "leave-full-screen")));
              r.win.setFullScreen(false);
              await n;
            }
            r.win.setBounds(i);
          }
        }
        async updateWindowControls(e, i) {
          this.N(i?.targetWindowId, e)?.updateWindowControls(i);
        }
        async focusWindow(e, i) {
          const s = this.N(i?.targetWindowId, e);
          s?.focus({
            force: i?.force ?? false
          });
          if (i?.webContents) {
            s?.webContents?.focus();
          }
        }
        async setMinimumSize(e, i, s) {
          const r = this.O(e);
          if (r?.win) {
            const [n, o] = r.win.getSize();
            const [a, c] = r.win.getMinimumSize();
            const [l, u] = [i ?? a, s ?? c];
            const [d, f] = [Math.max(n, l), Math.max(o, u)];
            if (a !== l || c !== u) {
              r.win.setMinimumSize(l, u);
            }
            if (n !== d || o !== f) {
              r.win.setSize(d, f);
            }
          }
        }
        async saveWindowSplash(e, i) {
          this.n.saveWindowSplash(e, i);
        }
        async getWindowInWindows(e) {
          const i = this.O(e);
          const s = this.b.getWindows();
          const r = i?.parentWindowId ? s.find(a => a.id === i.parentWindowId) : i;
          if (!r) {
            return [];
          }
          const n = s.filter(a => a.parentWindowId === r.id);
          const o = n.some(a => a.isBrowserViewVisible);
          return [{
            windowId: r.id,
            isRoot: true,
            isVisible: !o,
            remoteAuthority: r.remoteAuthority,
            lastShownAtUnixMs: r.lastShownAtUnixMs
          }, ...n.map(a => ({
            windowId: a.id,
            isRoot: false,
            isVisible: a.isBrowserViewVisible,
            remoteAuthority: a.remoteAuthority,
            lastShownAtUnixMs: a.lastShownAtUnixMs
          }))];
        }
        potentiallyGetParentWindowId(e) {
          if (false) {
            return;
          }
          const s = this.O(e);
          if (s?.parentWindowId) {
            return s.parentWindowId;
          } else {
            return e;
          }
        }
        async showWindowInWindow(e, i) {
          const r = (await this.getWindowInWindows(i.windowId)).find(a => a.isVisible);
          const n = this.O(i.windowId);
          if (n === undefined) {
            throw new Error("Window not found");
          }
          n.lastShownAtUnixMs = Date.now();
          if (i.explicitBounds && n.browserView) {
            n.windowInWindowExplicitBounds = i.explicitBounds;
            n.browserView.setBounds(i.explicitBounds);
          }
          if (n.browserView && n.id !== r?.windowId) {
            if (n.parentWindowId) {
              const a = this.O(n.parentWindowId);
              if (a?.win) {
                a.win.contentView.addChildView(n.browserView);
              }
              if (i.explicitBounds) {
                n.windowInWindowExplicitBounds = i.explicitBounds;
                n.browserView.setBounds(i.explicitBounds);
              } else {
                n.windowInWindowExplicitBounds = undefined;
                if (a?.win) {
                  const c = a.win.contentView.getBounds();
                  n.browserView.setBounds({
                    x: 0,
                    y: 0,
                    width: c.width,
                    height: c.height
                  });
                }
              }
            }
            n.isBrowserViewVisible = true;
          }
          if (r && r.windowId !== n.id) {
            const a = this.O(r.windowId);
            if (a?.browserView) {
              if (a.parentWindowId) {
                const c = this.O(a.parentWindowId);
                if (c?.win) {
                  c.win.contentView.removeChildView(a.browserView);
                }
              }
              a.isBrowserViewVisible = false;
            }
          }
          if (!i.doNotFocus) {
            n.webContents?.focus();
          }
          const o = {
            id: e4,
            from: "menu",
            args: [{
              windowId: i.windowId,
              forceZoomLevel: i.forceZoomLevel
            }]
          };
          n.sendWhenReady("vscode:runAction", We.None, o);
        }
        async runActionInWindow(e, i) {
          const s = this.O(i.windowId);
          if (s) {
            const r = {
              id: i.actionId,
              from: "menu",
              args: [{
                windowId: i.windowId,
                ...i.args
              }]
            };
            s.sendWhenReady("vscode:runAction", We.None, r);
          }
        }
        async replaceShellCommand(e) {
          const i = async () => {
            const n = Gi(this.h.appRoot, "bin", "code");
            const o = "/usr/local/bin/code";
            if (!(await ee.exists(n))) {
              throw new Error(v(2041, null, n));
            }
            return {
              source: o,
              target: n
            };
          };
          const {
            source: s,
            target: r
          } = await i();
          try {
            const {
              symbolicLink: n
            } = await jt.stat(s);
            if (n && !n.dangling) {
              const o = await a2(s);
              if (r === o) {
                return;
              }
            }
            await jo.promises.unlink(s);
          } catch (n) {
            if (n.code !== "EACCES" && n.code !== "ENOENT") {
              throw n;
            }
          }
          try {
            await jo.promises.symlink(r, s);
          } catch (n) {
            if (n.code !== "EACCES" && n.code !== "ENOENT" && n.code !== "EEXIST") {
              throw n;
            }
            const {
              response: o
            } = await this.showMessageBox(e, {
              type: "info",
              message: v(2042, null, this.m.nameShort),
              buttons: [v(2043, null), v(2044, null)]
            });
            if (o === 0) {
              try {
                const a = `osascript -e "do shell script \\"mkdir -p /usr/local/bin && ln -sf '${r}' '${s}'\\" with administrator privileges"`;
                await Bo(Uo)(a);
              } catch {
                throw new Error(v(2045, null, s));
              }
            }
          }
        }
        async fixWSL() {
          try {
            const e = Gi(this.h.appRoot);
            const i = Gi(this.h.appRoot, "bin");
            const s = i + "\\fixWSLNew.ps1";
            const r = i + "\\server-env-setup";
            console.log(await Bo(Uo)(`powershell.exe -ExecutionPolicy Bypass -File "${s}" -pathToAdd "${e}" -scriptPath "${r}"`));
          } catch (e) {
            console.error(e);
          }
        }
        async installShellCommandWindows() {
          const e = Gi(this.h.appRoot, "bin");
          try {
            const i = process.env.PATH || "";
            const s = j ? ";" : ":";
            const r = await import("@vscode/sudo-prompt");
            const n = e + "\\setPath.ps1";
            if (i.split(s).indexOf(e) === -1) {
              console.log(await Bo(r.exec)(`powershell.exe -ExecutionPolicy Bypass -File "${n}" -pathToAdd "${e}"`));
            }
          } catch (i) {
            console.error(i);
            throw new Error(v(2046, null, e));
          }
        }
        async replaceShellCommandWindows() {
          const e = Gi(this.h.appRoot, "bin");
          try {
            const i = process.env.PATH || "";
            const s = j ? ";" : ":";
            const r = await import("@vscode/sudo-prompt");
            const n = i.split(s).filter(a => !a.toLowerCase().includes("vs code")).join(s);
            const o = e + s + n + s + e;
            console.log(process.env);
            console.log(process.env.PATH);
            console.log(n);
            console.log(o);
            if (o !== i) {
              console.log(await Bo(r.exec)(`setx /M PATH "${o}"`));
            }
          } catch (i) {
            console.error(i);
            throw new Error(v(2047, null));
          }
        }
        async installShellCommand(e) {
          const {
            source: i,
            target: s
          } = await this.H();
          try {
            const {
              symbolicLink: r
            } = await jt.stat(i);
            if (r && !r.dangling) {
              const n = await a2(i);
              if (s === n) {
                return;
              }
            }
            await jo.promises.unlink(i);
          } catch (r) {
            if (r.code !== "EACCES" && r.code !== "ENOENT") {
              throw r;
            }
          }
          try {
            await jo.promises.symlink(s, i);
          } catch (r) {
            if (r.code !== "EACCES" && r.code !== "ENOENT" && r.code !== "EEXIST") {
              throw r;
            }
            const {
              response: n
            } = await this.showMessageBox(e, {
              type: "info",
              message: v(2048, null, this.m.nameShort),
              buttons: [v(2049, null), v(2050, null)]
            });
            if (n === 1) {
              throw new hi();
            }
            try {
              const o = `osascript -e "do shell script \\"mkdir -p /usr/local/bin && ln -sf '${s}' '${i}'\\" with administrator privileges"`;
              await Bo(Uo)(o);
            } catch {
              throw new Error(v(2051, null, i));
            }
          }
        }
        async uninstallShellCommand(e) {
          const {
            source: i
          } = await this.H();
          try {
            await jo.promises.unlink(i);
          } catch (s) {
            switch (s.code) {
              case "EACCES":
                {
                  const {
                    response: r
                  } = await this.showMessageBox(e, {
                    type: "info",
                    message: v(2052, null, this.m.nameShort),
                    buttons: [v(2053, null), v(2054, null)]
                  });
                  if (r === 1) {
                    throw new hi();
                  }
                  try {
                    const n = `osascript -e "do shell script \\"rm '${i}'\\" with administrator privileges"`;
                    await Bo(Uo)(n);
                  } catch {
                    throw new Error(v(2055, null, i));
                  }
                  break;
                }
              case "ENOENT":
                break;
              default:
                throw s;
            }
          }
        }
        async H() {
          const e = Gi(this.h.appRoot, "bin", "code");
          const i = `/usr/local/bin/${this.m.applicationName}`;
          if (!(await ee.exists(e))) {
            throw new Error(v(2056, null, e));
          }
          return {
            source: i,
            target: e
          };
        }
        async showMessageBox(e, i) {
          const s = this.N(i?.targetWindowId, e);
          let r = s?.win ?? undefined;
          if (s && "browserView" in s && s.browserView !== undefined) {
            const n = s;
            if (n.isBrowserViewVisible) {
              const o = this.O(n.parentWindowId);
              if (o) {
                r = o.win ?? undefined;
              }
            } else {
              throw new Error("Dialogs are skipped in hidden window-in-windows");
            }
          }
          return this.f.showMessageBox(i, r);
        }
        async showSaveDialog(e, i) {
          const s = this.N(i?.targetWindowId, e);
          return this.f.showSaveDialog(i, s?.win ?? undefined);
        }
        async showOpenDialog(e, i) {
          const s = this.N(i?.targetWindowId, e);
          return this.f.showOpenDialog(i, s?.win ?? undefined);
        }
        async pickFileFolderAndOpen(e, i) {
          const s = await this.f.pickFileFolder(i);
          if (s) {
            await this.I(await Promise.all(s.map(async r => (await jt.existsDirectory(r)) ? {
              folderUri: P.file(r)
            } : {
              fileUri: P.file(r)
            })), i, e);
          }
        }
        async pickFolderAndOpen(e, i) {
          const s = await this.f.pickFolder(i);
          if (s) {
            await this.I(s.map(r => ({
              folderUri: P.file(r)
            })), i, e);
          }
        }
        async pickFolder(e, i) {
          return await this.f.pickFolder(i);
        }
        async pickFileAndOpen(e, i) {
          const s = await this.f.pickFile(i);
          if (s) {
            await this.I(s.map(r => ({
              fileUri: P.file(r)
            })), i, e);
          }
        }
        async pickWorkspaceAndOpen(e, i) {
          const s = await this.f.pickWorkspace(i);
          if (s) {
            await this.I(s.map(r => ({
              workspaceUri: P.file(r)
            })), i, e);
          }
        }
        async I(e, i, s) {
          await this.b.open({
            context: 3,
            contextWindowId: s,
            cli: this.h.args,
            urisToOpen: e,
            forceNewWindow: i.forceNewWindow
          });
        }
        async showItemInFolder(e, i) {
          kn.showItemInFolder(i);
        }
        async setRepresentedFilename(e, i, s) {
          this.N(s?.targetWindowId, e)?.setRepresentedFilename(i);
        }
        async setDocumentEdited(e, i, s) {
          this.N(s?.targetWindowId, e)?.setDocumentEdited(i);
        }
        async openExternal(e, i, s) {
          this.h.unsetSnapExportedVariables();
          try {
            if (GE(i, R.http, R.https)) {
              this.J(i, s);
            } else {
              kn.openExternal(i);
            }
          } finally {
            this.h.restoreSnapExportedVariables();
          }
          return true;
        }
        async J(e, i) {
          const s = i ?? this.r.getValue("workbench.externalBrowser");
          if (!s) {
            return kn.openExternal(e);
          }
          if ((s.includes(ae.sep) || s.includes(Ge.sep)) && !(await ee.exists(s))) {
            this.j.error(`Configured external browser path does not exist: ${s}`);
            return kn.openExternal(e);
          }
          try {
            const {
              default: r
            } = await import("open");
            const n = await r(e, {
              app: {
                name: Object.hasOwn(r.apps, s) ? r.apps[s] : s
              }
            });
            if (!j) {
              n.stderr?.once("data", o => {
                this.j.error(`Error openening external URL '${e}' using browser '${s}': ${o.toString()}`);
                return kn.openExternal(e);
              });
            }
          } catch (r) {
            this.j.error(`Unable to open external URL '${e}' using browser '${s}' due to ${r}.`);
            return kn.openExternal(e);
          }
        }
        moveItemToTrash(e, i) {
          return kn.trashItem(i);
        }
        async isAdmin() {
          let e;
          if (j) {
            e = (await import("native-is-elevated")).default();
          } else {
            e = process.getuid?.() === 0;
          }
          return e;
        }
        async writeElevated(e, i, s, r) {
          const n = await import("@vscode/sudo-prompt");
          const o = qa(this.h.userDataPath, "code-elevated");
          await ee.writeFile(o, JSON.stringify({
            source: i.fsPath,
            target: s.fsPath
          }));
          try {
            await new Promise((a, c) => {
              const l = [`"${this.L}"`];
              if (r?.unlock) {
                l.push("--file-chmod");
              }
              l.push("--file-write", `"${o}"`);
              const u = {
                name: this.m.nameLong.replace("-", ""),
                icns: N && this.h.isBuilt ? F(Xe(this.h.appRoot), `${this.m.nameShort}.icns`) : undefined
              };
              this.j.trace(`[sudo-prompt] running command: ${l.join(" ")}`);
              n.exec(l.join(" "), u, (d, f, p) => {
                if (f) {
                  this.j.trace(`[sudo-prompt] received stdout: ${f}`);
                }
                if (p) {
                  this.j.error(`[sudo-prompt] received stderr: ${p}`);
                }
                if (d) {
                  c(d);
                } else {
                  a(undefined);
                }
              });
            });
          } finally {
            await jo.promises.unlink(o);
          }
        }
        async isRunningUnderARM64Translation() {
          if (Se || j) {
            return false;
          } else {
            return Oc.runningUnderARM64Translation;
          }
        }
        get L() {
          if (j) {
            if (this.h.isBuilt) {
              return F(Xe(process.execPath), "bin", `${this.m.applicationName}.cmd`);
            } else {
              return F(this.h.appRoot, "scripts", "code-cli.bat");
            }
          } else if (Se) {
            if (this.h.isBuilt) {
              return F(Xe(process.execPath), "bin", `${this.m.applicationName}`);
            } else {
              return F(this.h.appRoot, "scripts", "code-cli.sh");
            }
          } else if (this.h.isBuilt) {
            return F(this.h.appRoot, "bin", "code");
          } else {
            return F(this.h.appRoot, "scripts", "code-cli.sh");
          }
        }
        async getOSStatistics() {
          return {
            totalmem: G$(),
            freemem: q$(),
            loadavg: z$()
          };
        }
        async getOSProperties() {
          return {
            arch: U$(),
            platform: H$(),
            release: V$(),
            type: J$(),
            cpus: B$()
          };
        }
        async getOSVirtualMachineHint() {
          return Oh.value();
        }
        async getOSColorScheme() {
          return this.n.getColorScheme();
        }
        async hasWSLFeatureInstalled() {
          return j && A$();
        }
        async getScreenshot(e, i) {
          return (await this.N(i?.targetWindowId, e)?.win?.webContents.capturePage())?.toJPEG(95);
        }
        async getProcessId(e) {
          return this.N(undefined, e)?.win?.webContents.getOSProcessId();
        }
        async killProcess(e, i, s) {
          process.kill(i, s);
        }
        async readClipboardText(e, i) {
          return Rr.readText(i);
        }
        async readImage() {
          return Rr.readImage().toPNG();
        }
        async writeClipboardText(e, i, s) {
          return Rr.writeText(i, s);
        }
        async readClipboardFindText(e) {
          return Rr.readFindText();
        }
        async writeClipboardFindText(e, i) {
          return Rr.writeFindText(i);
        }
        async writeClipboardBuffer(e, i, s, r) {
          return Rr.writeBuffer(i, Buffer.from(s.buffer), r);
        }
        async readClipboardBuffer(e, i) {
          return z.wrap(Rr.readBuffer(i));
        }
        async hasClipboard(e, i, s) {
          return Rr.has(i, s);
        }
        async newWindowTab() {
          await this.b.open({
            context: 5,
            cli: this.h.args,
            forceNewTabbedWindow: true,
            forceEmpty: true,
            remoteAuthority: this.h.args.remote || undefined
          });
        }
        async showPreviousWindowTab() {
          Lc.sendActionToFirstResponder("selectPreviousTab:");
        }
        async showNextWindowTab() {
          Lc.sendActionToFirstResponder("selectNextTab:");
        }
        async moveWindowTabToNewWindow() {
          Lc.sendActionToFirstResponder("moveTabToNewWindow:");
        }
        async mergeAllWindowTabs() {
          Lc.sendActionToFirstResponder("mergeAllWindows:");
        }
        async toggleWindowTabsBar() {
          Lc.sendActionToFirstResponder("toggleTabBar:");
        }
        async updateTouchBar(e, i) {
          this.O(e)?.updateTouchBar(i);
        }
        async notifyReady(e) {
          this.O(e)?.setReady();
        }
        async relaunch(e, i) {
          return this.g.relaunch(i);
        }
        async reload(e, i) {
          const s = this.O(e);
          if (s) {
            if (Kt(s.openedWorkspace)) {
              const r = s.openedWorkspace.configPath;
              if (r.scheme === R.file && (await this.q.resolveLocalWorkspace(r))?.transient) {
                await this.openWindow(s.id, {
                  forceReuseWindow: true
                });
                return;
              }
            }
            return this.g.reload(s, i?.disableExtensions !== undefined || i?.hmr !== undefined ? {
              _: [],
              "disable-extensions": i.disableExtensions,
              hmr: i.hmr
            } : undefined);
          }
        }
        async destroyWindowNoFallback(e, i) {
          return this.O(i?.targetWindowId)?.win?.destroy();
        }
        async closeWindowNoFallback(e, i) {
          return this.O(i?.targetWindowId)?.close();
        }
        async closeWindow(e, i) {
          return this.N(i?.targetWindowId, e)?.win?.close();
        }
        async quit(e) {
          const i = this.b.getLastActiveWindow();
          if (i?.isExtensionDevelopmentHost && this.b.getWindowCount() > 1 && i.win) {
            i.win.close();
          } else {
            this.g.quit();
          }
        }
        async exit(e, i) {
          await this.g.kill(i);
        }
        async resolveProxy(e, i) {
          if (this.h.extensionTestsLocationURI) {
            const n = this.r.getValue("integration-test.http.proxy");
            if (n) {
              return n;
            }
          }
          return this.O(e)?.win?.webContents?.session?.resolveProxy(i);
        }
        async lookupAuthorization(e, i) {
          return this.t.lookupAuthorization(i);
        }
        async lookupKerberosAuthorization(e, i) {
          return this.s.lookupKerberosAuthorization(i);
        }
        async loadCertificates(e) {
          return this.s.loadCertificates();
        }
        findFreePort(e, i, s, r, n = 1) {
          return k$(i, s, r, n);
        }
        async openDevTools(e, i) {
          this.N(i?.targetWindowId, e)?.webContents?.openDevTools(i?.mode ? {
            mode: i.mode,
            activate: i.activate
          } : undefined);
        }
        async toggleDevTools(e, i) {
          this.N(i?.targetWindowId, e)?.webContents?.toggleDevTools();
        }
        async openGPUInfoWindow(e) {
          const i = this.O(e);
          if (i) {
            if (typeof this.M != "number") {
              const s = this.u.invokeFunction(rh, Ar(), {
                forceNativeTitlebar: true,
                hideBecauseShadowWindow: false
              });
              s.backgroundColor = undefined;
              const r = new Nh(s);
              r.setMenuBarVisibility(false);
              r.loadURL("chrome://gpu");
              r.once("ready-to-show", () => r.show());
              r.once("close", () => this.M = undefined);
              i.win?.on("close", () => {
                if (this.M) {
                  Nh.fromId(this.M)?.close();
                  this.M = undefined;
                }
              });
              this.M = r.id;
            }
            if (typeof this.M == "number") {
              const s = Nh.fromId(this.M);
              if (s?.isMinimized()) {
                s?.restore();
              }
              s?.focus();
            }
          }
        }
        async openDevToolsWindow(e, i) {
          if (!this.O(e)) {
            return;
          }
          const r = this.u.invokeFunction(rh, Ar(), {
            forceNativeTitlebar: true,
            hideBecauseShadowWindow: false
          });
          r.backgroundColor = undefined;
          const n = new Nh(r);
          n.setMenuBarVisibility(false);
          n.loadURL(i);
          n.once("ready-to-show", () => n.show());
        }
        async reloadWindowCSS(e) {
          const i = this.O(e);
          if (!i || !i.win) {
            throw new Error();
          }
          if (!this.z.isEnabled) {
            throw new Error("CSS Dev is not enabled");
          }
          const s = await this.z.getCssModules(true);
          if (i.config) {
            i.config.cssModules = s;
          }
          return Object.fromEntries(s);
        }
        async profileRenderer(e, i, s) {
          const r = this.O(e);
          if (!r || !r.win) {
            throw new Error();
          }
          return await new Lh(r.win, i, this.j).inspect(s);
        }
        async windowsGetStringRegKey(e, i, s, r) {
          if (!j) {
            return;
          }
          const n = await import("@vscode/windows-registry");
          try {
            return n.GetStringRegKey(i, s, r);
          } catch {
            return;
          }
        }
        N(e, i) {
          return this.O(e) ?? this.P(e) ?? this.O(i);
        }
        O(e) {
          if (typeof e == "number") {
            return this.b.getWindowById(e);
          }
        }
        P(e) {
          if (typeof e != "number") {
            return;
          }
          const i = j$.fromId(e);
          if (i) {
            return this.c.getWindowByWebContents(i);
          }
        }
      };
      __decorate([de], Fc.prototype, "L", null);
      Fc = __decorate([__param(0, dt), __param(1, To), __param(2, nr), __param(3, Te), __param(4, ot), __param(5, V), __param(6, Ve), __param(7, Eo), __param(8, Cr), __param(9, Je), __param(10, Sn), __param(11, oh), __param(12, Ss), __param(13, Wo)], Fc);
    }
  });
  var Wc;
  var Wh = g({
    "out-build/vs/platform/protocol/electron-main/protocol.js"() {
      "use strict";
  
      Y();
      Wc = q("protocolMainService");
    }
  });
  import { BrowserWindow as Og, contentTracing as Tc, screen as jc } from "electron";
  function K$(t) {
    if (typeof t != "object" || t === null) {
      return false;
    } else {
      return "x" in t && "y" in t && "width" in t && "height" in t;
    }
  }
  var Lg;
  var Mg;
  var Th;
  var Z$ = g({
    "out-build/vs/platform/process/electron-main/processMainService.js"() {
      "use strict";
  
      gi();
      M();
      Ie();
      H();
      b2();
      as();
      be();
      K1();
      y5();
      wn();
      vt();
      Cc();
      X();
      Nc();
      gc();
      ht();
      Wh();
      Ti();
      _o();
      fn();
      Mg = "issue.processExplorerWindowState";
      Th = class {
        static {
          Lg = this;
        }
        static {
          this.a = "#1E1E1E";
        }
        constructor(e, i, s, r, n, o, a, c, l, u, d) {
          this.f = e;
          this.g = i;
          this.h = s;
          this.i = r;
          this.j = n;
          this.k = o;
          this.l = a;
          this.m = c;
          this.n = l;
          this.o = u;
          this.p = d;
          this.b = null;
          this.c = null;
          this.d = false;
          this.q();
        }
        q() {
          it.on("vscode:listProcesses", async e => {
            const i = [];
            try {
              i.push({
                name: v(2057, null),
                rootProcess: await Pg(process.pid)
              });
              (await this.j.getRemoteDiagnostics({
                includeProcesses: true
              })).forEach(r => {
                if (G1(r)) {
                  i.push({
                    name: r.hostName,
                    rootProcess: r
                  });
                } else if (r.processes) {
                  i.push({
                    name: r.hostName,
                    rootProcess: r.processes
                  });
                }
              });
            } catch (s) {
              this.h.error(`Listing processes failed: ${s}`);
            }
            this.u(e, "vscode:listProcessesResponse", i);
          });
          it.on("vscode:workbenchCommand", (e, i) => {
            const {
              id: s,
              from: r,
              args: n
            } = i;
            let o;
            switch (r) {
              case "processExplorer":
                o = this.c;
                break;
              default:
                throw new Error(`Unexpected command source: ${r}`);
            }
            o?.webContents.send("vscode:runAction", {
              id: s,
              from: r,
              args: n
            });
          });
          it.on("vscode:closeProcessExplorer", e => {
            this.b?.close();
          });
          it.on("vscode:pidToNameRequest", async e => {
            const i = await this.j.getMainDiagnostics();
            const s = [];
            for (const r of i.windows) {
              s.push([r.pid, `window [${r.id}] (${r.title})`]);
            }
            for (const {
              pid: r,
              name: n
            } of _r.getAll()) {
              s.push([r, n]);
            }
            this.u(e, "vscode:pidToNameResponse", s);
          });
        }
        async openProcessExplorer(e) {
          if (!this.b && (this.c = Og.getFocusedWindow(), this.c)) {
            const i = new De();
            const s = i.add(this.m.createIPCObjectUrl());
            const r = this.o.getItem(Mg, undefined);
            const n = K$(r) ? r : this.s(this.c, 800, 500);
            this.b = this.t(n, s, {
              backgroundColor: e.styles.backgroundColor,
              title: v(2058, null),
              zoomLevel: e.zoomLevel,
              alwaysOnTop: true
            }, "process-explorer");
            s.update({
              appRoot: this.g.appRoot,
              windowId: this.b.id,
              userEnv: this.f,
              data: e,
              product: ko,
              nls: {
                messages: Tf(),
                language: Ll()
              },
              cssModules: this.p.isEnabled ? await this.p.getCssModules() : undefined
            });
            this.b.loadURL(Ct.asBrowserUri(`vs/code/electron-sandbox/processExplorer/processExplorer${this.g.isBuilt ? "" : "-dev"}.html`).toString(true));
            this.b.on("close", () => {
              this.b = null;
              i.dispose();
            });
            this.c.on("close", () => {
              if (this.b) {
                this.b.close();
                this.b = null;
                i.dispose();
              }
            });
            const o = () => {
              if (!this.b) {
                return;
              }
              const a = this.b.getSize();
              const c = this.b.getPosition();
              if (!a || !c) {
                return;
              }
              const l = {
                width: a[0],
                height: a[1],
                x: c[0],
                y: c[1]
              };
              this.o.setItem(Mg, l);
            };
            this.b.on("moved", o);
            this.b.on("resized", o);
          }
          if (this.b) {
            this.r(this.b);
          }
        }
        r(e) {
          if (e.isMinimized()) {
            e.restore();
          }
          e.focus();
        }
        s(e, i, s) {
          let r;
          const n = jc.getAllDisplays();
          if (n.length === 1) {
            r = n[0];
          } else {
            if (N) {
              const c = jc.getCursorScreenPoint();
              r = jc.getDisplayNearestPoint(c);
            }
            if (!r && e) {
              r = jc.getDisplayMatching(e.getBounds());
            }
            r ||= jc.getPrimaryDisplay() || n[0];
          }
          const o = r.bounds;
          const a = {
            width: i,
            height: s,
            x: o.x + o.width / 2 - i / 2,
            y: o.y + o.height / 2 - s / 2
          };
          if (o.width > 0 && o.height > 0) {
            if (a.x < o.x) {
              a.x = o.x;
            }
            if (a.y < o.y) {
              a.y = o.y;
            }
            if (a.x > o.x + o.width) {
              a.x = o.x;
            }
            if (a.y > o.y + o.height) {
              a.y = o.y;
            }
            if (a.width > o.width) {
              a.width = o.width;
            }
            if (a.height > o.height) {
              a.height = o.height;
            }
          }
          return a;
        }
        async isProfilerRunning() {
          return this.d;
        }
        async startProfilerCPU() {
          if (this.d) {
            return;
          }
          this.d = true;
          const e = this.g.args;
          const i = {
            categoryFilter: e["trace-category-filter"] || "-*,disabled-by-default-v8.cpu_profile*",
            traceOptions: e["trace-options"] || "record-until-full,enable-sampling"
          };
          await Tc.startRecording(i);
        }
        async startProfilerMemory() {
          if (this.d) {
            return;
          }
          this.d = true;
          const i = this.g.args["trace-category-filter"]?.split(",") || [];
          i.push("disabled-by-default-memory-infra", "disabled-by-default-memory-infra.v8.code_stats");
          const s = {
            included_categories: i,
            excluded_categories: ["*"],
            memory_dump_config: {
              allowed_dump_modes: ["light", "detailed"],
              triggers: [{
                type: "periodic_interval",
                mode: "detailed",
                min_time_between_dumps_ms: 10000
              }, {
                type: "periodic_interval",
                mode: "light",
                min_time_between_dumps_ms: 1000
              }]
            }
          };
          await Tc.startRecording(s);
        }
        async startProfilerGC() {
          if (this.d) {
            return;
          }
          this.d = true;
          const e = this.g.args;
          const i = {
            categoryFilter: e["trace-category-filter"] || "-*,disabled-by-default-v8.gc_stats",
            traceOptions: e["trace-options"] || "record-until-full,enable-sampling"
          };
          await Tc.startRecording(i);
        }
        async stopProfiler() {
          if (!this.d) {
            return;
          }
          this.d = false;
          const e = `${qa(this.g.userHome.fsPath, this.n.applicationName)}-${this.n.commit ?? "dev"}.profile.txt`;
          const i = await Tc.stopRecording(e);
          this.l.showItemInFolder(undefined, i);
        }
        async stopTracing() {
          if (!this.g.args.trace) {
            return;
          }
          const e = await Tc.stopRecording(`${qa(this.g.userHome.fsPath, this.n.applicationName)}.trace.txt`);
          await this.k.showMessageBox({
            type: "info",
            message: v(2059, null),
            detail: v(2060, null, e),
            buttons: [v(2061, null)]
          }, Og.getFocusedWindow() ?? undefined);
          this.l.showItemInFolder(undefined, e);
        }
        async getSystemStatus() {
          const [e, i] = await Promise.all([this.j.getMainDiagnostics(), this.j.getRemoteDiagnostics({
            includeProcesses: false,
            includeWorkspaceMetadata: false
          })]);
          return this.i.getDiagnostics(e, i);
        }
        async $getSystemInfo() {
          const [e, i] = await Promise.all([this.j.getMainDiagnostics(), this.j.getRemoteDiagnostics({
            includeProcesses: false,
            includeWorkspaceMetadata: false
          })]);
          return await this.i.getSystemInfo(e, i);
        }
        async $getPerformanceInfo() {
          try {
            const [e, i] = await Promise.all([this.j.getMainDiagnostics(), this.j.getRemoteDiagnostics({
              includeProcesses: true,
              includeWorkspaceMetadata: true
            })]);
            return await this.i.getPerformanceInfo(e, i);
          } catch (e) {
            this.h.warn("issueService#getPerformanceInfo ", e.message);
            throw e;
          }
        }
        t(e, i, s, r) {
          const n = {
            fullscreen: false,
            skipTaskbar: false,
            resizable: true,
            width: e.width,
            height: e.height,
            minWidth: 300,
            minHeight: 200,
            x: e.x,
            y: e.y,
            title: s.title,
            backgroundColor: s.backgroundColor || Lg.a,
            webPreferences: {
              preload: Ct.asFileUri("vs/base/parts/sandbox/electron-sandbox/preload.js").fsPath,
              additionalArguments: [`--vscode-window-config=${i.resource.toString()}`],
              v8CacheOptions: this.g.useCodeCache ? "bypassHeatCheck" : "none",
              enableWebSQL: false,
              spellcheck: false,
              zoomFactor: R4(s.zoomLevel),
              sandbox: true
            },
            alwaysOnTop: s.alwaysOnTop,
            experimentalDarkMode: true
          };
          const o = new Og(n);
          o.setMenuBarVisibility(false);
          return o;
        }
        u(e, i, ...s) {
          if (!e.sender.isDestroyed()) {
            e.sender.send(i, ...s);
          }
        }
        async closeProcessExplorer() {
          this.b?.close();
        }
      };
      Th = Lg = __decorate([__param(1, ot), __param(2, V), __param(3, J1), __param(4, vh), __param(5, nr), __param(6, Or), __param(7, Wc), __param(8, Ve), __param(9, Oi), __param(10, Wo)], Th);
    }
  });
  function W2(t) {
    const e = t.getKeyMap();
    const i = t.getCurrentKeyboardLayout();
    return {
      keyboardMapping: e,
      keyboardLayoutInfo: i
    };
  }
  var Fg;
  var jh;
  var Y$ = g({
    "out-build/vs/platform/keyboardLayout/electron-main/keyboardLayoutMainService.js"() {
      "use strict";
  
      H();
      B();
      M();
      Y();
      ct();
      Fg = q("keyboardLayoutMainService");
      jh = class extends T {
        constructor(e) {
          super();
          this.a = this.D(new $());
          this.onDidChangeKeyboardLayout = this.a.event;
          this.b = null;
          this.c = null;
          e.when(3).then(() => this.f());
        }
        f() {
          this.b ||= this.g();
          return this.b;
        }
        async g() {
          const e = await import("native-keymap");
          this.c = W2(e);
          if (!tw) {
            e.onDidChangeKeyboardLayout(() => {
              this.c = W2(e);
              this.a.fire(this.c);
            });
          }
        }
        async getKeyboardLayoutData() {
          await this.f();
          return this.c;
        }
      };
      jh = __decorate([__param(0, Te)], jh);
    }
  });
  var Uc;
  var T2 = g({
    "out-build/vs/platform/url/common/url.js"() {
      "use strict";
  
      Y();
      Uc = q("urlService");
    }
  });
  import { app as X$ } from "electron";
  var j2;
  var Ng;
  var Uh;
  var Q$ = g({
    "out-build/vs/platform/launch/electron-main/launchMainService.js"() {
      "use strict";
  
      zt();
      H();
      se();
      _t();
      Ke();
      kc();
      Y();
      X();
      T2();
      Lt();
      j2 = "launchMainService";
      Ng = q(j2);
      Uh = class {
        constructor(e, i, s, r) {
          this.a = e;
          this.b = i;
          this.c = s;
          this.d = r;
        }
        async start(e, i) {
          this.a.trace("Received data from other instance: ", e, i);
          if (N) {
            X$.focus({
              steal: true
            });
          }
          const s = this.e(e);
          if (s.length) {
            let r = Promise.resolve();
            if (this.b.getWindowCount() === 0) {
              const n = (await this.b.openEmptyWindow({
                context: 4
              })).at(0);
              if (n) {
                r = n.ready();
              }
            }
            r.then(() => {
              for (const {
                uri: n,
                originalUrl: o
              } of s) {
                this.c.open(n, {
                  originalUrl: o
                });
              }
            });
          } else {
            return this.f(e, i);
          }
        }
        e(e) {
          if (e["open-url"] && e._urls && e._urls.length > 0) {
            return $t(e._urls.map(i => {
              try {
                return {
                  uri: P.parse(i),
                  originalUrl: i
                };
              } catch {
                return null;
              }
            }));
          } else {
            return [];
          }
        }
        async f(e, i) {
          const s = bn(i) ? 0 : 4;
          let r = [];
          const n = e.wait && e.waitMarkerFilePath ? P.file(e.waitMarkerFilePath) : undefined;
          const o = e.remote || undefined;
          const a = {
            context: s,
            cli: e,
            userEnv: e["preserve-env"] || s === 0 ? i : undefined,
            waitMarkerFileURI: n,
            remoteAuthority: o,
            forceProfile: e.profile,
            forceTempProfile: e["profile-temp"]
          };
          if (e.extensionDevelopmentPath) {
            await this.b.openExtensionDevelopmentHostWindow(e.extensionDevelopmentPath, a);
          } else if (!e._.length && !e["folder-uri"] && !e["file-uri"]) {
            let c = false;
            if (e["new-window"] || a.forceProfile || a.forceTempProfile) {
              c = true;
            } else if (e["reuse-window"]) {
              c = false;
            } else {
              switch (this.d.getValue("window")?.openWithoutArgumentsInNewWindow || "default") {
                case "on":
                  c = true;
                  break;
                case "off":
                  c = false;
                  break;
                default:
                  c = !N;
              }
            }
            if (c) {
              r = await this.b.open({
                ...a,
                forceNewWindow: true,
                forceEmpty: true
              });
            } else {
              const l = this.b.getLastActiveWindow();
              if (l) {
                this.b.openExistingWindow(l, a);
                r = [l];
              } else {
                r = await this.b.open({
                  ...a,
                  forceEmpty: true
                });
              }
            }
          } else {
            r = await this.b.open({
              ...a,
              forceNewWindow: e["new-window"],
              preferNewWindow: !e["reuse-window"] && !e.wait,
              forceReuseWindow: e["reuse-window"],
              diffMode: e.diff,
              mergeMode: e.merge,
              addMode: e.add,
              noRecentEntry: !!e["skip-add-to-recently-opened"],
              gotoLineMode: e.goto
            });
          }
          if (n && r.length === 1 && r[0]) {
            return Promise.race([r[0].whenClosedOrLoaded, wk(n.fsPath)]).then(() => {}, () => {});
          }
        }
        async getMainProcessId() {
          this.a.trace("Received request for process ID from other instance.");
          return process.pid;
        }
      };
      Uh = __decorate([__param(0, V), __param(1, dt), __param(2, Uc), __param(3, Je)], Uh);
    }
  });
  function U2(t) {
    return t.submenu !== undefined;
  }
  function B2(t) {
    return t.id === "vscode.menubar.separator";
  }
  function q2(t) {
    return t.uri !== undefined;
  }
  function eI(t) {
    return !U2(t) && !B2(t) && !q2(t);
  }
  var tI = g({
    "out-build/vs/platform/menubar/common/menubar.js"() {
      "use strict";
    }
  });
  var z2;
  var H2;
  var V2;
  var fe;
  var xn;
  var Lr = g({
    "out-build/vs/platform/update/common/update.js"() {
      "use strict";
  
      _e();
      Y();
      (function (t) {
        t.Uninitialized = "uninitialized";
        t.Idle = "idle";
        t.Disabled = "disabled";
        t.CheckingForUpdates = "checking for updates";
        t.AvailableForDownload = "available for download";
        t.Downloading = "downloading";
        t.Downloaded = "downloaded";
        t.Updating = "updating";
        t.Ready = "ready";
      })(z2 ||= {});
      (function (t) {
        t[t.Setup = 0] = "Setup";
        t[t.Archive = 1] = "Archive";
        t[t.Snap = 2] = "Snap";
      })(H2 ||= {});
      (function (t) {
        t[t.NotBuilt = 0] = "NotBuilt";
        t[t.DisabledByEnvironment = 1] = "DisabledByEnvironment";
        t[t.ManuallyDisabled = 2] = "ManuallyDisabled";
        t[t.MissingConfiguration = 3] = "MissingConfiguration";
        t[t.InvalidConfiguration = 4] = "InvalidConfiguration";
        t[t.RunningAsAdmin = 5] = "RunningAsAdmin";
      })(V2 ||= {});
      fe = {
        Uninitialized: {
          type: "uninitialized"
        },
        Disabled: t => ({
          type: "disabled",
          reason: t
        }),
        Idle: (t, e) => ({
          type: "idle",
          updateType: t,
          error: e
        }),
        CheckingForUpdates: t => ({
          type: "checking for updates",
          explicit: t
        }),
        AvailableForDownload: t => ({
          type: "available for download",
          update: t
        }),
        Downloading: {
          type: "downloading"
        },
        Downloaded: t => ({
          type: "downloaded",
          update: t
        }),
        Updating: t => ({
          type: "updating",
          update: t
        }),
        Ready: t => ({
          type: "ready",
          update: t
        })
      };
      xn = q("updateService");
    }
  });
  function Bh(t) {
    if (!t) {
      return;
    }
    const e = t.split("+");
    if (e.length < 2) {
      return;
    }
    const i = e[0];
    if (!i || i !== "background-composer") {
      return;
    }
    const s = e[1];
    if (s && (!!s.startsWith("bc-") || !!s.startsWith("pod-"))) {
      return s;
    }
  }
  var Wg = g({
    "out-build/vs/base/common/bcIdFromAuthority.js"() {
      "use strict";
    }
  });
  import { app as Dn } from "electron";
  var Ui;
  var Bc;
  var qh;
  var zh = g({
    "out-build/vs/platform/workspaces/electron-main/workspacesHistoryMainService.js"() {
      "use strict";
  
      zt();
      ce();
      B();
      Sr();
      M();
      Ie();
      H();
      nt();
      se();
      _t();
      be();
      Y();
      ct();
      X();
      eh();
      sg();
      ri();
      vn();
      $i();
      wn();
      Wg();
      Bc = q("workspacesHistoryMainService");
      qh = class extends T {
        static {
          Ui = this;
        }
        static {
          this.a = 500;
        }
        static {
          this.b = "history.recentlyOpenedPathsList";
        }
        constructor(e, i, s, r, n) {
          super();
          this.f = e;
          this.g = i;
          this.h = s;
          this.j = r;
          this.m = n;
          this.c = this.D(new $());
          this.onDidChangeRecentlyOpened = this.c.event;
          this.H = this.D(new Ys(800));
          this.n();
        }
        n() {
          this.h.when(4).then(() => this.I());
          this.D(this.g.onDidEnterWorkspace(e => this.addRecentlyOpened([{
            workspace: e.workspace,
            remoteAuthority: e.window.remoteAuthority
          }])));
        }
        async addRecentlyOpened(e) {
          let i = [];
          let s = [];
          for (const n of e) {
            if (Bh(n.remoteAuthority) === undefined) {
              if (tg(n)) {
                if (!this.g.isUntitledWorkspace(n.workspace) && !this.u(i, n.workspace)) {
                  i.push(n);
                }
              } else if (gh(n)) {
                if (!this.w(i, n.folderUri)) {
                  i.push(n);
                }
              } else {
                const o = this.y(s, n.fileUri);
                const a = n.fileUri.scheme === R.file && Ui.G.indexOf(ks(n.fileUri)) >= 0;
                if (!o && !a) {
                  s.push(n);
                  if (j && n.fileUri.scheme === R.file) {
                    Dn.addRecentDocument(n.fileUri.fsPath);
                  }
                }
              }
            }
          }
          const r = await this.q({
            workspaces: i,
            files: s
          });
          i = r.workspaces;
          s = r.files;
          if (i.length > Ui.a) {
            i.length = Ui.a;
          }
          if (s.length > Ui.a) {
            s.length = Ui.a;
          }
          await this.s({
            workspaces: i,
            files: s
          });
          this.c.fire();
          if (N) {
            this.H.trigger(() => this.N());
          }
        }
        async removeRecentlyOpened(e) {
          const i = o => {
            const a = this.t(o);
            for (const c of e) {
              if (tt.isEqual(c, a)) {
                return false;
              }
            }
            return true;
          };
          const s = await this.getRecentlyOpened();
          const r = s.workspaces.filter(i);
          const n = s.files.filter(i);
          if (r.length !== s.workspaces.length || n.length !== s.files.length) {
            await this.s({
              files: n,
              workspaces: r
            });
            this.c.fire();
            if (N) {
              this.H.trigger(() => this.N());
            }
          }
        }
        async clearRecentlyOpened(e) {
          if (e?.confirm) {
            const {
              response: i
            } = await this.m.showMessageBox({
              type: "warning",
              buttons: [v(2534, null), v(2535, null)],
              message: v(2536, null),
              detail: v(2537, null),
              cancelId: 1
            });
            if (i !== 0) {
              return;
            }
          }
          await this.s({
            workspaces: [],
            files: []
          });
          Dn.clearRecentDocuments();
          this.c.fire();
        }
        async getRecentlyOpened() {
          return this.q();
        }
        async q(e) {
          const i = new Ht(n => tt.getComparisonKey(n));
          if (e?.workspaces) {
            for (const n of e.workspaces) {
              i.set(this.t(n), n);
            }
          }
          const s = new Ht(n => tt.getComparisonKey(n));
          if (e?.files) {
            for (const n of e.files) {
              s.set(this.t(n), n);
            }
          }
          const r = await this.r();
          for (const n of r.workspaces) {
            if (Bh(n.remoteAuthority) !== undefined) {
              continue;
            }
            const o = i.get(this.t(n));
            if (o) {
              o.label = o.label ?? n.label;
            } else {
              i.set(this.t(n), n);
            }
          }
          for (const n of r.files) {
            const o = s.get(this.t(n));
            if (o) {
              o.label = o.label ?? n.label;
            } else {
              s.set(this.t(n), n);
            }
          }
          return {
            workspaces: [...i.values()],
            files: [...s.values()]
          };
        }
        async r() {
          await this.j.whenReady;
          let e;
          const i = this.j.get(Ui.b, -1);
          if (typeof i == "string") {
            try {
              e = JSON.parse(i);
            } catch (s) {
              this.f.error("Unexpected error parsing opened paths list", s);
            }
          }
          return qD(e, this.f);
        }
        async s(e) {
          await this.j.whenReady;
          this.j.store(Ui.b, JSON.stringify(zD(e)), -1, 1);
        }
        t(e) {
          if (gh(e)) {
            return e.folderUri;
          } else if (FD(e)) {
            return e.fileUri;
          } else {
            return e.workspace.configPath;
          }
        }
        u(e, i) {
          return !!e.find(s => tg(s) && s.workspace.id === i.id);
        }
        w(e, i) {
          return !!e.find(s => gh(s) && tt.isEqual(s.folderUri, i));
        }
        y(e, i) {
          return !!e.find(s => tt.isEqual(s.fileUri, i));
        }
        static {
          this.z = 7;
        }
        static {
          this.C = 10;
        }
        static {
          this.F = 7;
        }
        static {
          this.G = ["COMMIT_EDITMSG", "MERGE_MSG", "git-rebase-todo"];
        }
        async I() {
          if (j) {
            await this.J();
            this.D(this.onDidChangeRecentlyOpened(() => this.J()));
          }
        }
        async J() {
          if (!j) {
            return;
          }
          const e = [];
          e.push({
            type: "tasks",
            items: [{
              type: "task",
              title: v(2538, null),
              description: v(2539, null),
              program: process.execPath,
              args: "-n",
              iconPath: process.execPath,
              iconIndex: 0
            }]
          });
          if ((await this.getRecentlyOpened()).workspaces.length > 0) {
            const i = [];
            for (const n of Dn.getJumpListSettings().removedItems) {
              const o = n.args;
              if (o) {
                const a = /^--(folder|file)-uri\s+"([^"]+)"$/.exec(o);
                if (a) {
                  i.push(P.parse(a[2]));
                }
              }
            }
            await this.removeRecentlyOpened(i);
            let s = false;
            const r = $t((await this.getRecentlyOpened()).workspaces.slice(0, Ui.F).map(n => {
              const o = tg(n) ? n.workspace : n.folderUri;
              const {
                title: a,
                description: c
              } = this.L(o, n.label);
              let l;
              if (P.isUri(o)) {
                l = `--folder-uri "${o.toString()}"`;
              } else {
                s = true;
                l = `--file-uri "${o.configPath.toString()}"`;
              }
              return {
                type: "task",
                title: a.substr(0, 255),
                description: c.substr(0, 255),
                program: process.execPath,
                args: l,
                iconPath: "explorer.exe",
                iconIndex: 0
              };
            }));
            if (r.length > 0) {
              e.push({
                type: "custom",
                name: v(s ? 2540 : 2541, null),
                items: r
              });
            }
          }
          e.push({
            type: "recent"
          });
          try {
            const i = Dn.setJumpList(e);
            if (i && i !== "ok") {
              this.f.warn(`updateWindowsJumpList#setJumpList unexpected result: ${i}`);
            }
          } catch (i) {
            this.f.warn("updateWindowsJumpList#setJumpList", i);
          }
        }
        L(e, i) {
          if (i) {
            return {
              title: lk(i).name,
              description: i
            };
          }
          if (P.isUri(e)) {
            return {
              title: ks(e),
              description: this.M(e)
            };
          }
          if (this.g.isUntitledWorkspace(e)) {
            return {
              title: v(2542, null),
              description: ""
            };
          }
          let s = ks(e.configPath);
          if (s.endsWith(cc)) {
            s = s.substr(0, s.length - cc.length - 1);
          }
          return {
            title: v(2543, null, s),
            description: this.M(e.configPath)
          };
        }
        M(e) {
          if (e.scheme === "file") {
            return Lp(e.fsPath);
          } else {
            return e.toString();
          }
        }
        async N() {
          if (!N) {
            return;
          }
          Dn.clearRecentDocuments();
          const e = await this.getRecentlyOpened();
          const i = [];
          let s = 0;
          for (let n = 0; n < e.workspaces.length && s < Ui.z; n++) {
            const o = this.t(e.workspaces[n]);
            if (o.scheme === R.file) {
              const a = Ci(o);
              if (await ee.exists(a)) {
                i.push(a);
                s++;
              }
            }
          }
          const r = [];
          for (let n = 0; n < e.files.length && s < Ui.C; n++) {
            const o = this.t(e.files[n]);
            if (o.scheme === R.file) {
              const a = Ci(o);
              if (Ui.G.includes(ks(o)) || i.includes(a)) {
                continue;
              }
              if (await ee.exists(a)) {
                r.push(a);
                s++;
              }
            }
          }
          r.reverse().forEach(n => Dn.addRecentDocument(n));
          i.reverse().forEach(n => Dn.addRecentDocument(n));
        }
      };
      qh = Ui = __decorate([__param(0, V), __param(1, Cr), __param(2, Te), __param(3, dc), __param(4, nr)], qh);
    }
  });
  import { app as iI, BrowserWindow as Hh, Menu as bt, MenuItem as Re } from "electron";
  function ar() {
    return new Re({
      type: "separator"
    });
  }
  var Vh;
  var qc;
  var Gh;
  var sI = g({
    "out-build/vs/platform/menubar/electron-main/menubar.js"() {
      "use strict";
  
      ce();
      At();
      Sr();
      H();
      se();
      be();
      Mh();
      Ke();
      vt();
      ct();
      X();
      tI();
      Nc();
      ht();
      Ti();
      xt();
      Lr();
      fn();
      Lt();
      zh();
      M();
      qc = "menu";
      Gh = class extends T {
        static {
          Vh = this;
        }
        static {
          this.a = "lastKnownMenubarData";
        }
        constructor(e, i, s, r, n, o, a, c, l, u, d, f) {
          super();
          this.s = e;
          this.t = i;
          this.u = s;
          this.w = r;
          this.y = n;
          this.z = o;
          this.C = a;
          this.F = c;
          this.G = l;
          this.H = u;
          this.I = d;
          this.J = f;
          this.r = Object.create(null);
          this.h = new os(() => this.R(), 0);
          this.j = new os(() => {
            this.m = [];
          }, 10000);
          this.n = Object.create(null);
          this.q = Object.create(null);
          if (N || dn(i)) {
            this.L();
          }
          this.M();
          this.f = false;
          this.g = false;
          this.m = [];
          this.W();
          this.N();
        }
        L() {
          const e = this.C.getItem(Vh.a);
          if (e) {
            if (e.menus) {
              this.n = e.menus;
            }
            if (e.keybindings) {
              this.q = e.keybindings;
            }
          }
        }
        M() {
          this.r["workbench.action.files.newUntitledFile"] = (o, a, c) => {
            if (!this.lb({
              type: "commandId",
              commandId: "workbench.action.files.newUntitledFile"
            })) {
              this.u.openEmptyWindow({
                context: 2,
                contextWindowId: a?.id
              });
            }
          };
          this.r["workbench.action.newWindow"] = (o, a, c) => this.u.openEmptyWindow({
            context: 2,
            contextWindowId: a?.id
          });
          this.r["workbench.action.files.openFileFolder"] = (o, a, c) => this.H.pickFileFolderAndOpen(undefined, {
            forceNewWindow: this.eb(c),
            telemetryExtraData: {
              from: qc
            }
          });
          this.r["workbench.action.files.openFolder"] = (o, a, c) => this.H.pickFolderAndOpen(undefined, {
            forceNewWindow: this.eb(c),
            telemetryExtraData: {
              from: qc
            }
          });
          this.r["workbench.action.openWorkspace"] = (o, a, c) => this.H.pickWorkspaceAndOpen(undefined, {
            forceNewWindow: this.eb(c),
            telemetryExtraData: {
              from: qc
            }
          });
          this.r["workbench.action.clearRecentFiles"] = () => this.z.clearRecentlyOpened({
            confirm: true
          });
          const e = this.I.youTubeUrl;
          if (e) {
            this.r["workbench.action.openYouTubeUrl"] = () => this.ob(e, "openYouTubeUrl");
          }
          const i = this.I.requestFeatureUrl;
          if (i) {
            this.r["workbench.action.openRequestFeatureUrl"] = () => this.ob(i, "openUserVoiceUrl");
          }
          const s = this.I.reportIssueUrl;
          if (s) {
            this.r["workbench.action.openIssueReporter"] = () => this.ob(s, "openReportIssues");
          }
          const r = this.I.licenseUrl;
          if (r) {
            this.r["workbench.action.openLicenseUrl"] = () => {
              if (Hi) {
                const o = r.indexOf("?") > 0 ? "&" : "?";
                this.ob(`${r}${o}lang=${Hi}`, "openLicenseUrl");
              } else {
                this.ob(r, "openLicenseUrl");
              }
            };
          }
          const n = this.I.privacyStatementUrl;
          if (n && r) {
            this.r["workbench.action.openPrivacyStatementUrl"] = () => {
              this.ob(n, "openPrivacyStatement");
            };
          }
        }
        N() {
          this.D(this.F.onWillShutdown(() => this.b = true));
          this.D(this.u.onDidChangeWindowsCount(e => this.S(e)));
          this.D(this.H.onDidBlurMainWindow(() => this.U()));
          this.D(this.H.onDidFocusMainWindow(() => this.U()));
        }
        get O() {
          return false;
        }
        get P() {
          if (!N) {
            return false;
          }
          const e = this.t.getValue("window.nativeTabs");
          if (typeof e != "boolean") {
            return false;
          } else {
            return e;
          }
        }
        updateMenu(e, i) {
          this.n = e.menus;
          this.q = e.keybindings;
          this.C.setItem(Vh.a, e);
          this.Q();
        }
        Q() {
          this.h.schedule();
        }
        R() {
          if (!this.b) {
            setTimeout(() => {
              if (!this.b) {
                this.W();
              }
            }, 10);
          }
        }
        S(e) {
          if (N && (e.oldCount === 0 && e.newCount > 0 || e.oldCount > 0 && e.newCount === 0)) {
            this.f = e.newCount === 0;
            this.Q();
          }
        }
        U() {
          if (!N) {
            return;
          }
          const e = Hh.getFocusedWindow();
          this.g = !e || !!this.J.getWindowByWebContents(e.webContents);
          this.Q();
        }
        W() {
          const e = bt.getApplicationMenu();
          if (e) {
            this.m.push(e);
          }
          if (Object.keys(this.n).length === 0) {
            this.X(N ? new bt() : null);
            return;
          }
          const i = new bt();
          let s;
          if (N) {
            const n = new bt();
            s = new Re({
              label: this.I.nameShort,
              submenu: n
            });
            this.Y(n);
            i.append(s);
          }
          if (N && !this.c) {
            this.c = true;
            const n = new bt();
            n.append(new Re({
              label: this.qb(v(2005, null)),
              click: () => this.u.openEmptyWindow({
                context: 1
              })
            }));
            iI.dock.setMenu(n);
          }
          if (this.$("File")) {
            const n = new bt();
            const o = new Re({
              label: this.qb(v(2006, null)),
              submenu: n
            });
            this.bb(n, "File");
            i.append(o);
          }
          if (this.$("Edit")) {
            const n = new bt();
            const o = new Re({
              label: this.qb(v(2007, null)),
              submenu: n
            });
            this.bb(n, "Edit");
            i.append(o);
          }
          if (this.$("Selection")) {
            const n = new bt();
            const o = new Re({
              label: this.qb(v(2008, null)),
              submenu: n
            });
            this.bb(n, "Selection");
            i.append(o);
          }
          if (this.$("View")) {
            const n = new bt();
            const o = new Re({
              label: this.qb(v(2009, null)),
              submenu: n
            });
            this.bb(n, "View");
            i.append(o);
          }
          if (this.$("Go")) {
            const n = new bt();
            const o = new Re({
              label: this.qb(v(2010, null)),
              submenu: n
            });
            this.bb(n, "Go");
            i.append(o);
          }
          if (this.$("Run")) {
            const n = new bt();
            const o = new Re({
              label: this.qb(v(2011, null)),
              submenu: n
            });
            this.bb(n, "Run");
            i.append(o);
          }
          if (this.$("Terminal")) {
            const n = new bt();
            const o = new Re({
              label: this.qb(v(2012, null)),
              submenu: n
            });
            this.bb(n, "Terminal");
            i.append(o);
          }
          let r;
          if (this.$("Window")) {
            const n = new bt();
            r = new Re({
              label: this.qb(v(2013, null)),
              submenu: n,
              role: "window"
            });
            this.hb(n);
          }
          if (r) {
            i.append(r);
          }
          if (this.$("Help")) {
            const n = new bt();
            const o = new Re({
              label: this.qb(v(2014, null)),
              submenu: n,
              role: "help"
            });
            this.bb(n, "Help");
            i.append(o);
          }
          if (i.items && i.items.length > 0) {
            this.X(i);
          } else {
            this.X(null);
          }
          this.j.schedule();
        }
        X(e) {
          bt.setApplicationMenu(e);
          if (e) {
            for (const i of this.J.getWindows()) {
              i.win?.setMenu(null);
            }
          }
        }
        Y(e) {
          const i = this.jb(v(2015, null, this.I.nameLong), "workbench.action.showAboutDialog");
          const s = this.ib();
          let r;
          if (this.$("Preferences")) {
            const f = new bt();
            this.bb(f, "Preferences");
            r = new Re({
              label: this.qb(v(2016, null)),
              submenu: f
            });
          }
          const n = new bt();
          const o = new Re({
            label: v(2017, null),
            role: "services",
            submenu: n
          });
          const a = new Re({
            label: v(2018, null, this.I.nameLong),
            role: "hide",
            accelerator: "Command+H"
          });
          const c = new Re({
            label: v(2019, null),
            role: "hideOthers",
            accelerator: "Command+Alt+H"
          });
          const l = new Re({
            label: v(2020, null),
            role: "unhide"
          });
          const u = new Re(this.nb("workbench.action.quit", {
            label: v(2021, null, this.I.nameLong),
            click: async (f, p, w) => {
              const m = this.u.getLastActiveWindow();
              if ((this.u.getWindowCount() === 0 || Hh.getFocusedWindow() || m?.win?.isMinimized()) && (await this.Z(w))) {
                this.H.quit(undefined);
              }
            }
          }));
          const d = [i];
          d.push(...s);
          if (r) {
            d.push(ar(), r);
          }
          d.push(ar(), o, ar(), a, c, l, ar(), u);
          d.forEach(f => e.append(f));
        }
        async Z(e) {
          if (this.u.getWindowCount() === 0) {
            return true;
          }
          const i = this.t.getValue("window.confirmBeforeClose");
          if (i === "always" || i === "keyboardOnly" && this.fb(e)) {
            const {
              response: s
            } = await this.H.showMessageBox(this.u.getFocusedWindow()?.id, {
              type: "question",
              buttons: [v(2022, null), v(2023, null)],
              message: v(2024, null)
            });
            return s === 0;
          }
          return true;
        }
        $(e) {
          if (!N && !dn(this.t)) {
            return false;
          }
          switch (e) {
            case "File":
            case "Help":
              if (N) {
                return this.u.getWindowCount() === 0 && this.f || this.u.getWindowCount() > 0 && this.g || !!this.n && !!this.n[e];
              }
            case "Window":
              if (N) {
                return this.u.getWindowCount() === 0 && this.f || this.u.getWindowCount() > 0 && this.g || !!this.n;
              }
            default:
              return this.u.getWindowCount() > 0 && !!this.n && !!this.n[e];
          }
        }
        ab(e, i) {
          i.forEach(s => {
            if (B2(s)) {
              e.append(ar());
            } else if (U2(s)) {
              const r = new bt();
              const n = new Re({
                label: this.qb(s.label),
                submenu: r
              });
              this.ab(r, s.submenu.items);
              e.append(n);
            } else if (q2(s)) {
              e.append(this.db(s));
            } else if (eI(s)) {
              if (s.id === "workbench.action.showAboutDialog") {
                this.cb(e);
              }
              if (N) {
                if (this.u.getWindowCount() === 0 && this.f || this.u.getWindowCount() > 0 && this.g) {
                  if (this.r[s.id]) {
                    e.append(new Re(this.nb(s.id, {
                      label: this.qb(s.label),
                      click: this.r[s.id]
                    })));
                  } else {
                    e.append(this.jb(s.label, s.id, false, s.checked));
                  }
                } else {
                  e.append(this.jb(s.label, s.id, s.enabled !== false, !!s.checked));
                }
              } else {
                e.append(this.jb(s.label, s.id, s.enabled !== false, !!s.checked));
              }
            }
          });
        }
        bb(e, i) {
          if (this.n && this.n[i]) {
            this.ab(e, this.n[i].items);
          }
        }
        cb(e) {
          const i = this.ib();
          if (i.length) {
            i.forEach(s => e.append(s));
            e.append(ar());
          }
        }
        db(e) {
          const i = P.revive(e.uri);
          const s = e.id;
          const r = s === "openRecentFile" ? {
            fileUri: i
          } : s === "openRecentWorkspace" ? {
            workspaceUri: i
          } : {
            folderUri: i
          };
          return new Re(this.nb(s, {
            label: e.label,
            click: async (n, o, a) => {
              const c = this.eb(a);
              if (!((await this.u.open({
                context: 2,
                cli: this.w.args,
                urisToOpen: [r],
                forceNewWindow: c,
                gotoLineMode: false,
                remoteAuthority: e.remoteAuthority
              })).length > 0)) {
                await this.z.removeRecentlyOpened([i]);
              }
            }
          }, false));
        }
        eb(e) {
          return !!e && (!N && (!!e.ctrlKey || !!e.shiftKey) || !!N && (!!e.metaKey || !!e.altKey));
        }
        fb(e) {
          return !!e.triggeredByAccelerator || !!e.altKey || !!e.ctrlKey || !!e.metaKey || !!e.shiftKey;
        }
        gb(e, i, s) {
          const r = {
            label: this.qb(e),
            role: s,
            enabled: true
          };
          return new Re(this.mb(i, r));
        }
        hb(e) {
          const i = new Re({
            label: v(2025, null),
            role: "minimize",
            accelerator: "Command+M",
            enabled: this.u.getWindowCount() > 0
          });
          const s = new Re({
            label: v(2026, null),
            role: "zoom",
            enabled: this.u.getWindowCount() > 0
          });
          const r = new Re({
            label: v(2027, null),
            role: "front",
            enabled: this.u.getWindowCount() > 0
          });
          const n = this.jb(v(2028, null), "workbench.action.switchWindow");
          const o = [];
          if (this.P) {
            o.push(ar());
            o.push(this.jb(v(2029, null), "workbench.action.newWindowTab"));
            o.push(this.gb(v(2030, null), "workbench.action.showPreviousWindowTab", "selectPreviousTab"));
            o.push(this.gb(v(2031, null), "workbench.action.showNextWindowTab", "selectNextTab"));
            o.push(this.gb(v(2032, null), "workbench.action.moveWindowTabToNewWindow", "moveTabToNewWindow"));
            o.push(this.gb(v(2033, null), "workbench.action.mergeAllWindowTabs", "mergeAllWindows"));
          }
          [i, s, ar(), n, ...o, ar(), r].forEach(a => e.append(a));
        }
        ib() {
          switch (this.s.state.type) {
            case "idle":
              return [new Re({
                label: this.qb(v(2034, null)),
                click: () => setTimeout(() => {
                  this.pb("CheckForUpdate");
                  this.s.checkForUpdates(true);
                }, 0)
              })];
            case "checking for updates":
              return [new Re({
                label: v(2035, null),
                enabled: false
              })];
            case "available for download":
              return [new Re({
                label: this.qb(v(2036, null)),
                click: () => {
                  this.s.downloadUpdate();
                }
              })];
            case "downloading":
              return [new Re({
                label: v(2037, null),
                enabled: false
              })];
            case "downloaded":
              if (N) {
                return [];
              } else {
                return [new Re({
                  label: this.qb(v(2038, null)),
                  click: () => {
                    this.pb("InstallUpdate");
                    this.s.applyUpdate();
                  }
                })];
              }
            case "updating":
              return [new Re({
                label: v(2039, null),
                enabled: false
              })];
            case "ready":
              return [new Re({
                label: this.qb(v(2040, null)),
                click: () => {
                  this.pb("RestartToUpdate");
                  this.s.quitAndInstall();
                }
              })];
            default:
              return [];
          }
        }
        jb(e, i, s, r) {
          const n = this.qb(e);
          const o = typeof i == "function" ? i : (d, f, p) => {
            const w = d ? d.userSettingsLabel : null;
            let m = i;
            if (Array.isArray(i)) {
              m = this.eb(p) ? i[1] : i[0];
            }
            if (w && p.triggeredByAccelerator) {
              this.lb({
                type: "keybinding",
                userSettingsLabel: w
              });
            } else {
              this.lb({
                type: "commandId",
                commandId: m
              });
            }
          };
          const a = typeof s == "boolean" ? s : this.u.getWindowCount() > 0;
          const c = typeof r == "boolean" ? r : false;
          const l = {
            label: n,
            click: o,
            enabled: a
          };
          if (c) {
            l.type = "checkbox";
            l.checked = c;
          }
          let u;
          if (typeof i == "string") {
            u = i;
          } else if (Array.isArray(i)) {
            u = i[0];
          }
          if (N) {
            if (u === "editor.action.clipboardCutAction") {
              l.role = "cut";
            } else if (u === "editor.action.clipboardCopyAction") {
              l.role = "copy";
            } else if (u === "editor.action.clipboardPasteAction") {
              l.role = "paste";
            }
            if (u === "undo") {
              l.click = this.kb(o, {
                inDevTools: d => d.undo(),
                inNoWindow: () => bt.sendActionToFirstResponder("undo:")
              });
            } else if (u === "redo") {
              l.click = this.kb(o, {
                inDevTools: d => d.redo(),
                inNoWindow: () => bt.sendActionToFirstResponder("redo:")
              });
            } else if (u === "editor.action.selectAll") {
              l.click = this.kb(o, {
                inDevTools: d => d.selectAll(),
                inNoWindow: () => bt.sendActionToFirstResponder("selectAll:")
              });
            }
          }
          return new Re(this.mb(u, l));
        }
        kb(e, i) {
          return (s, r, n) => {
            const o = Hh.getFocusedWindow();
            if (!o) {
              return i.inNoWindow();
            }
            if (o.webContents.isDevToolsFocused() && o.webContents.devToolsWebContents) {
              return i.inDevTools(o.webContents.devToolsWebContents);
            }
            e(s, r || o, n);
          };
        }
        lb(e) {
          let i = Hh.getFocusedWindow();
          if (i) {
            const r = this.J.getWindowByWebContents(i.webContents);
            if (r) {
              i = this.u.getWindowById(r.parentId)?.win ?? null;
            }
          }
          if (!i) {
            const r = this.u.getLastActiveWindow();
            if (r?.win?.isMinimized()) {
              i = r.win;
            }
          }
          const s = i ? this.u.getWindowById(i.id) : undefined;
          if (s) {
            this.G.trace("menubar#runActionInRenderer", e);
            if (N && !this.w.isBuilt && !s.isReady && (e.type === "commandId" && e.commandId === "workbench.action.toggleDevTools" || e.type !== "commandId" && e.userSettingsLabel === "alt+cmd+i")) {
              return false;
            }
            if (e.type === "commandId") {
              const r = {
                id: e.commandId,
                from: "menu"
              };
              s.sendWhenReady("vscode:runAction", We.None, r);
            } else {
              const r = {
                userSettingsLabel: e.userSettingsLabel
              };
              s.sendWhenReady("vscode:runKeybinding", We.None, r);
            }
            return true;
          } else {
            this.G.trace("menubar#runActionInRenderer: no active window found", e);
            return false;
          }
        }
        mb(e, i) {
          const s = typeof e == "string" ? this.q[e] : undefined;
          if (s?.label) {
            if (s.isNative !== false) {
              i.accelerator = s.label;
              i.userSettingsLabel = s.userSettingsLabel;
            } else if (typeof i.label == "string") {
              const r = i.label.indexOf("[");
              if (r >= 0) {
                i.label = `${i.label.substr(0, r)} [${s.label}]`;
              } else {
                i.label = `${i.label} [${s.label}]`;
              }
            }
          } else {
            i.accelerator = undefined;
          }
          return i;
        }
        nb(e, i, s = !i.accelerator) {
          if (s) {
            i = this.mb(e, i);
          }
          const r = i.click;
          i.click = (n, o, a) => {
            this.pb(e);
            r?.(n, o, a);
          };
          return i;
        }
        ob(e, i) {
          this.H.openExternal(undefined, e);
          this.pb(i);
        }
        pb(e) {
          this.y.publicLog2("workbenchActionExecuted", {
            id: e,
            from: qc
          });
        }
        qb(e) {
          return ck(e, !this.O);
        }
      };
      Gh = Vh = __decorate([__param(0, xn), __param(1, Je), __param(2, dt), __param(3, ot), __param(4, Ot), __param(5, Bc), __param(6, Oi), __param(7, Te), __param(8, V), __param(9, Or), __param(10, Ve), __param(11, To)], Gh);
    }
  });
  var Tg;
  var Jh;
  var rI = g({
    "out-build/vs/platform/menubar/electron-main/menubarMainService.js"() {
      "use strict";
  
      Y();
      ct();
      X();
      sI();
      M();
      Tg = q("menubarMainService");
      Jh = class extends T {
        constructor(e, i, s) {
          super();
          this.b = e;
          this.c = i;
          this.f = s;
          this.a = this.g();
        }
        async g() {
          await this.c.when(3);
          return this.D(this.b.createInstance(Gh));
        }
        async updateMenubar(e, i) {
          this.f.trace("menubarService#updateMenubar", e);
          (await this.a).updateMenu(i, e);
        }
      };
      Jh = __decorate([__param(0, Ss), __param(1, Te), __param(2, V)], Jh);
    }
  });
  var Pn;
  var jg;
  var Ug;
  var Ls = g({
    "out-build/vs/platform/policy/common/policy.js"() {
      "use strict";
  
      B();
      Bl();
      M();
      Y();
      Pn = q("policy");
      jg = class extends T {
        constructor() {
          super(...arguments);
          this.f = {};
          this.g = new Map();
          this.h = this.D(new $());
          this.onDidChange = this.h.event;
        }
        async updatePolicyDefinitions(t) {
          const e = Object.keys(this.f).length;
          this.f = {
            ...t,
            ...this.f
          };
          if (e !== Object.keys(this.f).length) {
            await this.j(t);
          }
          return Vr.reduce(this.g.entries(), (i, [s, r]) => ({
            ...i,
            [s]: r
          }), {});
        }
        getPolicyValue(t) {
          return this.g.get(t);
        }
        serialize() {
          return Vr.reduce(Object.entries(this.f), (t, [e, i]) => ({
            ...t,
            [e]: {
              definition: i,
              value: this.g.get(e)
            }
          }), {});
        }
      };
      Ug = class {
        constructor() {
          this.onDidChange = x.None;
        }
        async updatePolicyDefinitions() {
          return {};
        }
        getPolicyValue() {}
        serialize() {}
      };
    }
  });
  async function nI(t, e, i, s, r) {
    try {
      const n = await import("@vscode/spdlog");
      n.setFlushOn(cr.Trace);
      const o = await n.createAsyncRotatingLogger(t, e, i, s);
      if (r) {
        o.clearFormatters();
      } else {
        o.setPattern("%Y-%m-%d %H:%M:%S.%e [%l] %v");
      }
      return o;
    } catch (n) {
      console.error(n);
    }
    return null;
  }
  function G2(t, e, i) {
    switch (e) {
      case J.Trace:
        t.trace(i);
        break;
      case J.Debug:
        t.debug(i);
        break;
      case J.Info:
        t.info(i);
        break;
      case J.Warning:
        t.warn(i);
        break;
      case J.Error:
        t.error(i);
        break;
      case J.Off:
        break;
      default:
        throw new Error(`Invalid log level ${e}`);
    }
  }
  function J2(t, e) {
    switch (e) {
      case J.Trace:
        t.setLevel(cr.Trace);
        break;
      case J.Debug:
        t.setLevel(cr.Debug);
        break;
      case J.Info:
        t.setLevel(cr.Info);
        break;
      case J.Warning:
        t.setLevel(cr.Warning);
        break;
      case J.Error:
        t.setLevel(cr.Error);
        break;
      case J.Off:
        t.setLevel(cr.Off);
        break;
      default:
        throw new Error(`Invalid log level ${e}`);
    }
  }
  var cr;
  var K2;
  var oI = g({
    "out-build/vs/platform/log/node/spdlogLog.js"() {
      "use strict";
  
      He();
      X();
      (function (t) {
        t[t.Trace = 0] = "Trace";
        t[t.Debug = 1] = "Debug";
        t[t.Info = 2] = "Info";
        t[t.Warning = 3] = "Warning";
        t[t.Error = 4] = "Error";
        t[t.Critical = 5] = "Critical";
        t[t.Off = 6] = "Off";
      })(cr ||= {});
      K2 = class extends c1 {
        constructor(t, e, i, s, r) {
          super();
          this.n = [];
          this.setLevel(r);
          this.q = this.s(t, e, i, s);
          this.D(this.onDidChangeLogLevel(n => {
            if (this.r) {
              J2(this.r, n);
            }
          }));
        }
        async s(t, e, i, s) {
          const r = i ? 6 : 1;
          const n = 30 / r * cn.MB;
          const o = await nI(t, e, n, r, s);
          if (o) {
            this.r = o;
            J2(this.r, this.getLevel());
            for (const {
              level: a,
              message: c
            } of this.n) {
              G2(this.r, a, c);
            }
            this.n = [];
          }
        }
        m(t, e) {
          if (this.r) {
            G2(this.r, t, e);
          } else if (this.getLevel() <= t) {
            this.n.push({
              level: t,
              message: e
            });
          }
        }
        flush() {
          if (this.r) {
            this.u();
          } else {
            this.q.then(() => this.u());
          }
        }
        dispose() {
          if (this.r) {
            this.w();
          } else {
            this.q.then(() => this.w());
          }
          super.dispose();
        }
        u() {
          if (this.r) {
            this.r.flush();
          }
        }
        w() {
          if (this.r) {
            this.r.drop();
            this.r = undefined;
          }
        }
      };
    }
  });
  var Z2;
  var aI = g({
    "out-build/vs/platform/log/node/loggerService.js"() {
      "use strict";
  
      _i();
      X();
      oI();
      Z2 = class extends Sy {
        q(t, e, i) {
          return new K2(ti(), t.fsPath, !i?.donotRotate, !!i?.donotUseFormatters, e);
        }
      };
    }
  });
  var qo;
  var Y2;
  var zc = g({
    "out-build/vs/platform/log/electron-main/loggerService.js"() {
      "use strict";
  
      $i();
      B();
      Y();
      X();
      aI();
      qo = sc;
      Y2 = class extends Z2 {
        constructor() {
          super(...arguments);
          this.t = new Ht();
        }
        createLogger(t, e, i) {
          if (i !== undefined) {
            this.t.set(this.n(t), i);
          }
          try {
            return super.createLogger(t, e);
          } catch (s) {
            this.t.delete(this.n(t));
            throw s;
          }
        }
        registerLogger(t, e) {
          if (e !== undefined) {
            this.t.set(t.resource, e);
          }
          super.registerLogger(t);
        }
        deregisterLogger(t) {
          this.t.delete(t);
          super.deregisterLogger(t);
        }
        getRegisteredLoggers(t) {
          const e = [];
          for (const i of super.getRegisteredLoggers()) {
            if (t === this.t.get(i.resource)) {
              e.push(i);
            }
          }
          return e;
        }
        getOnDidChangeLogLevelEvent(t) {
          return x.filter(this.onDidChangeLogLevel, e => vy(e) || this.u(e[0], t));
        }
        getOnDidChangeVisibilityEvent(t) {
          return x.filter(this.onDidChangeVisibility, ([e]) => this.u(e, t));
        }
        getOnDidChangeLoggersEvent(t) {
          return x.filter(x.map(this.onDidChangeLoggers, e => ({
            added: [...e.added].filter(s => this.u(s.resource, t)),
            removed: [...e.removed].filter(s => this.u(s.resource, t))
          })), e => e.added.length > 0 || e.removed.length > 0);
        }
        deregisterLoggers(t) {
          for (const [e, i] of this.t) {
            if (i === t) {
              this.deregisterLogger(e);
            }
          }
        }
        u(t, e) {
          const i = this.t.get(t);
          return i === undefined || i === e;
        }
        dispose() {
          super.dispose();
          this.t.clear();
        }
      };
    }
  });
  function cI(t) {
    if (Ea === 2 && /^penguin(\.|$)/i.test(t)) {
      return "chromebook";
    }
  }
  function lI(t, e, i, s, r, n, o, a, c, l, u) {
    const d = Object.create(null);
    d["common.machineId"] = n;
    d["common.macMachineId"] = o;
    d["common.sqmId"] = a;
    d["common.devDeviceId"] = c;
    d.sessionID = ti() + Date.now();
    d.commitHash = s;
    d.version = r;
    d["common.platformVersion"] = (t || "").replace(/^(\d+)(\.\d+)?(\.\d+)?(.*)/, "$1$2$3");
    d["common.platform"] = J0(Ea);
    d["common.nodePlatform"] = rp;
    d["common.nodeArch"] = i;
    d["common.product"] = u || "desktop";
    if (l) {
      d["common.msftInternal"] = l;
    }
    let f = 0;
    const p = Date.now();
    Object.defineProperties(d, {
      timestamp: {
        get: () => new Date(),
        enumerable: true
      },
      "common.timesincesessionstart": {
        get: () => Date.now() - p,
        enumerable: true
      },
      "common.sequence": {
        get: () => f++,
        enumerable: true
      }
    });
    if (Gf) {
      d["common.snap"] = "true";
    }
    const w = cI(e);
    if (w) {
      d["common.platformDetail"] = w;
    }
    return d;
  }
  function uI(t) {
    const e = Ii.USERDNSDOMAIN;
    if (!e) {
      return false;
    }
    const i = e.toLowerCase();
    return t.some(s => i === s);
  }
  var X2 = g({
    "out-build/vs/platform/telemetry/common/commonProperties.js"() {
      "use strict";
  
      H();
      ys();
      _i();
    }
  });
  function Q2(t, e) {
    if (!e.isBuilt && !e.disableTelemetry) {
      return true;
    } else {
      return !e.disableTelemetry && !!t.enableTelemetry;
    }
  }
  function Bg(t) {
    const e = t.getValue(Hu);
    const i = t.getValue(D1);
    if (t.getValue(P1) === false || i === false) {
      return 0;
    }
    switch (e ?? "all") {
      case "all":
        return 3;
      case "off":
        return 0;
    }
  }
  function hI(t, e) {
    const i = t.msftInternalDomains || [];
    const s = e.getValue("telemetry.internalTesting");
    return uI(i) || s;
  }
  function dI(t) {
    return [t.appRoot, t.extensionsPath, t.userHome.fsPath, t.tmpDir.fsPath, t.userDataPath];
  }
  function fI(t, e) {
    if (!t || !t.includes("/") && !t.includes("\\")) {
      return t;
    }
    let i = t;
    const s = [];
    for (const a of e) {
      while (true) {
        const c = a.exec(t);
        if (!c) {
          break;
        }
        s.push([c.index, a.lastIndex]);
      }
    }
    const r = /^[\\\/]?(node_modules|node_modules\.asar)[\\\/]/;
    const n = /(file:\/\/)?([a-zA-Z]:(\\\\|\\|\/)|(\\\\|\\|\/))?([\w-\._]+(\\\\|\\|\/))+[\w-\._]*/g;
    let o = 0;
    for (i = "";;) {
      const a = n.exec(t);
      if (!a) {
        break;
      }
      const c = s.some(([l, u]) => a.index < u && l < n.lastIndex);
      if (!r.test(a[0]) && !c) {
        i += t.substring(o, a.index) + "<REDACTED: user-file-path>";
        o = n.lastIndex;
      }
    }
    if (o < t.length) {
      i += t.substr(o);
    }
    return i;
  }
  function pI(t) {
    if (!t) {
      return t;
    }
    const e = [{
      label: "Google API Key",
      regex: /AIza[A-Za-z0-9_\\\-]{35}/
    }, {
      label: "Slack Token",
      regex: /xox[pbar]\-[A-Za-z0-9]/
    }, {
      label: "GitHub Token",
      regex: /(gh[psuro]_[a-zA-Z0-9]{36}|github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59})/
    }, {
      label: "Generic Secret",
      regex: /(key|token|sig|secret|signature|password|passwd|pwd|android:value)[^a-zA-Z0-9]/i
    }, {
      label: "CLI Credentials",
      regex: /((login|psexec|(certutil|psexec)\.exe).{1,50}(\s-u(ser(name)?)?\s+.{3,100})?\s-(admin|user|vm|root)?p(ass(word)?)?\s+["']?[^$\-\/\s]|(^|[\s\r\n\\])net(\.exe)?.{1,5}(user\s+|share\s+\/user:| user -? secrets ? set) \s + [^ $\s \/])/
    }, {
      label: "Microsoft Entra ID",
      regex: /eyJ(?:0eXAiOiJKV1Qi|hbGci|[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.)/
    }, {
      label: "Email",
      regex: /@[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+/
    }];
    for (const i of e) {
      if (i.regex.test(t)) {
        return `<REDACTED: ${i.label}>`;
      }
    }
    return t;
  }
  function e6(t, e) {
    return xD(t, i => {
      if (i instanceof t6 || Object.hasOwnProperty.call(i, "isTrustedTelemetryValue")) {
        return i.value;
      }
      if (typeof i == "string") {
        let s = i.replaceAll("%20", " ");
        s = fI(s, e);
        for (const r of e) {
          s = s.replace(r, "");
        }
        s = pI(s);
        return s;
      }
    });
  }
  var t6;
  var i6;
  var Hc;
  var $n = g({
    "out-build/vs/platform/telemetry/common/telemetryUtils.js"() {
      "use strict";
  
      us();
      _e();
      Sc();
      X2();
      xt();
      t6 = class {
        constructor(t) {
          this.value = t;
          this.isTrustedTelemetryValue = true;
        }
      };
      i6 = class {
        constructor() {
          this.telemetryLevel = 0;
          this.sessionId = "someValue.sessionId";
          this.machineId = "someValue.machineId";
          this.macMachineId = "someValue.macMachineId";
          this.sqmId = "someValue.sqmId";
          this.devDeviceId = "someValue.devDeviceId";
          this.firstSessionDate = "someValue.firstSessionDate";
          this.sendErrorTelemetry = false;
        }
        registerAuthId() {}
        publicLog() {}
        publicLog2() {}
        publicLogError() {}
        publicLogError2() {}
        publicLogCapture() {}
        setExperimentProperty() {}
      };
      Hc = new i6();
    }
  });
  var Kh;
  var qg;
  var zg;
  var gI = g({
    "out-build/vs/platform/sharedProcess/common/sharedProcess.js"() {
      "use strict";
  
      Kh = {
        exit: "vscode:electron-main->shared-process=exit",
        ipcReady: "vscode:shared-process->electron-main=ipc-ready",
        initDone: "vscode:shared-process->electron-main=init-done"
      };
      qg = {
        request: "vscode:createSharedProcessChannelConnection",
        response: "vscode:createSharedProcessChannelConnectionResult"
      };
      zg = {
        request: "vscode:createSharedProcessRawConnection",
        response: "vscode:createSharedProcessRawConnectionResult"
      };
    }
  });
  var Zh;
  var mI = g({
    "out-build/vs/platform/sharedProcess/electron-main/sharedProcess.js"() {
      "use strict";
  
      as();
      ce();
      M();
      vt();
      ct();
      X();
      _s();
      Ls();
      zc();
      _o();
      $n();
      Qp();
      _e();
      gI();
      B();
      Zh = class extends T {
        constructor(e, i, s, r, n, o, a, c, l, u) {
          super();
          this.g = e;
          this.h = i;
          this.j = s;
          this.m = r;
          this.n = n;
          this.q = o;
          this.r = a;
          this.s = c;
          this.t = l;
          this.u = u;
          this.a = new Ga();
          this.b = undefined;
          this.c = undefined;
          this.f = this.D(new $());
          this.onDidCrash = this.f.event;
          this.C = undefined;
          this.F = undefined;
          this.w();
        }
        w() {
          it.on(qg.request, (e, i) => this.y(e, i, qg.response));
          it.on(zg.request, (e, i) => this.y(e, i, zg.response));
          this.D(this.r.onWillShutdown(() => this.z()));
        }
        async y(e, i, s) {
          this.s.trace(`[SharedProcess] onWindowConnection for: ${s}`);
          if (!this.a.isOpen()) {
            this.a.open();
          }
          await this.whenReady();
          const r = await this.connect(s);
          if (e.sender.isDestroyed()) {
            return r.close();
          }
          e.sender.postMessage(s, i, [r]);
        }
        z() {
          this.s.trace("[SharedProcess] onWillShutdown");
          this.b?.postMessage(Kh.exit);
          this.b = undefined;
        }
        whenReady() {
          this.C ||= (async () => {
            await this.G;
            const e = new Xs();
            this.b?.once(Kh.initDone, () => e.complete());
            await e.p;
            this.c?.dispose();
            this.s.trace("[SharedProcess] Overall ready");
          })();
          return this.C;
        }
        get G() {
          this.F ||= (async () => {
            await this.a.wait();
            this.H();
            const e = new Xs();
            this.b?.once(Kh.ipcReady, () => e.complete());
            await e.p;
            this.s.trace("[SharedProcess] IPC ready");
          })();
          return this.F;
        }
        H() {
          this.b = this.D(new _r(this.s, Hc, this.r));
          this.c = this.b.onMessage(s => {
            if (typeof s.warning == "string") {
              this.s.warn(s.warning);
            } else if (typeof s.error == "string") {
              this.s.error(s.error);
            }
          });
          const e = kx(this.n.args, this.n.isBuilt);
          let i;
          if (e.port) {
            i = ["--nolazy"];
            if (e.break) {
              i.push(`--inspect-brk=${e.port}`);
            } else {
              i.push(`--inspect=${e.port}`);
            }
          }
          this.b.start({
            processTitle: "shared-process",
            type: "shared-process",
            entryPoint: "vs/code/electron-utility/sharedProcess/sharedProcessMain",
            payload: this.I(),
            respondToAuthRequestsFromMainProcess: true,
            execArgv: i
          });
          this.D(this.b.onCrash(() => this.f.fire()));
        }
        I() {
          return {
            machineId: this.g,
            macMachineId: this.h,
            sqmId: this.j,
            devDeviceId: this.m,
            codeCachePath: this.n.codeCachePath,
            profiles: {
              home: this.q.profilesHome,
              all: this.q.profiles
            },
            args: this.n.args,
            logLevel: this.t.getLogLevel(),
            loggers: this.t.getRegisteredLoggers(),
            policiesData: this.u.serialize()
          };
        }
        async connect(e) {
          await this.G;
          return Vl(this.b).connect(e);
        }
      };
      Zh = __decorate([__param(4, ot), __param(5, Cs), __param(6, Te), __param(7, V), __param(8, qo), __param(9, Pn)], Zh);
    }
  });
  var s6;
  var zo;
  var Hg = g({
    "out-build/vs/platform/sign/common/sign.js"() {
      "use strict";
  
      Y();
      s6 = "signService";
      zo = q(s6);
    }
  });
  function wI(t) {
    return typeof t == "object" && t !== null && "prefix" in t && typeof t.prefix == "string";
  }
  var vI = g({
    "out-build/vs/platform/storage/common/storageIpc.js"() {
      "use strict";
  
      B();
      M();
    }
  });
  var r6;
  var bI = g({
    "out-build/vs/platform/storage/electron-main/storageIpc.js"() {
      "use strict";
  
      B();
      M();
      hu();
      vI();
      ri();
      r6 = class cS extends T {
        static {
          this.a = 100;
        }
        constructor(e, i) {
          super();
          this.f = e;
          this.g = i;
          this.b = this.D(new $());
          this.c = new Map();
          this.h(i.applicationStorage, this.b);
        }
        h(e, i) {
          this.D(x.debounce(e.onDidChangeStorage, (s, r) => {
            if (s) {
              s.push(r);
            } else {
              s = [r];
            }
            return s;
          }, cS.a)(s => {
            if (s.length) {
              i.fire(this.j(s, e));
            }
          }));
        }
        j(e, i) {
          const s = new Map();
          const r = new Set();
          e.forEach(n => {
            const o = i.get(n.key);
            if (typeof o == "string") {
              s.set(n.key, o);
            } else {
              r.add(n.key);
            }
          });
          return {
            changed: Array.from(s.entries()),
            deleted: Array.from(r.values())
          };
        }
        listen(e, i, s) {
          switch (i) {
            case "onDidChangeStorage":
              {
                const r = s.profile ? Er(s.profile) : undefined;
                if (!r) {
                  return this.b.event;
                }
                let n = this.c.get(r.id);
                if (!n) {
                  n = this.D(new $());
                  this.h(this.g.profileStorage(r), n);
                  this.c.set(r.id, n);
                }
                return n.event;
              }
          }
          throw new Error(`Event not found: ${i}`);
        }
        async call(e, i, s) {
          let r = {
            profile: undefined,
            workspace: undefined
          };
          if (Array.isArray(s)) {
            if (i !== "cursorDiskKVGet" && i !== "cursorDiskKVSet") {
              throw new Error(`Unexpected array argument for command: ${i}`);
            }
            const [c, l] = s;
            r = {
              profile: c,
              workspace: l
            };
          } else {
            r = s;
          }
          const n = r.profile ? Er(r.profile) : undefined;
          const o = Lx(r.workspace);
          const a = await this.m(n, o);
          if (Array.isArray(s)) {
            switch (i) {
              case "cursorDiskKVGet":
                {
                  const [,, c] = s;
                  return a.cursorDiskKVGet(c);
                }
              case "cursorDiskKVSet":
                {
                  const [,, c, l] = s;
                  return a.cursorDiskKVSet(c, l);
                }
              default:
                throw new Error(`Call not found: ${i}`);
            }
          }
          switch (i) {
            case "getItems":
              return Array.from(a.items.entries());
            case "updateItems":
              {
                const c = r;
                if (c.insert) {
                  for (const [l, u] of c.insert) {
                    a.set(l, u);
                  }
                }
                c.delete?.forEach(l => a.delete(l));
                break;
              }
            case "optimize":
              return a.optimize();
            case "isUsed":
              {
                const c = r.payload;
                if (typeof c == "string") {
                  return this.g.isUsed(c);
                }
              }
            case "cursorDiskKVClearPrefix":
              {
                if (!wI(r)) {
                  throw new Error("Invalid request for cursorDiskKVClearPrefix");
                }
                const c = r;
                return a.cursorDiskKVClearPrefix(c.prefix);
              }
            default:
              throw new Error(`Call not found: ${i}`);
          }
        }
        async m(e, i) {
          let s;
          if (i) {
            s = this.g.workspaceStorage(i);
          } else if (e) {
            s = this.g.profileStorage(e);
          } else {
            s = this.g.applicationStorage;
          }
          try {
            await s.init();
          } catch (r) {
            this.f.error(`StorageIPC#init: Unable to init ${i ? "workspace" : e ? "profile" : "application"} storage due to ${r}`);
          }
          return s;
        }
      };
    }
  });
  var n6;
  var yI = g({
    "out-build/vs/platform/telemetry/common/telemetryIpc.js"() {
      "use strict";
  
      n6 = class {
        constructor(t) {
          this.b = t;
        }
        log(t, e) {
          this.b.call("log", {
            eventName: t,
            data: e
          }).then(undefined, i => `Failed to log telemetry: ${console.warn(i)}`);
          return Promise.resolve(null);
        }
        flush() {
          return Promise.resolve();
        }
        registerAuthId(t) {
          this.b.call("registerAuthId", {
            eventName: "registerAuthId",
            data: t
          });
        }
        capture(t, e) {
          this.b.call("capture", {
            eventName: t,
            data: e
          }).then(undefined, i => `Failed to log telemetry: ${console.warn(i)}`);
          return Promise.resolve(null);
        }
      };
    }
  });
  function SI() {
    const t = v(2118, null, ko.nameLong);
    const e = v(2119, null, "https://cursor.com/privacy", "https://cursor.com/security");
    const i = fr ? "" : v(2120, null);
    return `
  ${t} ${e} ${i}
  `;
  }
  var Yh;
  var EI = g({
    "out-build/vs/platform/telemetry/common/telemetryService.js"() {
      "use strict";
  
      M();
      us();
      H();
      Wt();
      be();
      Ke();
      Xr();
      gc();
      ht();
      Zs();
      xt();
      $n();
      Yh = class {
        static {
          this.IDLE_START_EVENT_NAME = "UserIdleStart";
        }
        static {
          this.IDLE_STOP_EVENT_NAME = "UserIdleStop";
        }
        constructor(e, i, s) {
          this.k = i;
          this.l = s;
          this.d = {};
          this.i = new De();
          this.j = [];
          this.b = e.appenders;
          this.c = e.commonProperties ?? Object.create(null);
          this.sessionId = this.c.sessionID;
          this.machineId = this.c["common.machineId"];
          this.macMachineId = this.c["common.macMachineId"];
          this.sqmId = this.c["common.sqmId"];
          this.devDeviceId = this.c["common.devDeviceId"];
          this.firstSessionDate = this.c["common.firstSessionDate"];
          this.msftInternal = this.c["common.msftInternal"];
          this.f = e.piiPaths || [];
          this.g = 3;
          this.h = !!e.sendErrorTelemetry;
          this.j = [/(vscode-)?file:\/\/\/.*?\/resources\/app\//gi];
          for (const r of this.f) {
            this.j.push(new RegExp(ja(r), "gi"));
            if (r.indexOf("\\") >= 0) {
              this.j.push(new RegExp(ja(r.replace(/\\/g, "/")), "gi"));
            }
          }
          this.m();
          this.i.add(this.k.onDidChangeConfiguration(r => {
            if (r.affectsConfiguration(Hu) || r.affectsConfiguration(P1) || r.affectsConfiguration(D1)) {
              this.m();
            }
          }));
        }
        setExperimentProperty(e, i) {
          this.d[e] = i;
        }
        m() {
          let e = Bg(this.k);
          const i = this.l.enabledTelemetryLevels;
          if (i) {
            this.h = this.sendErrorTelemetry ? i.error : false;
            const s = i.usage ? 3 : i.error ? 2 : 0;
            e = Math.min(e, s);
          }
          this.g = e;
        }
        get sendErrorTelemetry() {
          return this.h;
        }
        get telemetryLevel() {
          return this.g;
        }
        dispose() {
          this.i.dispose();
        }
        n(e, i, s) {
          if (!(this.g < i)) {
            s = yc(s, this.d);
            s = e6(s, this.j);
            s = yc(s, this.c);
            this.b.forEach(r => r.log(e, s));
          }
        }
        o(e, i, s) {
          if (!(this.g < i)) {
            s = yc(s, this.d);
            s = e6(s, this.j);
            s = yc(s, this.c);
            this.b.forEach(r => {
              r.capture(e, s);
            });
          }
        }
        registerAuthId(e) {
          this.b.forEach(i => i.registerAuthId(e));
        }
        publicLog(e, i) {
          this.n(e, 3, i);
        }
        publicLog2(e, i) {
          this.publicLog(e, i);
        }
        publicLogError(e, i) {
          if (this.h) {
            this.n(e, 2, i);
          }
        }
        publicLogError2(e, i) {
          this.publicLogError(e, i);
        }
        publicLogCapture(e, i) {
          this.o(e, 3, i);
        }
      };
      Yh = __decorate([__param(1, Je), __param(2, Ve)], Yh);
      Gt.as(Ai.Configuration).registerConfiguration({
        id: l4,
        order: 1,
        type: "object",
        title: "Crash Reporting",
        properties: {
          [Hu]: {
            type: "string",
            enum: ["all", "off"],
            enumDescriptions: ["Send OS-level crash reports.", "Disable crash reporting."],
            markdownDescription: SI(),
            default: "all",
            restricted: true,
            scope: 1
          }
        }
      });
    }
  });
  var o6;
  var kI = g({
    "out-build/vs/platform/update/common/updateIpc.js"() {
      "use strict";
  
      B();
      M();
      Lr();
      o6 = class {
        constructor(t) {
          this.a = t;
        }
        listen(t, e) {
          switch (e) {
            case "onStateChange":
              return this.a.onStateChange;
          }
          throw new Error(`Event not found: ${e}`);
        }
        call(t, e, i) {
          switch (e) {
            case "checkForUpdates":
              return this.a.checkForUpdates(i);
            case "downloadUpdate":
              return this.a.downloadUpdate();
            case "applyUpdate":
              return this.a.applyUpdate();
            case "quitAndInstall":
              return this.a.quitAndInstall();
            case "_getInitialState":
              return Promise.resolve(this.a.state);
            case "isLatestVersion":
              return this.a.isLatestVersion();
            case "_applySpecificUpdate":
              return this.a._applySpecificUpdate(i);
          }
          throw new Error(`Call not found: ${e}`);
        }
      };
    }
  });
  import * as a6 from "original-fs";
  import xI from "path";
  import DI from "os";
  function PI(t) {
    return c6.includes(t);
  }
  var c6;
  var Ho;
  var Vg = g({
    "out-build/vs/platform/update/electron-main/abstractUpdateService.js"() {
      "use strict";
  
      ce();
      At();
      B();
      Ke();
      vt();
      ct();
      X();
      ht();
      En();
      Lr();
      c6 = ["stable", "prerelease"];
      Ho = class {
        get state() {
          return this.c;
        }
        f(e) {
          this.k.info("update#setState", e.type);
          this.c = e;
          this.d.fire(e);
        }
        constructor(e, i, s, r, n, o) {
          this.g = e;
          this.h = i;
          this.i = s;
          this.j = r;
          this.k = n;
          this.l = o;
          this.c = fe.Uninitialized;
          this.d = new $();
          this.onStateChange = this.d.event;
          e.when(3).finally(() => this.m());
        }
        async m() {
          this.F();
          if (!this.i.isBuilt) {
            this.f(fe.Disabled(0));
            this.k.info("update#ctor - updates are disabled by the environment");
            return;
          }
          if (this.i.disableUpdates) {
            this.f(fe.Disabled(1));
            this.k.info("update#ctor - updates are disabled by the environment");
            return;
          }
          if (!this.l.updateUrl || !this.l.commit) {
            this.f(fe.Disabled(3));
            this.k.info("update#ctor - updates are disabled as there is no update URL");
            return;
          }
          const e = this.h.getValue("update.mode");
          const i = this.p(e);
          if (!i) {
            this.f(fe.Disabled(2));
            this.k.info("update#ctor - updates are disabled by user preference");
            return;
          }
          this.a = this.n(i, false);
          if (!this.a) {
            this.f(fe.Disabled(4));
            this.k.info("update#ctor - updates are disabled as the update URL is badly formed");
            return;
          }
          this.f(fe.Idle(this.z()));
          if (e === "manual") {
            this.k.info("update#ctor - manual checks only; automatic updates are disabled by user preference");
            return;
          }
          if (e === "start") {
            this.k.info("update#ctor - startup checks only; automatic updates are disabled by user preference");
            setTimeout(() => this.checkForUpdates(false), 30000);
          } else {
            this.q(30000).then(undefined, s => this.k.error(s));
          }
        }
        n(e, i) {
          const s = this.H(e, i);
          if (s) {
            try {
              if (this.h.getValue("_update.prss")) {
                const r = new URL(s);
                r.searchParams.set("prss", "true");
                return r.toString();
              }
            } catch (r) {
              this.k.error("Failed to add update URL params", r);
            }
            return s;
          }
        }
        o() {
          try {
            const e = this.h.getValue("update.mode");
            return this.p(e);
          } catch (e) {
            this.k.error("Failed to get product quality", e);
          }
        }
        p(e) {
          if (e === "none") {
            return undefined;
          } else {
            return this.l.quality;
          }
        }
        q(e = 3600000) {
          return wi(e).then(() => this.checkForUpdates(false)).then(() => this.q(3600000));
        }
        async r() {
          return wi(300000).then(() => this.v()).catch(e => this.k.error("update#scheduleCheckForOutdatedUpdates received error", e));
        }
        async v() {
          const e = this.s();
          if (!e) {
            if (this.state.type !== "idle") {
              this.r();
            }
            return;
          }
          try {
            this.w();
            const i = this.C();
            if (i) {
              this.k.debug("update#checkForOutdatedUpdate - checking for outdated update", e);
              const s = await this.j.request({
                url: i
              }, We.None);
              if (Fh(s)) {
                const r = await this.t(s);
                if (r !== e && this.s() === e) {
                  this.k.info("update#checkForOutdatedUpdate - found outdated update", e, r);
                  this.u(e, r);
                  if (r) {
                    this.I(false);
                  }
                  return;
                }
              } else {
                this.k.warn("update#checkForOutdatedUpdate - error status code when checking for outdated update", s.res.statusCode);
              }
            }
          } catch (i) {
            this.k.error("update#checkForOutdatedUpdate - failed to check for outdated update", i);
          }
          if (this.state.type !== "idle") {
            this.r();
          }
        }
        async checkForUpdates(e) {
          this.k.trace("update#checkForUpdates, state = ", this.state.type);
          if (this.state.type === "idle") {
            this.w();
            this.I(e);
          }
        }
        w() {
          const e = this.getReleaseTrack();
          if (this.a && !this.a.includes(e) && this.l.updateUrl) {
            const i = this.o();
            if (i) {
              const s = this.n(i, false);
              if (s) {
                this.k.info("update#checkForUpdates - updating to release track", e);
                this.a = s;
              }
            }
          }
        }
        async downloadUpdate() {
          this.k.trace("update#downloadUpdate, state = ", this.state.type);
          if (this.state.type === "available for download") {
            await this.x(this.state);
          }
        }
        async x(e) {}
        async applyUpdate() {
          this.k.trace("update#applyUpdate, state = ", this.state.type);
          if (this.state.type === "downloaded") {
            await this.y();
          }
        }
        async y() {}
        quitAndInstall() {
          this.k.trace("update#quitAndInstall, state = ", this.state.type);
          if (this.state.type === "ready") {
            this.k.trace("update#quitAndInstall(): before lifecycle quit()");
            this.g.quit(true).then(e => {
              this.k.trace(`update#quitAndInstall(): after lifecycle quit() with veto: ${e}`);
              if (!e) {
                this.k.trace("update#quitAndInstall(): running raw#quitAndInstall()");
                this.A();
              }
            });
          }
          return Promise.resolve(undefined);
        }
        async isLatestVersion() {
          if (!this.a) {
            return;
          }
          if (this.h.getValue("update.mode") === "none") {
            return false;
          }
          for (const i of [this.a]) {
            if (i) {
              try {
                const s = await this.j.request({
                  url: i
                }, We.None);
                if (!Fh(s)) {
                  throw new Error("Server returned " + s.res.statusCode);
                }
                return s.res.statusCode === 204;
              } catch (s) {
                this.k.error("update#isLatestVersion(): failed to check for updates");
                this.k.error(s);
                return;
              }
            }
          }
        }
        async _applySpecificUpdate(e) {}
        z() {
          return 1;
        }
        A() {}
        B(e, i, s, r = false) {
          const n = s.nameShort.replace(/ /g, "-").toLowerCase();
          const o = this.getReleaseTrack();
          const a = `${s.updateUrl}/api/update/${e}/${n}/${s.version}/${this.b}/${o}`;
          this.k.info("updateURL", a);
          return a;
        }
        C() {
          if (!this.a) {
            return;
          }
          const e = new URL(this.a);
          e.searchParams.set("isOutdatedCheck", "1");
          return e.toString();
        }
        D() {
          if (!this.a) {
            return;
          }
          const e = new URL(this.a);
          e.searchParams.set("forceUpdate", "1");
          return e.toString();
        }
        E(e) {
          if (e) {
            return new URL(e).searchParams.get("forceUpdate") === "1";
          } else {
            return false;
          }
        }
        getReleaseTrack() {
          try {
            const e = this.h.getValue("update.releaseTrack");
            if (PI(e)) {
              return e;
            }
            this.k.warn("unknown release track", e);
          } catch (e) {
            this.k.warn("could not fetch release track - using default", e);
          }
          return "stable";
        }
        F() {
          try {
            if (a6.existsSync(this.G())) {
              a6.unlinkSync(this.G());
            }
          } catch (e) {
            this.k.error("Failed to check for legacy shouldUpdate file", e);
          }
        }
        G() {
          const e = this.l.dataFolderName ?? ".cursor";
          return xI.join(DI.homedir(), e, "shouldUpdate");
        }
      };
      Ho = __decorate([__param(0, Te), __param(1, Je), __param(2, ot), __param(3, Sn), __param(4, V), __param(5, Ve)], Ho);
    }
  });
  import * as Ms from "electron";
  var Mr;
  var $I = g({
    "out-build/vs/platform/update/electron-main/updateService.darwin.js"() {
      "use strict";
  
      sn();
      B();
      er();
      M();
      Ke();
      vt();
      ct();
      X();
      ht();
      En();
      xt();
      Lr();
      Vg();
      Mr = class extends Ho {
        get K() {
          return x.fromNodeEventEmitter(Ms.autoUpdater, "error", (e, i) => i);
        }
        get L() {
          return x.fromNodeEventEmitter(Ms.autoUpdater, "update-not-available");
        }
        get M() {
          return x.fromNodeEventEmitter(Ms.autoUpdater, "update-available");
        }
        get N() {
          return x.fromNodeEventEmitter(Ms.autoUpdater, "update-downloaded", (e, i, s, r) => ({
            version: s,
            productVersion: s,
            timestamp: r
          }));
        }
        constructor(e, i, s, r, n, o, a, c) {
          super(i, s, n, o, a, c);
          this.b = e;
          this.Q = r;
          this.J = new De();
          this.O = false;
          i.setRelaunchHandler(this);
        }
        handleRelaunch(e) {
          if (e?.addArgs || e?.removeArgs || this.state.type !== "ready") {
            return false;
          } else {
            this.k.trace("update#handleRelaunch(): running raw#quitAndInstall()");
            this.A();
            return true;
          }
        }
        async m() {
          await super.m();
          this.K(this.S, this, this.J);
          this.M(this.Y, this, this.J);
          this.N(this.Z, this, this.J);
          this.L(this.$, this, this.J);
        }
        S(e) {
          this.k.info("UpdateService onError()");
          if (!this.O) {
            this.Q.publicLog2("update:error", {
              messageHash: String(Ds(String(e)))
            });
          }
          this.k.error("UpdateService (using backup url: " + this.O + ") error:", e);
          const i = this.state.type === "checking for updates" && this.state.explicit ? e : undefined;
          this.f(fe.Idle(1, i));
        }
        H(e, i = false) {
          let s;
          if (this.l.darwinUniversalAssetId) {
            s = this.l.darwinUniversalAssetId;
          } else {
            s = process.arch === "x64" ? "darwin" : "darwin-arm64";
          }
          const r = this.B(s, e, this.l, i);
          if (i) {
            return r;
          }
          try {
            Ms.autoUpdater.setFeedURL({
              url: r
            });
          } catch (n) {
            this.k.error("Failed to set update feed URL", n);
            return;
          }
          return r;
        }
        s() {
          if (this.state.type === "ready") {
            return this.state.update?.version;
          } else {
            return undefined;
          }
        }
        async t(e) {
          const i = await Rc(e);
          if (i?.url) {
            return i.name;
          } else {
            return undefined;
          }
        }
        u(e, i) {
          if (!i) {
            const s = this.D();
            if (s) {
              Ms.autoUpdater.setFeedURL({
                url: s
              });
              this.I(false);
              return;
            }
          }
          this.f(fe.Idle(1));
        }
        I(e) {
          this.f(fe.CheckingForUpdates(e));
          Ms.autoUpdater.checkForUpdates();
        }
        Y() {
          this.k.info("UpdateService onUpdateAvailable()");
          if (this.state.type === "checking for updates") {
            this.f(fe.Downloading);
          }
        }
        Z(e) {
          this.k.info("UpdateService onUpdateDownloaded()");
          if (this.state.type === "downloading") {
            if (this.E(Ms.autoUpdater.getFeedURL()) && this.a) {
              this.k.info("update#onUpdateDownloaded() - canceled outdated update");
              Ms.autoUpdater.setFeedURL({
                url: this.a
              });
              this.f(fe.Idle(1));
              return;
            }
            this.f(fe.Downloaded(e));
            this.Q.publicLog2("update:downloaded", {
              version: e.version
            });
            this.f(fe.Ready(e));
            this.r();
          }
        }
        $() {
          this.k.info("UpdateService onUpdateNotAvailable()");
          if (this.state.type === "checking for updates") {
            this.Q.publicLog2("update:notAvailable", {
              explicit: this.state.explicit
            });
            this.f(fe.Idle(1));
          }
        }
        A() {
          this.k.info("UpdateService doQuitAndInstall()");
          this.k.trace("update#quitAndInstall(): running raw#quitAndInstall()");
          Ms.autoUpdater.quitAndInstall();
        }
        dispose() {
          this.J.dispose();
        }
      };
      __decorate([de], Mr.prototype, "K", null);
      __decorate([de], Mr.prototype, "L", null);
      __decorate([de], Mr.prototype, "M", null);
      __decorate([de], Mr.prototype, "N", null);
      Mr = __decorate([__param(1, Te), __param(2, Je), __param(3, Ot), __param(4, ot), __param(5, Sn), __param(6, V), __param(7, Ve)], Mr);
    }
  });
  import { spawn as II } from "node:child_process";
  var Xh;
  var AI = g({
    "out-build/vs/platform/update/electron-main/updateService.linux.js"() {
      "use strict";
  
      At();
      Ke();
      vt();
      ct();
      X();
      Nc();
      ht();
      En();
      Lr();
      xt();
      Vg();
      we();
      Xh = class extends Ho {
        constructor(e, i, s, r, n, o, a, c, l) {
          super(i, s, n, o, a, l);
          this.b = e;
          this.K = r;
          this.L = c;
          i.setRelaunchHandler(this);
        }
        H(e, i = false) {
          return this.B(`linux-${process.arch}`, e, this.l, i);
        }
        N() {
          return process.env.APPIMAGE !== undefined;
        }
        handleRelaunch(e) {
          if (e?.addArgs || e?.removeArgs || this.state.type !== "ready") {
            return false;
          } else {
            this.k.trace("update#handleRelaunch(): running raw#quitAndInstall()");
            if (this.N()) {
              this.A();
              return true;
            } else {
              this.k.info("Not running in an appimage; cannot auto-update");
              return false;
            }
          }
        }
        async O(e, i) {
          try {
            const s = await this.j.request({
              url: i
            }, We.None);
            const r = await Rc(s);
            if (!r || !r.url || !r.version || !r.productVersion) {
              this.K.publicLog2("update:notAvailable", {
                explicit: !!e
              });
              this.f(fe.Idle(1));
              return false;
            } else {
              this.a = i;
              this.r();
              if (this.N()) {
                this.f(fe.Ready(r));
              } else {
                this.f(fe.AvailableForDownload(r));
              }
              return true;
            }
          } catch (s) {
            this.k.error(s);
            const r = e ? s.message || s : undefined;
            this.f(fe.Idle(1, r));
            return false;
          }
        }
        s() {
          if (this.state.type === "ready") {
            return this.state.update?.version;
          } else {
            return undefined;
          }
        }
        async t(e) {
          const i = await Rc(e);
          if (i?.url) {
            return i.version;
          } else {
            return undefined;
          }
        }
        u(e, i) {
          this.f(fe.Idle(1));
        }
        async I(e) {
          this.k.debug("UpdateService: doCheckForUpdates");
          this.f(fe.CheckingForUpdates(e));
          for (const i of [this.a]) {
            if (i) {
              try {
                if (await this.O(e, i)) {
                  return;
                }
              } catch (s) {
                this.k.error("Failed to check for updates:", s);
              }
            }
          }
        }
        async x(e) {
          if (this.l.downloadUrl && this.l.downloadUrl.length > 0) {
            this.L.openExternal(undefined, this.l.downloadUrl);
          } else if (e.update.url) {
            this.L.openExternal(undefined, e.update.url);
          }
          this.f(fe.Idle(1));
        }
        A() {
          if (this.state.type !== "ready") {
            this.k.info("update#quitAndInstall(): Not ready; skippingupdate");
            return;
          } else if (this.N()) {
            if (!this.state.update?.url) {
              this.k.warn("update#quitAndInstall(): No update url; skipping update");
              return;
            }
          } else {
            this.k.info("update#quitAndInstall(): Unsupported installer type; skipping update");
            return;
          }
          const e = process.env.APPIMAGE;
          this.k.debug("update#quitAndInstall(): updating appImage at " + e);
          const s = `${F(process.resourcesPath, "appimageupdatetool.AppImage")} -u "zsync|${this.state.update.url}" -O "${e}"; ${e} &`;
          this.k.info("update#quitAndInstall(): starting updater with command " + s);
          II(s, {
            detached: true,
            stdio: "inherit",
            shell: true
          });
        }
      };
      Xh = __decorate([__param(1, Te), __param(2, Je), __param(3, Ot), __param(4, ot), __param(5, Sn), __param(6, V), __param(7, Or), __param(8, Ve)], Xh);
    }
  });
  import { spawn as CI } from "child_process";
  import { realpath as _I, watch as RI } from "fs";
  var Qh;
  var ed;
  var OI = g({
    "out-build/vs/platform/update/electron-main/updateService.snap.js"() {
      "use strict";
  
      ce();
      B();
      we();
      vt();
      ct();
      X();
      xt();
      Lr();
      Qh = class {
        get state() {
          return this.a;
        }
        d(e) {
          this.g.info("update#setState", e.type);
          this.a = e;
          this.b.fire(e);
        }
        constructor(e, i, s) {
          this.f = e;
          this.g = s;
          this.a = fe.Uninitialized;
          this.b = new $();
          this.onStateChange = this.b.event;
          if (i.disableUpdates) {
            this.g.info("update#ctor - updates are disabled");
            return;
          }
          this.d(fe.Idle(this.k()));
          this.h(30000).then(undefined, r => this.g.error(r));
        }
        h(e = 3600000) {
          return wi(e).then(() => this.checkForUpdates(false)).then(() => this.h(3600000));
        }
        async checkForUpdates(e) {
          this.g.trace("update#checkForUpdates, state = ", this.state.type);
          if (this.state.type === "idle") {
            this.m(e);
          }
        }
        async downloadUpdate() {
          this.g.trace("update#downloadUpdate, state = ", this.state.type);
          if (this.state.type === "available for download") {
            await this.i(this.state);
          }
        }
        i(e) {
          return Promise.resolve(undefined);
        }
        async applyUpdate() {
          this.g.trace("update#applyUpdate, state = ", this.state.type);
          if (this.state.type === "downloaded") {
            await this.j();
          }
        }
        j() {
          return Promise.resolve(undefined);
        }
        quitAndInstall() {
          this.g.trace("update#quitAndInstall, state = ", this.state.type);
          if (this.state.type === "ready") {
            this.g.trace("update#quitAndInstall(): before lifecycle quit()");
            this.f.quit(true).then(e => {
              this.g.trace(`update#quitAndInstall(): after lifecycle quit() with veto: ${e}`);
              if (!e) {
                this.g.trace("update#quitAndInstall(): running raw#quitAndInstall()");
                this.l();
              }
            });
          }
          return Promise.resolve(undefined);
        }
        k() {
          return 2;
        }
        l() {}
        async _applySpecificUpdate(e) {}
      };
      Qh = __decorate([__param(0, Te), __param(1, ot), __param(2, V)], Qh);
      ed = class extends Qh {
        constructor(e, i, s, r, n, o) {
          super(s, r, n);
          this.o = e;
          this.p = i;
          this.q = o;
          const a = RI(Xe(this.o));
          const c = x.fromNodeEventEmitter(a, "change", (f, p) => p);
          const l = x.filter(c, f => f === "current");
          const d = x.debounce(l, (f, p) => p, 2000)(() => this.checkForUpdates(false));
          s.onWillShutdown(() => {
            d.dispose();
            a.close();
          });
        }
        m() {
          this.d(fe.CheckingForUpdates(false));
          this.u().then(e => {
            if (e) {
              this.d(fe.Ready({
                version: "something"
              }));
            } else {
              this.q.publicLog2("update:notAvailable", {
                explicit: false
              });
              this.d(fe.Idle(2));
            }
          }, e => {
            this.g.error(e);
            this.q.publicLog2("update:notAvailable", {
              explicit: false
            });
            this.d(fe.Idle(2, e.message || e));
          });
        }
        l() {
          this.g.trace("update#quitAndInstall(): running raw#quitAndInstall()");
          CI("sleep 3 && " + Ue(process.argv[0]), {
            shell: true,
            detached: true,
            stdio: "ignore"
          });
        }
        async u() {
          const e = await new Promise((s, r) => _I(`${Xe(this.o)}/current`, (n, o) => n ? r(n) : s(o)));
          const i = Ue(e);
          return this.p !== i;
        }
        isLatestVersion() {
          return this.u().then(undefined, e => {
            this.g.error("update#checkForSnapUpdate(): Could not get realpath of application.");
          });
        }
      };
      ed = __decorate([__param(2, Te), __param(3, ot), __param(4, V), __param(5, Ot)], ed);
    }
  });
  import * as LI from "crypto";
  import * as MI from "fs";
  async function FI(t, e) {
    if ((await new Promise((r, n) => {
      const o = MI.createReadStream(t);
      const a = LI.createHash("sha256");
      o.pipe(a);
      const c = jl((l, u) => {
        o.removeAllListeners();
        a.removeAllListeners();
        if (l) {
          n(l);
        } else {
          r(u);
        }
      });
      o.once("error", c);
      o.once("end", c);
      a.once("error", c);
      a.once("data", l => c(undefined, l.toString("hex")));
    })) !== e) {
      throw new Error("Hash mismatch");
    }
  }
  var NI = g({
    "out-build/vs/base/node/crypto.js"() {
      "use strict";
  
      Ul();
    }
  });
  import { spawn as l6 } from "child_process";
  import * as td from "fs";
  import { tmpdir as WI } from "os";
  async function TI(t, e = 1000) {
    while (!t()) {
      await wi(e);
    }
  }
  function In() {
    if (typeof id === "undefined") {
      id = [F(Xe(process.execPath), "unins000.exe"), F(Xe(process.execPath), "Uninstall Cursor.exe"), F(Xe(process.execPath), "Uninstall Cursor Nightly.exe"), F(Xe(process.execPath), "Uninstall Cursor Lab.exe")].find(i => {
        try {
          return td.existsSync(i);
        } catch {
          return false;
        }
      }) ? 0 : 1;
    }
    return id;
  }
  var id;
  var Vc;
  var jI = g({
    "out-build/vs/platform/update/electron-main/updateService.win32.js"() {
      "use strict";
  
      ce();
      At();
      sn();
      er();
      we();
      se();
      NI();
      _t();
      Ke();
      vt();
      He();
      ct();
      X();
      Nc();
      ht();
      En();
      xt();
      Lr();
      Vg();
      id = undefined;
      Vc = class extends Ho {
        get cachePath() {
          const e = Math.random().toString(36).substring(2, 15);
          const i = F(WI(), `vscode-${this.l.quality}-${this.l.target}-${process.arch}-${e}`);
          return td.promises.mkdir(i, {
            recursive: true
          }).then(() => i);
        }
        constructor(e, i, s, r, n, o, a, c, l, u) {
          super(i, s, n, o, a, u);
          this.b = e;
          this.L = r;
          this.M = c;
          this.N = l;
          i.setRelaunchHandler(this);
        }
        handleRelaunch(e) {
          if (e?.addArgs || e?.removeArgs || this.state.type !== "ready" || !this.J) {
            return false;
          } else {
            this.k.trace("update#handleRelaunch(): running raw#quitAndInstall()");
            this.A();
            return true;
          }
        }
        async m() {
          if (this.l.target === "user" && (await this.N.isAdmin(undefined))) {
            this.f(fe.Disabled(5));
            this.k.info("update#ctor - updates are disabled due to running as Admin in user setup");
            return;
          }
          await super.m();
        }
        H(e, i = false) {
          let s = `win32-${process.arch}`;
          if (In() === 1) {
            s += "-archive";
          } else if (this.l.target === "user") {
            s += "-user";
          }
          return this.B(s, e, this.l, i);
        }
        s() {
          if (this.state.type === "ready") {
            if (this.J?.updateFilePath) {
              return undefined;
            } else {
              return this.state.update?.version;
            }
          }
          if (this.state.type === "downloaded") {
            return this.state.update?.version;
          }
        }
        async t(e) {
          const i = await Rc(e);
          if (i?.url) {
            return i.version;
          } else {
            return undefined;
          }
        }
        u(e, i) {
          this.J = undefined;
          this.f(fe.Idle(In()));
        }
        I(e) {
          if (this.a) {
            this.f(fe.CheckingForUpdates(e));
            this.j.request({
              url: this.a
            }, We.None).then(Rc).then(i => {
              const s = In();
              if (!i || !i.url || !i.version || !i.productVersion) {
                this.L.publicLog2("update:notAvailable", {
                  explicit: !!e
                });
                this.f(fe.Idle(s));
                return Promise.resolve(null);
              } else if (s === 1) {
                this.f(fe.AvailableForDownload(i));
                return Promise.resolve(null);
              } else {
                this.f(fe.Downloading);
                return this.W(i.version).then(() => this.V(i.version).then(r => ee.exists(r).then(n => {
                  if (n) {
                    return Promise.resolve(r);
                  }
                  const o = `${r}.tmp`;
                  return this.j.request({
                    url: i.url
                  }, We.None).then(a => {
                    if (!Fh(a)) {
                      throw new Error("Server returned " + a.res.statusCode);
                    }
                    if (M2(a)) {
                      throw new Error("Server returned no content");
                    }
                    return a;
                  }).then(a => this.M.writeFile(P.file(o), a.stream)).then(i.sha256hash ? () => FI(o, i.sha256hash) : () => {}).then(() => ee.rename(o, r, false)).then(() => r);
                })).then(r => {
                  this.J = {
                    packagePath: r
                  };
                  this.f(fe.Downloaded(i));
                  this.r();
                  if (this.h.getValue("update.enableWindowsBackgroundUpdates")) {
                    if (this.l.target === "user") {
                      this.y();
                    }
                  } else {
                    this.f(fe.Ready(i));
                  }
                }));
              }
            }).catch(i => {
              this.L.publicLog2("update:error", {
                messageHash: String(Ds(String(i)))
              });
              this.k.error(i);
              const s = e ? i.message || i : undefined;
              this.f(fe.Idle(In(), s));
            });
          }
        }
        async x(e) {
          if (e.update.url) {
            this.N.openExternal(undefined, e.update.url);
          }
          this.f(fe.Idle(In()));
        }
        async V(e) {
          const i = await this.cachePath;
          return F(i, `CodeSetup-${this.l.quality}-${e}.exe`);
        }
        async W(e = null) {
          const i = e ? o => !new RegExp(`${this.l.quality}-${e}\\.exe$`).test(o) : () => true;
          const s = await this.cachePath;
          const n = (await ee.readdir(s)).filter(i).map(async o => {
            try {
              await td.promises.unlink(F(s, o));
            } catch {}
          });
          await Promise.all(n);
        }
        async y() {
          if (this.state.type !== "downloaded" || !this.J) {
            return Promise.resolve(undefined);
          }
          const e = this.state.update;
          this.f(fe.Updating(e));
          const i = await this.cachePath;
          this.J.updateFilePath = F(i, `CodeSetup-${this.l.quality}-${e.version}.flag`);
          await ee.writeFile(this.J.updateFilePath, "flag");
          l6(this.J.packagePath, ["/verysilent", "/log", `/update="${this.J.updateFilePath}"`, "/nocloseapplications", "/mergetasks=runcode,!desktopicon,!quicklaunchicon"], {
            detached: true,
            stdio: ["ignore", "ignore", "ignore"],
            windowsVerbatimArguments: true
          }).once("exit", () => {
            this.J = undefined;
            this.f(fe.Idle(In()));
          });
          const r = `${this.l.win32MutexName}-ready`;
          const n = await import("@vscode/windows-mutex");
          TI(() => n.isActive(r)).then(() => {
            this.f(fe.Ready(e));
            if (this.l.target !== "user") {
              this.quitAndInstall();
            }
          });
        }
        A() {
          if (this.state.type === "ready" && !!this.J) {
            this.k.trace("update#quitAndInstall(): running raw#quitAndInstall()");
            if (this.J.updateFilePath) {
              td.unlinkSync(this.J.updateFilePath);
            } else {
              l6(this.J.packagePath, ["/silent", "/log", "/mergetasks=runcode,!desktopicon,!quicklaunchicon"], {
                detached: true,
                stdio: ["ignore", "ignore", "ignore"]
              });
            }
          }
        }
        z() {
          return In();
        }
        async _applySpecificUpdate(e) {
          if (this.state.type !== "idle") {
            return;
          }
          const i = this.h.getValue("update.enableWindowsBackgroundUpdates");
          const s = {
            version: "unknown",
            productVersion: "unknown"
          };
          this.f(fe.Downloading);
          this.J = {
            packagePath: e
          };
          this.f(fe.Downloaded(s));
          if (i) {
            if (this.l.target === "user") {
              this.y();
            }
          } else {
            this.f(fe.Ready(s));
          }
        }
      };
      __decorate([de], Vc.prototype, "cachePath", null);
      Vc = __decorate([__param(1, Te), __param(2, Je), __param(3, Ot), __param(4, ot), __param(5, Sn), __param(6, V), __param(7, at), __param(8, Or), __param(9, Ve)], Vc);
    }
  });
  var u6;
  var h6;
  var UI = g({
    "out-build/vs/platform/url/common/urlIpc.js"() {
      "use strict";
  
      se();
      u6 = class {
        constructor(t) {
          this.a = t;
        }
        handleURL(t, e) {
          return this.a.call("handleURL", [t.toJSON(), e]);
        }
      };
      h6 = class {
        constructor(t, e) {
          this.a = t;
          this.b = e;
        }
        async routeCall(t, e, i, s) {
          if (e !== "handleURL") {
            throw new Error(`Call not found: ${e}`);
          }
          if (Array.isArray(i) && i.length > 0) {
            const r = P.revive(i[0]);
            this.b.trace("URLHandlerRouter#routeCall() with URI argument", r.toString(true));
            if (r.query) {
              const n = /\bwindowId=(\d+)/.exec(r.query);
              if (n) {
                const o = n[1];
                this.b.trace(`URLHandlerRouter#routeCall(): found windowId query parameter with value "${o}"`, r.toString(true));
                const a = new RegExp(`window:${o}`);
                const c = t.connections.find(l => {
                  this.b.trace("URLHandlerRouter#routeCall(): testing connection", l.ctx);
                  return a.test(l.ctx);
                });
                if (c) {
                  this.b.trace("URLHandlerRouter#routeCall(): found a connection to route", r.toString(true));
                  return c;
                }
                this.b.trace("URLHandlerRouter#routeCall(): did not find a connection to route", r.toString(true));
              } else {
                this.b.trace("URLHandlerRouter#routeCall(): did not find windowId query parameter", r.toString(true));
              }
            }
          } else {
            this.b.trace("URLHandlerRouter#routeCall() without URI argument");
          }
          return this.a.routeCall(t, e, i, s);
        }
        routeEvent(t, e) {
          throw new Error(`Event not found: ${e}`);
        }
      };
    }
  });
  var d6;
  var sd;
  var BI = g({
    "out-build/vs/platform/url/common/urlService.js"() {
      "use strict";
  
      ce();
      M();
      se();
      ht();
      d6 = class extends T {
        constructor() {
          super(...arguments);
          this.a = new Set();
        }
        open(t, e) {
          const i = [...this.a.values()];
          return sk(i.map(s => () => s.handleURL(t, e)), undefined, false).then(s => s || false);
        }
        registerHandler(t) {
          this.a.add(t);
          return xe(() => this.a.delete(t));
        }
      };
      sd = class extends d6 {
        constructor(e) {
          super();
          this.b = e;
        }
        create(e) {
          let {
            authority: i,
            path: s,
            query: r,
            fragment: n
          } = e || {
            authority: undefined,
            path: undefined,
            query: undefined,
            fragment: undefined
          };
          if (i && s && s.indexOf("/") !== 0) {
            s = `/${s}`;
          }
          return P.from({
            scheme: this.b.urlProtocol,
            authority: i,
            path: s,
            query: r,
            fragment: n
          });
        }
      };
      sd = __decorate([__param(0, Ve)], sd);
    }
  });
  import { app as f6 } from "electron";
  var p6;
  var qI = g({
    "out-build/vs/platform/url/electron-main/electronUrlListener.js"() {
      "use strict";
  
      ce();
      B();
      M();
      H();
      se();
      p6 = class extends T {
        constructor(t, e, i, s, r, n) {
          super();
          this.c = e;
          this.f = n;
          this.a = [];
          this.b = 0;
          if (t) {
            n.trace("ElectronURLListener initialUrisToHandle:", t.map(c => c.originalUrl));
            this.a = t;
          }
          if (j) {
            const c = s.isBuilt ? [] : [`"${s.appRoot}"`];
            c.push("--open-url", "--");
            f6.setAsDefaultProtocolClient(r.urlProtocol, process.execPath, c);
          }
          const o = x.map(x.fromNodeEventEmitter(f6, "open-url", (c, l) => ({
            event: c,
            url: l
          })), ({
            event: c,
            url: l
          }) => {
            c.preventDefault();
            return l;
          });
          this.D(o(c => {
            const l = this.g(c);
            if (l) {
              this.c.open(l, {
                originalUrl: c
              });
            }
          }));
          if (i.getWindows().filter(c => c.isReady).length > 0) {
            n.trace("ElectronURLListener: window is ready to handle URLs");
            this.h();
          } else {
            n.trace("ElectronURLListener: waiting for window to be ready to handle URLs...");
            this.D(x.once(i.onDidSignalReadyWindow)(() => this.h()));
          }
        }
        g(t) {
          try {
            return P.parse(t);
          } catch {
            return;
          }
        }
        async h() {
          if (this.b++ > 10) {
            this.f.trace("ElectronURLListener#flush(): giving up after 10 retries");
            return;
          }
          this.f.trace("ElectronURLListener#flush(): flushing URLs");
          const t = [];
          for (const e of this.a) {
            if (await this.c.open(e.uri, {
              originalUrl: e.originalUrl
            })) {
              this.f.trace("ElectronURLListener#flush(): URL was handled", e.originalUrl);
            } else {
              this.f.trace("ElectronURLListener#flush(): URL was not yet handled", e.originalUrl);
              t.push(e);
            }
          }
          if (t.length !== 0) {
            this.a = t;
            ik(() => this.h(), 500, this.B);
          }
        }
      };
    }
  });
  var Gg;
  var zI = g({
    "out-build/vs/platform/webview/common/webviewManagerService.js"() {
      "use strict";
  
      Y();
      Gg = q("webviewManagerService");
    }
  });
  import { protocol as HI } from "electron";
  var g6;
  var VI = g({
    "out-build/vs/platform/webview/electron-main/webviewProtocolProvider.js"() {
      "use strict";
  
      M();
      Ie();
      se();
      g6 = class lS extends T {
        static {
          this.a = new Map([["/index.html", "index.html"], ["/fake.html", "fake.html"], ["/service-worker.js", "service-worker.js"]]);
        }
        constructor() {
          super();
          const e = this.b.bind(this);
          HI.registerFileProtocol(R.vscodeWebview, e);
        }
        b(e, i) {
          try {
            const s = P.parse(e.url);
            const r = lS.a.get(s.path);
            if (typeof r == "string") {
              const n = `vs/workbench/contrib/webview/browser/pre/${r}`;
              const o = Ct.asFileUri(n);
              return i({
                path: o.fsPath,
                headers: {
                  ...Ha.getHeadersFromQuery(e.url),
                  "Cross-Origin-Resource-Policy": "cross-origin"
                }
              });
            } else {
              return i({
                error: -10
              });
            }
          } catch {}
          return i({
            error: -2
          });
        }
      };
    }
  });
  import { webContents as GI } from "electron";
  var rd;
  var JI = g({
    "out-build/vs/platform/webview/electron-main/webviewMainService.js"() {
      "use strict";
  
      B();
      M();
      VI();
      Lt();
      rd = class extends T {
        constructor(e) {
          super();
          this.b = e;
          this.a = this.D(new $());
          this.onFoundInFrame = this.a.event;
          this.D(new g6());
        }
        async setIgnoreMenuShortcuts(e, i) {
          let s;
          if (typeof e.windowId == "number") {
            const {
              windowId: r
            } = e;
            const n = this.b.getWindowById(r);
            if (!n?.win) {
              throw new Error(`Invalid windowId: ${r}`);
            }
            s = n.win.webContents;
          } else {
            const {
              webContentsId: r
            } = e;
            s = GI.fromId(r);
            if (!s) {
              throw new Error(`Invalid webContentsId: ${r}`);
            }
          }
          if (!s.isDestroyed()) {
            s.setIgnoreMenuShortcuts(i);
          }
        }
        async findInFrame(e, i, s, r) {
          const o = this.c(e, i);
          if (typeof o.findInFrame == "function") {
            o.findInFrame(s, {
              findNext: r.findNext,
              forward: r.forward
            });
            const a = (c, l) => {
              if (l.finalUpdate) {
                this.a.fire(l);
                o.removeListener("found-in-frame", a);
              }
            };
            o.on("found-in-frame", a);
          }
        }
        async stopFindInFrame(e, i, s) {
          const n = this.c(e, i);
          if (typeof n.stopFindInFrame == "function") {
            n.stopFindInFrame(s.keepSelection ? "keepSelection" : "clearSelection");
          }
        }
        c(e, i) {
          const s = this.b.getWindowById(e.windowId);
          if (!s?.win) {
            throw new Error(`Invalid windowId: ${e}`);
          }
          const r = s.win.webContents.mainFrame.framesInSubtree.find(n => n.name === i);
          if (!r) {
            throw new Error(`Unknown frame: ${i}`);
          }
          return r;
        }
      };
      rd = __decorate([__param(0, dt)], rd);
    }
  });
  async function KI(t, e, i) {
    let s = i && i.get("storage.serviceMachineId", -1) || null;
    if (s) {
      return s;
    }
    try {
      const n = (await e.readFile(t.serviceMachineIdResource)).value.toString();
      s = Vk(n) ? n : null;
    } catch {
      s = null;
    }
    if (!s) {
      s = ti();
      try {
        await e.writeFile(t.serviceMachineIdResource, z.fromString(s));
      } catch {}
    }
    i?.store("storage.serviceMachineId", s, -1, 1);
    return s;
  }
  var ZI = g({
    "out-build/vs/platform/externalServices/common/serviceMachineId.js"() {
      "use strict";
  
      Ze();
      _i();
    }
  });
  async function YI(t, e, i, s, r, n) {
    const o = {
      "X-Market-Client-Id": `${Jg(t)} ${m6(t)}`,
      "User-Agent": `${Jg(t)} ${m6(t)} (${XI(t)})`
    };
    if (Q2(t, e) && Bg(i) === 3) {
      const a = await KI(e, s, r);
      o["X-Market-User-Id"] = a;
      o[`${Jg(t)}-SessionId`] = n.machineId || a;
    }
    return o;
  }
  function Jg(t) {
    if (t.extensionsGallery?.galleryId === "vscode" || t.extensionsGallery?.galleryId === "cursor") {
      return "VSCode";
    } else {
      return "Cursor";
    }
  }
  function m6(t) {
    return t.vscodeVersion;
  }
  function XI(t) {
    if (t.extensionsGallery?.galleryId === "vscode" || t.extensionsGallery?.galleryId === "cursor") {
      return "Code";
    } else {
      return t.nameShort;
    }
  }
  var QI = g({
    "out-build/vs/platform/externalServices/common/marketplace.js"() {
      "use strict";
  
      ZI();
      $n();
    }
  });
  function h(t, e) {
    if (wt(e)) {
      const i = Kg[e];
      if (i === undefined) {
        throw new Error(`${t} references an unknown codicon: ${e}`);
      }
      e = i;
    }
    Kg[t] = e;
    return {
      id: t
    };
  }
  var Kg;
  var w6 = g({
    "out-build/vs/base/common/codiconsUtil.js"() {
      "use strict";
  
      _e();
      Kg = Object.create(null);
    }
  });
  var v6;
  var eA = g({
    "out-build/vs/base/common/codiconsLibrary.js"() {
      "use strict";
  
      w6();
      v6 = {
        semantic: h("semantic", 62000),
        githubCopilot: h("github-copilot", 62001),
        plusCircle: h("plus-circle", 62002),
        smileySad: h("smiley-sad", 62003),
        smileyHappy: h("smiley-happy", 62004),
        smileyMedium: h("smiley-medium", 62005),
        sparkleStrikethrough: h("sparkle-strikethrough", 62006),
        keyPlusSparkle: h("key-plus-sparkle", 62007),
        paperclip: h("paperclip", 60500),
        atSign: h("at-sign", 60501),
        image: h("image", 60502),
        logo: h("logo", 60503),
        sparkleTwo: h("sparkle-two", 60504),
        logoSlash: h("logo-slash", 60505),
        add: h("add", 60000),
        plus: h("plus", 60000),
        gistNew: h("gist-new", 60000),
        repoCreate: h("repo-create", 60000),
        lightbulb: h("lightbulb", 60001),
        lightBulb: h("light-bulb", 60001),
        repo: h("repo", 60002),
        repoDelete: h("repo-delete", 60002),
        gistFork: h("gist-fork", 60003),
        repoForked: h("repo-forked", 60003),
        gitPullRequest: h("git-pull-request", 60004),
        gitPullRequestAbandoned: h("git-pull-request-abandoned", 60004),
        recordKeys: h("record-keys", 60005),
        keyboard: h("keyboard", 60005),
        tag: h("tag", 60006),
        gitPullRequestLabel: h("git-pull-request-label", 60006),
        tagAdd: h("tag-add", 60006),
        tagRemove: h("tag-remove", 60006),
        person: h("person", 60007),
        personFollow: h("person-follow", 60007),
        personOutline: h("person-outline", 60007),
        personFilled: h("person-filled", 60007),
        gitBranch: h("git-branch", 60008),
        gitBranchCreate: h("git-branch-create", 60008),
        gitBranchDelete: h("git-branch-delete", 60008),
        sourceControl: h("source-control", 60008),
        mirror: h("mirror", 60009),
        mirrorPublic: h("mirror-public", 60009),
        star: h("star", 60010),
        starAdd: h("star-add", 60010),
        starDelete: h("star-delete", 60010),
        starEmpty: h("star-empty", 60010),
        comment: h("comment", 60011),
        commentAdd: h("comment-add", 60011),
        alert: h("alert", 60012),
        warning: h("warning", 60012),
        search: h("search", 60013),
        searchSave: h("search-save", 60013),
        logOut: h("log-out", 60014),
        signOut: h("sign-out", 60014),
        logIn: h("log-in", 60015),
        signIn: h("sign-in", 60015),
        eye: h("eye", 60016),
        eyeUnwatch: h("eye-unwatch", 60016),
        eyeWatch: h("eye-watch", 60016),
        circleFilled: h("circle-filled", 60017),
        primitiveDot: h("primitive-dot", 60017),
        closeDirty: h("close-dirty", 60017),
        debugBreakpoint: h("debug-breakpoint", 60017),
        debugBreakpointDisabled: h("debug-breakpoint-disabled", 60017),
        debugHint: h("debug-hint", 60017),
        terminalDecorationSuccess: h("terminal-decoration-success", 60017),
        primitiveSquare: h("primitive-square", 60018),
        edit: h("edit", 60019),
        pencil: h("pencil", 60019),
        info: h("info", 60020),
        issueOpened: h("issue-opened", 60020),
        gistPrivate: h("gist-private", 60021),
        gitForkPrivate: h("git-fork-private", 60021),
        lock: h("lock", 60021),
        mirrorPrivate: h("mirror-private", 60021),
        close: h("close", 60022),
        removeClose: h("remove-close", 60022),
        x: h("x", 60022),
        repoSync: h("repo-sync", 60023),
        sync: h("sync", 60023),
        clone: h("clone", 60024),
        desktopDownload: h("desktop-download", 60024),
        beaker: h("beaker", 60025),
        microscope: h("microscope", 60025),
        vm: h("vm", 60026),
        deviceDesktop: h("device-desktop", 60026),
        file: h("file", 60027),
        fileText: h("file-text", 60027),
        more: h("more", 60028),
        ellipsis: h("ellipsis", 60028),
        kebabHorizontal: h("kebab-horizontal", 60028),
        mailReply: h("mail-reply", 60029),
        reply: h("reply", 60029),
        organization: h("organization", 60030),
        organizationFilled: h("organization-filled", 60030),
        organizationOutline: h("organization-outline", 60030),
        newFile: h("new-file", 60031),
        fileAdd: h("file-add", 60031),
        newFolder: h("new-folder", 60032),
        fileDirectoryCreate: h("file-directory-create", 60032),
        trash: h("trash", 60033),
        trashcan: h("trashcan", 60033),
        history: h("history", 60034),
        clock: h("clock", 60034),
        folder: h("folder", 60035),
        fileDirectory: h("file-directory", 60035),
        symbolFolder: h("symbol-folder", 60035),
        logoGithub: h("logo-github", 60036),
        markGithub: h("mark-github", 60036),
        github: h("github", 60036),
        terminal: h("terminal", 60037),
        console: h("console", 60037),
        repl: h("repl", 60037),
        zap: h("zap", 60038),
        symbolEvent: h("symbol-event", 60038),
        error: h("error", 60039),
        stop: h("stop", 60039),
        variable: h("variable", 60040),
        symbolVariable: h("symbol-variable", 60040),
        array: h("array", 60042),
        symbolArray: h("symbol-array", 60042),
        symbolModule: h("symbol-module", 60043),
        symbolPackage: h("symbol-package", 60043),
        symbolNamespace: h("symbol-namespace", 60043),
        symbolObject: h("symbol-object", 60043),
        symbolMethod: h("symbol-method", 60044),
        symbolFunction: h("symbol-function", 60044),
        symbolConstructor: h("symbol-constructor", 60044),
        symbolBoolean: h("symbol-boolean", 60047),
        symbolNull: h("symbol-null", 60047),
        symbolNumeric: h("symbol-numeric", 60048),
        symbolNumber: h("symbol-number", 60048),
        symbolStructure: h("symbol-structure", 60049),
        symbolStruct: h("symbol-struct", 60049),
        symbolParameter: h("symbol-parameter", 60050),
        symbolTypeParameter: h("symbol-type-parameter", 60050),
        symbolKey: h("symbol-key", 60051),
        symbolText: h("symbol-text", 60051),
        symbolReference: h("symbol-reference", 60052),
        goToFile: h("go-to-file", 60052),
        symbolEnum: h("symbol-enum", 60053),
        symbolValue: h("symbol-value", 60053),
        symbolRuler: h("symbol-ruler", 60054),
        symbolUnit: h("symbol-unit", 60054),
        activateBreakpoints: h("activate-breakpoints", 60055),
        archive: h("archive", 60056),
        arrowBoth: h("arrow-both", 60057),
        arrowDown: h("arrow-down", 60058),
        arrowLeft: h("arrow-left", 60059),
        arrowRight: h("arrow-right", 60060),
        arrowSmallDown: h("arrow-small-down", 60061),
        arrowSmallLeft: h("arrow-small-left", 60062),
        arrowSmallRight: h("arrow-small-right", 60063),
        arrowSmallUp: h("arrow-small-up", 60064),
        arrowUp: h("arrow-up", 60065),
        bell: h("bell", 60066),
        bold: h("bold", 60067),
        book: h("book", 60068),
        bookmark: h("bookmark", 60069),
        debugBreakpointConditionalUnverified: h("debug-breakpoint-conditional-unverified", 60070),
        debugBreakpointConditional: h("debug-breakpoint-conditional", 60071),
        debugBreakpointConditionalDisabled: h("debug-breakpoint-conditional-disabled", 60071),
        debugBreakpointDataUnverified: h("debug-breakpoint-data-unverified", 60072),
        debugBreakpointData: h("debug-breakpoint-data", 60073),
        debugBreakpointDataDisabled: h("debug-breakpoint-data-disabled", 60073),
        debugBreakpointLogUnverified: h("debug-breakpoint-log-unverified", 60074),
        debugBreakpointLog: h("debug-breakpoint-log", 60075),
        debugBreakpointLogDisabled: h("debug-breakpoint-log-disabled", 60075),
        briefcase: h("briefcase", 60076),
        broadcast: h("broadcast", 60077),
        browser: h("browser", 60078),
        bug: h("bug", 60079),
        calendar: h("calendar", 60080),
        caseSensitive: h("case-sensitive", 60081),
        check: h("check", 60082),
        checklist: h("checklist", 60083),
        chevronDown: h("chevron-down", 60084),
        chevronLeft: h("chevron-left", 60085),
        chevronRight: h("chevron-right", 60086),
        chevronUp: h("chevron-up", 60087),
        chromeClose: h("chrome-close", 60088),
        chromeMaximize: h("chrome-maximize", 60089),
        chromeMinimize: h("chrome-minimize", 60090),
        chromeRestore: h("chrome-restore", 60091),
        circleOutline: h("circle-outline", 60092),
        circle: h("circle", 60092),
        debugBreakpointUnverified: h("debug-breakpoint-unverified", 60092),
        terminalDecorationIncomplete: h("terminal-decoration-incomplete", 60092),
        circleSlash: h("circle-slash", 60093),
        circuitBoard: h("circuit-board", 60094),
        clearAll: h("clear-all", 60095),
        clippy: h("clippy", 60096),
        closeAll: h("close-all", 60097),
        cloudDownload: h("cloud-download", 60098),
        cloudUpload: h("cloud-upload", 60099),
        code: h("code", 60100),
        collapseAll: h("collapse-all", 60101),
        colorMode: h("color-mode", 60102),
        commentDiscussion: h("comment-discussion", 60103),
        creditCard: h("credit-card", 60105),
        dash: h("dash", 60108),
        dashboard: h("dashboard", 60109),
        database: h("database", 60110),
        debugContinue: h("debug-continue", 60111),
        debugDisconnect: h("debug-disconnect", 60112),
        debugPause: h("debug-pause", 60113),
        debugRestart: h("debug-restart", 60114),
        debugStart: h("debug-start", 60115),
        debugStepInto: h("debug-step-into", 60116),
        debugStepOut: h("debug-step-out", 60117),
        debugStepOver: h("debug-step-over", 60118),
        debugStop: h("debug-stop", 60119),
        debug: h("debug", 60120),
        deviceCameraVideo: h("device-camera-video", 60121),
        deviceCamera: h("device-camera", 60122),
        deviceMobile: h("device-mobile", 60123),
        diffAdded: h("diff-added", 60124),
        diffIgnored: h("diff-ignored", 60125),
        diffModified: h("diff-modified", 60126),
        diffRemoved: h("diff-removed", 60127),
        diffRenamed: h("diff-renamed", 60128),
        diff: h("diff", 60129),
        diffSidebyside: h("diff-sidebyside", 60129),
        discard: h("discard", 60130),
        editorLayout: h("editor-layout", 60131),
        emptyWindow: h("empty-window", 60132),
        exclude: h("exclude", 60133),
        extensions: h("extensions", 60134),
        eyeClosed: h("eye-closed", 60135),
        fileBinary: h("file-binary", 60136),
        fileCode: h("file-code", 60137),
        fileMedia: h("file-media", 60138),
        filePdf: h("file-pdf", 60139),
        fileSubmodule: h("file-submodule", 60140),
        fileSymlinkDirectory: h("file-symlink-directory", 60141),
        fileSymlinkFile: h("file-symlink-file", 60142),
        fileZip: h("file-zip", 60143),
        files: h("files", 60144),
        filter: h("filter", 60145),
        flame: h("flame", 60146),
        foldDown: h("fold-down", 60147),
        foldUp: h("fold-up", 60148),
        fold: h("fold", 60149),
        folderActive: h("folder-active", 60150),
        folderOpened: h("folder-opened", 60151),
        gear: h("gear", 60152),
        gift: h("gift", 60153),
        gistSecret: h("gist-secret", 60154),
        gist: h("gist", 60155),
        gitCommit: h("git-commit", 60156),
        gitCompare: h("git-compare", 60157),
        compareChanges: h("compare-changes", 60157),
        gitMerge: h("git-merge", 60158),
        githubAction: h("github-action", 60159),
        githubAlt: h("github-alt", 60160),
        globe: h("globe", 60161),
        grabber: h("grabber", 60162),
        graph: h("graph", 60163),
        gripper: h("gripper", 60164),
        heart: h("heart", 60165),
        home: h("home", 60166),
        horizontalRule: h("horizontal-rule", 60167),
        hubot: h("hubot", 60168),
        inbox: h("inbox", 60169),
        issueReopened: h("issue-reopened", 60171),
        issues: h("issues", 60172),
        italic: h("italic", 60173),
        jersey: h("jersey", 60174),
        json: h("json", 60175),
        kebabVertical: h("kebab-vertical", 60176),
        key: h("key", 60177),
        law: h("law", 60178),
        lightbulbAutofix: h("lightbulb-autofix", 60179),
        linkExternal: h("link-external", 60180),
        link: h("link", 60181),
        listOrdered: h("list-ordered", 60182),
        listUnordered: h("list-unordered", 60183),
        liveShare: h("live-share", 60184),
        loading: h("loading", 60185),
        location: h("location", 60186),
        mailRead: h("mail-read", 60187),
        mail: h("mail", 60188),
        markdown: h("markdown", 60189),
        megaphone: h("megaphone", 60190),
        mention: h("mention", 60191),
        milestone: h("milestone", 60192),
        gitPullRequestMilestone: h("git-pull-request-milestone", 60192),
        mortarBoard: h("mortar-board", 60193),
        move: h("move", 60194),
        multipleWindows: h("multiple-windows", 60195),
        mute: h("mute", 60196),
        noNewline: h("no-newline", 60197),
        note: h("note", 60198),
        octoface: h("octoface", 60199),
        openPreview: h("open-preview", 60200),
        package: h("package", 60201),
        paintcan: h("paintcan", 60202),
        pin: h("pin", 60203),
        play: h("play", 60204),
        run: h("run", 60204),
        plug: h("plug", 60205),
        preserveCase: h("preserve-case", 60206),
        preview: h("preview", 60207),
        project: h("project", 60208),
        pulse: h("pulse", 60209),
        question: h("question", 60210),
        quote: h("quote", 60211),
        radioTower: h("radio-tower", 60212),
        reactions: h("reactions", 60213),
        references: h("references", 60214),
        refresh: h("refresh", 60215),
        regex: h("regex", 60216),
        remoteExplorer: h("remote-explorer", 60217),
        remote: h("remote", 60218),
        remove: h("remove", 60219),
        replaceAll: h("replace-all", 60220),
        replace: h("replace", 60221),
        repoClone: h("repo-clone", 60222),
        repoForcePush: h("repo-force-push", 60223),
        repoPull: h("repo-pull", 60224),
        repoPush: h("repo-push", 60225),
        report: h("report", 60226),
        requestChanges: h("request-changes", 60227),
        rocket: h("rocket", 60228),
        rootFolderOpened: h("root-folder-opened", 60229),
        rootFolder: h("root-folder", 60230),
        rss: h("rss", 60231),
        ruby: h("ruby", 60232),
        saveAll: h("save-all", 60233),
        saveAs: h("save-as", 60234),
        save: h("save", 60235),
        screenFull: h("screen-full", 60236),
        screenNormal: h("screen-normal", 60237),
        searchStop: h("search-stop", 60238),
        server: h("server", 60240),
        settingsGear: h("settings-gear", 60241),
        settings: h("settings", 60242),
        shield: h("shield", 60243),
        smiley: h("smiley", 60244),
        sortPrecedence: h("sort-precedence", 60245),
        splitHorizontal: h("split-horizontal", 60246),
        splitVertical: h("split-vertical", 60247),
        squirrel: h("squirrel", 60248),
        starFull: h("star-full", 60249),
        starHalf: h("star-half", 60250),
        symbolClass: h("symbol-class", 60251),
        symbolColor: h("symbol-color", 60252),
        symbolConstant: h("symbol-constant", 60253),
        symbolEnumMember: h("symbol-enum-member", 60254),
        symbolField: h("symbol-field", 60255),
        symbolFile: h("symbol-file", 60256),
        symbolInterface: h("symbol-interface", 60257),
        symbolKeyword: h("symbol-keyword", 60258),
        symbolMisc: h("symbol-misc", 60259),
        symbolOperator: h("symbol-operator", 60260),
        symbolProperty: h("symbol-property", 60261),
        wrench: h("wrench", 60261),
        wrenchSubaction: h("wrench-subaction", 60261),
        symbolSnippet: h("symbol-snippet", 60262),
        tasklist: h("tasklist", 60263),
        telescope: h("telescope", 60264),
        textSize: h("text-size", 60265),
        threeBars: h("three-bars", 60266),
        thumbsdown: h("thumbsdown", 60267),
        thumbsup: h("thumbsup", 60268),
        tools: h("tools", 60269),
        triangleDown: h("triangle-down", 60270),
        triangleLeft: h("triangle-left", 60271),
        triangleRight: h("triangle-right", 60272),
        triangleUp: h("triangle-up", 60273),
        twitter: h("twitter", 60274),
        unfold: h("unfold", 60275),
        unlock: h("unlock", 60276),
        unmute: h("unmute", 60277),
        unverified: h("unverified", 60278),
        verified: h("verified", 60279),
        versions: h("versions", 60280),
        vmActive: h("vm-active", 60281),
        vmOutline: h("vm-outline", 60282),
        vmRunning: h("vm-running", 60283),
        watch: h("watch", 60284),
        whitespace: h("whitespace", 60285),
        wholeWord: h("whole-word", 60286),
        window: h("window", 60287),
        wordWrap: h("word-wrap", 60288),
        zoomIn: h("zoom-in", 60289),
        zoomOut: h("zoom-out", 60290),
        listFilter: h("list-filter", 60291),
        listFlat: h("list-flat", 60292),
        listSelection: h("list-selection", 60293),
        selection: h("selection", 60293),
        listTree: h("list-tree", 60294),
        debugBreakpointFunctionUnverified: h("debug-breakpoint-function-unverified", 60295),
        debugBreakpointFunction: h("debug-breakpoint-function", 60296),
        debugBreakpointFunctionDisabled: h("debug-breakpoint-function-disabled", 60296),
        debugStackframeActive: h("debug-stackframe-active", 60297),
        circleSmallFilled: h("circle-small-filled", 60298),
        debugStackframeDot: h("debug-stackframe-dot", 60298),
        terminalDecorationMark: h("terminal-decoration-mark", 60298),
        debugStackframe: h("debug-stackframe", 60299),
        debugStackframeFocused: h("debug-stackframe-focused", 60299),
        debugBreakpointUnsupported: h("debug-breakpoint-unsupported", 60300),
        symbolString: h("symbol-string", 60301),
        debugReverseContinue: h("debug-reverse-continue", 60302),
        debugStepBack: h("debug-step-back", 60303),
        debugRestartFrame: h("debug-restart-frame", 60304),
        debugAlt: h("debug-alt", 60305),
        callIncoming: h("call-incoming", 60306),
        callOutgoing: h("call-outgoing", 60307),
        menu: h("menu", 60308),
        expandAll: h("expand-all", 60309),
        feedback: h("feedback", 60310),
        gitPullRequestReviewer: h("git-pull-request-reviewer", 60310),
        groupByRefType: h("group-by-ref-type", 60311),
        ungroupByRefType: h("ungroup-by-ref-type", 60312),
        account: h("account", 60313),
        gitPullRequestAssignee: h("git-pull-request-assignee", 60313),
        bellDot: h("bell-dot", 60314),
        debugConsole: h("debug-console", 60315),
        library: h("library", 60316),
        output: h("output", 60317),
        runAll: h("run-all", 60318),
        syncIgnored: h("sync-ignored", 60319),
        pinned: h("pinned", 60320),
        githubInverted: h("github-inverted", 60321),
        serverProcess: h("server-process", 60322),
        serverEnvironment: h("server-environment", 60323),
        pass: h("pass", 60324),
        issueClosed: h("issue-closed", 60324),
        stopCircle: h("stop-circle", 60325),
        playCircle: h("play-circle", 60326),
        record: h("record", 60327),
        debugAltSmall: h("debug-alt-small", 60328),
        vmConnect: h("vm-connect", 60329),
        cloud: h("cloud", 60330),
        merge: h("merge", 60331),
        export: h("export", 60332),
        graphLeft: h("graph-left", 60333),
        magnet: h("magnet", 60334),
        notebook: h("notebook", 60335),
        redo: h("redo", 60336),
        checkAll: h("check-all", 60337),
        pinnedDirty: h("pinned-dirty", 60338),
        passFilled: h("pass-filled", 60339),
        circleLargeFilled: h("circle-large-filled", 60340),
        circleLarge: h("circle-large", 60341),
        circleLargeOutline: h("circle-large-outline", 60341),
        combine: h("combine", 60342),
        gather: h("gather", 60342),
        table: h("table", 60343),
        variableGroup: h("variable-group", 60344),
        typeHierarchy: h("type-hierarchy", 60345),
        typeHierarchySub: h("type-hierarchy-sub", 60346),
        typeHierarchySuper: h("type-hierarchy-super", 60347),
        gitPullRequestCreate: h("git-pull-request-create", 60348),
        runAbove: h("run-above", 60349),
        runBelow: h("run-below", 60350),
        notebookTemplate: h("notebook-template", 60351),
        debugRerun: h("debug-rerun", 60352),
        workspaceTrusted: h("workspace-trusted", 60353),
        workspaceUntrusted: h("workspace-untrusted", 60354),
        workspaceUnknown: h("workspace-unknown", 60355),
        terminalCmd: h("terminal-cmd", 60356),
        terminalDebian: h("terminal-debian", 60357),
        terminalLinux: h("terminal-linux", 60358),
        terminalPowershell: h("terminal-powershell", 60359),
        terminalTmux: h("terminal-tmux", 60360),
        terminalUbuntu: h("terminal-ubuntu", 60361),
        terminalBash: h("terminal-bash", 60362),
        arrowSwap: h("arrow-swap", 60363),
        copy: h("copy", 60364),
        personAdd: h("person-add", 60365),
        filterFilled: h("filter-filled", 60366),
        wand: h("wand", 60367),
        debugLineByLine: h("debug-line-by-line", 60368),
        inspect: h("inspect", 60369),
        layers: h("layers", 60370),
        layersDot: h("layers-dot", 60371),
        layersActive: h("layers-active", 60372),
        compass: h("compass", 60373),
        compassDot: h("compass-dot", 60374),
        compassActive: h("compass-active", 60375),
        azure: h("azure", 60376),
        issueDraft: h("issue-draft", 60377),
        gitPullRequestClosed: h("git-pull-request-closed", 60378),
        gitPullRequestDraft: h("git-pull-request-draft", 60379),
        debugAll: h("debug-all", 60380),
        debugCoverage: h("debug-coverage", 60381),
        runErrors: h("run-errors", 60382),
        folderLibrary: h("folder-library", 60383),
        debugContinueSmall: h("debug-continue-small", 60384),
        beakerStop: h("beaker-stop", 60385),
        graphLine: h("graph-line", 60386),
        graphScatter: h("graph-scatter", 60387),
        pieChart: h("pie-chart", 60388),
        bracket: h("bracket", 60175),
        bracketDot: h("bracket-dot", 60389),
        bracketError: h("bracket-error", 60390),
        lockSmall: h("lock-small", 60391),
        azureDevops: h("azure-devops", 60392),
        verifiedFilled: h("verified-filled", 60393),
        newline: h("newline", 60394),
        layout: h("layout", 60395),
        layoutActivitybarLeft: h("layout-activitybar-left", 60396),
        layoutActivitybarRight: h("layout-activitybar-right", 60397),
        layoutPanelLeft: h("layout-panel-left", 60398),
        layoutPanelCenter: h("layout-panel-center", 60399),
        layoutPanelJustify: h("layout-panel-justify", 60400),
        layoutPanelRight: h("layout-panel-right", 60401),
        layoutPanel: h("layout-panel", 60402),
        layoutSidebarLeft: h("layout-sidebar-left", 60403),
        layoutSidebarRight: h("layout-sidebar-right", 60404),
        layoutStatusbar: h("layout-statusbar", 60405),
        layoutMenubar: h("layout-menubar", 60406),
        layoutCentered: h("layout-centered", 60407),
        target: h("target", 60408),
        indent: h("indent", 60409),
        recordSmall: h("record-small", 60410),
        errorSmall: h("error-small", 60411),
        terminalDecorationError: h("terminal-decoration-error", 60411),
        arrowCircleDown: h("arrow-circle-down", 60412),
        arrowCircleLeft: h("arrow-circle-left", 60413),
        arrowCircleRight: h("arrow-circle-right", 60414),
        arrowCircleUp: h("arrow-circle-up", 60415),
        layoutSidebarRightOff: h("layout-sidebar-right-off", 60416),
        layoutPanelOff: h("layout-panel-off", 60417),
        layoutSidebarLeftOff: h("layout-sidebar-left-off", 60418),
        blank: h("blank", 60419),
        heartFilled: h("heart-filled", 60420),
        map: h("map", 60421),
        mapHorizontal: h("map-horizontal", 60421),
        foldHorizontal: h("fold-horizontal", 60421),
        mapFilled: h("map-filled", 60422),
        mapHorizontalFilled: h("map-horizontal-filled", 60422),
        foldHorizontalFilled: h("fold-horizontal-filled", 60422),
        circleSmall: h("circle-small", 60423),
        bellSlash: h("bell-slash", 60424),
        bellSlashDot: h("bell-slash-dot", 60425),
        commentUnresolved: h("comment-unresolved", 60426),
        gitPullRequestGoToChanges: h("git-pull-request-go-to-changes", 60427),
        gitPullRequestNewChanges: h("git-pull-request-new-changes", 60428),
        searchFuzzy: h("search-fuzzy", 60429),
        commentDraft: h("comment-draft", 60430),
        send: h("send", 60431),
        sparkle: h("sparkle", 60432),
        insert: h("insert", 60433),
        mic: h("mic", 60434),
        thumbsdownFilled: h("thumbsdown-filled", 60435),
        thumbsupFilled: h("thumbsup-filled", 60436),
        coffee: h("coffee", 60437),
        snake: h("snake", 60438),
        game: h("game", 60439),
        vr: h("vr", 60440),
        chip: h("chip", 60441),
        piano: h("piano", 60442),
        music: h("music", 60443),
        micFilled: h("mic-filled", 60444),
        repoFetch: h("repo-fetch", 60445),
        copilot: h("copilot", 60446),
        lightbulbSparkle: h("lightbulb-sparkle", 60447),
        robot: h("robot", 60448),
        sparkleFilled: h("sparkle-filled", 60449),
        diffSingle: h("diff-single", 60450),
        diffMultiple: h("diff-multiple", 60451),
        surroundWith: h("surround-with", 60452),
        share: h("share", 60453),
        gitStash: h("git-stash", 60454),
        gitStashApply: h("git-stash-apply", 60455),
        gitStashPop: h("git-stash-pop", 60456),
        vscode: h("vscode", 60457),
        vscodeInsiders: h("vscode-insiders", 60458),
        codeOss: h("code-oss", 60459),
        runCoverage: h("run-coverage", 60460),
        runAllCoverage: h("run-all-coverage", 60461),
        coverage: h("coverage", 60462),
        githubProject: h("github-project", 60463),
        mapVertical: h("map-vertical", 60464),
        foldVertical: h("fold-vertical", 60464),
        mapVerticalFilled: h("map-vertical-filled", 60465),
        foldVerticalFilled: h("fold-vertical-filled", 60465),
        goToSearch: h("go-to-search", 60466),
        percentage: h("percentage", 60467),
        sortPercentage: h("sort-percentage", 60467),
        attach: h("attach", 60468),
        goToEditingSession: h("go-to-editing-session", 60469),
        editSession: h("edit-session", 60470),
        codeReview: h("code-review", 60471),
        copilotWarning: h("copilot-warning", 60472),
        python: h("python", 60473),
        copilotLarge: h("copilot-large", 60474),
        copilotWarningLarge: h("copilot-warning-large", 60475),
        terminalTwo: h("terminal-two", 60800),
        checkTwo: h("check-two", 60801),
        xTwo: h("x-two", 60802),
        expander: h("expander", 60803),
        restore: h("restore", 60804),
        pinTwo: h("pin-two", 60805),
        stopTwo: h("stop-two", 60806),
        brain: h("brain", 60807),
        magnifyingGlass: h("magnifying-glass", 60808),
        imageTwo: h("image-two", 60809),
        microphone: h("microphone", 60810),
        submit: h("submit", 60811),
        running: h("running", 60812),
        fileAddTwo: h("file-add-two", 60813),
        infinity: h("infinity", 60814),
        editTwo: h("edit-two", 60815),
        stopThree: h("stop-three", 60816),
        warningTwo: h("warning-two", 60817),
        arrowLeftTwo: h("arrow-left-two", 60818),
        redoTwo: h("redo-two", 60819),
        infoTwo: h("info-two", 60820),
        chat: h("chat", 60821),
        thumbsDown: h("thumbs-down", 60822),
        thumbsUp: h("thumbs-up", 60823),
        thumbsDownFilled: h("thumbs-down-filled", 60824),
        thumbsUpFilled: h("thumbs-up-filled", 60825),
        copyTwo: h("copy-two", 60826),
        ellipsisTwo: h("ellipsis-two", 60827),
        eyeTwo: h("eye-two", 60828),
        globeTwo: h("globe-two", 60829),
        reload: h("reload", 60830),
        folderTwo: h("folder-two", 60831),
        eraser: h("eraser", 60832),
        swirlSparkle: h("swirl-sparkle", 60833),
        sendTwo: h("send-two", 60834),
        inboxTwo: h("inbox-two", 60835),
        fileTwo: h("file-two", 60836),
        list: h("list", 60837),
        calendarTwo: h("calendar-two", 60838),
        openNotebook: h("open-notebook", 60839),
        paperWords: h("paper-words", 60840),
        mortarboard: h("mortarboard", 60841),
        lightning: h("lightning", 60842),
        hammer: h("hammer", 60843),
        keyboardTwo: h("keyboard-two", 60844),
        arrowUpTwo: h("arrow-up-two", 60845),
        import: h("import", 60846),
        targetTwo: h("target-two", 60847),
        tab: h("tab", 60848),
        magic: h("magic", 60849),
        cloneTwo: h("clone-two", 60850),
        brush: h("brush", 60851),
        branch: h("branch", 60852),
        addTwo: h("add-two", 60853),
        historyTwo: h("history-two", 60854),
        cloudTwo: h("cloud-two", 60855),
        review: h("review", 60856),
        plusSquare: h("plus-square", 60857),
        checkCircled: h("check-circled", 60858),
        dottedCircle: h("dotted-circle", 60859),
        warnCircle: h("warn-circle", 60860),
        downLocalMachine: h("down-local-machine", 60861),
        mergeUpwards: h("merge-upwards", 60862),
        asterisk: h("asterisk", 60863),
        time: h("time", 60864),
        arrowUpRight: h("arrow-up-right", 60865),
        arrowUpRightSquare: h("arrow-up-right-square", 60866),
        bubbleAndPencil: h("bubble-and-pencil", 60867),
        downloadOnSquare: h("download-on-square", 60868),
        shippingBox: h("shipping-box", 60869)
      };
    }
  });
  function b6() {
    return Object.values(Si);
  }
  var y6;
  var Si;
  var nd = g({
    "out-build/vs/base/common/codicons.js"() {
      "use strict";
  
      w6();
      eA();
      y6 = {
        dialogError: h("dialog-error", "error"),
        dialogWarning: h("dialog-warning", "warning"),
        dialogInfo: h("dialog-info", "info"),
        dialogClose: h("dialog-close", "close"),
        treeItemExpanded: h("tree-item-expanded", "chevron-down"),
        treeFilterOnTypeOn: h("tree-filter-on-type-on", "list-filter"),
        treeFilterOnTypeOff: h("tree-filter-on-type-off", "list-selection"),
        treeFilterClear: h("tree-filter-clear", "close"),
        treeItemLoading: h("tree-item-loading", "loading"),
        menuSelection: h("menu-selection", "check"),
        menuSubmenu: h("menu-submenu", "chevron-right"),
        menuBarMore: h("menubar-more", "more"),
        scrollbarButtonLeft: h("scrollbar-button-left", "triangle-left"),
        scrollbarButtonRight: h("scrollbar-button-right", "triangle-right"),
        scrollbarButtonUp: h("scrollbar-button-up", "triangle-up"),
        scrollbarButtonDown: h("scrollbar-button-down", "triangle-down"),
        toolBarMore: h("toolbar-more", "more"),
        quickInputBack: h("quick-input-back", "arrow-left"),
        dropDownButton: h("drop-down-button", 60084),
        symbolCustomColor: h("symbol-customcolor", 60252),
        exportIcon: h("export", 60332),
        workspaceUnspecified: h("workspace-unspecified", 60355),
        newLine: h("newline", 60394),
        gitFetch: h("git-fetch", 60445),
        lightbulbSparkleAutofix: h("lightbulb-sparkle-autofix", 60447),
        debugBreakpointPending: h("debug-breakpoint-pending", 60377)
      };
      Si = {
        ...v6,
        ...y6
      };
    }
  });
  var Zg;
  var Gc;
  var S6 = g({
    "out-build/vs/base/common/themables.js"() {
      "use strict";
  
      nd();
      (function (t) {
        function e(i) {
          return i && typeof i == "object" && typeof i.id == "string";
        }
        t.isThemeColor = e;
      })(Zg ||= {});
      (function (t) {
        t.iconNameSegment = "[A-Za-z0-9]+";
        t.iconNameExpression = "[A-Za-z0-9-]+";
        t.iconModifierExpression = "~[A-Za-z]+";
        t.iconNameCharacter = "[A-Za-z0-9~-]";
        const e = new RegExp(`^(${t.iconNameExpression})(${t.iconModifierExpression})?$`);
        function i(f) {
          const p = e.exec(f.id);
          if (!p) {
            return i(Si.error);
          }
          const [, w, m] = p;
          const y = ["codicon", "codicon-" + w];
          if (m) {
            y.push("codicon-modifier-" + m.substring(1));
          }
          return y;
        }
        t.asClassNameArray = i;
        function s(f) {
          const p = e.exec(f.id);
          if (!p) {
            return s(Si.error);
          }
          const [, w, m] = p;
          let y = `codicon codicon-${w}`;
          if (m) {
            y += ` codicon-modifier-${m.substring(1)}`;
          }
          return y;
        }
        t.asClassName = s;
        function r(f) {
          const p = e.exec(f.id);
          if (!p) {
            return r(Si.error);
          }
          const [, w, m] = p;
          let y = `.codicon.codicon-${w}`;
          if (m) {
            y += `.codicon-modifier-${m.substring(1)}`;
          }
          return y;
        }
        t.asCSSSelector = r;
        function n(f) {
          return f && typeof f == "object" && typeof f.id == "string" && (typeof f.color === "undefined" || Zg.isThemeColor(f.color));
        }
        t.isThemeIcon = n;
        const o = new RegExp(`^\\$\\((${t.iconNameExpression}(?:${t.iconModifierExpression})?)\\)$`);
        function a(f) {
          const p = o.exec(f);
          if (!p) {
            return;
          }
          const [, w] = p;
          return {
            id: w
          };
        }
        t.fromString = a;
        function c(f) {
          return {
            id: f
          };
        }
        t.fromId = c;
        function l(f, p) {
          let w = f.id;
          const m = w.lastIndexOf("~");
          if (m !== -1) {
            w = w.substring(0, m);
          }
          if (p) {
            w = `${w}~${p}`;
          }
          return {
            id: w
          };
        }
        t.modify = l;
        function u(f) {
          const p = f.id.lastIndexOf("~");
          if (p !== -1) {
            return f.id.substring(p + 1);
          }
        }
        t.getModifier = u;
        function d(f, p) {
          return f.id === p.id && f.color?.id === p.color?.id;
        }
        t.isEqual = d;
      })(Gc ||= {});
    }
  });
  import Mi from "electron";
  import { release as tA } from "os";
  var E6;
  var Yg;
  var Jc;
  var k6;
  var x6 = g({
    "out-build/vs/platform/windows/electron-main/windowImpl.js"() {
      "use strict";
  
      ce();
      At();
      en();
      B();
      M();
      Ie();
      Hs();
      H();
      se();
      be();
      wc();
      Ke();
      wn();
      vt();
      kc();
      He();
      ct();
      X();
      ht();
      Wh();
      QI();
      eh();
      xt();
      S6();
      pc();
      fn();
      Lt();
      ri();
      vn();
      mc();
      Ls();
      Ti();
      un();
      zc();
      Y();
      b1();
      Ze();
      Cc();
      $e();
      (function (t) {
        t[t.NONE = 0] = "NONE";
        t[t.NAVIGATING = 1] = "NAVIGATING";
        t[t.READY = 2] = "READY";
      })(E6 ||= {});
      Yg = class uS extends T {
        get lastFocusTime() {
          return this.n;
        }
        get win() {
          return this.q;
        }
        get webContents() {
          return this.r;
        }
        s(e, i) {
          this.q = e;
          this.D(x.fromNodeEventEmitter(e, "maximize")(() => this.f.fire()));
          this.D(x.fromNodeEventEmitter(e, "unmaximize")(() => this.g.fire()));
          this.D(x.fromNodeEventEmitter(e, "closed")(() => {
            this.c.fire();
            this.dispose();
          }));
          this.D(x.fromNodeEventEmitter(e, "focus")(() => {
            this.n = Date.now();
          }));
          this.D(x.fromNodeEventEmitter(this.q, "enter-full-screen")(() => this.j.fire()));
          this.D(x.fromNodeEventEmitter(this.q, "leave-full-screen")(() => this.m.fire()));
          const s = !dn(this.t, i?.titleBarStyle === "hidden" ? "custom" : undefined);
          if (N && s) {
            e.setSheetOffset(FS(tA()) ? 28 : 22);
          }
          if (s && (W1(this.t) || N)) {
            const r = this.u.getItem(uS.H);
            if (r) {
              this.updateWindowControls({
                height: r
              });
            } else {
              this.updateWindowControls({
                height: F4
              });
            }
          }
          if (j && s) {
            e.hookWindowMessage(278, () => {
              const [n, o] = e.getPosition();
              const a = Mi.screen.getCursorScreenPoint();
              const c = a.x - n;
              const l = a.y - o;
              if (!!(c > 30) && !!(l >= 0) && !!(l <= Math.max(e.getBounds().height * 0.15, 35))) {
                e.setEnabled(false);
                e.setEnabled(true);
                this.h.fire({
                  x: c,
                  y: l
                });
              }
              return 0;
            });
          }
          if (this.w.args["open-devtools"] === true) {
            e.webContents.openDevTools();
          }
          if (N) {
            this.D(this.onDidEnterFullScreen(() => {
              this.L?.complete(true);
            }));
            this.D(this.onDidLeaveFullScreen(() => {
              this.L?.complete(true);
            }));
          }
        }
        constructor(e, i, s, r) {
          super();
          this.t = e;
          this.u = i;
          this.w = s;
          this.z = r;
          this.c = this.D(new $());
          this.onDidClose = this.c.event;
          this.f = this.D(new $());
          this.onDidMaximize = this.f.event;
          this.g = this.D(new $());
          this.onDidUnmaximize = this.g.event;
          this.h = this.D(new $());
          this.onDidTriggerSystemContextMenu = this.h.event;
          this.j = this.D(new $());
          this.onDidEnterFullScreen = this.j.event;
          this.m = this.D(new $());
          this.onDidLeaveFullScreen = this.m.event;
          this.n = Date.now();
          this.q = null;
          this.r = undefined;
          this.I = W1(this.t);
          this.J = undefined;
          this.L = undefined;
        }
        C(e, i, s = Mi.screen.getAllDisplays().length > 0) {
          const r = this.t.getValue("window");
          const n = N && r?.nativeTabs === true;
          if ((N || j) && s && (!n || Mi.BrowserWindow.getAllWindows().length === 1) && [e.width, e.height, e.x, e.y].every(o => typeof o == "number")) {
            this.q?.setBounds({
              width: e.width,
              height: e.height,
              x: e.x,
              y: e.y
            });
          }
          if ((e.mode === 0 || e.mode === 3) && !i.hideBecauseShadowWindow) {
            this.q?.maximize();
            if (e.mode === 3) {
              this.M(true, true);
            }
            this.q?.show();
          }
        }
        setRepresentedFilename(e) {
          if (N) {
            this.win?.setRepresentedFilename(e);
          } else {
            this.F = e;
          }
        }
        getRepresentedFilename() {
          if (N) {
            return this.win?.getRepresentedFilename();
          } else {
            return this.F;
          }
        }
        setDocumentEdited(e) {
          if (N) {
            this.win?.setDocumentEdited(e);
          }
          this.G = e;
        }
        isDocumentEdited() {
          if (N) {
            return !!this.win?.isDocumentEdited();
          } else {
            return !!this.G;
          }
        }
        focus(e) {
          if (N && e?.force) {
            Mi.app.focus({
              steal: true
            });
          }
          const i = this.win;
          if (i) {
            if (i.isMinimized()) {
              i.restore();
            }
            i.focus();
          }
        }
        handleTitleDoubleClick() {
          const e = this.win;
          if (e) {
            if (N) {
              switch (Mi.systemPreferences.getUserDefault("AppleActionOnDoubleClick", "string")) {
                case "Minimize":
                  e.minimize();
                  break;
                case "None":
                  break;
                case "Maximize":
                default:
                  if (e.isMaximized()) {
                    e.unmaximize();
                  } else {
                    e.maximize();
                  }
              }
            } else if (e.isMaximized()) {
              e.unmaximize();
            } else {
              e.maximize();
            }
          }
        }
        static {
          this.H = "windowControlHeight";
        }
        updateWindowControls(e) {
          const i = this.win;
          if (i) {
            if (e.height) {
              this.u.setItem(Jc.H, e.height);
            }
            if (this.I) {
              i.setTitleBarOverlay({
                color: e.backgroundColor?.trim() === "" ? undefined : e.backgroundColor,
                symbolColor: e.foregroundColor?.trim() === "" ? undefined : e.foregroundColor,
                height: e.height ? e.height - 1 : undefined
              });
            } else if (N && e.height !== undefined) {
              const s = (e.height - 15) / 2;
              if (s) {
                i.setWindowButtonPosition({
                  x: s,
                  y: s
                });
              } else {
                i.setWindowButtonPosition(null);
              }
            }
          }
        }
        toggleFullScreen() {
          this.M(!this.isFullScreen, false);
        }
        M(e, i) {
          if (_4(this.t)) {
            this.N(e, i);
          } else {
            this.P(e);
          }
        }
        get isFullScreen() {
          if (N && typeof this.J == "boolean") {
            return this.J;
          }
          const e = this.win;
          const i = e?.isFullScreen();
          const s = e?.isSimpleFullScreen();
          return !!i || !!s;
        }
        N(e, i) {
          const s = this.win;
          if (s?.isSimpleFullScreen()) {
            s?.setSimpleFullScreen(false);
          }
          this.O(e, i);
        }
        O(e, i) {
          if (N) {
            this.J = e;
            const r = this.L = new Xs();
            (async () => {
              const n = await Promise.race([r.p, wi(10000).then(() => false)]);
              if (this.L === r) {
                this.J = undefined;
                this.L = undefined;
                if (!n && e && i && this.win && !this.win.isFullScreen()) {
                  this.z.warn("window: native macOS fullscreen transition did not happen within 10s from restoring");
                  this.m.fire();
                }
              }
            })();
          }
          this.win?.setFullScreen(e);
        }
        P(e) {
          const i = this.win;
          if (i?.isFullScreen()) {
            this.O(false, false);
          }
          i?.setSimpleFullScreen(e);
          i?.webContents.focus();
        }
        dispose() {
          super.dispose();
          this.q = null;
        }
      };
      Jc = class extends Yg {
        get id() {
          return this.U;
        }
        get webContents() {
          return this.q?.webContents ?? this.browserView?.webContents;
        }
        get backupPath() {
          return this.X?.backupPath;
        }
        get openedWorkspace() {
          return this.X?.workspace;
        }
        get profile() {
          if (!this.config) {
            return;
          }
          const e = this.ob.profiles.find(i => i.id === this.config?.profiles.profile.id);
          if (this.isExtensionDevelopmentHost && e) {
            return e;
          } else {
            return this.ob.getProfileForWorkspace(this.config.workspace ?? ju(this.backupPath, this.isExtensionDevelopmentHost)) ?? this.ob.defaultProfile;
          }
        }
        get remoteAuthority() {
          return this.X?.remoteAuthority;
        }
        get config() {
          return this.X;
        }
        get isExtensionDevelopmentHost() {
          return !!this.X?.extensionDevelopmentPath;
        }
        get isExtensionTestHost() {
          return !!this.X?.extensionTestsPath;
        }
        get isExtensionDevelopmentTestFromCli() {
          return this.isExtensionDevelopmentHost && this.isExtensionTestHost && !this.X?.debugId;
        }
        constructor(e, i, s, r, n, o, a, c, l, u, d, f, p, w, m, y, b, k, A, C, _, Z) {
          super(u, C, r, i);
          this.mb = s;
          this.nb = n;
          this.ob = o;
          this.pb = a;
          this.qb = c;
          this.rb = l;
          this.sb = d;
          this.tb = f;
          this.ub = p;
          this.vb = w;
          this.wb = m;
          this.xb = y;
          this.yb = b;
          this.zb = k;
          this.Ab = A;
          this.Bb = Z;
          this.Q = this.D(new $());
          this.onWillLoad = this.Q.event;
          this.R = this.D(new $());
          this.onDidSignalReady = this.R.event;
          this.S = this.D(new $());
          this.onDidDestroy = this.S.event;
          this.q = null;
          this.isBrowserViewVisible = false;
          this.lastShownAtUnixMs = undefined;
          this.$ = [];
          this.ab = [];
          this.bb = undefined;
          this.db = undefined;
          this.eb = undefined;
          this.fb = this.D(this.zb.createIPCObjectUrl());
          this.hb = false;
          this.Cb = 0;
          {
            const [W, Ee] = this.Mb(e.state);
            this.Y = W;
            this.z.trace("window#ctor: using window state", W);
            const Ye = e.shadowWindowForWorkspaceId !== undefined && e.shadowWindowForWorkspaceId.length > 0 && !Qy;
            const re = _.invokeFunction(rh, this.Y, {
              hideBecauseShadowWindow: Ye
            }, {
              preload: Ct.asFileUri("vs/base/parts/sandbox/electron-sandbox/preload.js").fsPath,
              additionalArguments: [`--vscode-window-config=${this.fb.resource.toString()}`],
              v8CacheOptions: this.w.useCodeCache ? "bypassHeatCheck" : "none"
            });
            Ne("code/willCreateCodeBrowserWindow");
            if (e.windowInWindow === undefined) {
              this.q = new Mi.BrowserWindow(re);
              this.U = this.q.id;
              this.s(this.q, re);
            } else {
              this.browserView = new Mi.WebContentsView(re);
              this.browserView.setBackgroundColor("#00000000");
              let St = 1000 + Math.round(Math.random() * 1000000);
              while (this.Ab.getWindowById(St)) {
                St = 1000 + Math.round(Math.random() * 1000000);
              }
              this.U = St;
            }
            Ne("code/didCreateCodeBrowserWindow");
            this.C(this.Y, {
              hideBecauseShadowWindow: Ye
            }, Ee);
            this.n = Date.now();
          }
          let ie = parseInt(this.w.args["unresponsive-sample-interval"] || "1000");
          let me = parseInt(this.w.args["unresponsive-sample-period"] || "15000");
          if (ie <= 0 || me <= 0 || ie > me) {
            this.z.warn(`Invalid unresponsive sample interval (${ie}ms) or period (${me}ms), using defaults.`);
            ie = 1000;
            me = 15000;
          }
          this.ib = new Map();
          this.jb = Math.round(me / ie);
          this.kb = this.D(new su(ie));
          this.lb = this.D(new os(() => {
            this.Wb();
          }, me));
          this.Jb();
          this.Sb();
          this.Db();
        }
        setReady() {
          this.z.trace(`window#load: window reported ready (id: ${this.U})`);
          this.Cb = 2;
          while (this.$.length) {
            this.$.pop()(this);
          }
          this.R.fire();
        }
        ready() {
          return new Promise(e => {
            if (this.isReady) {
              return e(this);
            }
            this.$.push(e);
          });
        }
        get isReady() {
          return this.Cb === 2;
        }
        get whenClosedOrLoaded() {
          return new Promise(e => {
            function i() {
              s.dispose();
              r.dispose();
              e();
            }
            const s = this.onDidClose(() => i());
            const r = this.onWillLoad(() => i());
          });
        }
        registerListener(e) {
          this.D(e);
        }
        Db() {
          let e = this.q && this.D(x.fromNodeEventEmitter(this.q, "unresponsive")(() => this.Gb(1)));
          e = this.q && this.D(x.fromNodeEventEmitter(this.q, "responsive")(() => this.Gb(4)));
          e = this.webContents && this.D(x.fromNodeEventEmitter(this.webContents, "render-process-gone", (s, r) => r)(s => this.Gb(2, {
            ...s
          })));
          e = this.webContents && this.D(x.fromNodeEventEmitter(this.webContents, "did-fail-load", (s, r, n) => ({
            exitCode: r,
            reason: n
          }))(({
            exitCode: s,
            reason: r
          }) => this.Gb(3, {
            reason: r,
            exitCode: s
          })));
          e = this.webContents && this.D(x.fromNodeEventEmitter(this.webContents, "will-prevent-unload")(s => s.preventDefault()));
          e = this.webContents && this.D(x.fromNodeEventEmitter(this.webContents, "did-finish-load")(() => {
            if (this.gb) {
              this.X = this.gb;
              this.gb = undefined;
            }
          }));
          this.D(this.onDidMaximize(() => {
            if (this.X) {
              this.X.maximized = true;
            }
          }));
          this.D(this.onDidUnmaximize(() => {
            if (this.X) {
              this.X.maximized = false;
            }
          }));
          this.D(this.onDidEnterFullScreen(() => {
            this.sendWhenReady("vscode:enterFullScreen", We.None);
          }));
          this.D(this.onDidLeaveFullScreen(() => {
            this.sendWhenReady("vscode:leaveFullScreen", We.None);
          }));
          this.D(this.t.onDidChangeConfiguration(s => this.Jb(s)));
          this.D(this.tb.onDidDeleteUntitledWorkspace(s => this.Ib(s)));
          const i = ["https://marketplace.visualstudio.com/*", "https://*.vsassets.io/*", "http://*.cursor.localhost:8001/*", "https://staging-marketplace.cursor.sh/*", "https://marketplace.cursor.sh/*", "https://marketplace.cursorapi.com/*"];
          this.webContents?.session.webRequest.onBeforeSendHeaders({
            urls: i
          }, async (s, r) => {
            const n = await this.Fb();
            r({
              cancel: false,
              requestHeaders: Object.assign(s.requestHeaders, n)
            });
          });
        }
        Fb() {
          this.Eb ||= YI(this.yb, this.w, this.t, this.pb, this.qb, this.vb);
          return this.Eb;
        }
        async Gb(e, i) {
          switch (e) {
            case 2:
              this.z.error(`CodeWindow: renderer process gone (reason: ${i?.reason || "<unknown>"}, code: ${i?.exitCode || "<unknown>"})`);
              break;
            case 1:
              this.z.error("CodeWindow: detected unresponsive");
              break;
            case 4:
              this.z.error("CodeWindow: recovered from unresponsive");
              break;
            case 3:
              this.z.error(`CodeWindow: failed to load (reason: ${i?.reason || "<unknown>"}, code: ${i?.exitCode || "<unknown>"})`);
              break;
          }
          this.vb.publicLog2("windowerror", {
            type: e,
            reason: i?.reason,
            code: i?.exitCode
          });
          switch (e) {
            case 1:
            case 2:
              if (this.isExtensionDevelopmentTestFromCli) {
                this.xb.kill(1);
                return;
              }
              if (this.w.args["enable-smoke-test-driver"]) {
                await this.Hb(false, false);
                this.xb.quit();
                return;
              }
              if (e === 1) {
                if (this.isExtensionDevelopmentHost || this.isExtensionTestHost || this.q && this.q.webContents && this.q.webContents.isDevToolsOpened()) {
                  return;
                }
                this.kb.trigger(() => this.Vb());
                this.lb.schedule();
                const {
                  response: s,
                  checkboxChecked: r
                } = await this.wb.showMessageBox({
                  type: "warning",
                  buttons: [v(2507, null), v(2508, null), v(2509, null)],
                  message: v(2510, null),
                  detail: v(2511, null),
                  checkboxLabel: this.X?.workspace ? v(2512, null) : undefined
                }, this.q ?? undefined);
                if (s !== 2) {
                  const n = s === 0;
                  this.Wb();
                  await this.Hb(n, r);
                }
              } else if (e === 2) {
                let s;
                if (i) {
                  s = v(2514, null, i.reason, i.exitCode ?? "<unknown>");
                } else {
                  s = v(2513, null);
                }
                const {
                  response: r,
                  checkboxChecked: n
                } = await this.wb.showMessageBox({
                  type: "warning",
                  buttons: [this.X?.workspace ? v(2515, null) : v(2516, null), v(2517, null)],
                  message: s,
                  detail: this.X?.workspace ? v(2518, null) : v(2519, null),
                  checkboxLabel: this.X?.workspace ? v(2520, null) : undefined
                }, this.q ?? undefined);
                const o = r === 0;
                await this.Hb(o, n);
              }
              break;
            case 4:
              this.Wb();
              break;
          }
        }
        async Hb(e, i) {
          const s = this.X?.workspace;
          if (i && s) {
            try {
              const r = this.rb.workspaceStorage(s);
              await r.init();
              r.delete("memento/workbench.parts.editor");
              await r.close();
            } catch (r) {
              this.z.error(r);
            }
          }
          this.S.fire();
          try {
            if (e && this.X) {
              let r;
              let n;
              if (Li(s)) {
                r = {
                  folderUri: s.uri
                };
              } else if (Kt(s)) {
                r = {
                  workspaceUri: s.configPath
                };
              } else {
                n = true;
              }
              (await this.Ab.open({
                context: 5,
                userEnv: this.X.userEnv,
                cli: {
                  ...this.w.args,
                  _: []
                },
                urisToOpen: r ? [r] : undefined,
                forceEmpty: n,
                forceNewWindow: true,
                remoteAuthority: this.remoteAuthority
              })).at(0)?.focus();
            }
          } finally {
            this.q?.destroy();
          }
        }
        Ib(e) {
          if (this.X?.workspace?.id === e.id) {
            this.X.workspace = undefined;
          }
        }
        Jb(e) {
          if (!e || e.affectsConfiguration("window.menuBarVisibility")) {
            const i = this.Ob();
            if (i !== this.Z) {
              this.Z = i;
              this.Pb(i);
            }
          }
          if (!e || e.affectsConfiguration("http.proxy") || e.affectsConfiguration("http.noProxy")) {
            let i = (this.t.getValue("http.proxy") || "").trim() || (process.env.https_proxy || process.env.HTTPS_PROXY || process.env.http_proxy || process.env.HTTP_PROXY || "").trim() || undefined;
            if (i?.indexOf("@") !== -1) {
              const r = P.parse(i);
              const n = r.authority.indexOf("@");
              if (n !== -1) {
                i = r.with({
                  authority: r.authority.substring(n + 1)
                }).toString();
              }
            }
            if (i?.endsWith("/")) {
              i = i.substr(0, i.length - 1);
            }
            const s = (this.t.getValue("http.noProxy") || []).map(r => r.trim()).join(",") || (process.env.no_proxy || process.env.NO_PROXY || "").trim() || undefined;
            if ((i || "").indexOf("@") === -1 && (i !== this.bb || s !== this.db)) {
              this.bb = i;
              this.db = s;
              const r = i || "";
              const n = s ? `${s},<local>` : "<local>";
              this.z.trace(`Setting proxy to '${r}', bypassing '${n}'`);
              this.webContents?.session.setProxy({
                proxyRules: r,
                proxyBypassRules: n,
                pacScript: ""
              });
              Mi.app.setProxy({
                proxyRules: r,
                proxyBypassRules: n,
                pacScript: ""
              });
            }
          }
        }
        addTabbedWindow(e) {
          if (N && e.win) {
            this.q?.addTabbedWindow(e.win);
          }
        }
        load(e, i = Object.create(null)) {
          this.z.trace(`window#load: attempt to load window (id: ${this.U})`);
          if (this.isDocumentEdited() && (!i.isReload || !this.ub.isHotExitEnabled())) {
            this.setDocumentEdited(false);
          }
          if (!i.isReload) {
            if (this.getRepresentedFilename()) {
              this.setRepresentedFilename("");
            }
            this.q?.setTitle(this.yb.nameLong);
          }
          this.Kb(e, i);
          if (this.Cb === 0) {
            this.X = e;
          } else {
            this.gb = e;
          }
          this.Cb = 1;
          this.webContents?.loadURL(Ct.asBrowserUri(`vs/code/electron-sandbox/workbench/workbench${this.w.isBuilt ? "" : "-dev"}.html`).toString(true));
          const s = this.hb;
          this.hb = true;
          if (!this.w.isBuilt && !this.w.extensionTestsLocationURI) {
            this.D(new os(() => {
              if (this.q && !this.q.isVisible() && !this.q.isMinimized() && !e.shadowWindowForWorkspaceId && e.windowInWindow === undefined) {
                this.q.show();
                this.focus({
                  force: true
                });
                this.webContents?.openDevTools();
              }
            }, 10000)).schedule();
          }
          this.Q.fire({
            workspace: e.workspace,
            reason: i.isReload ? 3 : s ? 2 : 1
          });
        }
        Kb(e, i) {
          const s = (this.X ?? this.gb)?.userEnv;
          if (s) {
            const r = bn(s) && !bn(e.userEnv);
            const n = this.isExtensionDevelopmentHost;
            if (r || n) {
              e.userEnv = {
                ...s,
                ...e.userEnv
              };
            }
          }
          if (process.env.CHROME_CRASHPAD_PIPE_NAME) {
            Object.assign(e.userEnv, {
              CHROME_CRASHPAD_PIPE_NAME: process.env.CHROME_CRASHPAD_PIPE_NAME
            });
          }
          if (i.disableExtensions !== undefined) {
            e["disable-extensions"] = i.disableExtensions;
          }
          try {
            if (this.q) {
              e.handle = z.wrap(this.q.getNativeWindowHandle());
            }
          } catch (r) {
            this.z.error(`Error getting native window handle: ${r}`);
          }
          e.fullscreen = this.isFullScreen;
          e.maximized = this.q?.isMaximized() ?? false;
          e.partsSplash = this.sb.getWindowSplash();
          e.zoomLevel = this.Rb();
          e.isCustomZoomLevel = typeof this.eb == "number";
          if (e.isCustomZoomLevel && e.partsSplash) {
            e.partsSplash.zoomLevel = e.zoomLevel;
          }
          Ne("code/willOpenNewWindow");
          e.perfMarks = Wf();
          this.fb.update(e);
        }
        async reload(e) {
          const i = Object.assign({}, this.X);
          i.workspace = await this.Lb(i);
          delete i.filesToOpenOrCreate;
          delete i.filesToDiff;
          delete i.filesToMerge;
          delete i.filesToWait;
          if (this.isExtensionDevelopmentHost && e) {
            i.verbose = e.verbose;
            i.debugId = e.debugId;
            i.extensionEnvironment = e.extensionEnvironment;
            i["inspect-extensions"] = e["inspect-extensions"];
            i["inspect-brk-extensions"] = e["inspect-brk-extensions"];
            i["extensions-dir"] = e["extensions-dir"];
          }
          i.accessibilitySupport = Mi.app.isAccessibilitySupportEnabled();
          i.isInitialStartup = false;
          i.policiesData = this.nb.serialize();
          i.continueOn = this.w.continueOn;
          i.profiles = {
            all: this.ob.profiles,
            profile: this.profile || this.ob.defaultProfile,
            home: this.ob.profilesHome
          };
          i.logLevel = this.mb.getLogLevel();
          i.loggers = {
            window: this.mb.getRegisteredLoggers(this.id),
            global: this.mb.getRegisteredLoggers()
          };
          i.cssModules = this.Bb.isEnabled ? await this.Bb.getCssModules(true) : undefined;
          i.hmr = e?.hmr;
          this.load(i, {
            isReload: true,
            disableExtensions: e?.["disable-extensions"]
          });
        }
        async Lb(e) {
          if (Kt(e.workspace)) {
            const i = e.workspace.configPath;
            if (i.scheme === R.file && !(await this.pb.exists(i))) {
              return;
            }
          } else if (Li(e.workspace)) {
            const i = e.workspace.uri;
            if (i.scheme === R.file && !(await this.pb.exists(i))) {
              return;
            }
          }
          return e.workspace;
        }
        serializeWindowState() {
          if (!this.q) {
            return Ar();
          }
          if (this.isFullScreen) {
            let s;
            try {
              s = Mi.screen.getDisplayMatching(this.getBounds());
            } catch {}
            const r = Ar();
            return {
              mode: 3,
              display: s ? s.id : undefined,
              width: this.Y.width || r.width,
              height: this.Y.height || r.height,
              x: this.Y.x || 0,
              y: this.Y.y || 0,
              zoomLevel: this.eb
            };
          }
          const e = Object.create(null);
          let i;
          if (!N && this.q.isMaximized()) {
            i = 0;
          } else {
            i = 1;
          }
          if (i === 0) {
            e.mode = 0;
          } else {
            e.mode = 1;
          }
          if (i === 1 || i === 0) {
            let s;
            if (i === 1) {
              s = this.getBounds();
            } else {
              s = this.q.getNormalBounds();
            }
            e.x = s.x;
            e.y = s.y;
            e.width = s.width;
            e.height = s.height;
          }
          e.zoomLevel = this.eb;
          return e;
        }
        Mb(e) {
          Ne("code/willRestoreCodeWindowState");
          let i = false;
          if (e) {
            this.eb = e.zoomLevel;
            try {
              const s = Mi.screen.getAllDisplays();
              i = s.length > 1;
              e = nh.validateWindowState(this.z, e, s);
            } catch (s) {
              this.z.warn(`Unexpected error validating window state: ${s}
  ${s.stack}`);
            }
          }
          Ne("code/didRestoreCodeWindowState");
          return [e || Ar(), i];
        }
        getBounds() {
          if (!this.q) {
            return this.browserView?.getBounds() ?? {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            };
          }
          const [e, i] = this.q.getPosition();
          const [s, r] = this.q.getSize();
          return {
            x: e,
            y: i,
            width: s,
            height: r
          };
        }
        M(e, i) {
          super.M(e, i);
          this.sendWhenReady(e ? "vscode:enterFullScreen" : "vscode:leaveFullScreen", We.None);
          if (this.Z) {
            this.Pb(this.Z, false);
          }
        }
        Ob() {
          let e = nD(this.t);
          if (["visible", "toggle", "hidden"].indexOf(e) < 0) {
            e = "classic";
          }
          return e;
        }
        Pb(e, i = true) {
          if (!N) {
            if (e === "toggle" && i) {
              this.send("vscode:showInfoMessage", v(2521, null));
            }
            if (e === "hidden") {
              setTimeout(() => {
                this.Qb(e);
              });
            } else {
              this.Qb(e);
            }
          }
        }
        Qb(e) {
          const i = this.isFullScreen;
          if (this.q) {
            switch (e) {
              case "classic":
                this.q.setMenuBarVisibility(!i);
                this.q.autoHideMenuBar = i;
                break;
              case "visible":
                this.q.setMenuBarVisibility(true);
                this.q.autoHideMenuBar = false;
                break;
              case "toggle":
                this.q.setMenuBarVisibility(false);
                this.q.autoHideMenuBar = true;
                break;
              case "hidden":
                this.q.setMenuBarVisibility(false);
                this.q.autoHideMenuBar = false;
                break;
            }
          }
        }
        notifyZoomLevel(e) {
          this.eb = e;
        }
        Rb() {
          if (typeof this.eb == "number") {
            return this.eb;
          } else {
            return this.t.getValue("window")?.zoomLevel;
          }
        }
        close() {
          if (this.q) {
            this.q.close();
          } else if (this.browserView) {
            try {
              this.browserView.webContents.close({
                waitForBeforeUnload: false
              });
            } catch (e) {
              this.z.warn(`Error closing browser view: ${Ki(e)}`);
            }
            this.c.fire();
            this.dispose();
          }
        }
        sendWhenReady(e, i, ...s) {
          if (this.isReady) {
            this.send(e, ...s);
          } else {
            this.ready().then(() => {
              if (!i.isCancellationRequested) {
                this.send(e, ...s);
              }
            });
          }
        }
        send(e, ...i) {
          if (this.webContents) {
            if (this.q?.isDestroyed() || this.webContents.isDestroyed()) {
              this.z.warn(`Sending IPC message to channel '${e}' for window that is destroyed`);
              return;
            }
            try {
              this.webContents.send(e, ...i);
            } catch (s) {
              this.z.warn(`Error sending IPC message to channel '${e}' of window ${this.U}: ${Ki(s)}`);
            }
          }
        }
        updateTouchBar(e) {
          if (N) {
            this.ab.forEach((i, s) => {
              const r = e[s];
              i.segments = this.Ub(r);
            });
          }
        }
        Sb() {
          if (N) {
            for (let e = 0; e < 10; e++) {
              const i = this.Tb();
              this.ab.push(i);
            }
            if (this.q) {
              this.q.setTouchBar(new Mi.TouchBar({
                items: this.ab
              }));
            }
          }
        }
        Tb(e = []) {
          const i = this.Ub(e);
          const s = new Mi.TouchBar.TouchBarSegmentedControl({
            segments: i,
            mode: "buttons",
            segmentStyle: "automatic",
            change: r => {
              this.sendWhenReady("vscode:runAction", We.None, {
                id: s.segments[r].id,
                from: "touchbar"
              });
            }
          });
          return s;
        }
        Ub(e = []) {
          return e.map(s => {
            let r;
            if (s.icon && !Gc.isThemeIcon(s.icon) && s.icon?.dark?.scheme === R.file) {
              r = Mi.nativeImage.createFromPath(P.revive(s.icon.dark).fsPath);
              if (r.isEmpty()) {
                r = undefined;
              }
            }
            let n;
            if (typeof s.title == "string") {
              n = s.title;
            } else {
              n = s.title.value;
            }
            return {
              id: s.id,
              label: r ? undefined : n,
              icon: r
            };
          });
        }
        async Vb() {
          if (!this.kb.isTriggered()) {
            const e = await this.q?.webContents.mainFrame.collectJavaScriptCallStack();
            if (e) {
              const i = this.ib.get(e) || 0;
              this.ib.set(e, i + 1);
            }
            this.kb.trigger(() => this.Vb());
          }
        }
        Wb() {
          this.lb.cancel();
          this.kb.cancel();
          if (this.ib.size) {
            let e = `CodeWindow unresponsive samples:
  `;
            let i = 0;
            const s = Array.from(this.ib.entries()).sort((r, n) => n[1] - r[1]);
            for (const [r, n] of s) {
              i += n;
              if (Math.round(n * 100 / this.jb) > 20) {
                const o = new k6(r, this.id, this.win?.webContents.getOSProcessId());
                Wl.onUnexpectedError(o);
              }
              e += `<${n}> ${r}
  `;
            }
            e += `Total Samples: ${i}
  `;
            e += "For full overview of the unresponsive period, capture cpu profile via https://aka.ms/vscode-tracing-cpu-profile";
            this.z.error(e);
          }
          this.ib.clear();
        }
        matches(e) {
          return this.q?.webContents.id === e.id;
        }
        dispose() {
          super.dispose();
          if (this.browserView) {
            try {
              if (!this.browserView.webContents.isDestroyed()) {
                this.browserView.webContents.destroy();
              }
            } catch (e) {
              this.z.warn(`Error destroying browser view: ${Ki(e)}`);
            }
            this.browserView = null;
          }
          this.mb.deregisterLoggers(this.id);
        }
      };
      Jc = __decorate([__param(1, V), __param(2, qo), __param(3, ot), __param(4, Pn), __param(5, Rs), __param(6, at), __param(7, dc), __param(8, yo), __param(9, Je), __param(10, Eo), __param(11, Cr), __param(12, xo), __param(13, Ot), __param(14, nr), __param(15, Te), __param(16, Ve), __param(17, Wc), __param(18, dt), __param(19, Oi), __param(20, Ss), __param(21, Wo)], Jc);
      k6 = class extends Error {
        constructor(t, e, i = 0) {
          super(`UnresponsiveSampleError: by ${e} from ${i}`);
          this.name = "UnresponsiveSampleError";
          this.stack = t;
        }
      };
    }
  });
  import Vo from "electron";
  function iA(t) {
    const e = {
      openedWindows: []
    };
    const i = t || {
      openedWindows: []
    };
    if (i.lastActiveWindow) {
      e.lastActiveWindow = Xg(i.lastActiveWindow);
    }
    if (i.lastPluginDevelopmentHostWindow) {
      e.lastPluginDevelopmentHostWindow = Xg(i.lastPluginDevelopmentHostWindow);
    }
    if (Array.isArray(i.openedWindows)) {
      e.openedWindows = i.openedWindows.map(s => Xg(s));
    }
    return e;
  }
  function Xg(t) {
    const e = {
      uiState: t.uiState
    };
    if (t.backupPath) {
      e.backupPath = t.backupPath;
    }
    if (t.remoteAuthority) {
      e.remoteAuthority = t.remoteAuthority;
    }
    if (t.folder) {
      e.folderUri = P.parse(t.folder);
    }
    if (t.workspaceIdentifier) {
      e.workspace = {
        id: t.workspaceIdentifier.id,
        configPath: P.parse(t.workspaceIdentifier.configURIPath)
      };
    }
    return e;
  }
  function sA(t) {
    return {
      lastActiveWindow: t.lastActiveWindow && Qg(t.lastActiveWindow),
      lastPluginDevelopmentHostWindow: t.lastPluginDevelopmentHostWindow && Qg(t.lastPluginDevelopmentHostWindow),
      openedWindows: t.openedWindows.map(e => Qg(e))
    };
  }
  function Qg(t) {
    return {
      workspaceIdentifier: t.workspace && {
        id: t.workspace.id,
        configURIPath: t.workspace.configPath.toString()
      },
      folder: t.folderUri && t.folderUri.toString(),
      backupPath: t.backupPath,
      remoteAuthority: t.remoteAuthority,
      uiState: t.uiState
    };
  }
  var od;
  var ad;
  var rA = g({
    "out-build/vs/platform/windows/electron-main/windowsStateHandler.js"() {
      "use strict";
  
      M();
      H();
      nt();
      se();
      Ke();
      ct();
      X();
      Ti();
      Lt();
      mc();
      ri();
      ad = class extends T {
        static {
          od = this;
        }
        static {
          this.a = "windowsState";
        }
        get state() {
          return this.b;
        }
        constructor(e, i, s, r, n) {
          super();
          this.g = e;
          this.h = i;
          this.j = s;
          this.m = r;
          this.n = n;
          this.b = iA(this.h.getItem(od.a));
          this.c = undefined;
          this.f = false;
          this.q();
        }
        q() {
          Vo.app.on("browser-window-blur", () => {
            if (!this.f) {
              this.s();
            }
          });
          this.D(this.j.onBeforeCloseWindow(e => this.t(e)));
          this.D(this.j.onBeforeShutdown(() => this.r()));
          this.D(this.g.onDidChangeWindowsCount(e => {
            if (e.newCount - e.oldCount > 0) {
              this.c = undefined;
            }
          }));
          this.D(this.g.onDidDestroyWindow(e => this.t(e)));
        }
        r() {
          this.f = true;
          this.s();
        }
        s() {
          const e = new Set();
          const i = {
            openedWindows: [],
            lastPluginDevelopmentHostWindow: this.b.lastPluginDevelopmentHostWindow,
            lastActiveWindow: this.c
          };
          if (!i.lastActiveWindow) {
            let n = this.g.getLastActiveWindow();
            if (!n || n.isExtensionDevelopmentHost || n.config?.shadowWindowForWorkspaceId || n.config?.windowInWindow !== undefined) {
              n = this.g.getWindows().find(o => !o.isExtensionDevelopmentHost && !o.config?.shadowWindowForWorkspaceId && o.config?.windowInWindow === undefined);
            }
            if (n) {
              i.lastActiveWindow = this.u(n);
              if (i.lastActiveWindow.uiState.mode === 3) {
                e.add(i.lastActiveWindow.uiState.display);
              }
            }
          }
          const s = this.g.getWindows().find(n => n.isExtensionDevelopmentHost && !n.isExtensionTestHost);
          if (s) {
            i.lastPluginDevelopmentHostWindow = this.u(s);
            if (i.lastPluginDevelopmentHostWindow.uiState.mode === 3) {
              if (e.has(i.lastPluginDevelopmentHostWindow.uiState.display)) {
                if (N && !s.win?.isSimpleFullScreen()) {
                  i.lastPluginDevelopmentHostWindow.uiState.mode = 1;
                }
              } else {
                e.add(i.lastPluginDevelopmentHostWindow.uiState.display);
              }
            }
          }
          if (this.g.getWindowCount() > 1) {
            i.openedWindows = this.g.getWindows().filter(n => !n.isExtensionDevelopmentHost && !n.config?.shadowWindowForWorkspaceId && n.config?.windowInWindow === undefined).map(n => {
              const o = this.u(n);
              if (o.uiState.mode === 3) {
                if (e.has(o.uiState.display)) {
                  if (N && o.windowId !== i.lastActiveWindow?.windowId && !n.win?.isSimpleFullScreen()) {
                    o.uiState.mode = 1;
                  }
                } else {
                  e.add(o.uiState.display);
                }
              }
              return o;
            });
          }
          const r = sA(i);
          this.h.setItem(od.a, r);
          if (this.f) {
            this.m.trace("[WindowsStateHandler] onBeforeShutdown", r);
          }
        }
        t(e) {
          if (this.j.quitRequested) {
            return;
          }
          const i = this.u(e);
          if (e.isExtensionDevelopmentHost && !e.isExtensionTestHost) {
            this.b.lastPluginDevelopmentHostWindow = i;
          } else if (!e.isExtensionDevelopmentHost && e.openedWorkspace && !e.config?.shadowWindowForWorkspaceId && e.config?.windowInWindow === undefined) {
            this.b.openedWindows.forEach(s => {
              const r = Kt(e.openedWorkspace) && s.workspace?.id === e.openedWorkspace.id;
              const n = Li(e.openedWorkspace) && s.folderUri && tt.isEqual(s.folderUri, e.openedWorkspace.uri);
              if (r || n) {
                s.uiState = i.uiState;
              }
            });
          }
          if (this.g.getWindowCount() === 1) {
            this.c = i;
          }
        }
        u(e) {
          return {
            windowId: e.id,
            workspace: Kt(e.openedWorkspace) ? e.openedWorkspace : undefined,
            folderUri: Li(e.openedWorkspace) ? e.openedWorkspace.uri : undefined,
            backupPath: e.backupPath,
            remoteAuthority: e.remoteAuthority,
            uiState: e.serializeWindowState()
          };
        }
        getNewWindowState(e) {
          const i = this.w(e);
          const s = this.n.getValue("window");
          if (i.mode === 3) {
            let r;
            if (i.hasDefaultState) {
              r = !!s?.newWindowDimensions && !!(["fullscreen", "inherit", "offset"].indexOf(s.newWindowDimensions) >= 0);
            } else {
              r = !!this.j.wasRestarted || !!s?.restoreFullscreen;
            }
            if (!r) {
              i.mode = 1;
            }
          }
          return i;
        }
        w(e) {
          const i = this.g.getLastActiveWindow();
          if (!e.extensionTestsPath) {
            if (e.extensionDevelopmentPath && this.state.lastPluginDevelopmentHostWindow) {
              return this.state.lastPluginDevelopmentHostWindow.uiState;
            }
            const c = e.workspace;
            if (Kt(c)) {
              const u = this.state.openedWindows.filter(d => d.workspace && d.workspace.id === c.id).map(d => d.uiState);
              if (u.length) {
                return u[0];
              }
            }
            if (Li(c)) {
              const u = this.state.openedWindows.filter(d => d.folderUri && tt.isEqual(d.folderUri, c.uri)).map(d => d.uiState);
              if (u.length) {
                return u[0];
              }
            } else if (e.backupPath) {
              const u = this.state.openedWindows.filter(d => d.backupPath === e.backupPath).map(d => d.uiState);
              if (u.length) {
                return u[0];
              }
            }
            const l = this.c || this.state.lastActiveWindow;
            if (!i && l) {
              return l.uiState;
            }
          }
          let s;
          const r = Vo.screen.getAllDisplays();
          if (r.length === 1) {
            s = r[0];
          } else {
            if (N) {
              const c = Vo.screen.getCursorScreenPoint();
              s = Vo.screen.getDisplayNearestPoint(c);
            }
            if (!s && i) {
              s = Vo.screen.getDisplayMatching(i.getBounds());
            }
            s ||= Vo.screen.getPrimaryDisplay() || r[0];
          }
          let n = Ar();
          n.x = Math.round(s.bounds.x + s.bounds.width / 2 - n.width / 2);
          n.y = Math.round(s.bounds.y + s.bounds.height / 2 - n.height / 2);
          const o = this.n.getValue("window");
          let a = true;
          if (o?.newWindowDimensions) {
            if (o.newWindowDimensions === "maximized") {
              n.mode = 0;
              a = false;
            } else if (o.newWindowDimensions === "fullscreen") {
              n.mode = 3;
              a = false;
            } else if ((o.newWindowDimensions === "inherit" || o.newWindowDimensions === "offset") && i) {
              const c = i.serializeWindowState();
              if (c.mode === 3) {
                n.mode = 3;
              } else {
                n = {
                  ...c,
                  zoomLevel: undefined
                };
              }
              a = n.mode !== 3 && o.newWindowDimensions === "offset";
            }
          }
          if (a) {
            n = this.z(n);
          }
          n.hasDefaultState = true;
          return n;
        }
        z(e) {
          if (this.g.getWindows().length === 0) {
            return e;
          }
          e.x = typeof e.x == "number" ? e.x : 0;
          e.y = typeof e.y == "number" ? e.y : 0;
          const i = this.g.getWindows().map(s => s.getBounds());
          while (i.some(s => s.x === e.x || s.y === e.y)) {
            e.x += 30;
            e.y += 30;
          }
          return e;
        }
      };
      ad = od = __decorate([__param(0, dt), __param(1, Oi), __param(2, Te), __param(3, V), __param(4, Je)], ad);
    }
  });
  import * as nA from "fs";
  import { app as oA, BrowserWindow as cd, shell as aA } from "electron";
  import { hostname as cA, release as lA, arch as uA } from "os";
  function ld(t) {
    return Kt(t?.workspace);
  }
  function Go(t) {
    return Li(t?.workspace);
  }
  var ud;
  var hA = g({
    "out-build/vs/platform/windows/electron-main/windowsMainService.js"() {
      "use strict";
  
      wa();
      zt();
      At();
      B();
      gi();
      Sr();
      M();
      Ie();
      we();
      Hs();
      H();
      ys();
      nt();
      _e();
      se();
      be();
      wc();
      Ke();
      wn();
      vt();
      He();
      Y();
      ct();
      X();
      gc();
      Wh();
      Sc();
      Ti();
      fn();
      x6();
      Lt();
      c5();
      rA();
      ri();
      q1();
      zh();
      vn();
      pc();
      Ls();
      un();
      zc();
      Mh();
      Cc();
      ud = class extends T {
        constructor(e, i, s, r, n, o, a, c, l, u, d, f, p, w, m, y, b, k, A, C, _, Z, ie) {
          super();
          this.r = e;
          this.s = i;
          this.t = s;
          this.u = r;
          this.w = n;
          this.z = o;
          this.C = a;
          this.F = c;
          this.G = l;
          this.H = u;
          this.I = d;
          this.J = f;
          this.L = p;
          this.M = w;
          this.N = m;
          this.O = y;
          this.P = b;
          this.Q = k;
          this.R = A;
          this.S = C;
          this.U = _;
          this.W = Z;
          this.X = ie;
          this.a = this.D(new $());
          this.onDidOpenWindow = this.a.event;
          this.b = this.D(new $());
          this.onDidSignalReadyWindow = this.b.event;
          this.c = this.D(new $());
          this.onDidDestroyWindow = this.c.event;
          this.f = this.D(new $());
          this.onDidChangeWindowsCount = this.f.event;
          this.g = this.D(new $());
          this.onDidMaximizeWindow = this.g.event;
          this.h = this.D(new $());
          this.onDidUnmaximizeWindow = this.h.event;
          this.j = this.D(new $());
          this.onDidChangeFullScreen = this.j.event;
          this.m = this.D(new $());
          this.onDidTriggerSystemContextMenu = this.m.event;
          this.n = new Map();
          this.q = this.D(new ad(this, this.F, this.J, this.z, this.M));
          this.Y();
        }
        Y() {
          this.D(this.O.onDidEnterWorkspace(e => this.b.fire(e.window)));
          this.D(this.onDidSignalReadyWindow(e => {
            if (e.config?.extensionDevelopmentPath || e.config?.extensionTestsPath) {
              const i = new De();
              i.add(x.any(e.onDidClose, e.onDidDestroy)(() => i.dispose()));
              if (e.config.extensionDevelopmentPath) {
                for (const s of e.config.extensionDevelopmentPath) {
                  i.add(this.S.addValidFileRoot(s));
                }
              }
              if (e.config.extensionTestsPath) {
                i.add(this.S.addValidFileRoot(e.config.extensionTestsPath));
              }
            }
          }));
        }
        openEmptyWindow(e, i) {
          const s = this.H.args;
          const r = i?.remoteAuthority || undefined;
          const n = true;
          const o = i?.forceReuseWindow;
          const a = !o;
          return this.open({
            ...e,
            cli: s,
            forceEmpty: n,
            forceNewWindow: a,
            forceReuseWindow: o,
            remoteAuthority: r,
            forceTempProfile: i?.forceTempProfile,
            forceProfile: i?.forceProfile
          });
        }
        openExistingWindow(e, i) {
          e.focus();
          this.Z(i, [e]);
        }
        async open(e) {
          this.z.trace("windowsManager#open");
          if (e.addMode && (e.initialStartup || !this.getLastActiveWindow())) {
            e.addMode = false;
          }
          const i = [];
          const s = [];
          const r = [];
          const n = [];
          const o = [];
          let a;
          let c = false;
          const l = await this.fb(e);
          this.z.trace("windowsManager#open pathsToOpen", l);
          for (const w of l) {
            if (Go(w)) {
              if (e.addMode) {
                i.push(w);
              } else {
                s.push(w);
              }
            } else if (ld(w)) {
              r.push(w);
            } else if (w.fileUri) {
              a ||= {
                filesToOpenOrCreate: [],
                filesToDiff: [],
                filesToMerge: [],
                remoteAuthority: w.remoteAuthority
              };
              a.filesToOpenOrCreate.push(w);
            } else if (w.backupPath) {
              o.push({
                backupFolder: Ue(w.backupPath),
                remoteAuthority: w.remoteAuthority
              });
            } else {
              c = true;
            }
          }
          if (e.diffMode && a && a.filesToOpenOrCreate.length >= 2) {
            a.filesToDiff = a.filesToOpenOrCreate.slice(0, 2);
            a.filesToOpenOrCreate = [];
          }
          if (e.mergeMode && a && a.filesToOpenOrCreate.length === 4) {
            a.filesToMerge = a.filesToOpenOrCreate.slice(0, 4);
            a.filesToOpenOrCreate = [];
            a.filesToDiff = [];
          }
          if (a && e.waitMarkerFileURI) {
            a.filesToWait = {
              paths: $t([...a.filesToDiff, a.filesToMerge[3], ...a.filesToOpenOrCreate]),
              waitMarkerFileUri: e.waitMarkerFileURI
            };
          }
          if (e.initialStartup) {
            n.push(...this.O.getUntitledWorkspaces());
            r.push(...n);
            o.push(...this.L.getEmptyWindowBackups());
          } else {
            o.length = 0;
          }
          const {
            windows: u,
            filesOpenedInWindow: d
          } = await this.$(e, r, s, o, c, a, i);
          this.z.trace(`windowsManager#open used window count ${u.length} (workspacesToOpen: ${r.length}, foldersToOpen: ${s.length}, emptyToRestore: ${o.length}, openOneEmptyWindow: ${c})`);
          if (u.length > 1) {
            if (d) {
              d.focus();
            } else {
              const w = this.q.state.lastActiveWindow && !e.forceEmpty && !e.cli._.length && !e.cli["file-uri"] && !e.cli["folder-uri"] && (!e.urisToOpen || !e.urisToOpen.length);
              let m = true;
              let y = true;
              if (w) {
                const b = u.filter(k => this.q.state.lastActiveWindow && k.backupPath === this.q.state.lastActiveWindow.backupPath);
                if (b.length) {
                  b[0].focus();
                  m = false;
                  y = false;
                }
              }
              if (m) {
                for (let b = u.length - 1; b >= 0; b--) {
                  const k = u[b];
                  if ((!k.openedWorkspace || !n.some(A => k.openedWorkspace && A.workspace.id === k.openedWorkspace.id)) && (!k.backupPath || !o.some(A => k.backupPath && A.backupFolder === Ue(k.backupPath)))) {
                    k.focus();
                    y = false;
                    break;
                  }
                }
              }
              if (y) {
                u[u.length - 1].focus();
              }
            }
          }
          const f = a && a.filesToDiff.length > 0;
          const p = a && a.filesToMerge.length > 0;
          if (!u.some(w => w.isExtensionDevelopmentHost) && !f && !p && !e.noRecentEntry) {
            const w = [];
            for (const m of l) {
              if (ld(m) && !m.transient) {
                w.push({
                  label: m.label,
                  workspace: m.workspace,
                  remoteAuthority: m.remoteAuthority
                });
              } else if (Go(m)) {
                w.push({
                  label: m.label,
                  folderUri: m.workspace.uri,
                  remoteAuthority: m.remoteAuthority
                });
              } else if (m.fileUri) {
                w.push({
                  label: m.label,
                  fileUri: m.fileUri,
                  remoteAuthority: m.remoteAuthority
                });
              }
            }
            this.N.addRecentlyOpened(w);
          }
          this.Z(e, u);
          return u;
        }
        Z(e, i) {
          const s = e.waitMarkerFileURI;
          if (e.context === 0 && s && i.length === 1 && i[0]) {
            (async () => {
              await i[0].whenClosedOrLoaded;
              try {
                await this.R.del(s);
              } catch {}
            })();
          }
        }
        async $(e, i, s, r, n, o, a) {
          const c = [];
          let l;
          function u(b, k) {
            c.push(b);
            if (k) {
              l = b;
              o = undefined;
            }
          }
          let {
            openFolderInNewWindow: d,
            openFilesInNewWindow: f
          } = this.rb(e);
          if (!e.initialStartup && a.length > 0) {
            const b = a[0].remoteAuthority;
            const k = this.xb(b);
            if (k) {
              u(this.cb(k, a.map(A => A.workspace.uri)));
            }
          }
          const p = s.length + i.length + r.length;
          if (o && p === 0) {
            const b = o.filesToOpenOrCreate[0] || o.filesToDiff[0] || o.filesToMerge[3];
            const k = this.getWindows().filter(C => o && mi(C.remoteAuthority, o.remoteAuthority));
            let A;
            if (b?.fileUri && !f) {
              if (e.context === 4 || e.context === 0 || e.context === 1 || e.context === 6) {
                A = await ID(k, b.fileUri, async C => C.configPath.scheme === R.file ? this.O.resolveLocalWorkspace(C.configPath) : undefined);
              }
              A ||= this.yb(k);
            }
            if (A) {
              if (Kt(A.openedWorkspace)) {
                i.push({
                  workspace: A.openedWorkspace,
                  remoteAuthority: A.remoteAuthority
                });
              } else if (Li(A.openedWorkspace)) {
                s.push({
                  workspace: A.openedWorkspace,
                  remoteAuthority: A.remoteAuthority
                });
              } else {
                u(this.ab(e, A, o), true);
              }
            } else {
              u(await this.sb({
                userEnv: e.userEnv,
                cli: e.cli,
                initialStartup: e.initialStartup,
                shadowWindowForWorkspaceId: e.shadowWindowForWorkspaceId,
                windowInWindow: e.windowInWindow,
                windowInWindowBodyClass: e.windowInWindowBodyClass,
                filesToOpen: o,
                forceNewWindow: true,
                remoteAuthority: o.remoteAuthority,
                forceNewTabbedWindow: e.forceNewTabbedWindow,
                forceProfile: e.forceProfile,
                forceTempProfile: e.forceTempProfile
              }), true);
            }
          }
          const w = ss(i, b => b.workspace.id);
          if (w.length > 0) {
            const b = $t(w.map(k => $o(this.getWindows(), k.workspace.configPath)));
            if (b.length > 0) {
              const k = b[0];
              const A = mi(o?.remoteAuthority, k.remoteAuthority) ? o : undefined;
              u(this.ab(e, k, A), !!A);
              d = true;
            }
            for (const k of w) {
              if (b.some(_ => _.openedWorkspace && _.openedWorkspace.id === k.workspace.id)) {
                continue;
              }
              const A = k.remoteAuthority;
              const C = mi(o?.remoteAuthority, A) ? o : undefined;
              u(await this.eb(e, k, d, C), !!C);
              d = true;
            }
          }
          const m = ss(s, b => tt.getComparisonKey(b.workspace.uri));
          if (m.length > 0) {
            const b = $t(m.map(k => $o(this.getWindows(), k.workspace.uri)));
            if (b.length > 0) {
              const k = b[0];
              const A = mi(o?.remoteAuthority, k.remoteAuthority) ? o : undefined;
              u(this.ab(e, k, A), !!A);
              d = true;
            }
            for (const k of m) {
              if (b.some(_ => Li(_.openedWorkspace) && tt.isEqual(_.openedWorkspace.uri, k.workspace.uri))) {
                continue;
              }
              const A = k.remoteAuthority;
              const C = mi(o?.remoteAuthority, A) ? o : undefined;
              u(await this.eb(e, k, d, C), !!C);
              d = true;
            }
          }
          const y = ss(r, b => b.backupFolder);
          if (y.length > 0) {
            for (const b of y) {
              const k = b.remoteAuthority;
              const A = mi(o?.remoteAuthority, k) ? o : undefined;
              u(await this.db(e, true, k, A, b), !!A);
              d = true;
            }
          }
          if (o || n) {
            const b = o ? o.remoteAuthority : e.remoteAuthority;
            u(await this.db(e, d, b, o), !!o);
          }
          return {
            windows: ss(c),
            filesOpenedInWindow: l
          };
        }
        ab(e, i, s) {
          this.z.trace("windowsManager#doOpenFilesInExistingWindow", {
            filesToOpen: s
          });
          this.bb(i);
          const r = {
            filesToOpenOrCreate: s?.filesToOpenOrCreate,
            filesToDiff: s?.filesToDiff,
            filesToMerge: s?.filesToMerge,
            filesToWait: s?.filesToWait,
            termProgram: e?.userEnv?.TERM_PROGRAM
          };
          i.sendWhenReady("vscode:openFiles", We.None, r);
          return i;
        }
        bb(e) {
          let i = e;
          const s = cd.getFocusedWindow();
          if (s && s.id !== e.id) {
            const r = this.W.getWindowByWebContents(s.webContents);
            if (r && r.parentId === e.id) {
              i = r;
            }
          }
          i.focus();
        }
        cb(e, i) {
          this.z.trace("windowsManager#doAddFoldersToExistingWindow", {
            foldersToAdd: i
          });
          e.focus();
          const s = {
            foldersToAdd: i
          };
          e.sendWhenReady("vscode:addFolders", We.None, s);
          return e;
        }
        db(e, i, s, r, n) {
          this.z.trace("windowsManager#doOpenEmpty", {
            restore: !!n,
            remoteAuthority: s,
            filesToOpen: r,
            forceNewWindow: i
          });
          let o;
          if (!i && typeof e.contextWindowId == "number") {
            o = this.getWindowById(e.contextWindowId);
          }
          return this.sb({
            userEnv: e.userEnv,
            cli: e.cli,
            initialStartup: e.initialStartup,
            remoteAuthority: s,
            forceNewWindow: i,
            forceNewTabbedWindow: e.forceNewTabbedWindow,
            shadowWindowForWorkspaceId: e.shadowWindowForWorkspaceId,
            windowInWindow: e.windowInWindow,
            windowInWindowBodyClass: e.windowInWindowBodyClass,
            filesToOpen: r,
            windowToUse: o,
            emptyWindowBackupInfo: n,
            forceProfile: e.forceProfile,
            forceTempProfile: e.forceTempProfile
          });
        }
        eb(e, i, s, r, n) {
          this.z.trace("windowsManager#doOpenFolderOrWorkspace", {
            folderOrWorkspace: i,
            filesToOpen: r
          });
          if (!s && !n && typeof e.contextWindowId == "number") {
            n = this.getWindowById(e.contextWindowId);
          }
          return this.sb({
            workspace: i.workspace,
            userEnv: e.userEnv,
            cli: e.cli,
            initialStartup: e.initialStartup,
            remoteAuthority: i.remoteAuthority,
            forceNewWindow: s,
            forceNewTabbedWindow: e.forceNewTabbedWindow,
            filesToOpen: r,
            windowToUse: n,
            shadowWindowForWorkspaceId: e.shadowWindowForWorkspaceId,
            windowInWindow: e.windowInWindow,
            windowInWindowBodyClass: e.windowInWindowBodyClass,
            forceProfile: e.forceProfile,
            forceTempProfile: e.forceTempProfile
          });
        }
        async fb(e) {
          let i;
          let s = false;
          let r = false;
          if (e.urisToOpen && e.urisToOpen.length > 0) {
            i = await this.gb(e);
            s = true;
          } else if (e.forceEmpty) {
            i = [Object.create(null)];
          } else if (e.cli._.length || e.cli["folder-uri"] || e.cli["file-uri"]) {
            i = await this.hb(e.cli);
            if (i.length === 0) {
              i.push(Object.create(null));
            }
            s = true;
          } else {
            i = await this.jb();
            if (i.length === 0) {
              i.push(Object.create(null));
            }
            r = true;
          }
          if (!e.addMode && s) {
            const n = i.filter(o => Go(o));
            if (n.length > 1) {
              const o = n[0].remoteAuthority;
              if (n.every(a => mi(a.remoteAuthority, o))) {
                const a = await this.O.createUntitledWorkspace(n.map(c => ({
                  uri: c.workspace.uri
                })));
                i.push({
                  workspace: a,
                  remoteAuthority: o
                });
                i = i.filter(c => !Go(c));
              }
            }
          }
          if (e.initialStartup && !r && this.M.getValue("window")?.restoreWindows === "preserve") {
            const n = await this.jb();
            i.unshift(...n.filter(o => ld(o) || Go(o) || o.backupPath));
          }
          return i;
        }
        async gb(e) {
          const i = {
            gotoLineMode: e.gotoLineMode,
            remoteAuthority: e.remoteAuthority
          };
          const s = await Promise.all($t(e.urisToOpen || []).map(async r => {
            const n = await this.lb(r, i);
            if (n) {
              n.label = r.label;
              return n;
            }
            const o = this.nb(r);
            this.Q.showMessageBox({
              type: "info",
              buttons: [v(2522, null)],
              message: o.scheme === R.file ? v(2523, null) : v(2524, null),
              detail: o.scheme === R.file ? v(2525, null, to(o, {
                os: Wi,
                tildify: this.H
              })) : v(2526, null, o.toString(true))
            }, cd.getFocusedWindow() ?? undefined);
          }));
          return $t(s);
        }
        async hb(e) {
          const i = [];
          const s = {
            ignoreFileNotFound: true,
            gotoLineMode: e.goto,
            remoteAuthority: e.remote || undefined,
            forceOpenWorkspaceAsFile: e.diff && e._.length === 2 || e.merge && e._.length === 4
          };
          const r = e["folder-uri"];
          if (r) {
            const a = await Promise.all(r.map(c => {
              const l = this.ib(c);
              if (l) {
                return this.lb({
                  folderUri: l
                }, s);
              }
            }));
            i.push(...$t(a));
          }
          const n = e["file-uri"];
          if (n) {
            const a = await Promise.all(n.map(c => {
              const l = this.ib(c);
              if (l) {
                return this.lb(ln(c) ? {
                  workspaceUri: l
                } : {
                  fileUri: l
                }, s);
              }
            }));
            i.push(...$t(a));
          }
          const o = await Promise.all(e._.map(a => s.remoteAuthority ? this.qb(a, s) : this.ob(a, s)));
          i.push(...$t(o));
          return i;
        }
        ib(e) {
          try {
            const i = P.parse(e);
            if (!i.scheme) {
              this.z.error(`Invalid URI input string, scheme missing: ${e}`);
              return;
            }
            if (i.path) {
              return i;
            } else {
              return i.with({
                path: "/"
              });
            }
          } catch (i) {
            this.z.error(`Invalid URI input string: ${e}, ${i.message}`);
          }
        }
        async jb() {
          const e = this.kb();
          switch (e) {
            case "none":
              return [];
            case "one":
            case "all":
            case "preserve":
            case "folders":
              {
                const i = [];
                if (e !== "one") {
                  i.push(...this.q.state.openedWindows);
                }
                if (this.q.state.lastActiveWindow) {
                  i.push(this.q.state.lastActiveWindow);
                }
                const s = await Promise.all(i.map(async r => {
                  if (r.workspace) {
                    const n = await this.lb({
                      workspaceUri: r.workspace.configPath
                    }, {
                      remoteAuthority: r.remoteAuthority,
                      rejectTransientWorkspaces: true
                    });
                    if (ld(n)) {
                      return n;
                    }
                  } else if (r.folderUri) {
                    const n = await this.lb({
                      folderUri: r.folderUri
                    }, {
                      remoteAuthority: r.remoteAuthority
                    });
                    if (Go(n)) {
                      return n;
                    }
                  } else if (e !== "folders" && r.backupPath) {
                    return {
                      backupPath: r.backupPath,
                      remoteAuthority: r.remoteAuthority
                    };
                  }
                }));
                return $t(s);
              }
          }
        }
        kb() {
          let e;
          if (this.J.wasRestarted) {
            e = "all";
          } else {
            e = this.M.getValue("window")?.restoreWindows || "all";
            if (!["preserve", "all", "folders", "one", "none"].includes(e)) {
              e = "all";
            }
          }
          return e;
        }
        async lb(e, i = Object.create(null)) {
          const s = this.nb(e);
          if (s.scheme === R.file) {
            if (C4(e)) {
              i = {
                ...i,
                forceOpenWorkspaceAsFile: true
              };
            }
            return this.ob(s.fsPath, i);
          } else {
            return this.mb(e, i);
          }
        }
        mb(e, i) {
          let s = this.nb(e);
          const r = Ao(s) || i.remoteAuthority;
          s = Wv(Pp(s));
          if (C4(e)) {
            if (i.gotoLineMode) {
              const {
                path: n,
                line: o,
                column: a
              } = iu(s.path);
              return {
                fileUri: s.with({
                  path: n
                }),
                options: {
                  selection: o ? {
                    startLineNumber: o,
                    startColumn: a || 1
                  } : undefined
                },
                remoteAuthority: r
              };
            }
            return {
              fileUri: s,
              remoteAuthority: r
            };
          } else if (N1(e)) {
            return {
              workspace: pn(s),
              remoteAuthority: r
            };
          }
          return {
            workspace: U1(s),
            remoteAuthority: r
          };
        }
        nb(e) {
          if (N1(e)) {
            return e.workspaceUri;
          } else if (A4(e)) {
            return e.folderUri;
          } else {
            return e.fileUri;
          }
        }
        async ob(e, i, s) {
          let r;
          let n;
          if (i.gotoLineMode) {
            ({
              path: e,
              line: r,
              column: n
            } = iu(e));
          }
          e = Ev(pi(e), bs());
          try {
            const o = await nA.promises.stat(e);
            if (o.isFile()) {
              if (!i.forceOpenWorkspaceAsFile) {
                const a = await this.O.resolveLocalWorkspace(P.file(e));
                if (a) {
                  if (a.transient && i.rejectTransientWorkspaces) {
                    return undefined;
                  } else {
                    return {
                      workspace: {
                        id: a.id,
                        configPath: a.configPath
                      },
                      type: Rt.File,
                      exists: true,
                      remoteAuthority: a.remoteAuthority,
                      transient: a.transient
                    };
                  }
                }
              }
              return {
                fileUri: P.file(e),
                type: Rt.File,
                exists: true,
                options: {
                  selection: r ? {
                    startLineNumber: r,
                    startColumn: n || 1
                  } : undefined
                }
              };
            } else {
              if (o.isDirectory()) {
                return {
                  workspace: U1(P.file(e), o),
                  type: Rt.Directory,
                  exists: true
                };
              }
              if (!j && e === "/dev/null") {
                return {
                  fileUri: P.file(e),
                  type: Rt.File,
                  exists: true
                };
              }
            }
          } catch (o) {
            if (o.code === "ERR_UNC_HOST_NOT_ALLOWED" && !s) {
              return this.pb(e, i);
            }
            const a = P.file(e);
            this.N.removeRecentlyOpened([a]);
            if (i.ignoreFileNotFound) {
              return {
                fileUri: a,
                type: Rt.File,
                exists: false
              };
            }
          }
        }
        async pb(e, i) {
          const s = P.file(e);
          const {
            response: r,
            checkboxChecked: n
          } = await this.Q.showMessageBox({
            type: "warning",
            buttons: [v(2527, null), v(2528, null), v(2529, null)],
            message: v(2530, null, s.authority),
            detail: v(2531, null, to(s, {
              os: Wi,
              tildify: this.H
            })),
            checkboxLabel: v(2532, null, s.authority),
            cancelId: 1
          });
          if (r === 0) {
            ma(s.authority);
            if (n) {
              const o = {
                channel: "vscode:configureAllowedUNCHost",
                args: s.authority
              };
              this.sendToFocused(o.channel, o.args);
              this.sendToOpeningWindow(o.channel, o.args);
            }
            return this.ob(e, i, true);
          }
          if (r === 2) {
            aA.openExternal("https://aka.ms/vscode-windows-unc");
            return this.pb(e, i);
          }
        }
        qb(e, i) {
          const s = e.charCodeAt(0);
          const r = i.remoteAuthority;
          let n;
          let o;
          if (i.gotoLineMode) {
            ({
              path: e,
              line: n,
              column: o
            } = iu(e));
          }
          if (s !== 47) {
            if (Sp(s) && e.charCodeAt(e.charCodeAt(1)) === 58) {
              e = Xn(e);
            }
            e = `/${e}`;
          }
          const a = P.from({
            scheme: R.vscodeRemote,
            authority: r,
            path: e
          });
          if (e.charCodeAt(e.length - 1) !== 47) {
            if (ln(e)) {
              if (i.forceOpenWorkspaceAsFile) {
                return {
                  fileUri: a,
                  options: {
                    selection: n ? {
                      startLineNumber: n,
                      startColumn: o || 1
                    } : undefined
                  },
                  remoteAuthority: i.remoteAuthority
                };
              } else {
                return {
                  workspace: pn(a),
                  remoteAuthority: r
                };
              }
            }
            if (i.gotoLineMode || ae.basename(e).indexOf(".") !== -1) {
              return {
                fileUri: a,
                options: {
                  selection: n ? {
                    startLineNumber: n,
                    startColumn: o || 1
                  } : undefined
                },
                remoteAuthority: r
              };
            }
          }
          return {
            workspace: U1(a),
            remoteAuthority: r
          };
        }
        rb(e) {
          const i = this.M.getValue("window");
          const s = i?.openFoldersInNewWindow || "default";
          const r = i?.openFilesInNewWindow || "off";
          let n = (e.preferNewWindow || e.forceNewWindow) && !e.forceReuseWindow;
          if (!e.forceNewWindow && !e.forceReuseWindow && (s === "on" || s === "off")) {
            n = s === "on";
          }
          let o = false;
          if (e.forceNewWindow || e.forceReuseWindow) {
            o = !!e.forceNewWindow && !e.forceReuseWindow;
          } else {
            if (N) {
              if (e.context === 1) {
                o = true;
              }
            } else if (e.context !== 3 && e.context !== 2 && (!e.userEnv || e.userEnv.TERM_PROGRAM !== "vscode")) {
              o = true;
            }
            if (!e.cli.extensionDevelopmentPath && (r === "on" || r === "off")) {
              o = r === "on";
            }
          }
          return {
            openFolderInNewWindow: !!n,
            openFilesInNewWindow: o
          };
        }
        async openExtensionDevelopmentHostWindow(e, i) {
          const s = AD(this.getWindows(), e);
          if (s) {
            this.J.reload(s, i.cli);
            s.focus();
            return [s];
          }
          let r = i.cli["folder-uri"] || [];
          let n = i.cli["file-uri"] || [];
          let o = i.cli._;
          if (!o.length && !r.length && !n.length && !i.cli.extensionTestsPath) {
            const l = this.q.state.lastPluginDevelopmentHostWindow;
            const u = l?.workspace ?? l?.folderUri;
            if (u) {
              if (P.isUri(u)) {
                if (u.scheme === R.file) {
                  o = [u.fsPath];
                } else {
                  r = [u.toString()];
                }
              } else if (u.configPath.scheme === R.file) {
                o = [Ci(u.configPath)];
              } else {
                n = [u.configPath.toString()];
              }
            }
          }
          let a = i.remoteAuthority;
          for (const l of e) {
            if (l.match(/^[a-zA-Z][a-zA-Z0-9\+\-\.]+:/)) {
              const u = P.parse(l);
              const d = Ao(u);
              if (d) {
                if (a) {
                  if (!mi(d, a)) {
                    this.z.error("more than one extension development path authority");
                  }
                } else {
                  a = d;
                }
              }
            }
          }
          o = o.filter(l => {
            const u = P.file(l);
            if ($o(this.getWindows(), u)) {
              return false;
            } else {
              return mi(Ao(u), a);
            }
          });
          r = r.filter(l => {
            const u = this.ib(l);
            if (u && $o(this.getWindows(), u)) {
              return false;
            } else if (u) {
              return mi(Ao(u), a);
            } else {
              return false;
            }
          });
          n = n.filter(l => {
            const u = this.ib(l);
            if (u && $o(this.getWindows(), u)) {
              return false;
            } else if (u) {
              return mi(Ao(u), a);
            } else {
              return false;
            }
          });
          i.cli._ = o;
          i.cli["folder-uri"] = r;
          i.cli["file-uri"] = n;
          const c = {
            context: i.context,
            cli: i.cli,
            forceNewWindow: true,
            forceEmpty: !o.length && !r.length && !n.length,
            userEnv: i.userEnv,
            noRecentEntry: true,
            waitMarkerFileURI: i.waitMarkerFileURI,
            remoteAuthority: a,
            forceProfile: i.forceProfile,
            forceTempProfile: i.forceTempProfile
          };
          return this.open(c);
        }
        async sb(e) {
          const i = this.M.getValue("window");
          const s = this.getLastActiveWindow();
          const n = (i?.newWindowProfile ? this.I.profiles.find(c => c.name === i.newWindowProfile) : undefined) ?? s?.profile ?? this.I.defaultProfile;
          let o;
          if (!e.forceNewWindow && !e.forceNewTabbedWindow) {
            o = e.windowToUse || s;
            if (o) {
              o.focus();
            }
          }
          const a = {
            ...this.H.args,
            ...e.cli,
            machineId: this.r,
            macMachineId: this.s,
            sqmId: this.t,
            devDeviceId: this.u,
            windowId: -1,
            shadowWindowForWorkspaceId: e.shadowWindowForWorkspaceId ?? this.H.args["shadow-window-for-workspace-id"] ?? e.cli?.["shadow-window-for-workspace-id"],
            windowInWindow: e.windowInWindow,
            windowInWindowBodyClass: e.windowInWindowBodyClass,
            windowInWindowParentDimensions: (() => {
              if (e.windowInWindow !== undefined) {
                const c = this.getWindowById(e.windowInWindow);
                if (c) {
                  const l = c.win?.getBounds();
                  if (l) {
                    return {
                      width: l.width,
                      height: l.height
                    };
                  }
                }
              }
            })(),
            mainPid: process.pid,
            appRoot: this.H.appRoot,
            execPath: process.execPath,
            codeCachePath: this.H.codeCachePath,
            backupPath: e.emptyWindowBackupInfo ? F(this.H.backupHome, e.emptyWindowBackupInfo.backupFolder) : undefined,
            profiles: {
              home: this.I.profilesHome,
              all: this.I.profiles,
              profile: n
            },
            homeDir: this.H.userHome.with({
              scheme: R.file
            }).fsPath,
            tmpDir: this.H.tmpDir.with({
              scheme: R.file
            }).fsPath,
            userDataDir: this.H.userDataPath,
            remoteAuthority: e.remoteAuthority,
            workspace: e.workspace,
            userEnv: {
              ...this.w,
              ...e.userEnv
            },
            nls: {
              messages: Tf(),
              language: Ll()
            },
            filesToOpenOrCreate: e.filesToOpen?.filesToOpenOrCreate,
            filesToDiff: e.filesToOpen?.filesToDiff,
            filesToMerge: e.filesToOpen?.filesToMerge,
            filesToWait: e.filesToOpen?.filesToWait,
            logLevel: this.C.getLogLevel(),
            loggers: {
              window: [],
              global: this.C.getRegisteredLoggers()
            },
            logsPath: this.H.logsHome.with({
              scheme: R.file
            }).fsPath,
            product: ko,
            isInitialStartup: e.initialStartup,
            perfMarks: Wf(),
            os: {
              release: lA(),
              hostname: cA(),
              arch: uA()
            },
            autoDetectHighContrast: i?.autoDetectHighContrast ?? true,
            autoDetectColorScheme: i?.autoDetectColorScheme ?? false,
            accessibilitySupport: oA.accessibilitySupportEnabled,
            colorScheme: this.U.getColorScheme(),
            policiesData: this.G.serialize(),
            continueOn: this.H.continueOn,
            cssModules: this.X.isEnabled ? await this.X.getCssModules() : undefined
          };
          if (o) {
            const c = o.config;
            if (!a.extensionDevelopmentPath && c?.extensionDevelopmentPath) {
              a.extensionDevelopmentPath = c.extensionDevelopmentPath;
              a.extensionDevelopmentKind = c.extensionDevelopmentKind;
              a["enable-proposed-api"] = c["enable-proposed-api"];
              a.verbose = c.verbose;
              a["inspect-extensions"] = c["inspect-extensions"];
              a["inspect-brk-extensions"] = c["inspect-brk-extensions"];
              a.debugId = c.debugId;
              a.extensionEnvironment = c.extensionEnvironment;
              a["extensions-dir"] = c["extensions-dir"];
              a["disable-extensions"] = c["disable-extensions"];
            }
            a.loggers = {
              global: a.loggers.global,
              window: c?.loggers.window ?? a.loggers.window
            };
          } else {
            const c = this.q.getNewWindowState(a);
            Ne("code/willCreateCodeWindow");
            const l = o = this.P.createInstance(Jc, {
              state: c,
              extensionDevelopmentPath: a.extensionDevelopmentPath,
              isExtensionTestHost: !!a.extensionTestsPath,
              shadowWindowForWorkspaceId: a.shadowWindowForWorkspaceId,
              windowInWindow: e.windowInWindow
            });
            Ne("code/didCreateCodeWindow");
            if (e.forceNewTabbedWindow) {
              this.getLastActiveWindow()?.addTabbedWindow(l);
            }
            if (e.windowInWindow !== undefined) {
              const f = this.getWindowById(e.windowInWindow);
              if (l.browserView && f && f.win) {
                l.parentWindowId = f.id;
                const p = f.win.getBounds();
                l.browserView.setBounds({
                  x: 0,
                  y: 0,
                  width: p.width,
                  height: p.height
                });
                l.registerListener({
                  dispose: () => {
                    if (l.browserView && f && f.win) {
                      f.win.contentView.removeChildView(l.browserView);
                    }
                  }
                });
                l.registerListener(x.fromNodeEventEmitter(f.win, "closed")(() => {
                  l.close();
                }));
                l.registerListener(x.fromNodeEventEmitter(f.win, "resize")(() => {
                  if (!l.browserView || !f.win || l.windowInWindowExplicitBounds !== undefined) {
                    return;
                  }
                  const w = f.win.getBounds();
                  l.browserView.setBounds({
                    x: 0,
                    y: 0,
                    width: w.width,
                    height: w.height
                  });
                }));
                l.registerListener(x.fromNodeEventEmitter(f.win, "focus")(() => {
                  if (!!l.browserView && !!f.win) {
                    if (l.isBrowserViewVisible) {
                      l.browserView.webContents.focus();
                    }
                  }
                }));
              }
            }
            this.n.set(l.id, l);
            this.a.fire(l);
            this.f.fire({
              oldCount: this.getWindowCount() - 1,
              newCount: this.getWindowCount()
            });
            const u = new De();
            u.add(l.onDidSignalReady(() => this.b.fire(l)));
            u.add(x.once(l.onDidClose)(() => this.vb(l, u)));
            u.add(x.once(l.onDidDestroy)(() => this.wb(l)));
            u.add(l.onDidMaximize(() => this.g.fire(l)));
            u.add(l.onDidUnmaximize(() => this.h.fire(l)));
            u.add(l.onDidEnterFullScreen(() => this.j.fire({
              window: l,
              fullscreen: true
            })));
            u.add(l.onDidLeaveFullScreen(() => this.j.fire({
              window: l,
              fullscreen: false
            })));
            u.add(l.onDidTriggerSystemContextMenu(({
              x: f,
              y: p
            }) => this.m.fire({
              window: l,
              x: f,
              y: p
            })));
            const d = Vl(l.webContents);
            d.removeAllListeners("devtools-reload-page");
            u.add(x.fromNodeEventEmitter(d, "devtools-reload-page")(() => this.J.reload(l)));
            this.J.registerWindow(l);
          }
          a.windowId = o.id;
          if (o.isReady) {
            this.J.unload(o, 4).then(async c => {
              if (!c) {
                await this.tb(o, a, e, n);
              }
            });
          } else {
            await this.tb(o, a, e, n);
          }
          return o;
        }
        async tb(e, i, s, r) {
          if (!i.extensionDevelopmentPath) {
            if (Kt(i.workspace)) {
              i.backupPath = this.L.registerWorkspaceBackup({
                workspace: i.workspace,
                remoteAuthority: i.remoteAuthority
              });
            } else if (Li(i.workspace)) {
              i.backupPath = this.L.registerFolderBackup({
                folderUri: i.workspace.uri,
                remoteAuthority: i.remoteAuthority
              });
            } else {
              i.backupPath = this.L.registerEmptyWindowBackup({
                backupFolder: s.emptyWindowBackupInfo?.backupFolder ?? B1().id,
                remoteAuthority: i.remoteAuthority
              });
            }
          }
          const n = i.workspace ?? ju(i.backupPath, false);
          const o = this.ub(s, n, r);
          const a = o instanceof Promise ? await o : o;
          i.profiles.profile = a;
          if (!i.extensionDevelopmentPath) {
            await this.I.setProfileForWorkspace(n, a);
          }
          e.load(i);
        }
        ub(e, i, s) {
          if (e.forceProfile) {
            return this.I.profiles.find(r => r.name === e.forceProfile) ?? this.I.createNamedProfile(e.forceProfile);
          } else if (e.forceTempProfile) {
            return this.I.createTransientProfile();
          } else {
            return this.I.getProfileForWorkspace(i) ?? s;
          }
        }
        vb(e, i) {
          this.n.delete(e.id);
          this.f.fire({
            oldCount: this.getWindowCount() + 1,
            newCount: this.getWindowCount()
          });
          i.dispose();
        }
        wb(e) {
          this.n.delete(e.id);
          this.c.fire(e);
        }
        getFocusedWindow() {
          const e = cd.getFocusedWindow();
          if (e) {
            return this.getWindowById(e.id);
          }
        }
        getLastActiveWindow() {
          return this.yb(this.getWindows().filter(e => !e.config?.shadowWindowForWorkspaceId));
        }
        xb(e) {
          return this.yb(this.getWindows().filter(i => mi(i.remoteAuthority, e)));
        }
        yb(e) {
          return q4(e);
        }
        sendToFocused(e, ...i) {
          (this.getFocusedWindow() || this.getLastActiveWindow())?.sendWhenReady(e, We.None, ...i);
        }
        sendToOpeningWindow(e, ...i) {
          this.D(x.once(this.onDidSignalReadyWindow)(s => {
            s.sendWhenReady(e, We.None, ...i);
          }));
        }
        sendToAll(e, i, s) {
          for (const r of this.getWindows()) {
            if (!s || !(s.indexOf(r.id) >= 0)) {
              r.sendWhenReady(e, We.None, i);
            }
          }
        }
        getWindows() {
          return Array.from(this.n.values());
        }
        getWindowCount() {
          return this.n.size;
        }
        getWindowById(e) {
          return this.n.get(e);
        }
        getWindowByWebContents(e) {
          const i = cd.fromWebContents(e);
          if (!i) {
            return;
          }
          const s = this.getWindowById(i.id);
          if (s?.matches(e)) {
            return s;
          } else {
            return undefined;
          }
        }
      };
      ud = __decorate([__param(5, V), __param(6, qo), __param(7, Oi), __param(8, Pn), __param(9, ot), __param(10, Rs), __param(11, Te), __param(12, xo), __param(13, Je), __param(14, Bc), __param(15, Cr), __param(16, Ss), __param(17, nr), __param(18, at), __param(19, Wc), __param(20, Eo), __param(21, To), __param(22, Wo)], ud);
    }
  });
  var D6;
  var dA = g({
    "out-build/vs/platform/windows/node/windowTracker.js"() {
      "use strict";
  
      ce();
      B();
      M();
      D6 = class extends T {
        constructor({
          onDidOpenMainWindow: t,
          onDidFocusMainWindow: e,
          getActiveWindowId: i
        }) {
          super();
          this.a = this.D(new De());
          x.latch(x.any(t, e))(this.f, this, this.a);
          this.b = Qn(() => i());
          (async () => {
            try {
              const r = await this.b;
              this.c = typeof this.c == "number" ? this.c : r;
            } catch {} finally {
              this.b = undefined;
            }
          })();
        }
        f(t) {
          if (this.b) {
            this.b.cancel();
            this.b = undefined;
          }
          this.c = t;
        }
        async getActiveClientId() {
          return `window:${this.b ? await this.b : this.c}`;
        }
      };
    }
  });
  var hd;
  var fA = g({
    "out-build/vs/platform/workspaces/electron-main/workspacesMainService.js"() {
      "use strict";
  
      wc();
      Lt();
      zh();
      vn();
      hd = class {
        constructor(e, i, s, r) {
          this.a = e;
          this.b = i;
          this.c = s;
          this.d = r;
          this.onDidChangeRecentlyOpened = this.c.onDidChangeRecentlyOpened;
        }
        async enterWorkspace(e, i) {
          const s = this.b.getWindowById(e);
          if (s) {
            return this.a.enterWorkspace(s, this.b.getWindows(), i);
          }
        }
        createUntitledWorkspace(e, i, s) {
          return this.a.createUntitledWorkspace(i, s);
        }
        deleteUntitledWorkspace(e, i) {
          return this.a.deleteUntitledWorkspace(i);
        }
        getWorkspaceIdentifier(e, i) {
          return this.a.getWorkspaceIdentifier(i);
        }
        getRecentlyOpened(e) {
          return this.c.getRecentlyOpened();
        }
        addRecentlyOpened(e, i) {
          return this.c.addRecentlyOpened(i);
        }
        removeRecentlyOpened(e, i) {
          return this.c.removeRecentlyOpened(i);
        }
        clearRecentlyOpened(e) {
          return this.c.clearRecentlyOpened();
        }
        async getDirtyWorkspaces() {
          return this.d.getDirtyWorkspaces();
        }
      };
      hd = __decorate([__param(0, Cr), __param(1, dt), __param(2, Bc), __param(3, xo)], hd);
    }
  });
  var P6;
  var pA = g({
    "out-build/vs/platform/policy/common/policyIpc.js"() {
      "use strict";
  
      B();
      M();
      Ls();
      P6 = class {
        constructor(t) {
          this.b = t;
          this.a = new De();
        }
        listen(t, e) {
          switch (e) {
            case "onDidChange":
              return x.map(this.b.onDidChange, i => i.reduce((s, r) => ({
                ...s,
                [r]: this.b.getPolicyValue(r) ?? null
              }), {}), this.a);
          }
          throw new Error(`Event not found: ${e}`);
        }
        call(t, e, i) {
          switch (e) {
            case "updatePolicyDefinitions":
              return this.b.updatePolicyDefinitions(i);
          }
          throw new Error(`Call not found: ${e}`);
        }
        dispose() {
          this.a.dispose();
        }
      };
    }
  });
  function gA(t) {
    return t.map(e => {
      const [i, s] = e.split("@");
      return {
        proposalName: i,
        version: s ? parseInt(s) : undefined
      };
    });
  }
  function mA(t) {
    return t.map(e => e.split("@")[0]);
  }
  var $6;
  var I6;
  var em;
  var A6;
  var C6;
  var Jo;
  var _6;
  var wA;
  var tm = g({
    "out-build/vs/platform/extensions/common/extensions.js"() {
      "use strict";
  
      Wt();
      Y();
      Sc();
      $6 = "extensions.user.cache";
      I6 = "extensions.builtin.cache";
      em = "undefined_publisher";
      (function (t) {
        t[t.System = 0] = "System";
        t[t.User = 1] = "User";
      })(A6 ||= {});
      (function (t) {
        t.WIN32_X64 = "win32-x64";
        t.WIN32_ARM64 = "win32-arm64";
        t.LINUX_X64 = "linux-x64";
        t.LINUX_ARM64 = "linux-arm64";
        t.LINUX_ARMHF = "linux-armhf";
        t.ALPINE_X64 = "alpine-x64";
        t.ALPINE_ARM64 = "alpine-arm64";
        t.DARWIN_X64 = "darwin-x64";
        t.DARWIN_ARM64 = "darwin-arm64";
        t.WEB = "web";
        t.UNIVERSAL = "universal";
        t.UNKNOWN = "unknown";
        t.UNDEFINED = "undefined";
      })(C6 ||= {});
      Jo = class {
        constructor(t) {
          this.value = t;
          this._lower = t.toLowerCase();
        }
        static equals(t, e) {
          if (typeof t === "undefined" || t === null) {
            return typeof e === "undefined" || e === null;
          }
          if (typeof e === "undefined" || e === null) {
            return false;
          }
          if (typeof t == "string" || typeof e == "string") {
            const i = typeof t == "string" ? t : t.value;
            const s = typeof e == "string" ? e : e.value;
            return br(i, s);
          }
          return t._lower === e._lower;
        }
        static toKey(t) {
          if (typeof t == "string") {
            return t.toLowerCase();
          } else {
            return t._lower;
          }
        }
      };
      _6 = class {
        constructor() {
          this.c = new Map();
        }
        clear() {
          this.c.clear();
        }
        delete(t) {
          this.c.delete(Jo.toKey(t));
        }
        get(t) {
          return this.c.get(Jo.toKey(t));
        }
        has(t) {
          return this.c.has(Jo.toKey(t));
        }
        set(t, e) {
          this.c.set(Jo.toKey(t), e);
        }
        values() {
          return this.c.values();
        }
        forEach(t) {
          this.c.forEach(t);
        }
        [Symbol.iterator]() {
          return this.c[Symbol.iterator]();
        }
      };
      wA = q("IBuiltinExtensionsScannerService");
    }
  });
  function Ko(t, e) {
    if (t.uuid && e.uuid) {
      return t.uuid === e.uuid;
    } else if (t.id === e.id) {
      return true;
    } else {
      return yp(t.id, e.id) === 0;
    }
  }
  function vA(t, e) {
    return `${t}.${e}`;
  }
  function bA(t) {
    return t.toLowerCase();
  }
  function yA(t, e) {
    return bA(vA(t ?? em, e));
  }
  async function SA(t, e) {
    if (!Se) {
      return false;
    }
    let i;
    try {
      i = (await t.readFile(P.file("/etc/os-release"))).value.toString();
    } catch {
      try {
        i = (await t.readFile(P.file("/usr/lib/os-release"))).value.toString();
      } catch (r) {
        e.debug("Error while getting the os-release file.", Vi(r));
      }
    }
    return !!i && (i.match(/^ID=([^\u001b\r\n]*)/m) || [])[1] === "alpine";
  }
  async function EA(t, e) {
    const i = await SA(t, e);
    const s = zx(i ? "alpine" : Ea, Bw);
    e.debug("ComputeTargetPlatform:", s);
    return s;
  }
  var R6;
  var O6;
  var kA;
  var L6 = g({
    "out-build/vs/platform/extensionManagement/common/extensionManagementUtil.js"() {
      "use strict";
  
      Wt();
      Vu();
      tm();
      H();
      se();
      $e();
      ys();
      $n();
      R6 = /^([^.]+\..+)-(\d+\.\d+\.\d+)(-(.+))?$/;
      O6 = class Af {
        static create(e) {
          const i = e.manifest ? e.manifest.version : e.version;
          const s = e.manifest ? e.targetPlatform : e.properties.targetPlatform;
          return new Af(e.identifier, i, s);
        }
        static parse(e) {
          const i = R6.exec(e);
          if (i && i[1] && i[2]) {
            return new Af({
              id: i[1]
            }, i[2], i[4] || undefined);
          } else {
            return null;
          }
        }
        constructor(e, i, s = "undefined") {
          this.identifier = e;
          this.version = i;
          this.targetPlatform = s;
          this.id = e.id;
        }
        toString() {
          return `${this.id}-${this.version}${this.targetPlatform !== "undefined" ? `-${this.targetPlatform}` : ""}`;
        }
        equals(e) {
          if (e instanceof Af) {
            return Ko(this, e) && this.version === e.version && this.targetPlatform === e.targetPlatform;
          } else {
            return false;
          }
        }
      };
      kA = new Jo("pprice.better-merge");
    }
  });
  function M6(t) {
    return Nt(t) && Hx(t.identifier) && (xA(t.location) || wt(t.location) && t.location) && (Gs(t.relativeLocation) || wt(t.relativeLocation)) && t.version && wt(t.version);
  }
  function xA(t) {
    if (t) {
      return wt(t.path) && wt(t.scheme);
    } else {
      return false;
    }
  }
  var F6;
  var Kc;
  var Zo;
  var dd;
  var fd = g({
    "out-build/vs/platform/extensionManagement/common/extensionsProfileScannerService.js"() {
      "use strict";
  
      ce();
      Ze();
      M();
      B();
      $i();
      se();
      Vu();
      L6();
      He();
      Y();
      X();
      _s();
      As();
      _e();
      $e();
      xt();
      (function (t) {
        t.ERROR_PROFILE_NOT_FOUND = "ERROR_PROFILE_NOT_FOUND";
        t.ERROR_INVALID_CONTENT = "ERROR_INVALID_CONTENT";
      })(F6 ||= {});
      Kc = class extends Error {
        constructor(t, e) {
          super(t);
          this.code = e;
        }
      };
      Zo = q("IExtensionsProfileScannerService");
      dd = class extends T {
        constructor(e, i, s, r, n, o) {
          super();
          this.j = e;
          this.m = i;
          this.n = s;
          this.q = r;
          this.r = n;
          this.s = o;
          this.b = this.D(new $());
          this.onAddExtensions = this.b.event;
          this.c = this.D(new $());
          this.onDidAddExtensions = this.c.event;
          this.f = this.D(new $());
          this.onRemoveExtensions = this.f.event;
          this.g = this.D(new $());
          this.onDidRemoveExtensions = this.g.event;
          this.h = new Ht();
        }
        scanProfileExtensions(e, i) {
          return this.t(e, undefined, i);
        }
        async addExtensionsToProfile(e, i, s) {
          const r = [];
          const n = [];
          try {
            await this.t(i, o => {
              const a = [];
              if (s) {
                a.push(...o);
              } else {
                for (const c of o) {
                  if (e.some(([l]) => Ko(l.identifier, c.identifier) && (l.manifest.version !== c.version || l.location.toString() !== c.location.toString()))) {
                    r.push(c);
                  } else {
                    a.push(c);
                  }
                }
              }
              for (const [c, l] of e) {
                const u = a.findIndex(f => Ko(f.identifier, c.identifier) && f.version === c.manifest.version && f.location.toString() === c.location.toString());
                const d = {
                  identifier: c.identifier,
                  version: c.manifest.version,
                  location: c.location,
                  metadata: l
                };
                if (u === -1) {
                  n.push(d);
                  a.push(d);
                } else {
                  a.splice(u, 1, d);
                }
              }
              if (n.length) {
                this.b.fire({
                  extensions: n,
                  profileLocation: i
                });
              }
              if (r.length) {
                this.f.fire({
                  extensions: r,
                  profileLocation: i
                });
              }
              return a;
            });
            if (n.length) {
              this.c.fire({
                extensions: n,
                profileLocation: i
              });
            }
            if (r.length) {
              this.g.fire({
                extensions: r,
                profileLocation: i
              });
            }
            return n;
          } catch (o) {
            if (n.length) {
              this.c.fire({
                extensions: n,
                error: o,
                profileLocation: i
              });
            }
            if (r.length) {
              this.g.fire({
                extensions: r,
                error: o,
                profileLocation: i
              });
            }
            throw o;
          }
        }
        async updateMetadata(e, i) {
          const s = [];
          await this.t(i, r => {
            const n = [];
            for (const o of r) {
              const a = e.find(([c]) => Ko(c.identifier, o.identifier) && c.manifest.version === o.version);
              if (a) {
                o.metadata = {
                  ...o.metadata,
                  ...a[1]
                };
                s.push(o);
              }
              n.push(o);
            }
            return n;
          });
          return s;
        }
        async removeExtensionFromProfile(e, i) {
          const s = [];
          try {
            await this.t(i, r => {
              const n = [];
              for (const o of r) {
                if (Ko(o.identifier, e.identifier)) {
                  s.push(o);
                } else {
                  n.push(o);
                }
              }
              if (s.length) {
                this.f.fire({
                  extensions: s,
                  profileLocation: i
                });
              }
              return n;
            });
            if (s.length) {
              this.g.fire({
                extensions: s,
                profileLocation: i
              });
            }
          } catch (r) {
            if (s.length) {
              this.g.fire({
                extensions: s,
                error: r,
                profileLocation: i
              });
            }
            throw r;
          }
        }
        async t(e, i, s) {
          return this.F(e).queue(async () => {
            let r = [];
            let n;
            try {
              const o = await this.m.readFile(e);
              n = JSON.parse(o.value.toString().trim() || "[]");
            } catch (o) {
              if ($s(o) !== 1) {
                throw o;
              }
              if (this.q.extUri.isEqual(e, this.n.defaultProfile.extensionsResource)) {
                n = await this.C();
              }
              if (!n && s?.bailOutWhenFileNotFound) {
                throw new Kc(Vi(o), "ERROR_PROFILE_NOT_FOUND");
              }
            }
            if (n) {
              if (!Array.isArray(n)) {
                this.u(e);
              }
              let o = false;
              for (const a of n) {
                if (!M6(a)) {
                  this.u(e);
                }
                let c;
                if (wt(a.relativeLocation) && a.relativeLocation) {
                  c = this.y(a.relativeLocation);
                } else if (wt(a.location)) {
                  this.s.warn(`Extensions profile: Ignoring extension with invalid location: ${a.location}`);
                  continue;
                } else {
                  c = P.revive(a.location);
                  const l = this.w(c);
                  if (l) {
                    o = true;
                    a.relativeLocation = l;
                  }
                }
                if (Gs(a.metadata?.hasPreReleaseVersion) && a.metadata?.preRelease) {
                  o = true;
                  a.metadata.hasPreReleaseVersion = true;
                }
                r.push({
                  identifier: a.identifier,
                  location: c,
                  version: a.version,
                  metadata: a.metadata
                });
              }
              if (o) {
                await this.m.writeFile(e, z.fromString(JSON.stringify(n)));
              }
            }
            if (i) {
              r = i(r);
              const o = r.map(a => ({
                identifier: a.identifier,
                version: a.version,
                location: a.location.toJSON(),
                relativeLocation: this.w(a.location),
                metadata: a.metadata
              }));
              await this.m.writeFile(e, z.fromString(JSON.stringify(o)));
            }
            return r;
          });
        }
        u(e) {
          const i = new Kc(`Invalid extensions content in ${e.toString()}`, "ERROR_INVALID_CONTENT");
          this.r.publicLogError2("extensionsProfileScanningError", {
            code: i.code
          });
          throw i;
        }
        w(e) {
          if (this.q.extUri.isEqual(this.q.extUri.dirname(e), this.j)) {
            return this.q.extUri.basename(e);
          } else {
            return undefined;
          }
        }
        y(e) {
          return this.q.extUri.joinPath(this.j, e);
        }
        async C() {
          this.z ||= (async () => {
            const e = this.q.extUri.joinPath(this.n.defaultProfile.location, "extensions.json");
            const i = this.q.extUri.joinPath(this.j, ".init-default-profile-extensions");
            let s;
            try {
              s = (await this.m.readFile(e)).value.toString();
            } catch (n) {
              if ($s(n) === 1) {
                return;
              }
              throw n;
            }
            this.s.info("Migrating extensions from old default profile location", e.toString());
            let r;
            try {
              const n = JSON.parse(s);
              if (Array.isArray(n) && n.every(o => M6(o))) {
                r = n;
              } else {
                this.s.warn("Skipping migrating from old default profile locaiton: Found invalid data", n);
              }
            } catch (n) {
              this.s.error(n);
            }
            if (r) {
              try {
                await this.m.createFile(this.n.defaultProfile.extensionsResource, z.fromString(JSON.stringify(r)), {
                  overwrite: false
                });
                this.s.info("Migrated extensions from old default profile location to new location", e.toString(), this.n.defaultProfile.extensionsResource.toString());
              } catch (n) {
                if ($s(n) === 3) {
                  this.s.info("Migration from old default profile location to new location is done by another window", e.toString(), this.n.defaultProfile.extensionsResource.toString());
                } else {
                  throw n;
                }
              }
            }
            try {
              await this.m.del(e);
            } catch (n) {
              if ($s(n) !== 1) {
                this.s.error(n);
              }
            }
            try {
              await this.m.del(i);
            } catch (n) {
              if ($s(n) !== 1) {
                this.s.error(n);
              }
            }
            return r;
          })();
          return this.z;
        }
        F(e) {
          let i = this.h.get(e);
          if (!i) {
            i = new eo();
            this.h.set(e, i);
          }
          return i;
        }
      };
      dd = __decorate([__param(1, at), __param(2, Cs), __param(3, yi), __param(4, Ot), __param(5, V)], dd);
    }
  });
  function im(t) {
    switch (t) {
      case 1:
        return v(116, null);
      case 2:
        return v(117, null);
      case 3:
        return v(118, null);
      case 4:
        return v(119, null);
      case 5:
        return v(120, null);
      case 6:
        return v(121, null);
      case 7:
        return v(122, null);
      case 8:
        return v(123, null);
      case 9:
        return v(124, null);
      default:
        return "";
    }
  }
  var DA = g({
    "out-build/vs/base/common/jsonErrorMessages.js"() {
      "use strict";
  
      be();
    }
  });
  var Zc;
  var ve;
  var PA;
  var $A;
  var N6;
  var IA;
  var AA;
  var CA;
  var _A;
  var RA;
  var OA;
  var LA;
  var W6;
  var MA;
  var FA;
  var NA;
  var T6;
  var WA;
  var TA;
  var jA;
  var UA;
  var BA;
  var qA;
  var zA;
  var HA;
  var VA;
  var GA;
  var JA;
  var KA;
  var ZA;
  var YA;
  var XA;
  var QA;
  var eC;
  var tC;
  var iC;
  var sC;
  var rC;
  var nC;
  var j6 = g({
    "out-build/vs/base/common/semver/semver.js"() {
      "use strict";
  
      Zc = {};
      ve = {
        exports: Zc
      };
      (function (t, e) {
        if (typeof Zc == "object" && typeof ve == "object") {
          ve.exports = e();
        } else if (typeof define == "function" && define.amd) {
          define([], e);
        } else {
          var i = e();
          for (var s in i) {
            (typeof Zc == "object" ? Zc : t)[s] = i[s];
          }
        }
      })(typeof self !== "undefined" ? self : undefined, function () {
        return function (t) {
          var e = {};
          function i(s) {
            if (e[s]) {
              return e[s].exports;
            }
            var r = e[s] = {
              i: s,
              l: false,
              exports: {}
            };
            t[s].call(r.exports, r, r.exports, i);
            r.l = true;
            return r.exports;
          }
          i.m = t;
          i.c = e;
          i.d = function (s, r, n) {
            if (!i.o(s, r)) {
              Object.defineProperty(s, r, {
                enumerable: true,
                get: n
              });
            }
          };
          i.r = function (s) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(s, Symbol.toStringTag, {
                value: "Module"
              });
            }
            Object.defineProperty(s, "__esModule", {
              value: true
            });
          };
          i.t = function (s, r) {
            if (r & 1) {
              s = i(s);
            }
            if (r & 8 || r & 4 && typeof s == "object" && s && s.__esModule) {
              return s;
            }
            var n = Object.create(null);
            i.r(n);
            Object.defineProperty(n, "default", {
              enumerable: true,
              value: s
            });
            if (r & 2 && typeof s != "string") {
              for (var o in s) {
                i.d(n, o, function (a) {
                  return s[a];
                }.bind(null, o));
              }
            }
            return n;
          };
          i.n = function (s) {
            var r = s && s.__esModule ? function () {
              return s.default;
            } : function () {
              return s;
            };
            i.d(r, "a", r);
            return r;
          };
          i.o = function (s, r) {
            return Object.prototype.hasOwnProperty.call(s, r);
          };
          i.p = "";
          return i(i.s = 0);
        }([function (t, e, i) {
          (function (s) {
            var r;
            e = t.exports = Oe;
            r = typeof s == "object" && s.env && s.env.NODE_DEBUG && /\bsemver\b/i.test(s.env.NODE_DEBUG) ? function () {
              var S = Array.prototype.slice.call(arguments, 0);
              S.unshift("SEMVER");
              console.log.apply(console, S);
            } : function () {};
            e.SEMVER_SPEC_VERSION = "2.0.0";
            var n = 256;
            var o = Number.MAX_SAFE_INTEGER || 9007199254740991;
            var a = e.re = [];
            var c = e.src = [];
            var l = 0;
            var u = l++;
            c[u] = "0|[1-9]\\d*";
            var d = l++;
            c[d] = "[0-9]+";
            var f = l++;
            c[f] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
            var p = l++;
            c[p] = "(" + c[u] + ")\\.(" + c[u] + ")\\.(" + c[u] + ")";
            var w = l++;
            c[w] = "(" + c[d] + ")\\.(" + c[d] + ")\\.(" + c[d] + ")";
            var m = l++;
            c[m] = "(?:" + c[u] + "|" + c[f] + ")";
            var y = l++;
            c[y] = "(?:" + c[d] + "|" + c[f] + ")";
            var b = l++;
            c[b] = "(?:-(" + c[m] + "(?:\\." + c[m] + ")*))";
            var k = l++;
            c[k] = "(?:-?(" + c[y] + "(?:\\." + c[y] + ")*))";
            var A = l++;
            c[A] = "[0-9A-Za-z-]+";
            var C = l++;
            c[C] = "(?:\\+(" + c[A] + "(?:\\." + c[A] + ")*))";
            var _ = l++;
            var Z = "v?" + c[p] + c[b] + "?" + c[C] + "?";
            c[_] = "^" + Z + "$";
            var ie = "[v=\\s]*" + c[w] + c[k] + "?" + c[C] + "?";
            var me = l++;
            c[me] = "^" + ie + "$";
            var W = l++;
            c[W] = "((?:<|>)?=?)";
            var Ee = l++;
            c[Ee] = c[d] + "|x|X|\\*";
            var Ye = l++;
            c[Ye] = c[u] + "|x|X|\\*";
            var re = l++;
            c[re] = "[v=\\s]*(" + c[Ye] + ")(?:\\.(" + c[Ye] + ")(?:\\.(" + c[Ye] + ")(?:" + c[b] + ")?" + c[C] + "?)?)?";
            var St = l++;
            c[St] = "[v=\\s]*(" + c[Ee] + ")(?:\\.(" + c[Ee] + ")(?:\\.(" + c[Ee] + ")(?:" + c[k] + ")?" + c[C] + "?)?)?";
            var L = l++;
            c[L] = "^" + c[W] + "\\s*" + c[re] + "$";
            var O = l++;
            c[O] = "^" + c[W] + "\\s*" + c[St] + "$";
            var G = l++;
            c[G] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";
            var U = l++;
            c[U] = "(?:~>?)";
            var te = l++;
            c[te] = "(\\s*)" + c[U] + "\\s+";
            a[te] = new RegExp(c[te], "g");
            var pe = l++;
            c[pe] = "^" + c[U] + c[re] + "$";
            var Ce = l++;
            c[Ce] = "^" + c[U] + c[St] + "$";
            var rt = l++;
            c[rt] = "(?:\\^)";
            var pt = l++;
            c[pt] = "(\\s*)" + c[rt] + "\\s+";
            a[pt] = new RegExp(c[pt], "g");
            var Bs = l++;
            c[Bs] = "^" + c[rt] + c[re] + "$";
            var Br = l++;
            c[Br] = "^" + c[rt] + c[St] + "$";
            var qs = l++;
            c[qs] = "^" + c[W] + "\\s*(" + ie + ")$|^$";
            var qn = l++;
            c[qn] = "^" + c[W] + "\\s*(" + Z + ")$|^$";
            var gs = l++;
            c[gs] = "(\\s*)" + c[W] + "\\s*(" + ie + "|" + c[re] + ")";
            a[gs] = new RegExp(c[gs], "g");
            var Il = l++;
            c[Il] = "^\\s*(" + c[re] + ")\\s+-\\s+(" + c[re] + ")\\s*$";
            var Al = l++;
            c[Al] = "^\\s*(" + c[St] + ")\\s+-\\s+(" + c[St] + ")\\s*$";
            var $0 = l++;
            c[$0] = "(<|>)?=?\\s*\\*";
            for (var qr = 0; qr < 35; qr++) {
              r(qr, c[qr]);
              a[qr] ||= new RegExp(c[qr]);
            }
            function zr(S, D) {
              if (S instanceof Oe) {
                return S;
              }
              if (typeof S != "string" || S.length > n || !(D ? a[me] : a[_]).test(S)) {
                return null;
              }
              try {
                return new Oe(S, D);
              } catch {
                return null;
              }
            }
            function Oe(S, D) {
              if (S instanceof Oe) {
                if (S.loose === D) {
                  return S;
                }
                S = S.version;
              } else if (typeof S != "string") {
                throw new TypeError("Invalid Version: " + S);
              }
              if (S.length > n) {
                throw new TypeError("version is longer than " + n + " characters");
              }
              if (!(this instanceof Oe)) {
                return new Oe(S, D);
              }
              r("SemVer", S, D);
              this.loose = D;
              var I = S.trim().match(D ? a[me] : a[_]);
              if (!I) {
                throw new TypeError("Invalid Version: " + S);
              }
              this.raw = S;
              this.major = +I[1];
              this.minor = +I[2];
              this.patch = +I[3];
              if (this.major > o || this.major < 0) {
                throw new TypeError("Invalid major version");
              }
              if (this.minor > o || this.minor < 0) {
                throw new TypeError("Invalid minor version");
              }
              if (this.patch > o || this.patch < 0) {
                throw new TypeError("Invalid patch version");
              }
              if (I[4]) {
                this.prerelease = I[4].split(".").map(function (Q) {
                  if (/^[0-9]+$/.test(Q)) {
                    var ne = +Q;
                    if (ne >= 0 && ne < o) {
                      return ne;
                    }
                  }
                  return Q;
                });
              } else {
                this.prerelease = [];
              }
              this.build = I[5] ? I[5].split(".") : [];
              this.format();
            }
            e.parse = zr;
            e.valid = function (S, D) {
              var I = zr(S, D);
              if (I) {
                return I.version;
              } else {
                return null;
              }
            };
            e.clean = function (S, D) {
              var I = zr(S.trim().replace(/^[=v]+/, ""), D);
              if (I) {
                return I.version;
              } else {
                return null;
              }
            };
            e.SemVer = Oe;
            Oe.prototype.format = function () {
              this.version = this.major + "." + this.minor + "." + this.patch;
              if (this.prerelease.length) {
                this.version += "-" + this.prerelease.join(".");
              }
              return this.version;
            };
            Oe.prototype.toString = function () {
              return this.version;
            };
            Oe.prototype.compare = function (S) {
              r("SemVer.compare", this.version, this.loose, S);
              if (!(S instanceof Oe)) {
                S = new Oe(S, this.loose);
              }
              return this.compareMain(S) || this.comparePre(S);
            };
            Oe.prototype.compareMain = function (S) {
              if (!(S instanceof Oe)) {
                S = new Oe(S, this.loose);
              }
              return zn(this.major, S.major) || zn(this.minor, S.minor) || zn(this.patch, S.patch);
            };
            Oe.prototype.comparePre = function (S) {
              if (!(S instanceof Oe)) {
                S = new Oe(S, this.loose);
              }
              if (this.prerelease.length && !S.prerelease.length) {
                return -1;
              }
              if (!this.prerelease.length && S.prerelease.length) {
                return 1;
              }
              if (!this.prerelease.length && !S.prerelease.length) {
                return 0;
              }
              var D = 0;
              do {
                var I = this.prerelease[D];
                var Q = S.prerelease[D];
                r("prerelease compare", D, I, Q);
                if (I === undefined && Q === undefined) {
                  return 0;
                }
                if (Q === undefined) {
                  return 1;
                }
                if (I === undefined) {
                  return -1;
                }
                if (I !== Q) {
                  return zn(I, Q);
                }
              } while (++D);
            };
            Oe.prototype.inc = function (S, D) {
              switch (S) {
                case "premajor":
                  this.prerelease.length = 0;
                  this.patch = 0;
                  this.minor = 0;
                  this.major++;
                  this.inc("pre", D);
                  break;
                case "preminor":
                  this.prerelease.length = 0;
                  this.patch = 0;
                  this.minor++;
                  this.inc("pre", D);
                  break;
                case "prepatch":
                  this.prerelease.length = 0;
                  this.inc("patch", D);
                  this.inc("pre", D);
                  break;
                case "prerelease":
                  if (this.prerelease.length === 0) {
                    this.inc("patch", D);
                  }
                  this.inc("pre", D);
                  break;
                case "major":
                  if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                    this.major++;
                  }
                  this.minor = 0;
                  this.patch = 0;
                  this.prerelease = [];
                  break;
                case "minor":
                  if (this.patch !== 0 || this.prerelease.length === 0) {
                    this.minor++;
                  }
                  this.patch = 0;
                  this.prerelease = [];
                  break;
                case "patch":
                  if (this.prerelease.length === 0) {
                    this.patch++;
                  }
                  this.prerelease = [];
                  break;
                case "pre":
                  if (this.prerelease.length === 0) {
                    this.prerelease = [0];
                  } else {
                    for (var I = this.prerelease.length; --I >= 0;) {
                      if (typeof this.prerelease[I] == "number") {
                        this.prerelease[I]++;
                        I = -2;
                      }
                    }
                    if (I === -1) {
                      this.prerelease.push(0);
                    }
                  }
                  if (D) {
                    if (this.prerelease[0] === D) {
                      if (isNaN(this.prerelease[1])) {
                        this.prerelease = [D, 0];
                      }
                    } else {
                      this.prerelease = [D, 0];
                    }
                  }
                  break;
                default:
                  throw new Error("invalid increment argument: " + S);
              }
              this.format();
              this.raw = this.version;
              return this;
            };
            e.inc = function (S, D, I, Q) {
              if (typeof I == "string") {
                Q = I;
                I = undefined;
              }
              try {
                return new Oe(S, I).inc(D, Q).version;
              } catch {
                return null;
              }
            };
            e.diff = function (S, D) {
              if (Cf(S, D)) {
                return null;
              }
              var I = zr(S);
              var Q = zr(D);
              if (I.prerelease.length || Q.prerelease.length) {
                for (var ne in I) {
                  if ((ne === "major" || ne === "minor" || ne === "patch") && I[ne] !== Q[ne]) {
                    return "pre" + ne;
                  }
                }
                return "prerelease";
              }
              for (var ne in I) {
                if ((ne === "major" || ne === "minor" || ne === "patch") && I[ne] !== Q[ne]) {
                  return ne;
                }
              }
            };
            e.compareIdentifiers = zn;
            var I0 = /^[0-9]+$/;
            function zn(S, D) {
              var I = I0.test(S);
              var Q = I0.test(D);
              if (I && Q) {
                S = +S;
                D = +D;
              }
              if (I && !Q) {
                return -1;
              } else if (Q && !I) {
                return 1;
              } else if (S < D) {
                return -1;
              } else if (S > D) {
                return 1;
              } else {
                return 0;
              }
            }
            function zs(S, D, I) {
              return new Oe(S, I).compare(new Oe(D, I));
            }
            function Cl(S, D, I) {
              return zs(S, D, I) > 0;
            }
            function _l(S, D, I) {
              return zs(S, D, I) < 0;
            }
            function Cf(S, D, I) {
              return zs(S, D, I) === 0;
            }
            function A0(S, D, I) {
              return zs(S, D, I) !== 0;
            }
            function _f(S, D, I) {
              return zs(S, D, I) >= 0;
            }
            function Rf(S, D, I) {
              return zs(S, D, I) <= 0;
            }
            function Rl(S, D, I, Q) {
              var ne;
              switch (D) {
                case "===":
                  if (typeof S == "object") {
                    S = S.version;
                  }
                  if (typeof I == "object") {
                    I = I.version;
                  }
                  ne = S === I;
                  break;
                case "!==":
                  if (typeof S == "object") {
                    S = S.version;
                  }
                  if (typeof I == "object") {
                    I = I.version;
                  }
                  ne = S !== I;
                  break;
                case "":
                case "=":
                case "==":
                  ne = Cf(S, I, Q);
                  break;
                case "!=":
                  ne = A0(S, I, Q);
                  break;
                case ">":
                  ne = Cl(S, I, Q);
                  break;
                case ">=":
                  ne = _f(S, I, Q);
                  break;
                case "<":
                  ne = _l(S, I, Q);
                  break;
                case "<=":
                  ne = Rf(S, I, Q);
                  break;
                default:
                  throw new TypeError("Invalid operator: " + D);
              }
              return ne;
            }
            function zi(S, D) {
              if (S instanceof zi) {
                if (S.loose === D) {
                  return S;
                }
                S = S.value;
              }
              if (!(this instanceof zi)) {
                return new zi(S, D);
              }
              r("comparator", S, D);
              this.loose = D;
              this.parse(S);
              if (this.semver === fa) {
                this.value = "";
              } else {
                this.value = this.operator + this.semver.version;
              }
              r("comp", this);
            }
            e.rcompareIdentifiers = function (S, D) {
              return zn(D, S);
            };
            e.major = function (S, D) {
              return new Oe(S, D).major;
            };
            e.minor = function (S, D) {
              return new Oe(S, D).minor;
            };
            e.patch = function (S, D) {
              return new Oe(S, D).patch;
            };
            e.compare = zs;
            e.compareLoose = function (S, D) {
              return zs(S, D, true);
            };
            e.rcompare = function (S, D, I) {
              return zs(D, S, I);
            };
            e.sort = function (S, D) {
              return S.sort(function (I, Q) {
                return e.compare(I, Q, D);
              });
            };
            e.rsort = function (S, D) {
              return S.sort(function (I, Q) {
                return e.rcompare(I, Q, D);
              });
            };
            e.gt = Cl;
            e.lt = _l;
            e.eq = Cf;
            e.neq = A0;
            e.gte = _f;
            e.lte = Rf;
            e.cmp = Rl;
            e.Comparator = zi;
            var fa = {};
            function lt(S, D) {
              if (S instanceof lt) {
                if (S.loose === D) {
                  return S;
                } else {
                  return new lt(S.raw, D);
                }
              }
              if (S instanceof zi) {
                return new lt(S.value, D);
              }
              if (!(this instanceof lt)) {
                return new lt(S, D);
              }
              this.loose = D;
              this.raw = S;
              this.set = S.split(/\s*\|\|\s*/).map(function (I) {
                return this.parseRange(I.trim());
              }, this).filter(function (I) {
                return I.length;
              });
              if (!this.set.length) {
                throw new TypeError("Invalid SemVer Range: " + S);
              }
              this.format();
            }
            function ui(S) {
              return !S || S.toLowerCase() === "x" || S === "*";
            }
            function pS(S, D, I, Q, ne, Mt, Le, Di, gt, Yt, ms, mt, Ut) {
              return ((D = ui(I) ? "" : ui(Q) ? ">=" + I + ".0.0" : ui(ne) ? ">=" + I + "." + Q + ".0" : ">=" + D) + " " + (Di = ui(gt) ? "" : ui(Yt) ? "<" + (+gt + 1) + ".0.0" : ui(ms) ? "<" + gt + "." + (+Yt + 1) + ".0" : mt ? "<=" + gt + "." + Yt + "." + ms + "-" + mt : "<=" + Di)).trim();
            }
            function gS(S, D) {
              for (var I = 0; I < S.length; I++) {
                if (!S[I].test(D)) {
                  return false;
                }
              }
              if (D.prerelease.length) {
                for (I = 0; I < S.length; I++) {
                  r(S[I].semver);
                  if (S[I].semver !== fa && S[I].semver.prerelease.length > 0) {
                    var Q = S[I].semver;
                    if (Q.major === D.major && Q.minor === D.minor && Q.patch === D.patch) {
                      return true;
                    }
                  }
                }
                return false;
              }
              return true;
            }
            function Ol(S, D, I) {
              try {
                D = new lt(D, I);
              } catch {
                return false;
              }
              return D.test(S);
            }
            function Of(S, D, I, Q) {
              var ne;
              var Mt;
              var Le;
              var Di;
              var gt;
              S = new Oe(S, Q);
              D = new lt(D, Q);
              switch (I) {
                case ">":
                  ne = Cl;
                  Mt = Rf;
                  Le = _l;
                  Di = ">";
                  gt = ">=";
                  break;
                case "<":
                  ne = _l;
                  Mt = _f;
                  Le = Cl;
                  Di = "<";
                  gt = "<=";
                  break;
                default:
                  throw new TypeError("Must provide a hilo val of \"<\" or \">\"");
              }
              if (Ol(S, D, Q)) {
                return false;
              }
              for (var Yt = 0; Yt < D.set.length; ++Yt) {
                var ms = D.set[Yt];
                var mt = null;
                var Ut = null;
                ms.forEach(function (Pi) {
                  if (Pi.semver === fa) {
                    Pi = new zi(">=0.0.0");
                  }
                  mt = mt || Pi;
                  Ut = Ut || Pi;
                  if (ne(Pi.semver, mt.semver, Q)) {
                    mt = Pi;
                  } else if (Le(Pi.semver, Ut.semver, Q)) {
                    Ut = Pi;
                  }
                });
                if (mt.operator === Di || mt.operator === gt || (!Ut.operator || Ut.operator === Di) && Mt(S, Ut.semver) || Ut.operator === gt && Le(S, Ut.semver)) {
                  return false;
                }
              }
              return true;
            }
            zi.prototype.parse = function (S) {
              var D = this.loose ? a[qs] : a[qn];
              var I = S.match(D);
              if (!I) {
                throw new TypeError("Invalid comparator: " + S);
              }
              this.operator = I[1];
              if (this.operator === "=") {
                this.operator = "";
              }
              if (I[2]) {
                this.semver = new Oe(I[2], this.loose);
              } else {
                this.semver = fa;
              }
            };
            zi.prototype.toString = function () {
              return this.value;
            };
            zi.prototype.test = function (S) {
              r("Comparator.test", S, this.loose);
              return this.semver === fa || (typeof S == "string" && (S = new Oe(S, this.loose)), Rl(S, this.operator, this.semver, this.loose));
            };
            zi.prototype.intersects = function (S, D) {
              if (!(S instanceof zi)) {
                throw new TypeError("a Comparator is required");
              }
              var I;
              if (this.operator === "") {
                I = new lt(S.value, D);
                return Ol(this.value, I, D);
              }
              if (S.operator === "") {
                I = new lt(this.value, D);
                return Ol(S.semver, I, D);
              }
              var Q = (this.operator === ">=" || this.operator === ">") && (S.operator === ">=" || S.operator === ">");
              var ne = (this.operator === "<=" || this.operator === "<") && (S.operator === "<=" || S.operator === "<");
              var Mt = this.semver.version === S.semver.version;
              var Le = (this.operator === ">=" || this.operator === "<=") && (S.operator === ">=" || S.operator === "<=");
              var Di = Rl(this.semver, "<", S.semver, D) && (this.operator === ">=" || this.operator === ">") && (S.operator === "<=" || S.operator === "<");
              var gt = Rl(this.semver, ">", S.semver, D) && (this.operator === "<=" || this.operator === "<") && (S.operator === ">=" || S.operator === ">");
              return Q || ne || Mt && Le || Di || gt;
            };
            e.Range = lt;
            lt.prototype.format = function () {
              this.range = this.set.map(function (S) {
                return S.join(" ").trim();
              }).join("||").trim();
              return this.range;
            };
            lt.prototype.toString = function () {
              return this.range;
            };
            lt.prototype.parseRange = function (S) {
              var D = this.loose;
              S = S.trim();
              r("range", S, D);
              var I = D ? a[Al] : a[Il];
              S = S.replace(I, pS);
              r("hyphen replace", S);
              S = S.replace(a[gs], "$1$2$3");
              r("comparator trim", S, a[gs]);
              S = (S = (S = S.replace(a[te], "$1~")).replace(a[pt], "$1^")).split(/\s+/).join(" ");
              var Q = D ? a[qs] : a[qn];
              var ne = S.split(" ").map(function (Mt) {
                return function (Le, Di) {
                  r("comp", Le);
                  Le = function (gt, Yt) {
                    return gt.trim().split(/\s+/).map(function (ms) {
                      return function (mt, Ut) {
                        r("caret", mt, Ut);
                        var Pi = Ut ? a[Br] : a[Bs];
                        return mt.replace(Pi, function (ts, le, ye, qe, Qe) {
                          var Bt;
                          r("caret", mt, ts, le, ye, qe, Qe);
                          if (ui(le)) {
                            Bt = "";
                          } else if (ui(ye)) {
                            Bt = ">=" + le + ".0.0 <" + (+le + 1) + ".0.0";
                          } else if (ui(qe)) {
                            Bt = le === "0" ? ">=" + le + "." + ye + ".0 <" + le + "." + (+ye + 1) + ".0" : ">=" + le + "." + ye + ".0 <" + (+le + 1) + ".0.0";
                          } else if (Qe) {
                            r("replaceCaret pr", Qe);
                            if (Qe.charAt(0) !== "-") {
                              Qe = "-" + Qe;
                            }
                            Bt = le === "0" ? ye === "0" ? ">=" + le + "." + ye + "." + qe + Qe + " <" + le + "." + ye + "." + (+qe + 1) : ">=" + le + "." + ye + "." + qe + Qe + " <" + le + "." + (+ye + 1) + ".0" : ">=" + le + "." + ye + "." + qe + Qe + " <" + (+le + 1) + ".0.0";
                          } else {
                            r("no pr");
                            Bt = le === "0" ? ye === "0" ? ">=" + le + "." + ye + "." + qe + " <" + le + "." + ye + "." + (+qe + 1) : ">=" + le + "." + ye + "." + qe + " <" + le + "." + (+ye + 1) + ".0" : ">=" + le + "." + ye + "." + qe + " <" + (+le + 1) + ".0.0";
                          }
                          r("caret return", Bt);
                          return Bt;
                        });
                      }(ms, Yt);
                    }).join(" ");
                  }(Le, Di);
                  r("caret", Le);
                  Le = function (gt, Yt) {
                    return gt.trim().split(/\s+/).map(function (ms) {
                      return function (mt, Ut) {
                        var Pi = Ut ? a[Ce] : a[pe];
                        return mt.replace(Pi, function (ts, le, ye, qe, Qe) {
                          var Bt;
                          r("tilde", mt, ts, le, ye, qe, Qe);
                          if (ui(le)) {
                            Bt = "";
                          } else if (ui(ye)) {
                            Bt = ">=" + le + ".0.0 <" + (+le + 1) + ".0.0";
                          } else if (ui(qe)) {
                            Bt = ">=" + le + "." + ye + ".0 <" + le + "." + (+ye + 1) + ".0";
                          } else if (Qe) {
                            r("replaceTilde pr", Qe);
                            if (Qe.charAt(0) !== "-") {
                              Qe = "-" + Qe;
                            }
                            Bt = ">=" + le + "." + ye + "." + qe + Qe + " <" + le + "." + (+ye + 1) + ".0";
                          } else {
                            Bt = ">=" + le + "." + ye + "." + qe + " <" + le + "." + (+ye + 1) + ".0";
                          }
                          r("tilde return", Bt);
                          return Bt;
                        });
                      }(ms, Yt);
                    }).join(" ");
                  }(Le, Di);
                  r("tildes", Le);
                  Le = function (gt, Yt) {
                    r("replaceXRanges", gt, Yt);
                    return gt.split(/\s+/).map(function (ms) {
                      return function (mt, Ut) {
                        mt = mt.trim();
                        var Pi = Ut ? a[O] : a[L];
                        return mt.replace(Pi, function (ts, le, ye, qe, Qe, Bt) {
                          r("xRange", mt, ts, le, ye, qe, Qe, Bt);
                          var C0 = ui(ye);
                          var pa = C0 || ui(qe);
                          var ga = pa || ui(Qe);
                          if (le === "=" && ga) {
                            le = "";
                          }
                          if (C0) {
                            ts = le === ">" || le === "<" ? "<0.0.0" : "*";
                          } else if (le && ga) {
                            if (pa) {
                              qe = 0;
                            }
                            if (ga) {
                              Qe = 0;
                            }
                            if (le === ">") {
                              le = ">=";
                              if (pa) {
                                ye = +ye + 1;
                                qe = 0;
                                Qe = 0;
                              } else if (ga) {
                                qe = +qe + 1;
                                Qe = 0;
                              }
                            } else if (le === "<=") {
                              le = "<";
                              if (pa) {
                                ye = +ye + 1;
                              } else {
                                qe = +qe + 1;
                              }
                            }
                            ts = le + ye + "." + qe + "." + Qe;
                          } else if (pa) {
                            ts = ">=" + ye + ".0.0 <" + (+ye + 1) + ".0.0";
                          } else if (ga) {
                            ts = ">=" + ye + "." + qe + ".0 <" + ye + "." + (+qe + 1) + ".0";
                          }
                          r("xRange return", ts);
                          return ts;
                        });
                      }(ms, Yt);
                    }).join(" ");
                  }(Le, Di);
                  r("xrange", Le);
                  Le = function (gt, Yt) {
                    r("replaceStars", gt, Yt);
                    return gt.trim().replace(a[$0], "");
                  }(Le, Di);
                  r("stars", Le);
                  return Le;
                }(Mt, D);
              }).join(" ").split(/\s+/);
              if (this.loose) {
                ne = ne.filter(function (Mt) {
                  return !!Mt.match(Q);
                });
              }
              return ne = ne.map(function (Mt) {
                return new zi(Mt, D);
              });
            };
            lt.prototype.intersects = function (S, D) {
              if (!(S instanceof lt)) {
                throw new TypeError("a Range is required");
              }
              return this.set.some(function (I) {
                return I.every(function (Q) {
                  return S.set.some(function (ne) {
                    return ne.every(function (Mt) {
                      return Q.intersects(Mt, D);
                    });
                  });
                });
              });
            };
            e.toComparators = function (S, D) {
              return new lt(S, D).set.map(function (I) {
                return I.map(function (Q) {
                  return Q.value;
                }).join(" ").trim().split(" ");
              });
            };
            lt.prototype.test = function (S) {
              if (!S) {
                return false;
              }
              if (typeof S == "string") {
                S = new Oe(S, this.loose);
              }
              for (var D = 0; D < this.set.length; D++) {
                if (gS(this.set[D], S)) {
                  return true;
                }
              }
              return false;
            };
            e.satisfies = Ol;
            e.maxSatisfying = function (S, D, I) {
              var Q = null;
              var ne = null;
              try {
                var Mt = new lt(D, I);
              } catch {
                return null;
              }
              S.forEach(function (Le) {
                if (Mt.test(Le)) {
                  if (!Q || ne.compare(Le) === -1) {
                    ne = new Oe(Q = Le, I);
                  }
                }
              });
              return Q;
            };
            e.minSatisfying = function (S, D, I) {
              var Q = null;
              var ne = null;
              try {
                var Mt = new lt(D, I);
              } catch {
                return null;
              }
              S.forEach(function (Le) {
                if (Mt.test(Le)) {
                  if (!Q || ne.compare(Le) === 1) {
                    ne = new Oe(Q = Le, I);
                  }
                }
              });
              return Q;
            };
            e.validRange = function (S, D) {
              try {
                return new lt(S, D).range || "*";
              } catch {
                return null;
              }
            };
            e.ltr = function (S, D, I) {
              return Of(S, D, "<", I);
            };
            e.gtr = function (S, D, I) {
              return Of(S, D, ">", I);
            };
            e.outside = Of;
            e.prerelease = function (S, D) {
              var I = zr(S, D);
              if (I && I.prerelease.length) {
                return I.prerelease;
              } else {
                return null;
              }
            };
            e.intersects = function (S, D, I) {
              S = new lt(S, I);
              D = new lt(D, I);
              return S.intersects(D);
            };
            e.coerce = function (S) {
              if (S instanceof Oe) {
                return S;
              }
              if (typeof S != "string") {
                return null;
              }
              var D = S.match(a[G]);
              if (D == null) {
                return null;
              } else {
                return zr((D[1] || "0") + "." + (D[2] || "0") + "." + (D[3] || "0"));
              }
            };
          }).call(this, i(1));
        }, function (t, e) {
          var i;
          var s;
          var r = t.exports = {};
          function n() {
            throw new Error("setTimeout has not been defined");
          }
          function o() {
            throw new Error("clearTimeout has not been defined");
          }
          function a(y) {
            if (i === setTimeout) {
              return setTimeout(y, 0);
            }
            if ((i === n || !i) && setTimeout) {
              i = setTimeout;
              return setTimeout(y, 0);
            }
            try {
              return i(y, 0);
            } catch {
              try {
                return i.call(null, y, 0);
              } catch {
                return i.call(this, y, 0);
              }
            }
          }
          (function () {
            try {
              i = typeof setTimeout == "function" ? setTimeout : n;
            } catch {
              i = n;
            }
            try {
              s = typeof clearTimeout == "function" ? clearTimeout : o;
            } catch {
              s = o;
            }
          })();
          var c;
          var l = [];
          var u = false;
          var d = -1;
          function f() {
            if (u && c) {
              u = false;
              if (c.length) {
                l = c.concat(l);
              } else {
                d = -1;
              }
              if (l.length) {
                p();
              }
            }
          }
          function p() {
            if (!u) {
              var y = a(f);
              u = true;
              for (var b = l.length; b;) {
                c = l;
                l = [];
                while (++d < b) {
                  if (c) {
                    c[d].run();
                  }
                }
                d = -1;
                b = l.length;
              }
              c = null;
              u = false;
              (function (k) {
                if (s === clearTimeout) {
                  return clearTimeout(k);
                }
                if ((s === o || !s) && clearTimeout) {
                  s = clearTimeout;
                  return clearTimeout(k);
                }
                try {
                  s(k);
                } catch {
                  try {
                    return s.call(null, k);
                  } catch {
                    return s.call(this, k);
                  }
                }
              })(y);
            }
          }
          function w(y, b) {
            this.fun = y;
            this.array = b;
          }
          function m() {}
          r.nextTick = function (y) {
            var b = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (var k = 1; k < arguments.length; k++) {
                b[k - 1] = arguments[k];
              }
            }
            l.push(new w(y, b));
            if (l.length === 1 && !u) {
              a(p);
            }
          };
          w.prototype.run = function () {
            this.fun.apply(null, this.array);
          };
          r.title = "browser";
          r.browser = true;
          r.env = {};
          r.argv = [];
          r.version = "";
          r.versions = {};
          r.on = m;
          r.addListener = m;
          r.once = m;
          r.off = m;
          r.removeListener = m;
          r.removeAllListeners = m;
          r.emit = m;
          r.prependListener = m;
          r.prependOnceListener = m;
          r.listeners = function (y) {
            return [];
          };
          r.binding = function (y) {
            throw new Error("process.binding is not supported");
          };
          r.cwd = function () {
            return "/";
          };
          r.chdir = function (y) {
            throw new Error("process.chdir is not supported");
          };
          r.umask = function () {
            return 0;
          };
        }]);
      });
      PA = ve.exports.SEMVER_SPEC_VERSION;
      $A = ve.exports.parse;
      N6 = ve.exports.valid;
      IA = ve.exports.coerce;
      AA = ve.exports.clean;
      CA = ve.exports.inc;
      _A = ve.exports.major;
      RA = ve.exports.minor;
      OA = ve.exports.patch;
      LA = ve.exports.prerelease;
      W6 = ve.exports.gt;
      MA = ve.exports.gte;
      FA = ve.exports.lt;
      NA = ve.exports.lte;
      T6 = ve.exports.eq;
      WA = ve.exports.neq;
      TA = ve.exports.cmp;
      jA = ve.exports.compare;
      UA = ve.exports.rcompare;
      BA = ve.exports.compareIdentifiers;
      qA = ve.exports.rcompareIdentifiers;
      zA = ve.exports.compareBuild;
      HA = ve.exports.sort;
      VA = ve.exports.rsort;
      GA = ve.exports.diff;
      JA = ve.exports.validRange;
      KA = ve.exports.satisfies;
      ZA = ve.exports.maxSatisfying;
      YA = ve.exports.minSatisfying;
      XA = ve.exports.minVersion;
      QA = ve.exports.gtr;
      eC = ve.exports.ltr;
      tC = ve.exports.outside;
      iC = ve.exports.intersects;
      sC = ve.exports.SemVer;
      rC = ve.exports.Comparator;
      nC = ve.exports.Range;
    }
  });
  var U6;
  var B6;
  var oC = g({
    "out-build/vs/platform/extensions/common/extensionsApiProposals.js"() {
      "use strict";
  
      U6 = {
        activeComment: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.activeComment.d.ts"
        },
        aiRelatedInformation: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiRelatedInformation.d.ts"
        },
        aiTextSearchProvider: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiTextSearchProvider.d.ts",
          version: 2
        },
        authLearnMore: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authLearnMore.d.ts"
        },
        authSession: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authSession.d.ts"
        },
        canonicalUriProvider: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.canonicalUriProvider.d.ts"
        },
        chatEditing: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatEditing.d.ts"
        },
        chatParticipantAdditions: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantAdditions.d.ts"
        },
        chatParticipantPrivate: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantPrivate.d.ts",
          version: 2
        },
        chatProvider: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatProvider.d.ts"
        },
        chatReferenceBinaryData: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatReferenceBinaryData.d.ts"
        },
        chatTab: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatTab.d.ts"
        },
        chatVariableResolver: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatVariableResolver.d.ts"
        },
        codeActionAI: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionAI.d.ts"
        },
        codeActionRanges: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionRanges.d.ts"
        },
        codiconDecoration: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codiconDecoration.d.ts"
        },
        commentReactor: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReactor.d.ts"
        },
        commentReveal: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReveal.d.ts"
        },
        commentThreadApplicability: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentThreadApplicability.d.ts"
        },
        commentingRangeHint: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentingRangeHint.d.ts"
        },
        commentsDraftState: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentsDraftState.d.ts"
        },
        contribAccessibilityHelpContent: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribAccessibilityHelpContent.d.ts"
        },
        contribChatParticipantDetection: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribChatParticipantDetection.d.ts"
        },
        contribCommentEditorActionsMenu: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentEditorActionsMenu.d.ts"
        },
        contribCommentPeekContext: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentPeekContext.d.ts"
        },
        contribCommentThreadAdditionalMenu: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentThreadAdditionalMenu.d.ts"
        },
        contribCommentsViewThreadMenus: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentsViewThreadMenus.d.ts"
        },
        contribDebugCreateConfiguration: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDebugCreateConfiguration.d.ts"
        },
        contribDiffEditorGutterToolBarMenus: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDiffEditorGutterToolBarMenus.d.ts"
        },
        contribEditSessions: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditSessions.d.ts"
        },
        contribEditorContentMenu: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditorContentMenu.d.ts"
        },
        contribLabelFormatterWorkspaceTooltip: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribLabelFormatterWorkspaceTooltip.d.ts"
        },
        contribMenuBarHome: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMenuBarHome.d.ts"
        },
        contribMergeEditorMenus: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMergeEditorMenus.d.ts"
        },
        contribMultiDiffEditorMenus: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMultiDiffEditorMenus.d.ts"
        },
        contribNotebookStaticPreloads: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribNotebookStaticPreloads.d.ts"
        },
        contribRemoteHelp: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribRemoteHelp.d.ts"
        },
        contribShareMenu: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribShareMenu.d.ts"
        },
        contribSourceControlHistoryItemMenu: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryItemMenu.d.ts"
        },
        contribSourceControlHistoryTitleMenu: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryTitleMenu.d.ts"
        },
        contribSourceControlInputBoxMenu: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlInputBoxMenu.d.ts"
        },
        contribSourceControlTitleMenu: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlTitleMenu.d.ts"
        },
        contribStatusBarItems: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribStatusBarItems.d.ts"
        },
        contribViewContainerTitle: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewContainerTitle.d.ts"
        },
        contribViewsRemote: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsRemote.d.ts"
        },
        contribViewsWelcome: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsWelcome.d.ts"
        },
        control: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.control.d.ts"
        },
        createFileSystemWatcher: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.createFileSystemWatcher.d.ts"
        },
        cursor: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.cursor.d.ts"
        },
        cursorNoDeps: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.cursorNoDeps.d.ts"
        },
        cursorPublic: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.cursorPublic.d.ts"
        },
        cursorTracing: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.cursorTracing.d.ts"
        },
        customEditorMove: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.customEditorMove.d.ts"
        },
        debugVisualization: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.debugVisualization.d.ts"
        },
        defaultChatParticipant: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.defaultChatParticipant.d.ts",
          version: 2
        },
        diffCommand: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffCommand.d.ts"
        },
        diffContentOptions: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffContentOptions.d.ts"
        },
        documentFiltersExclusive: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentFiltersExclusive.d.ts"
        },
        documentPaste: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentPaste.d.ts"
        },
        editSessionIdentityProvider: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editSessionIdentityProvider.d.ts"
        },
        editorHoverVerbosityLevel: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorHoverVerbosityLevel.d.ts"
        },
        editorInsets: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorInsets.d.ts"
        },
        embeddings: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.embeddings.d.ts"
        },
        extensionRuntime: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionRuntime.d.ts"
        },
        extensionsAny: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionsAny.d.ts"
        },
        externalUriOpener: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.externalUriOpener.d.ts"
        },
        fileComments: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileComments.d.ts"
        },
        fileSearchProvider: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider.d.ts"
        },
        fileSearchProvider2: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider2.d.ts"
        },
        findFiles2: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findFiles2.d.ts",
          version: 2
        },
        findTextInFiles: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles.d.ts"
        },
        findTextInFiles2: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles2.d.ts"
        },
        fsChunks: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fsChunks.d.ts"
        },
        idToken: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.idToken.d.ts"
        },
        inlineCompletionsAdditions: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineCompletionsAdditions.d.ts"
        },
        inlineEdit: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineEdit.d.ts"
        },
        interactive: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactive.d.ts"
        },
        interactiveWindow: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactiveWindow.d.ts"
        },
        ipc: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.ipc.d.ts"
        },
        languageModelSystem: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelSystem.d.ts"
        },
        languageStatusText: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageStatusText.d.ts"
        },
        mappedEditsProvider: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.mappedEditsProvider.d.ts"
        },
        multiDocumentHighlightProvider: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.multiDocumentHighlightProvider.d.ts"
        },
        nativeWindowHandle: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.nativeWindowHandle.d.ts"
        },
        newSymbolNamesProvider: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.newSymbolNamesProvider.d.ts"
        },
        notebookCellExecution: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecution.d.ts"
        },
        notebookCellExecutionState: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecutionState.d.ts"
        },
        notebookControllerAffinityHidden: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookControllerAffinityHidden.d.ts"
        },
        notebookDeprecated: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookDeprecated.d.ts"
        },
        notebookExecution: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookExecution.d.ts"
        },
        notebookKernelSource: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookKernelSource.d.ts"
        },
        notebookLiveShare: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookLiveShare.d.ts"
        },
        notebookMessaging: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMessaging.d.ts"
        },
        notebookMime: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMime.d.ts"
        },
        notebookReplDocument: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookReplDocument.d.ts"
        },
        notebookVariableProvider: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookVariableProvider.d.ts"
        },
        portsAttributes: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.portsAttributes.d.ts"
        },
        profileContentHandlers: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.profileContentHandlers.d.ts"
        },
        quickDiffProvider: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickDiffProvider.d.ts"
        },
        quickInputButtonLocation: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickInputButtonLocation.d.ts"
        },
        quickPickItemTooltip: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickItemTooltip.d.ts"
        },
        quickPickSortByLabel: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickSortByLabel.d.ts"
        },
        resolvers: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.resolvers.d.ts"
        },
        scmActionButton: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmActionButton.d.ts"
        },
        scmHistoryProvider: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmHistoryProvider.d.ts"
        },
        scmMultiDiffEditor: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmMultiDiffEditor.d.ts"
        },
        scmRemotes: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmRemotes.d.ts"
        },
        scmSelectedProvider: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmSelectedProvider.d.ts"
        },
        scmTextDocument: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmTextDocument.d.ts"
        },
        scmValidation: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmValidation.d.ts"
        },
        shareProvider: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.shareProvider.d.ts"
        },
        showLocal: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.showLocal.d.ts"
        },
        speech: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.speech.d.ts"
        },
        tabInputMultiDiff: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputMultiDiff.d.ts"
        },
        tabInputTextMerge: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputTextMerge.d.ts"
        },
        taskPresentationGroup: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskPresentationGroup.d.ts"
        },
        telemetry: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.telemetry.d.ts"
        },
        terminalCompletionProvider: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalCompletionProvider.d.ts"
        },
        terminalDataWriteEvent: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDataWriteEvent.d.ts"
        },
        terminalDimensions: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDimensions.d.ts"
        },
        terminalExecuteCommandEvent: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalExecuteCommandEvent.d.ts"
        },
        terminalQuickFixProvider: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalQuickFixProvider.d.ts"
        },
        terminalSelection: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalSelection.d.ts"
        },
        testObserver: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testObserver.d.ts"
        },
        testRelatedCode: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testRelatedCode.d.ts"
        },
        textEditorDiffInformation: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textEditorDiffInformation.d.ts"
        },
        textSearchComplete2: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchComplete2.d.ts"
        },
        textSearchProvider: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider.d.ts"
        },
        textSearchProvider2: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider2.d.ts"
        },
        timeline: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.timeline.d.ts"
        },
        tokenInformation: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tokenInformation.d.ts"
        },
        treeViewActiveItem: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewActiveItem.d.ts"
        },
        treeViewMarkdownMessage: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewMarkdownMessage.d.ts"
        },
        treeViewReveal: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewReveal.d.ts"
        },
        tunnelFactory: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnelFactory.d.ts"
        },
        tunnels: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnels.d.ts"
        },
        valueSelectionInQuickPick: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.valueSelectionInQuickPick.d.ts"
        },
        workspaceTrust: {
          proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.workspaceTrust.d.ts"
        }
      };
      B6 = Object.freeze(U6);
    }
  });
  function aC(t) {
    t = t.trim();
    return t === "*" || nm.test(t);
  }
  function sm(t) {
    if (!aC(t)) {
      return null;
    }
    t = t.trim();
    if (t === "*") {
      return {
        hasCaret: false,
        hasGreaterEquals: false,
        majorBase: 0,
        majorMustEqual: false,
        minorBase: 0,
        minorMustEqual: false,
        patchBase: 0,
        patchMustEqual: false,
        preRelease: null
      };
    }
    const e = t.match(nm);
    if (e) {
      return {
        hasCaret: e[1] === "^",
        hasGreaterEquals: e[1] === ">=",
        majorBase: e[2] === "x" ? 0 : parseInt(e[2], 10),
        majorMustEqual: e[2] !== "x",
        minorBase: e[4] === "x" ? 0 : parseInt(e[4], 10),
        minorMustEqual: e[4] !== "x",
        patchBase: e[6] === "x" ? 0 : parseInt(e[6], 10),
        patchMustEqual: e[6] !== "x",
        preRelease: e[8] || null
      };
    } else {
      return null;
    }
  }
  function rm(t) {
    if (!t) {
      return null;
    }
    const e = t.majorBase;
    const i = t.majorMustEqual;
    const s = t.minorBase;
    let r = t.minorMustEqual;
    const n = t.patchBase;
    let o = t.patchMustEqual;
    if (t.hasCaret) {
      if (e !== 0) {
        r = false;
      }
      o = false;
    }
    let a = 0;
    if (t.preRelease) {
      const c = z6.exec(t.preRelease);
      if (c) {
        const [, l, u, d] = c;
        a = Date.UTC(Number(l), Number(u) - 1, Number(d));
      }
    }
    return {
      majorBase: e,
      majorMustEqual: i,
      minorBase: s,
      minorMustEqual: r,
      patchBase: n,
      patchMustEqual: o,
      isMinimum: t.hasGreaterEquals,
      notBefore: a
    };
  }
  function cC(t, e, i) {
    let s;
    if (typeof t == "string") {
      s = rm(sm(t));
    } else {
      s = t;
    }
    let r;
    if (e instanceof Date) {
      r = e.getTime();
    } else if (typeof e == "string") {
      r = new Date(e).getTime();
    }
    let n;
    if (typeof i == "string") {
      n = rm(sm(i));
    } else {
      n = i;
    }
    if (!s || !n) {
      return false;
    }
    const o = s.majorBase;
    const a = s.minorBase;
    const c = s.patchBase;
    let l = n.majorBase;
    let u = n.minorBase;
    let d = n.patchBase;
    const f = n.notBefore;
    let p = n.majorMustEqual;
    let w = n.minorMustEqual;
    let m = n.patchMustEqual;
    if (n.isMinimum) {
      if (o > l) {
        return true;
      } else if (o < l) {
        return false;
      } else if (a > u) {
        return true;
      } else if (a < u || r && r < f) {
        return false;
      } else {
        return c >= d;
      }
    } else {
      if (o === 1 && l === 0 && (!p || !w || !m)) {
        l = 1;
        u = 0;
        d = 0;
        p = true;
        w = false;
        m = false;
      }
      if (o < l) {
        return false;
      } else if (o > l) {
        return !p;
      } else if (a < u) {
        return false;
      } else if (a > u) {
        return !w;
      } else if (c < d) {
        return false;
      } else if (c > d) {
        return !m;
      } else {
        return !r || !(r < f);
      }
    }
  }
  function lC(t, e, i, s, r, n) {
    const o = [];
    if (typeof s.publisher !== "undefined" && typeof s.publisher != "string") {
      o.push([Pe.Error, v(1880, null)]);
      return o;
    }
    if (typeof s.name != "string") {
      o.push([Pe.Error, v(1881, null, "name")]);
      return o;
    }
    if (typeof s.version != "string") {
      o.push([Pe.Error, v(1882, null, "version")]);
      return o;
    }
    if (!s.engines) {
      o.push([Pe.Error, v(1883, null, "engines")]);
      return o;
    }
    if (typeof s.engines.vscode != "string") {
      o.push([Pe.Error, v(1884, null, "engines.vscode")]);
      return o;
    }
    if (typeof s.extensionDependencies !== "undefined" && !q6(s.extensionDependencies)) {
      o.push([Pe.Error, v(1885, null, "extensionDependencies")]);
      return o;
    }
    if (typeof s.activationEvents !== "undefined") {
      if (!q6(s.activationEvents)) {
        o.push([Pe.Error, v(1886, null, "activationEvents")]);
        return o;
      }
      if (typeof s.main === "undefined" && typeof s.browser === "undefined") {
        o.push([Pe.Error, v(1887, null, "activationEvents", "main", "browser")]);
        return o;
      }
    }
    if (typeof s.extensionKind !== "undefined" && typeof s.main === "undefined") {
      o.push([Pe.Warning, v(1888, null, "extensionKind")]);
    }
    if (typeof s.main !== "undefined") {
      if (typeof s.main != "string") {
        o.push([Pe.Error, v(1889, null, "main")]);
        return o;
      }
      {
        const l = he(i, s.main);
        if (!Dp(l, i)) {
          o.push([Pe.Warning, v(1890, null, l.path, i.path)]);
        }
      }
    }
    if (typeof s.browser !== "undefined") {
      if (typeof s.browser != "string") {
        o.push([Pe.Error, v(1891, null, "browser")]);
        return o;
      }
      {
        const l = he(i, s.browser);
        if (!Dp(l, i)) {
          o.push([Pe.Warning, v(1892, null, l.path, i.path)]);
        }
      }
    }
    if (!N6(s.version)) {
      o.push([Pe.Error, v(1893, null)]);
      return o;
    }
    const a = [];
    if (!uC(t, e, s, r, a)) {
      for (const l of a) {
        o.push([Pe.Error, l]);
      }
    }
    if (n && s.enabledApiProposals?.length) {
      const l = [];
      if (!hC([...s.enabledApiProposals], l)) {
        for (const u of l) {
          o.push([Pe.Error, u]);
        }
      }
    }
    return o;
  }
  function uC(t, e, i, s, r) {
    if (s || typeof i.main === "undefined" && typeof i.browser === "undefined") {
      return true;
    } else {
      return dC(t, e, i.engines.vscode, r);
    }
  }
  function hC(t, e) {
    if (t.length === 0) {
      return true;
    }
    const i = Array.isArray(e) ? e : undefined;
    const s = (i ? undefined : e) ?? B6;
    const r = [];
    const n = gA(t);
    for (const {
      proposalName: o,
      version: a
    } of n) {
      if (!a) {
        continue;
      }
      if (s[o]?.version !== a) {
        r.push(o);
      }
    }
    if (r.length) {
      if (i) {
        if (r.length === 1) {
          i.push(v(1894, null, r[0]));
        } else {
          i.push(v(1895, null, r.slice(0, r.length - 1).map(o => `'${o}'`).join(", "), r[r.length - 1]));
        }
      }
      return false;
    } else {
      return true;
    }
  }
  function dC(t, e, i, s = []) {
    const r = rm(sm(i));
    if (!r) {
      s.push(v(1896, null, i));
      return false;
    }
    if (r.majorBase === 0) {
      if (!r.majorMustEqual || !r.minorMustEqual) {
        s.push(v(1897, null, i));
        return false;
      }
    } else if (!r.majorMustEqual) {
      s.push(v(1898, null, i));
      return false;
    }
    if (cC(t, e, r)) {
      return true;
    } else {
      s.push(v(1899, null, t, i));
      return false;
    }
  }
  function q6(t) {
    if (!Array.isArray(t)) {
      return false;
    }
    for (let e = 0, i = t.length; e < i; e++) {
      if (typeof t[e] != "string") {
        return false;
      }
    }
    return true;
  }
  var nm;
  var z6;
  var fC = g({
    "out-build/vs/platform/extensions/common/extensionValidator.js"() {
      "use strict";
  
      nt();
      dh();
      be();
      j6();
      tm();
      oC();
      nm = /^(\^|>=)?((\d+)|x)\.((\d+)|x)\.((\d+)|x)(\-.*)?$/;
      z6 = /^-(\d{4})(\d{2})(\d{2})$/;
    }
  });
  function pC(t, e, i, s) {
    try {
      gC(t, e, i, s);
    } catch (r) {
      t.error(r?.message ?? r);
    }
    return e;
  }
  function gC(t, e, i, s) {
    const r = (n, o, a) => {
      const c = n[o];
      if (wt(c)) {
        const l = c;
        const u = l.length;
        if (u > 1 && l[0] === "%" && l[u - 1] === "%") {
          const d = l.substr(1, u - 2);
          let f = i[d];
          if (f === undefined && s) {
            f = s[d];
          }
          const p = typeof f == "string" ? f : f?.message;
          const w = s?.[d];
          const m = typeof w == "string" ? w : w?.message;
          if (!p) {
            if (!m) {
              t.warn(`[${e.name}]: ${v(1858, null, d)}`);
            }
            return;
          }
          if (a && (o === "title" || o === "category") && m && m !== p) {
            const y = {
              value: p,
              original: m
            };
            n[o] = y;
          } else {
            n[o] = p;
          }
        }
      } else if (Nt(c)) {
        for (const l in c) {
          if (c.hasOwnProperty(l)) {
            if (l === "commands") {
              r(c, l, true);
            } else {
              r(c, l, a);
            }
          }
        }
      } else if (Array.isArray(c)) {
        for (let l = 0; l < c.length; l++) {
          r(c, l, a);
        }
      }
    };
    for (const n in e) {
      if (e.hasOwnProperty(n)) {
        r(e, n);
      }
    }
  }
  var mC = g({
    "out-build/vs/platform/extensionManagement/common/extensionNls.js"() {
      "use strict";
  
      _e();
      be();
    }
  });
  var om;
  var H6;
  var pd;
  var Yo;
  var Yc;
  var Xc;
  var V6;
  var G6 = g({
    "out-build/vs/platform/extensionManagement/common/extensionsScannerService.js"() {
      "use strict";
  
      zt();
      ce();
      us();
      Ze();
      $e();
      rr();
      DA();
      M();
      Ie();
      we();
      H();
      nt();
      j6();
      dh();
      _e();
      se();
      be();
      Ri();
      L6();
      tm();
      fC();
      He();
      Y();
      X();
      ht();
      B();
      hu();
      fd();
      _s();
      As();
      mC();
      (function (t) {
        function e(i, s) {
          if (i === s) {
            return true;
          }
          const r = Object.keys(i);
          const n = new Set();
          for (const o of Object.keys(s)) {
            n.add(o);
          }
          if (r.length !== n.size) {
            return false;
          }
          for (const o of r) {
            if (i[o] !== s[o]) {
              return false;
            }
            n.delete(o);
          }
          return n.size === 0;
        }
        t.equals = e;
      })(om ||= {});
      H6 = q("IExtensionsScannerService");
      pd = class extends T {
        constructor(e, i, s, r, n, o, a, c, l, u, d, f) {
          super();
          this.systemExtensionsLocation = e;
          this.userExtensionsLocation = i;
          this.q = s;
          this.r = r;
          this.s = n;
          this.t = o;
          this.u = a;
          this.w = c;
          this.y = l;
          this.z = u;
          this.C = d;
          this.F = f;
          this.g = this.D(new $());
          this.onDidChangeCache = this.g.event;
          this.h = he(this.userExtensionsLocation, ".obsolete");
          this.j = this.D(this.F.createInstance(Xc, this.r, this.h));
          this.m = this.D(this.F.createInstance(Xc, this.r, this.h));
          this.n = this.D(this.F.createInstance(Yc, this.h));
          this.H = undefined;
          this.D(this.j.onDidChangeCache(() => this.g.fire(0)));
          this.D(this.m.onDidChangeCache(() => this.g.fire(1)));
        }
        getTargetPlatform() {
          this.G ||= EA(this.u, this.w);
          return this.G;
        }
        async scanAllExtensions(e, i, s) {
          const [r, n] = await Promise.all([this.scanSystemExtensions(e), this.scanUserExtensions(i)]);
          const o = s ? await this.scanExtensionsUnderDevelopment(e, [...r, ...n]) : [];
          return this.L(r, n, o, await this.getTargetPlatform(), true);
        }
        async scanSystemExtensions(e) {
          const i = [];
          i.push(this.M(!!e.useCache, e.language));
          i.push(this.N(e.language, !!e.checkControlFile));
          const [s, r] = await Promise.all(i);
          return this.J([...s, ...r], 0, e, false);
        }
        async scanUserExtensions(e) {
          const i = e.profileLocation ?? this.userExtensionsLocation;
          this.w.trace("Started scanning user extensions", i);
          const s = this.C.extUri.isEqual(e.profileLocation, this.s.defaultProfile.extensionsResource) ? {
            bailOutWhenFileNotFound: true
          } : undefined;
          const r = await this.P(i, !!e.profileLocation, 1, !e.includeUninstalled, e.language, true, s, e.productVersion ?? this.R());
          const n = e.useCache && !r.devMode && r.excludeObsolete ? this.m : this.n;
          let o;
          try {
            o = await n.scanExtensions(r);
          } catch (a) {
            if (a instanceof Kc && a.code === "ERROR_PROFILE_NOT_FOUND") {
              await this.I();
              o = await n.scanExtensions(r);
            } else {
              throw a;
            }
          }
          o = await this.J(o, 1, e, true);
          this.w.trace("Scanned user extensions:", o.length);
          return o;
        }
        async scanExtensionsUnderDevelopment(e, i) {
          if (this.y.isExtensionDevelopment && this.y.extensionDevelopmentLocationURI) {
            const s = (await Promise.all(this.y.extensionDevelopmentLocationURI.filter(r => r.scheme === R.file).map(async r => {
              const n = await this.P(r, false, 1, true, e.language, false, undefined, e.productVersion ?? this.R());
              return (await this.n.scanOneOrMultipleExtensions(n)).map(a => {
                a.type = i.find(c => Ko(c.identifier, a.identifier))?.type ?? a.type;
                return this.n.validate(a, n);
              });
            }))).flat();
            return this.J(s, "development", e, true);
          }
          return [];
        }
        async scanExistingExtension(e, i, s) {
          const r = await this.P(e, false, i, true, s.language, true, undefined, s.productVersion ?? this.R());
          const n = await this.n.scanExtension(r);
          if (!n || !s.includeInvalid && !n.isValid) {
            return null;
          } else {
            return n;
          }
        }
        async scanOneOrMultipleExtensions(e, i, s) {
          const r = await this.P(e, false, i, true, s.language, true, undefined, s.productVersion ?? this.R());
          const n = await this.n.scanOneOrMultipleExtensions(r);
          return this.J(n, i, s, true);
        }
        async scanMultipleExtensions(e, i, s) {
          const r = [];
          await Promise.all(e.map(async n => {
            const o = await this.scanOneOrMultipleExtensions(n, i, s);
            r.push(...o);
          }));
          return this.J(r, i, s, true);
        }
        async scanMetadata(e) {
          const i = he(e, "package.json");
          const s = (await this.u.readFile(i)).value.toString();
          return JSON.parse(s).__metadata;
        }
        async updateMetadata(e, i) {
          const s = he(e, "package.json");
          const r = (await this.u.readFile(s)).value.toString();
          const n = JSON.parse(r);
          if (i.isMachineScoped === false) {
            delete i.isMachineScoped;
          }
          if (i.isBuiltin === false) {
            delete i.isBuiltin;
          }
          n.__metadata = {
            ...n.__metadata,
            ...i
          };
          await this.u.writeFile(he(e, "package.json"), z.fromString(JSON.stringify(n, null, "\t")));
        }
        async initializeDefaultProfileExtensions() {
          try {
            await this.t.scanProfileExtensions(this.s.defaultProfile.extensionsResource, {
              bailOutWhenFileNotFound: true
            });
          } catch (e) {
            if (e instanceof Kc && e.code === "ERROR_PROFILE_NOT_FOUND") {
              await this.I();
            } else {
              throw e;
            }
          }
        }
        async I() {
          this.H ||= (async () => {
            try {
              this.w.info("Started initializing default profile extensions in extensions installation folder.", this.userExtensionsLocation.toString());
              const e = await this.scanUserExtensions({
                includeInvalid: true
              });
              if (e.length) {
                await this.t.addExtensionsToProfile(e.map(i => [i, i.metadata]), this.s.defaultProfile.extensionsResource);
              } else {
                try {
                  await this.u.createFile(this.s.defaultProfile.extensionsResource, z.fromString(JSON.stringify([])));
                } catch (i) {
                  if ($s(i) !== 1) {
                    this.w.warn("Failed to create default profile extensions manifest in extensions installation folder.", this.userExtensionsLocation.toString(), Vi(i));
                  }
                }
              }
              this.w.info("Completed initializing default profile extensions in extensions installation folder.", this.userExtensionsLocation.toString());
            } catch (e) {
              this.w.error(e);
            } finally {
              this.H = undefined;
            }
          })();
          return this.H;
        }
        async J(e, i, s, r) {
          if (!s.includeAllVersions) {
            e = this.L(i === 0 ? e : undefined, i === 1 ? e : undefined, i === "development" ? e : undefined, await this.getTargetPlatform(), r);
          }
          if (!s.includeInvalid) {
            e = e.filter(n => n.isValid);
          }
          return e.sort((n, o) => {
            const a = Ue(n.location.fsPath);
            const c = Ue(o.location.fsPath);
            if (a < c) {
              return -1;
            } else if (a > c) {
              return 1;
            } else {
              return 0;
            }
          });
        }
        L(e, i, s, r, n) {
          const o = (c, l, u) => {
            if (c.isValid && !l.isValid) {
              return false;
            }
            if (c.isValid === l.isValid) {
              if (n && W6(c.manifest.version, l.manifest.version)) {
                this.w.debug(`Skipping extension ${l.location.path} with lower version ${l.manifest.version} in favour of ${c.location.path} with version ${c.manifest.version}`);
                return false;
              }
              if (T6(c.manifest.version, l.manifest.version)) {
                if (c.type === 0) {
                  this.w.debug(`Skipping extension ${l.location.path} in favour of system extension ${c.location.path} with same version`);
                  return false;
                }
                if (c.targetPlatform === r) {
                  this.w.debug(`Skipping extension ${l.location.path} from different target platform ${l.targetPlatform}`);
                  return false;
                }
              }
            }
            if (u) {
              this.w.warn(`Overwriting user extension ${c.location.path} with ${l.location.path}.`);
            } else {
              this.w.debug(`Overwriting user extension ${c.location.path} with ${l.location.path}.`);
            }
            return true;
          };
          const a = new _6();
          e?.forEach(c => {
            const l = a.get(c.identifier.id);
            if (!l || o(l, c, false)) {
              a.set(c.identifier.id, c);
            }
          });
          i?.forEach(c => {
            const l = a.get(c.identifier.id);
            if (!l && e && c.type === 0) {
              this.w.debug(`Skipping obsolete system extension ${c.location.path}.`);
              return;
            }
            if (!l || o(l, c, false)) {
              a.set(c.identifier.id, c);
            }
          });
          s?.forEach(c => {
            const l = a.get(c.identifier.id);
            if (!l || o(l, c, true)) {
              a.set(c.identifier.id, c);
            }
            a.set(c.identifier.id, c);
          });
          return [...a.values()];
        }
        async M(e, i) {
          this.w.trace("Started scanning system extensions");
          const s = await this.P(this.systemExtensionsLocation, false, 0, true, i, true, undefined, this.R());
          const n = await (e && !s.devMode ? this.j : this.n).scanExtensions(s);
          this.w.trace("Scanned system extensions:", n.length);
          return n;
        }
        async N(e, i) {
          const s = this.y.isBuilt ? [] : this.z.builtInExtensions;
          if (!s?.length) {
            return [];
          }
          this.w.trace("Started scanning dev system extensions");
          const r = i ? await this.O() : {};
          const n = [];
          const o = P.file(pi(F(Ct.asFileUri("").fsPath, "..", ".build", "builtInExtensions")));
          for (const c of s) {
            const l = r[c.name] || "marketplace";
            switch (l) {
              case "disabled":
                break;
              case "marketplace":
                n.push(he(o, c.name));
                break;
              default:
                n.push(P.file(l));
                break;
            }
          }
          const a = await Promise.all(n.map(async c => this.n.scanExtension(await this.P(c, false, 0, true, e, true, undefined, this.R()))));
          this.w.trace("Scanned dev system extensions:", a.length);
          return $t(a);
        }
        async O() {
          try {
            const e = await this.u.readFile(this.q);
            return JSON.parse(e.value.toString());
          } catch {
            return {};
          }
        }
        async P(e, i, s, r, n, o, a, c) {
          const l = await this.f(n ?? Hi);
          const u = await this.Q(e);
          const d = i && !this.C.extUri.isEqual(e, this.s.defaultProfile.extensionsResource) ? this.s.defaultProfile.extensionsResource : undefined;
          const f = d ? await this.Q(d) : undefined;
          return new Yo(e, u, d, f, i, a, s, r, o, c.vscodeVersion, c.date, this.z.commit, !this.y.isBuilt, n, l);
        }
        async Q(e) {
          try {
            const i = await this.u.stat(e);
            if (typeof i.mtime == "number") {
              return i.mtime;
            }
          } catch {}
        }
        R() {
          return {
            vscodeVersion: this.z.vscodeVersion,
            version: this.z.version,
            date: this.z.date
          };
        }
      };
      pd = __decorate([__param(4, Cs), __param(5, Zo), __param(6, at), __param(7, V), __param(8, Yi), __param(9, Ve), __param(10, yi), __param(11, Ss)], pd);
      Yo = class {
        constructor(t, e, i, s, r, n, o, a, c, l, u, d, f, p, w) {
          this.location = t;
          this.mtime = e;
          this.applicationExtensionslocation = i;
          this.applicationExtensionslocationMtime = s;
          this.profile = r;
          this.profileScanOptions = n;
          this.type = o;
          this.excludeObsolete = a;
          this.validate = c;
          this.productVersion = l;
          this.productDate = u;
          this.productCommit = d;
          this.devMode = f;
          this.language = p;
          this.translations = w;
        }
        static createNlsConfiguration(t) {
          return {
            language: t.language,
            pseudo: t.language === "pseudo",
            devMode: t.devMode,
            translations: t.translations
          };
        }
        static equals(t, e) {
          return xp(t.location, e.location) && t.mtime === e.mtime && xp(t.applicationExtensionslocation, e.applicationExtensionslocation) && t.applicationExtensionslocationMtime === e.applicationExtensionslocationMtime && t.profile === e.profile && Os(t.profileScanOptions, e.profileScanOptions) && t.type === e.type && t.excludeObsolete === e.excludeObsolete && t.validate === e.validate && t.productVersion === e.productVersion && t.productDate === e.productDate && t.productCommit === e.productCommit && t.devMode === e.devMode && t.language === e.language && om.equals(t.translations, e.translations);
        }
      };
      Yc = class extends T {
        constructor(e, i, s, r, n, o, a) {
          super();
          this.g = e;
          this.h = i;
          this.j = s;
          this.m = r;
          this.n = o;
          this.q = a;
          this.f = n.extensionsEnabledWithApiProposalVersion?.map(c => c.toLowerCase()) ?? [];
        }
        async scanExtensions(e) {
          const i = e.profile ? await this.s(e) : await this.r(e);
          let s = {};
          if (e.excludeObsolete && e.type === 1) {
            try {
              const r = (await this.m.readFile(this.g)).value.toString();
              s = JSON.parse(r);
            } catch {}
          }
          if (sp(s)) {
            return i;
          } else {
            return i.filter(r => !s[O6.create(r).toString()]);
          }
        }
        async r(e) {
          const i = await this.m.resolve(e.location);
          if (!i.children?.length) {
            return [];
          }
          const s = await Promise.all(i.children.map(async r => {
            if (!r.isDirectory || e.type === 1 && ks(r.resource).indexOf(".") === 0) {
              return null;
            }
            const n = new Yo(r.resource, e.mtime, e.applicationExtensionslocation, e.applicationExtensionslocationMtime, e.profile, e.profileScanOptions, e.type, e.excludeObsolete, e.validate, e.productVersion, e.productDate, e.productCommit, e.devMode, e.language, e.translations);
            return this.scanExtension(n);
          }));
          return $t(s).sort((r, n) => r.location.path < n.location.path ? -1 : 1);
        }
        async s(e) {
          let i = await this.t(e.location, () => true, e);
          if (e.applicationExtensionslocation && !this.j.extUri.isEqual(e.location, e.applicationExtensionslocation)) {
            i = i.filter(r => !r.metadata?.isApplicationScoped);
            const s = await this.t(e.applicationExtensionslocation, r => !!r.metadata?.isBuiltin || !!r.metadata?.isApplicationScoped, e);
            i.push(...s);
          }
          return i;
        }
        async t(e, i, s) {
          const r = await this.h.scanProfileExtensions(e, s.profileScanOptions);
          if (!r.length) {
            return [];
          }
          const n = await Promise.all(r.map(async o => {
            if (i(o)) {
              const a = new Yo(o.location, s.mtime, s.applicationExtensionslocation, s.applicationExtensionslocationMtime, s.profile, s.profileScanOptions, s.type, s.excludeObsolete, s.validate, s.productVersion, s.productDate, s.productCommit, s.devMode, s.language, s.translations);
              return this.scanExtension(a, o.metadata);
            }
            return null;
          }));
          return $t(n);
        }
        async scanOneOrMultipleExtensions(e) {
          try {
            if (await this.m.exists(he(e.location, "package.json"))) {
              const i = await this.scanExtension(e);
              if (i) {
                return [i];
              } else {
                return [];
              }
            } else {
              return await this.scanExtensions(e);
            }
          } catch (i) {
            this.q.error(`Error scanning extensions at ${e.location.path}:`, Vi(i));
            return [];
          }
        }
        async scanExtension(e, i) {
          try {
            let s = await this.u(e.location);
            if (s) {
              s.publisher ||= em;
              i = i ?? s.__metadata;
              if (i && !i?.size && s.__metadata?.size) {
                i.size = s.__metadata?.size;
              }
              delete s.__metadata;
              const r = yA(s.publisher, s.name);
              const n = i?.id ? {
                id: r,
                uuid: i.id
              } : {
                id: r
              };
              const o = i?.isSystem ? 0 : e.type;
              const a = o === 0 || !!i?.isBuiltin;
              s = await this.w(e.location, s, Yo.createNlsConfiguration(e));
              let c = {
                type: o,
                identifier: n,
                manifest: s,
                location: e.location,
                isBuiltin: a,
                targetPlatform: i?.targetPlatform ?? "undefined",
                publisherDisplayName: i?.publisherDisplayName,
                metadata: i,
                isValid: true,
                validations: [],
                preRelease: !!i?.preRelease
              };
              if (e.validate) {
                c = this.validate(c, e);
              }
              if (s.enabledApiProposals && (!this.n.isBuilt || this.f.includes(r.toLowerCase()))) {
                s.originalEnabledApiProposals = s.enabledApiProposals;
                s.enabledApiProposals = mA([...s.enabledApiProposals]);
              }
              return c;
            }
          } catch (s) {
            if (e.type !== 0) {
              this.q.error(s);
            }
          }
          return null;
        }
        validate(e, i) {
          let s = true;
          const r = this.n.isBuilt && this.f.includes(e.identifier.id.toLowerCase());
          const n = lC(i.productVersion, i.productDate, i.location, e.manifest, e.isBuiltin, r);
          for (const [o, a] of n) {
            if (o === Pe.Error) {
              s = false;
              this.q.error(this.F(i.location, a));
            }
          }
          e.isValid = s;
          e.validations = n;
          return e;
        }
        async u(e) {
          const i = he(e, "package.json");
          let s;
          try {
            s = (await this.m.readFile(i)).value.toString();
          } catch (n) {
            if ($s(n) !== 1) {
              this.q.error(this.F(e, v(1859, null, i.path, n.message)));
            }
            return null;
          }
          let r;
          try {
            r = JSON.parse(s);
          } catch {
            const o = [];
            gn(s, o);
            for (const a of o) {
              this.q.error(this.F(e, v(1860, null, i.path, a.offset, a.length, im(a.error))));
            }
            return null;
          }
          if (Po(r) !== "object") {
            this.q.error(this.F(e, v(1861, null, i.path)));
            return null;
          } else {
            return r;
          }
        }
        async w(e, i, s) {
          const r = await this.y(e, i, s);
          if (r) {
            try {
              const n = [];
              const o = await this.z(r.default, n);
              if (n.length > 0) {
                n.forEach(c => {
                  this.q.error(this.F(e, v(1862, null, r.default?.path, im(c.error))));
                });
                return i;
              }
              if (Po(r) !== "object") {
                this.q.error(this.F(e, v(1863, null, r.default?.path)));
                return i;
              }
              const a = r.values || Object.create(null);
              return pC(this.q, i, a, o);
            } catch {}
          }
          return i;
        }
        async y(e, i, s) {
          const r = he(e, "package.nls.json");
          const n = (l, u) => {
            u.forEach(d => {
              this.q.error(this.F(e, v(1864, null, l?.path, im(d.error))));
            });
          };
          const o = l => {
            this.q.error(this.F(e, v(1865, null, l?.path)));
          };
          const a = `${i.publisher}.${i.name}`;
          const c = s.translations[a];
          if (c) {
            try {
              const l = P.file(c);
              const u = (await this.m.readFile(l)).value.toString();
              const d = [];
              const f = gn(u, d);
              if (d.length > 0) {
                n(l, d);
                return {
                  values: undefined,
                  default: r
                };
              } else if (Po(f) !== "object") {
                o(l);
                return {
                  values: undefined,
                  default: r
                };
              } else {
                return {
                  values: f.contents ? f.contents.package : undefined,
                  default: r
                };
              }
            } catch {
              return {
                values: undefined,
                default: r
              };
            }
          } else {
            if (!(await this.m.exists(r))) {
              return;
            }
            let u;
            try {
              u = await this.C(e, s);
            } catch {
              return;
            }
            if (!u.localized) {
              return {
                values: undefined,
                default: u.original
              };
            }
            try {
              const d = (await this.m.readFile(u.localized)).value.toString();
              const f = [];
              const p = gn(d, f);
              if (f.length > 0) {
                n(u.localized, f);
                return {
                  values: undefined,
                  default: u.original
                };
              } else if (Po(p) !== "object") {
                o(u.localized);
                return {
                  values: undefined,
                  default: u.original
                };
              } else {
                return {
                  values: p,
                  default: u.original
                };
              }
            } catch {
              return {
                values: undefined,
                default: u.original
              };
            }
          }
        }
        async z(e, i) {
          if (e) {
            try {
              const s = (await this.m.readFile(e)).value.toString();
              return gn(s, i);
            } catch {}
          }
        }
        C(e, i) {
          return new Promise((s, r) => {
            const n = o => {
              const a = he(e, `package.nls.${o}.json`);
              this.m.exists(a).then(c => {
                if (c) {
                  s({
                    localized: a,
                    original: he(e, "package.nls.json")
                  });
                }
                const l = o.lastIndexOf("-");
                if (l === -1) {
                  s({
                    localized: he(e, "package.nls.json"),
                    original: null
                  });
                } else {
                  o = o.substring(0, l);
                  n(o);
                }
              });
            };
            if (i.devMode || i.pseudo || !i.language) {
              return s({
                localized: he(e, "package.nls.json"),
                original: null
              });
            }
            n(i.language);
          });
        }
        F(e, i) {
          return `[${e.path}]: ${i}`;
        }
      };
      Yc = __decorate([__param(1, Zo), __param(2, yi), __param(3, at), __param(4, Ve), __param(5, Yi), __param(6, V)], Yc);
      Xc = class extends Yc {
        constructor(e, i, s, r, n, o, a, c, l) {
          super(i, r, n, o, a, c, l);
          this.J = e;
          this.L = s;
          this.H = this.D(new Ys(3000));
          this.I = this.D(new $());
          this.onDidChangeCache = this.I.event;
        }
        async scanExtensions(e) {
          const i = this.P(e);
          const s = await this.M(i);
          this.G = e;
          if (s && s.input && Yo.equals(s.input, this.G)) {
            this.q.debug("Using cached extensions scan result", e.type === 0 ? "system" : "user", e.location.toString());
            this.H.trigger(() => this.O());
            return s.result.map(n => {
              n.location = P.revive(n.location);
              return n;
            });
          }
          const r = await super.scanExtensions(e);
          await this.N(i, {
            input: e,
            result: r
          });
          return r;
        }
        async M(e) {
          try {
            const i = await this.m.readFile(e);
            const s = JSON.parse(i.value.toString());
            return {
              result: s.result,
              input: Er(s.input)
            };
          } catch (i) {
            this.q.debug("Error while reading the extension cache file:", e.path, Vi(i));
          }
          return null;
        }
        async N(e, i) {
          try {
            await this.m.writeFile(e, z.fromString(JSON.stringify(i)));
          } catch (s) {
            this.q.debug("Error while writing the extension cache file:", e.path, Vi(s));
          }
        }
        async O() {
          if (!this.G) {
            return;
          }
          const e = this.P(this.G);
          const i = await this.M(e);
          if (!i) {
            return;
          }
          const s = i.result;
          const r = JSON.parse(JSON.stringify(await super.scanExtensions(this.G)));
          if (!Os(r, s)) {
            try {
              this.q.info("Invalidating Cache", s, r);
              await this.m.del(e);
              this.I.fire();
            } catch (n) {
              this.q.error(n);
            }
          }
        }
        P(e) {
          const i = this.Q(e);
          return this.j.extUri.joinPath(i.cacheHome, e.type === 0 ? I6 : $6);
        }
        Q(e) {
          if (e.type === 0) {
            return this.L.defaultProfile;
          } else if (e.profile) {
            if (this.j.extUri.isEqual(e.location, this.J.extensionsResource)) {
              return this.J;
            } else {
              return this.L.profiles.find(i => this.j.extUri.isEqual(e.location, i.extensionsResource)) ?? this.J;
            }
          } else {
            return this.L.defaultProfile;
          }
        }
      };
      Xc = __decorate([__param(2, Cs), __param(3, Zo), __param(4, yi), __param(5, at), __param(6, Ve), __param(7, Yi), __param(8, V)], Xc);
      V6 = class extends pd {
        constructor(t, e, i, s, r, n, o, a, c, l, u, d) {
          super(t, e, he(i, ".cursor-dev", "extensions", "control.json"), s, r, n, o, a, c, l, u, d);
          this.S = (async () => {
            if (Kf) {
              try {
                const f = await this.u.readFile(P.file(Kf));
                return JSON.parse(f.value.toString());
              } catch {}
            }
            return Object.create(null);
          })();
        }
        f(t) {
          return this.S;
        }
      };
    }
  });
  var gd;
  var wC = g({
    "out-build/vs/platform/extensionManagement/node/extensionsScannerService.js"() {
      "use strict";
  
      se();
      Ri();
      fd();
      G6();
      He();
      Y();
      X();
      ht();
      As();
      _s();
      gd = class extends V6 {
        constructor(e, i, s, r, n, o, a, c) {
          super(P.file(n.builtinExtensionsPath), P.file(n.extensionsPath), n.userHome, e.defaultProfile, e, i, s, r, n, o, a, c);
        }
      };
      gd = __decorate([__param(0, Cs), __param(1, Zo), __param(2, at), __param(3, V), __param(4, tr), __param(5, Ve), __param(6, yi), __param(7, Ss)], gd);
    }
  });
  var md;
  var vC = g({
    "out-build/vs/platform/userDataProfile/electron-main/userDataProfilesHandler.js"() {
      "use strict";
  
      M();
      ct();
      un();
      ri();
      ce();
      Lt();
      md = class extends T {
        constructor(e, i, s) {
          super();
          this.a = i;
          this.b = s;
          this.D(e.onWillLoadWindow(r => {
            if (r.reason === 2) {
              this.c(r.window);
            }
          }));
          this.D(e.onBeforeCloseWindow(r => this.c(r)));
          this.D(new os(() => this.g(), 30000)).schedule();
        }
        async c(e) {
          const i = this.f(e);
          const s = this.a.getProfileForWorkspace(i);
          if (s?.isTransient) {
            this.a.unsetWorkspace(i, s.isTransient);
            if (s.isTransient) {
              await this.a.cleanUpTransientProfiles();
            }
          }
        }
        f(e) {
          return e.openedWorkspace ?? ju(e.backupPath, e.isExtensionDevelopmentHost);
        }
        g() {
          const e = this.a.getAssociatedEmptyWindows();
          if (e.length === 0) {
            return;
          }
          const i = this.b.getWindows().map(s => this.f(s));
          for (const s of e) {
            if (!i.some(r => r.id === s.id)) {
              this.a.unsetWorkspace(s, false);
            }
          }
        }
      };
      md = __decorate([__param(0, Te), __param(1, Rs), __param(2, dt)], md);
    }
  });
  var J6;
  var bC = g({
    "out-build/vs/platform/userDataProfile/electron-main/userDataProfileStorageIpc.js"() {
      "use strict";
  
      B();
      M();
      v1();
      J6 = class extends T {
        constructor(t, e, i) {
          super();
          this.b = t;
          this.c = e;
          this.f = i;
          const s = this.D(new pr());
          this.a = this.D(new $({
            onWillAddFirstListener: () => s.value = this.g(),
            onDidRemoveLastListener: () => s.value = undefined
          }));
        }
        g() {
          this.f.debug("ProfileStorageChangesListenerChannel#registerStorageChangeListeners");
          const t = new De();
          t.add(x.debounce(this.b.applicationStorage.onDidChangeStorage, (e, i) => {
            if (e) {
              e.push(i.key);
            } else {
              e = [i.key];
            }
            return e;
          }, 100)(e => this.h(e)));
          t.add(x.debounce(this.b.onDidChangeProfileStorage, (e, i) => {
            e ||= new Map();
            let s = e.get(i.profile.id);
            if (!s) {
              e.set(i.profile.id, s = {
                profile: i.profile,
                keys: [],
                storage: i.storage
              });
            }
            s.keys.push(i.key);
            return e;
          }, 100)(e => this.j(e)));
          return t;
        }
        h(t) {
          const e = t.includes(sr) ? [this.c.defaultProfile] : [];
          const i = [];
          t = t.filter(s => s !== sr);
          if (t.length) {
            const s = m1(this.b.applicationStorage.storage);
            i.push({
              profile: this.c.defaultProfile,
              changes: t.map(r => ({
                key: r,
                scope: 0,
                target: s[r]
              }))
            });
          }
          this.m(e, i);
        }
        j(t) {
          const e = [];
          const i = new Map();
          for (const [s, r] of t.entries()) {
            if (r.keys.includes(sr)) {
              e.push(r.profile);
            }
            const n = r.keys.filter(o => o !== sr);
            if (n.length) {
              const o = m1(r.storage.storage);
              i.set(s, {
                profile: r.profile,
                changes: n.map(a => ({
                  key: a,
                  scope: 0,
                  target: o[a]
                }))
              });
            }
          }
          this.m(e, [...i.values()]);
        }
        m(t, e) {
          if (t.length || e.length) {
            this.a.fire({
              valueChanges: e,
              targetChanges: t
            });
          }
        }
        listen(t, e, i) {
          switch (e) {
            case "onDidChange":
              return this.a.event;
          }
          throw new Error(`[ProfileStorageChangesListenerChannel] Event not found: ${e}`);
        }
        async call(t, e) {
          throw new Error(`Call not found: ${e}`);
        }
      };
    }
  });
  async function yC(t, e) {
    let i = t.getItem(E1);
    if (typeof i != "string" || N && i === "6c9d2bc8f91b89624add29c0abeae7fb42bf539fa1cdb2e3e57cd668fa9bcead") {
      i = await b$(e.error.bind(e));
    }
    return i;
  }
  async function SC(t, e) {
    let i = t.getItem(k1);
    if (typeof i != "string") {
      i = await D2(e.error.bind(e));
    }
    return i;
  }
  async function EC(t, e) {
    let i = t.getItem(x1);
    if (typeof i != "string") {
      i = await E$(e.error.bind(e));
    }
    return i;
  }
  async function K6(t, e) {
    let i = t.getItem(zu);
    if (typeof i != "string") {
      i = await $2(e.error.bind(e));
    }
    return i;
  }
  var kC = g({
    "out-build/vs/platform/telemetry/node/telemetryUtils.js"() {
      "use strict";
  
      H();
      _c();
      xt();
    }
  });
  async function xC(t, e) {
    const i = await yC(t, e);
    t.setItem(E1, i);
    return i;
  }
  async function DC(t, e) {
    const i = await SC(t, e);
    t.setItem(k1, i);
    return i;
  }
  async function PC(t, e) {
    const i = await EC(t, e);
    t.setItem(x1, i);
    return i;
  }
  async function $C(t, e) {
    const i = await K6(t, e);
    t.setItem(zu, i);
    return i;
  }
  async function IC(t, e) {
    const i = await $2(e.error.bind(e));
    const s = await K6(t, e);
    if (i !== s) {
      t.setItem(zu, i);
    }
  }
  var AC = g({
    "out-build/vs/platform/telemetry/electron-main/telemetryUtils.js"() {
      "use strict";
  
      xt();
      kC();
      _c();
    }
  });
  var wd;
  var CC = g({
    "out-build/vs/platform/extensionManagement/node/extensionsProfileScannerService.js"() {
      "use strict";
  
      X();
      _s();
      As();
      xt();
      fd();
      He();
      Ri();
      se();
      wd = class extends dd {
        constructor(e, i, s, r, n, o) {
          super(P.file(e.extensionsPath), i, s, r, n, o);
        }
      };
      wd = __decorate([__param(0, tr), __param(1, at), __param(2, Cs), __param(3, yi), __param(4, Ot), __param(5, V)], wd);
    }
  });
  var Z6;
  var _C = g({
    "out-build/vs/platform/log/electron-main/logIpc.js"() {
      "use strict";
  
      $i();
      se();
      X();
      Z6 = class {
        constructor(t) {
          this.b = t;
          this.a = new Ht();
        }
        listen(t, e, i) {
          switch (e) {
            case "onDidChangeLoggers":
              if (i) {
                return this.b.getOnDidChangeLoggersEvent(i);
              } else {
                return this.b.onDidChangeLoggers;
              }
            case "onDidChangeLogLevel":
              if (i) {
                return this.b.getOnDidChangeLogLevelEvent(i);
              } else {
                return this.b.onDidChangeLogLevel;
              }
            case "onDidChangeVisibility":
              if (i) {
                return this.b.getOnDidChangeVisibilityEvent(i);
              } else {
                return this.b.onDidChangeVisibility;
              }
          }
          throw new Error(`Event not found: ${e}`);
        }
        async call(t, e, i) {
          switch (e) {
            case "createLogger":
              this.c(P.revive(i[0]), i[1], i[2]);
              return;
            case "log":
              return this.e(P.revive(i[0]), i[1]);
            case "consoleLog":
              return this.d(i[0], i[1]);
            case "setLogLevel":
              if (vy(i[0])) {
                return this.b.setLogLevel(i[0]);
              } else {
                return this.b.setLogLevel(P.revive(i[0]), i[1]);
              }
            case "setVisibility":
              return this.b.setVisibility(P.revive(i[0]), i[1]);
            case "registerLogger":
              return this.b.registerLogger({
                ...i[0],
                resource: P.revive(i[0].resource)
              }, i[1]);
            case "deregisterLogger":
              return this.b.deregisterLogger(P.revive(i[0]));
          }
          throw new Error(`Call not found: ${e}`);
        }
        c(t, e, i) {
          this.a.set(t, this.b.createLogger(t, e, i));
        }
        d(t, e) {
          let i = console.log;
          switch (t) {
            case J.Error:
              i = console.error;
              break;
            case J.Warning:
              i = console.warn;
              break;
            case J.Info:
              i = console.info;
              break;
          }
          i.call(console, ...e);
        }
        e(t, e) {
          const i = this.a.get(t);
          if (!i) {
            throw new Error("Create the logger before logging");
          }
          for (const [s, r] of e) {
            a1(i, s, r);
          }
        }
      };
    }
  });
  var am;
  var vd;
  var bd;
  var RC = g({
    "out-build/vs/platform/utilityProcess/electron-main/utilityProcessWorkerMainService.js"() {
      "use strict";
  
      M();
      Y();
      X();
      Lt();
      _o();
      xt();
      er();
      B();
      ce();
      ct();
      am = q("utilityProcessWorker");
      vd = class extends T {
        constructor(e, i, s, r) {
          super();
          this.b = e;
          this.c = i;
          this.f = s;
          this.g = r;
          this.a = new Map();
        }
        async createWorker(e) {
          const i = `window: ${e.reply.windowId}, moduleId: ${e.process.moduleId}`;
          this.b.trace(`[UtilityProcessWorker]: createWorker(${i})`);
          const s = this.h(e);
          if (this.a.has(s)) {
            this.b.warn(`[UtilityProcessWorker]: createWorker() found an existing worker that will be terminated (${i})`);
            this.disposeWorker(e);
          }
          const r = new bd(this.b, this.c, this.f, this.g, e);
          if (!r.spawn()) {
            return {
              reason: {
                code: 1,
                signal: "EINVALID"
              }
            };
          }
          this.a.set(s, r);
          const n = new Xs();
          x.once(r.onDidTerminate)(o => {
            if (o.code === 0) {
              this.b.trace(`[UtilityProcessWorker]: terminated normally with code ${o.code}, signal: ${o.signal}`);
            } else {
              this.b.error(`[UtilityProcessWorker]: terminated unexpectedly with code ${o.code}, signal: ${o.signal}`);
            }
            this.a.delete(s);
            n.complete({
              reason: o
            });
          });
          return n.p;
        }
        h(e) {
          return Ds({
            moduleId: e.process.moduleId,
            windowId: e.reply.windowId
          });
        }
        async disposeWorker(e) {
          const i = this.h(e);
          const s = this.a.get(i);
          if (s) {
            this.b.trace(`[UtilityProcessWorker]: disposeWorker(window: ${e.reply.windowId}, moduleId: ${e.process.moduleId})`);
            s.kill();
            s.dispose();
            this.a.delete(i);
          }
        }
      };
      vd = __decorate([__param(0, V), __param(1, dt), __param(2, Ot), __param(3, Te)], vd);
      bd = class extends T {
        constructor(e, i, s, r, n) {
          super();
          this.c = e;
          this.f = i;
          this.g = s;
          this.h = r;
          this.j = n;
          this.a = this.D(new $());
          this.onDidTerminate = this.a.event;
          this.b = this.D(new Ec(this.c, this.f, this.g, this.h));
          this.m();
        }
        m() {
          this.D(this.b.onExit(e => this.a.fire({
            code: e.code,
            signal: e.signal
          })));
          this.D(this.b.onCrash(e => this.a.fire({
            code: e.code,
            signal: "ECRASH"
          })));
        }
        spawn() {
          const i = this.f.getWindowById(this.j.reply.windowId)?.win?.webContents.getOSProcessId();
          return this.b.start({
            processTitle: `${this.j.process.type} [${this.j.reply.windowId}]`,
            type: this.j.process.type,
            entryPoint: this.j.process.moduleId,
            parentLifecycleBound: i,
            windowLifecycleBound: true,
            correlationId: `${this.j.reply.windowId}`,
            responseWindowId: this.j.reply.windowId,
            responseChannel: this.j.reply.channel,
            responseNonce: this.j.reply.nonce
          });
        }
        kill() {
          this.b.kill();
        }
      };
      bd = __decorate([__param(0, V), __param(1, dt), __param(2, Ot), __param(3, Te)], bd);
    }
  });
  var Y6;
  var OC = g({
    "out-build/vs/platform/utilityProcess/common/utilityProcessWorkerService.js"() {
      "use strict";
  
      Y6 = "utilityProcessWorker";
    }
  });
  var LC;
  var X6;
  var Q6;
  var e7;
  var t7;
  var i7;
  var s7;
  var Xo;
  var r7;
  var MC;
  var Ei;
  var n7;
  var o7;
  var a7;
  var c7;
  var l7;
  var u7;
  var h7;
  var d7;
  var f7;
  var cm;
  var FC;
  var p7 = g({
    "out-build/vs/platform/terminal/common/terminal.js"() {
      "use strict";
  
      Y();
      wy();
      Zs();
      LC = new o1("terminalTabFocusMode", false, true);
      (function (t) {
        t.AutomationProfile = "terminal.integrated.automationProfile.";
        t.DefaultProfile = "terminal.integrated.defaultProfile.";
        t.Profiles = "terminal.integrated.profiles.";
      })(X6 ||= {});
      (function (t) {
        t.SendKeybindingsToShell = "terminal.integrated.sendKeybindingsToShell";
        t.AutomationProfileLinux = "terminal.integrated.automationProfile.linux";
        t.AutomationProfileMacOs = "terminal.integrated.automationProfile.osx";
        t.AutomationProfileWindows = "terminal.integrated.automationProfile.windows";
        t.ProfilesWindows = "terminal.integrated.profiles.windows";
        t.ProfilesMacOs = "terminal.integrated.profiles.osx";
        t.ProfilesLinux = "terminal.integrated.profiles.linux";
        t.DefaultProfileLinux = "terminal.integrated.defaultProfile.linux";
        t.DefaultProfileMacOs = "terminal.integrated.defaultProfile.osx";
        t.DefaultProfileWindows = "terminal.integrated.defaultProfile.windows";
        t.UseWslProfiles = "terminal.integrated.useWslProfiles";
        t.TabsDefaultColor = "terminal.integrated.tabs.defaultColor";
        t.TabsDefaultIcon = "terminal.integrated.tabs.defaultIcon";
        t.TabsEnabled = "terminal.integrated.tabs.enabled";
        t.TabsEnableAnimation = "terminal.integrated.tabs.enableAnimation";
        t.TabsHideCondition = "terminal.integrated.tabs.hideCondition";
        t.TabsShowActiveTerminal = "terminal.integrated.tabs.showActiveTerminal";
        t.TabsShowActions = "terminal.integrated.tabs.showActions";
        t.TabsLocation = "terminal.integrated.tabs.location";
        t.TabsFocusMode = "terminal.integrated.tabs.focusMode";
        t.MacOptionIsMeta = "terminal.integrated.macOptionIsMeta";
        t.MacOptionClickForcesSelection = "terminal.integrated.macOptionClickForcesSelection";
        t.AltClickMovesCursor = "terminal.integrated.altClickMovesCursor";
        t.CopyOnSelection = "terminal.integrated.copyOnSelection";
        t.EnableMultiLinePasteWarning = "terminal.integrated.enableMultiLinePasteWarning";
        t.DrawBoldTextInBrightColors = "terminal.integrated.drawBoldTextInBrightColors";
        t.FontFamily = "terminal.integrated.fontFamily";
        t.FontSize = "terminal.integrated.fontSize";
        t.LetterSpacing = "terminal.integrated.letterSpacing";
        t.LineHeight = "terminal.integrated.lineHeight";
        t.MinimumContrastRatio = "terminal.integrated.minimumContrastRatio";
        t.TabStopWidth = "terminal.integrated.tabStopWidth";
        t.FastScrollSensitivity = "terminal.integrated.fastScrollSensitivity";
        t.MouseWheelScrollSensitivity = "terminal.integrated.mouseWheelScrollSensitivity";
        t.BellDuration = "terminal.integrated.bellDuration";
        t.FontWeight = "terminal.integrated.fontWeight";
        t.FontWeightBold = "terminal.integrated.fontWeightBold";
        t.CursorBlinking = "terminal.integrated.cursorBlinking";
        t.CursorStyle = "terminal.integrated.cursorStyle";
        t.CursorStyleInactive = "terminal.integrated.cursorStyleInactive";
        t.CursorWidth = "terminal.integrated.cursorWidth";
        t.Scrollback = "terminal.integrated.scrollback";
        t.DetectLocale = "terminal.integrated.detectLocale";
        t.DefaultLocation = "terminal.integrated.defaultLocation";
        t.GpuAcceleration = "terminal.integrated.gpuAcceleration";
        t.TerminalTitleSeparator = "terminal.integrated.tabs.separator";
        t.TerminalTitle = "terminal.integrated.tabs.title";
        t.TerminalDescription = "terminal.integrated.tabs.description";
        t.RightClickBehavior = "terminal.integrated.rightClickBehavior";
        t.MiddleClickBehavior = "terminal.integrated.middleClickBehavior";
        t.Cwd = "terminal.integrated.cwd";
        t.ConfirmOnExit = "terminal.integrated.confirmOnExit";
        t.ConfirmOnKill = "terminal.integrated.confirmOnKill";
        t.EnableBell = "terminal.integrated.enableBell";
        t.EnableVisualBell = "terminal.integrated.enableVisualBell";
        t.CommandsToSkipShell = "terminal.integrated.commandsToSkipShell";
        t.AllowChords = "terminal.integrated.allowChords";
        t.AllowMnemonics = "terminal.integrated.allowMnemonics";
        t.TabFocusMode = "terminal.integrated.tabFocusMode";
        t.EnvMacOs = "terminal.integrated.env.osx";
        t.EnvLinux = "terminal.integrated.env.linux";
        t.EnvWindows = "terminal.integrated.env.windows";
        t.EnvironmentChangesIndicator = "terminal.integrated.environmentChangesIndicator";
        t.EnvironmentChangesRelaunch = "terminal.integrated.environmentChangesRelaunch";
        t.ExperimentalWindowsUseConptyDll = "terminal.integrated.experimental.windowsUseConptyDll";
        t.ShowExitAlert = "terminal.integrated.showExitAlert";
        t.SplitCwd = "terminal.integrated.splitCwd";
        t.WindowsEnableConpty = "terminal.integrated.windowsEnableConpty";
        t.WordSeparators = "terminal.integrated.wordSeparators";
        t.EnableFileLinks = "terminal.integrated.enableFileLinks";
        t.AllowedLinkSchemes = "terminal.integrated.allowedLinkSchemes";
        t.UnicodeVersion = "terminal.integrated.unicodeVersion";
        t.EnablePersistentSessions = "terminal.integrated.enablePersistentSessions";
        t.PersistentSessionReviveProcess = "terminal.integrated.persistentSessionReviveProcess";
        t.HideOnStartup = "terminal.integrated.hideOnStartup";
        t.CustomGlyphs = "terminal.integrated.customGlyphs";
        t.RescaleOverlappingGlyphs = "terminal.integrated.rescaleOverlappingGlyphs";
        t.PersistentSessionScrollback = "terminal.integrated.persistentSessionScrollback";
        t.InheritEnv = "terminal.integrated.inheritEnv";
        t.ShowLinkHover = "terminal.integrated.showLinkHover";
        t.IgnoreProcessNames = "terminal.integrated.ignoreProcessNames";
        t.ShellIntegrationEnabled = "terminal.integrated.shellIntegration.enabled";
        t.ShellIntegrationShowWelcome = "terminal.integrated.shellIntegration.showWelcome";
        t.ShellIntegrationDecorationsEnabled = "terminal.integrated.shellIntegration.decorationsEnabled";
        t.EnableImages = "terminal.integrated.enableImages";
        t.SmoothScrolling = "terminal.integrated.smoothScrolling";
        t.IgnoreBracketedPasteMode = "terminal.integrated.ignoreBracketedPasteMode";
        t.FocusAfterRun = "terminal.integrated.focusAfterRun";
        t.FontLigatures = "terminal.integrated.fontLigatures";
        t.DeveloperPtyHostLatency = "terminal.integrated.developer.ptyHost.latency";
        t.DeveloperPtyHostStartupDelay = "terminal.integrated.developer.ptyHost.startupDelay";
        t.DevMode = "terminal.integrated.developer.devMode";
      })(Q6 ||= {});
      (function (t) {
        t.Bash = "bash";
        t.Fish = "fish";
        t.Sh = "sh";
        t.Csh = "csh";
        t.Ksh = "ksh";
        t.Zsh = "zsh";
      })(e7 ||= {});
      (function (t) {
        t.CommandPrompt = "cmd";
        t.Wsl = "wsl";
        t.GitBash = "gitbash";
      })(t7 ||= {});
      (function (t) {
        t.PowerShell = "pwsh";
        t.Python = "python";
        t.Julia = "julia";
        t.NuShell = "nu";
      })(i7 ||= {});
      (function (t) {
        t[t.Api = 0] = "Api";
        t[t.Process = 1] = "Process";
        t[t.Sequence = 2] = "Sequence";
        t[t.Config = 3] = "Config";
      })(s7 ||= {});
      (function (t) {
        t.LocalPty = "localPty";
        t.PtyHost = "ptyHost";
        t.PtyHostWindow = "ptyHostWindow";
        t.Logger = "logger";
        t.Heartbeat = "heartbeat";
      })(Xo ||= {});
      (function (t) {
        t.Cwd = "cwd";
        t.InitialCwd = "initialCwd";
        t.FixedDimensions = "fixedDimensions";
        t.Title = "title";
        t.ShellType = "shellType";
        t.HasChildProcesses = "hasChildProcesses";
        t.ResolvedShellLaunchConfig = "resolvedShellLaunchConfig";
        t.OverrideDimensions = "overrideDimensions";
        t.FailedShellIntegrationActivation = "failedShellIntegrationActivation";
        t.UsedShellIntegrationInjection = "usedShellIntegrationInjection";
      })(r7 ||= {});
      MC = q("ptyService");
      (function (t) {
        t[t.BeatInterval = 5000] = "BeatInterval";
        t[t.ConnectingBeatInterval = 20000] = "ConnectingBeatInterval";
        t[t.FirstWaitMultiplier = 1.2] = "FirstWaitMultiplier";
        t[t.SecondWaitMultiplier = 1] = "SecondWaitMultiplier";
        t[t.CreateProcessTimeout = 5000] = "CreateProcessTimeout";
      })(Ei ||= {});
      (function (t) {
        t[t.Panel = 1] = "Panel";
        t[t.Editor = 2] = "Editor";
      })(n7 ||= {});
      (function (t) {
        t.TerminalView = "view";
        t.Editor = "editor";
      })(o7 ||= {});
      (function (t) {
        t[t.GraceTime = 60000] = "GraceTime";
        t[t.ShortGraceTime = 6000] = "ShortGraceTime";
      })(a7 ||= {});
      (function (t) {
        t[t.HighWatermarkChars = 100000] = "HighWatermarkChars";
        t[t.LowWatermarkChars = 5000] = "LowWatermarkChars";
        t[t.CharCountAckSize = 5000] = "CharCountAckSize";
      })(c7 ||= {});
      (function (t) {
        t.GitBash = "Git Bash";
        t.Pwsh = "PowerShell";
      })(l7 ||= {});
      (function (t) {
        t[t.Off = 0] = "Off";
        t[t.FinalTerm = 1] = "FinalTerm";
        t[t.VSCode = 2] = "VSCode";
      })(u7 ||= {});
      (function (t) {
        t[t.Unknown = 0] = "Unknown";
        t[t.Shutdown = 1] = "Shutdown";
        t[t.Process = 2] = "Process";
        t[t.User = 3] = "User";
        t[t.Extension = 4] = "Extension";
      })(h7 ||= {});
      d7 = {
        Backend: "workbench.contributions.terminal.processBackend"
      };
      f7 = class {
        constructor() {
          this.a = new Map();
        }
        get backends() {
          return this.a;
        }
        registerTerminalBackend(t) {
          const e = this.b(t.remoteAuthority);
          if (this.a.has(e)) {
            throw new Error(`A terminal backend with remote authority '${e}' was already registered.`);
          }
          this.a.set(e, t);
        }
        getTerminalBackend(t) {
          return this.a.get(this.b(t));
        }
        b(t) {
          return t?.toLowerCase() ?? "";
        }
      };
      Gt.add(d7.Backend, new f7());
      cm = q("localPtyService");
      FC = q("terminalLogService");
    }
  });
  var yd;
  var NC = g({
    "out-build/vs/platform/terminal/electron-main/electronPtyHostStarter.js"() {
      "use strict";
  
      vt();
      Qp();
      ct();
      X();
      $n();
      _o();
      zb();
      as();
      M();
      B();
      us();
      Ke();
      Ie();
      yd = class extends T {
        constructor(e, i, s, r, n) {
          super();
          this.f = e;
          this.g = i;
          this.h = s;
          this.j = r;
          this.m = n;
          this.a = undefined;
          this.b = new $();
          this.onRequestConnection = this.b.event;
          this.c = new $();
          this.onWillShutdown = this.c.event;
          this.D(this.j.onWillShutdown(() => this.c.fire()));
          it.on("vscode:createPtyHostMessageChannel", (o, a) => this.q(o, a));
          this.D(xe(() => {
            it.removeHandler("vscode:createPtyHostMessageChannel");
          }));
        }
        start() {
          this.a = new _r(this.m, Hc, this.j);
          const e = Ex(this.h.args, this.h.isBuilt);
          const i = e.port ? ["--nolazy", `--inspect${e.break ? "-brk" : ""}=${e.port}`] : undefined;
          this.a.start({
            processTitle: "terminal pty-host",
            type: "ptyHost",
            entryPoint: "vs/platform/terminal/node/ptyHostMain",
            execArgv: i,
            args: ["--logsPath", this.h.logsHome.with({
              scheme: R.file
            }).fsPath],
            env: this.n()
          });
          const s = this.a.connect();
          const r = new Jp(s, "ptyHost");
          const n = new De();
          n.add(r);
          n.add(xe(() => {
            this.a?.kill();
            this.a?.dispose();
            this.a = undefined;
          }));
          return {
            client: r,
            store: n,
            onDidProcessExit: this.a.onExit
          };
        }
        n() {
          this.h.unsetSnapExportedVariables();
          const e = {
            ...ls(process.env),
            VSCODE_ESM_ENTRYPOINT: "vs/platform/terminal/node/ptyHostMain",
            VSCODE_PIPE_LOGGING: "true",
            VSCODE_VERBOSE_LOGGING: "true",
            VSCODE_RECONNECT_GRACE_TIME: String(this.f.graceTime),
            VSCODE_RECONNECT_SHORT_GRACE_TIME: String(this.f.shortGraceTime),
            VSCODE_RECONNECT_SCROLLBACK: String(this.f.scrollback)
          };
          const i = this.g.getValue("terminal.integrated.developer.ptyHost.latency");
          if (i && typeof i == "number") {
            e.VSCODE_LATENCY = String(i);
          }
          const s = this.g.getValue("terminal.integrated.developer.ptyHost.startupDelay");
          if (s && typeof s == "number") {
            e.VSCODE_STARTUP_DELAY = String(s);
          }
          this.h.restoreSnapExportedVariables();
          return e;
        }
        q(e, i) {
          this.b.fire();
          const s = this.a.connect();
          if (e.sender.isDestroyed()) {
            s.close();
            return;
          }
          e.sender.postMessage("vscode:createPtyHostMessageChannelResult", i, [s]);
        }
      };
      yd = __decorate([__param(1, Je), __param(2, ot), __param(3, Te), __param(4, V)], yd);
    }
  });
  var g7;
  var WC = g({
    "out-build/vs/platform/log/common/logIpc.js"() {
      "use strict";
  
      se();
      B();
      X();
      M();
      g7 = class extends T {
        constructor(t, e) {
          super();
          e.call("setLogLevel", [t.getLogLevel()]);
          this.D(t.onDidChangeLogLevel(i => e.call("setLogLevel", [i])));
          e.call("getRegisteredLoggers").then(i => {
            for (const s of i) {
              t.registerLogger({
                ...s,
                resource: P.revive(s.resource)
              });
            }
          });
          this.D(e.listen("onDidChangeVisibility")(([i, s]) => t.setVisibility(P.revive(i), s)));
          this.D(e.listen("onDidChangeLoggers")(({
            added: i,
            removed: s
          }) => {
            for (const r of i) {
              t.registerLogger({
                ...r,
                resource: P.revive(r.resource)
              });
            }
            for (const r of s) {
              t.deregisterLogger(r.resource);
            }
          }));
        }
      };
    }
  });
  var Sd;
  var TC = g({
    "out-build/vs/platform/terminal/common/requestStore.js"() {
      "use strict";
  
      ce();
      At();
      B();
      M();
      X();
      Sd = class extends T {
        constructor(e, i) {
          super();
          this.h = i;
          this.a = 0;
          this.c = new Map();
          this.f = new Map();
          this.g = this.D(new $());
          this.onCreateRequest = this.g.event;
          this.b = e === undefined ? 15000 : e;
          this.D(xe(() => {
            for (const s of this.f.values()) {
              Et(s);
            }
          }));
        }
        createRequest(e) {
          return new Promise((i, s) => {
            const r = ++this.a;
            this.c.set(r, i);
            this.g.fire({
              requestId: r,
              ...e
            });
            const n = new ns();
            wi(this.b, n.token).then(() => s(`Request ${r} timed out (${this.b}ms)`));
            this.f.set(r, [xe(() => n.cancel())]);
          });
        }
        acceptReply(e, i) {
          const s = this.c.get(e);
          if (s) {
            this.c.delete(e);
            Et(this.f.get(e) || []);
            this.f.delete(e);
            s(i);
          } else {
            this.h.warn(`RequestStore#acceptReply was called without receiving a matching request ${e}`);
          }
        }
      };
      Sd = __decorate([__param(1, V)], Sd);
    }
  });
  function jC(t, e) {
    const i = [{
      name: null,
      description: v(2153, null)
    }];
    i.push(...t.map(s => ({
      name: s.profileName,
      description: UC(s)
    })));
    if (e) {
      i.push(...e.map(s => ({
        name: s.title,
        description: BC(s)
      })));
    }
    return {
      values: i.map(s => s.name),
      markdownDescriptions: i.map(s => s.description)
    };
  }
  function UC(t) {
    let e = `$(${Gc.isThemeIcon(t.icon) ? t.icon.id : t.icon ? t.icon : Si.terminal.id}) ${t.profileName}
  - path: ${t.path}`;
    if (t.args) {
      if (typeof t.args == "string") {
        e += `
  - args: "${t.args}"`;
      } else {
        e += `
  - args: [${t.args.length === 0 ? "" : `'${t.args.join("','")}'`}]`;
      }
    }
    if (t.overrideName !== undefined) {
      e += `
  - overrideName: ${t.overrideName}`;
    }
    if (t.color) {
      e += `
  - color: ${t.color}`;
    }
    if (t.env) {
      e += `
  - env: ${JSON.stringify(t.env)}`;
    }
    return e;
  }
  function BC(t) {
    return `$(${Gc.isThemeIcon(t.icon) ? t.icon.id : t.icon ? t.icon : Si.terminal.id}) ${t.title}
  - extensionIdentifier: ${t.extensionIdentifier}`;
  }
  var qC = g({
    "out-build/vs/platform/terminal/common/terminalProfiles.js"() {
      "use strict";
  
      nd();
      se();
      be();
      S6();
    }
  });
  function lm(t) {
    const e = t === 2 ? "linux" : t === 1 ? "osx" : "windows";
    return v(2129, null, J0(t), "```json\n\"terminal.integrated.profile." + e + "\": {\n  \"bash\": null\n}\n```", "[", "](https://code.visualstudio.com/docs/terminal/profiles)");
  }
  function zC() {
    Gt.as(Ai.Configuration).registerConfiguration(v7);
    HC();
  }
  function HC(t, e) {
    const i = Gt.as(Ai.Configuration);
    let s;
    if (t) {
      s = jC(t?.profiles, e);
    }
    const r = um;
    um = {
      id: "terminal",
      order: 100,
      title: v(2149, null),
      type: "object",
      properties: {
        "terminal.integrated.defaultProfile.linux": {
          restricted: true,
          markdownDescription: v(2150, null),
          type: ["string", "null"],
          default: null,
          enum: t?.os === 3 ? s?.values : undefined,
          markdownEnumDescriptions: t?.os === 3 ? s?.markdownDescriptions : undefined
        },
        "terminal.integrated.defaultProfile.osx": {
          restricted: true,
          markdownDescription: v(2151, null),
          type: ["string", "null"],
          default: null,
          enum: t?.os === 2 ? s?.values : undefined,
          markdownEnumDescriptions: t?.os === 2 ? s?.markdownDescriptions : undefined
        },
        "terminal.integrated.defaultProfile.windows": {
          restricted: true,
          markdownDescription: v(2152, null),
          type: ["string", "null"],
          default: null,
          enum: t?.os === 1 ? s?.values : undefined,
          markdownEnumDescriptions: t?.os === 1 ? s?.markdownDescriptions : undefined
        }
      }
    };
    i.updateConfigurations({
      add: [um],
      remove: r ? [r] : []
    });
  }
  var m7;
  var w7;
  var An;
  var Ed;
  var kd;
  var v7;
  var um;
  var VC = g({
    "out-build/vs/platform/terminal/common/terminalPlatformConfiguration.js"() {
      "use strict";
  
      nd();
      H();
      be();
      Xr();
      Zs();
      qC();
      m7 = {
        type: ["string", "null"],
        enum: ["terminal.ansiBlack", "terminal.ansiRed", "terminal.ansiGreen", "terminal.ansiYellow", "terminal.ansiBlue", "terminal.ansiMagenta", "terminal.ansiCyan", "terminal.ansiWhite"],
        default: null
      };
      w7 = {
        type: "string",
        enum: Array.from(b6(), t => t.id),
        markdownEnumDescriptions: Array.from(b6(), t => `$(${t.id})`)
      };
      An = {
        args: {
          description: v(2122, null),
          type: "array",
          items: {
            type: "string"
          }
        },
        overrideName: {
          description: v(2123, null),
          type: "boolean"
        },
        icon: {
          description: v(2124, null),
          ...w7
        },
        color: {
          description: v(2125, null),
          ...m7
        },
        env: {
          markdownDescription: v(2126, null),
          type: "object",
          additionalProperties: {
            type: ["string", "null"]
          },
          default: {}
        }
      };
      Ed = {
        type: "object",
        required: ["path"],
        properties: {
          path: {
            description: v(2127, null),
            type: ["string", "array"],
            items: {
              type: "string"
            }
          },
          ...An
        }
      };
      kd = {
        type: "object",
        required: ["path"],
        properties: {
          path: {
            description: v(2128, null),
            type: ["string"],
            items: {
              type: "string"
            }
          },
          ...An
        }
      };
      v7 = {
        id: "terminal",
        order: 100,
        title: v(2130, null),
        type: "object",
        properties: {
          "terminal.integrated.automationProfile.linux": {
            restricted: true,
            markdownDescription: v(2131, null),
            type: ["object", "null"],
            default: null,
            anyOf: [{
              type: "null"
            }, kd],
            defaultSnippets: [{
              body: {
                path: "${1}",
                icon: "${2}"
              }
            }]
          },
          "terminal.integrated.automationProfile.osx": {
            restricted: true,
            markdownDescription: v(2132, null),
            type: ["object", "null"],
            default: null,
            anyOf: [{
              type: "null"
            }, kd],
            defaultSnippets: [{
              body: {
                path: "${1}",
                icon: "${2}"
              }
            }]
          },
          "terminal.integrated.automationProfile.windows": {
            restricted: true,
            markdownDescription: v(2133, null, "`terminal.integrated.automationShell.windows`"),
            type: ["object", "null"],
            default: null,
            anyOf: [{
              type: "null"
            }, kd],
            defaultSnippets: [{
              body: {
                path: "${1}",
                icon: "${2}"
              }
            }]
          },
          "terminal.integrated.profiles.windows": {
            restricted: true,
            markdownDescription: lm(3),
            type: "object",
            default: {
              PowerShell: {
                source: "PowerShell",
                icon: "terminal-powershell"
              },
              "Command Prompt": {
                path: ["${env:windir}\\Sysnative\\cmd.exe", "${env:windir}\\System32\\cmd.exe"],
                args: [],
                icon: "terminal-cmd"
              },
              "Git Bash": {
                source: "Git Bash"
              }
            },
            additionalProperties: {
              anyOf: [{
                type: "object",
                required: ["source"],
                properties: {
                  source: {
                    description: v(2134, null),
                    enum: ["PowerShell", "Git Bash"]
                  },
                  ...An
                }
              }, {
                type: "object",
                required: ["extensionIdentifier", "id", "title"],
                properties: {
                  extensionIdentifier: {
                    description: v(2135, null),
                    type: "string"
                  },
                  id: {
                    description: v(2136, null),
                    type: "string"
                  },
                  title: {
                    description: v(2137, null),
                    type: "string"
                  },
                  ...An
                }
              }, {
                type: "null"
              }, Ed]
            }
          },
          "terminal.integrated.profiles.osx": {
            restricted: true,
            markdownDescription: lm(1),
            type: "object",
            default: {
              bash: {
                path: "bash",
                args: ["-l"],
                icon: "terminal-bash"
              },
              zsh: {
                path: "zsh",
                args: ["-l"]
              },
              fish: {
                path: "fish",
                args: ["-l"]
              },
              tmux: {
                path: "tmux",
                icon: "terminal-tmux"
              },
              pwsh: {
                path: "pwsh",
                icon: "terminal-powershell"
              }
            },
            additionalProperties: {
              anyOf: [{
                type: "object",
                required: ["extensionIdentifier", "id", "title"],
                properties: {
                  extensionIdentifier: {
                    description: v(2138, null),
                    type: "string"
                  },
                  id: {
                    description: v(2139, null),
                    type: "string"
                  },
                  title: {
                    description: v(2140, null),
                    type: "string"
                  },
                  ...An
                }
              }, {
                type: "null"
              }, Ed]
            }
          },
          "terminal.integrated.profiles.linux": {
            restricted: true,
            markdownDescription: lm(2),
            type: "object",
            default: {
              bash: {
                path: "bash",
                icon: "terminal-bash"
              },
              zsh: {
                path: "zsh"
              },
              fish: {
                path: "fish"
              },
              tmux: {
                path: "tmux",
                icon: "terminal-tmux"
              },
              pwsh: {
                path: "pwsh",
                icon: "terminal-powershell"
              }
            },
            additionalProperties: {
              anyOf: [{
                type: "object",
                required: ["extensionIdentifier", "id", "title"],
                properties: {
                  extensionIdentifier: {
                    description: v(2141, null),
                    type: "string"
                  },
                  id: {
                    description: v(2142, null),
                    type: "string"
                  },
                  title: {
                    description: v(2143, null),
                    type: "string"
                  },
                  ...An
                }
              }, {
                type: "null"
              }, Ed]
            }
          },
          "terminal.integrated.useWslProfiles": {
            description: v(2144, null),
            type: "boolean",
            default: true
          },
          "terminal.integrated.inheritEnv": {
            scope: 1,
            description: v(2145, null),
            type: "boolean",
            default: true
          },
          "terminal.integrated.persistentSessionScrollback": {
            scope: 1,
            markdownDescription: v(2146, null),
            type: "number",
            default: 100
          },
          "terminal.integrated.showLinkHover": {
            scope: 1,
            description: v(2147, null),
            type: "boolean",
            default: true
          },
          "terminal.integrated.ignoreProcessNames": {
            markdownDescription: v(2148, null, "`#terminal.integrated.confirmOnKill#`"),
            type: "array",
            items: {
              type: "string",
              uniqueItems: true
            },
            default: ["starship", "oh-my-posh", "bash", "zsh"]
          }
        }
      };
    }
  });
  var Qc;
  var b7 = g({
    "out-build/vs/platform/terminal/common/environmentVariable.js"() {
      "use strict";
  
      (function (t) {
        t[t.Replace = 1] = "Replace";
        t[t.Append = 2] = "Append";
        t[t.Prepend = 3] = "Prepend";
      })(Qc ||= {});
    }
  });
  var GC = g({
    "out-build/vs/platform/terminal/common/environmentVariableShared.js"() {
      "use strict";
    }
  });
  var JC;
  var KC = g({
    "out-build/vs/platform/terminal/common/environmentVariableCollection.js"() {
      "use strict";
  
      H();
      b7();
      JC = new Map([[Qc.Append, "APPEND"], [Qc.Prepend, "PREPEND"], [Qc.Replace, "REPLACE"]]);
    }
  });
  import * as ZC from "os";
  function YC() {
    const t = /(\d+)\.(\d+)\.(\d+)/g.exec(ZC.release());
    let e = 0;
    if (t && t.length === 4) {
      e = parseInt(t[3]);
    }
    return e;
  }
  async function y7(t, e, i, s = Ii, r = ee.exists) {
    if (Zr(t)) {
      if (await r(t)) {
        return t;
      } else {
        return undefined;
      }
    }
    if (e === undefined) {
      e = bs();
    }
    if (Xe(t) !== ".") {
      const c = F(e, t);
      if (await r(c)) {
        return c;
      } else {
        return undefined;
      }
    }
    const o = DD(s, "PATH");
    if (i === undefined && wt(o)) {
      i = o.split(Zl);
    }
    if (i === undefined || i.length === 0) {
      const c = F(e, t);
      if (await r(c)) {
        return c;
      } else {
        return undefined;
      }
    }
    for (const c of i) {
      let l;
      if (Zr(c)) {
        l = F(c, t);
      } else {
        l = F(e, c, t);
      }
      if (await r(l)) {
        return l;
      }
      if (j) {
        let u = l + ".com";
        if ((await r(u)) || (u = l + ".exe", await r(u))) {
          return u;
        }
      }
    }
    const a = F(e, t);
    if (await r(a)) {
      return a;
    } else {
      return undefined;
    }
  }
  var ds;
  var Fs;
  var XC = g({
    "out-build/vs/platform/terminal/node/terminalEnvironment.js"() {
      "use strict";
  
      Ie();
      us();
      we();
      H();
      ys();
      Wt();
      _e();
      _t();
      b7();
      GC();
      KC();
      (function (t) {
        t.WindowsPwsh = "windows-pwsh";
        t.WindowsPwshLogin = "windows-pwsh-login";
        t.Pwsh = "pwsh";
        t.PwshLogin = "pwsh-login";
        t.Zsh = "zsh";
        t.ZshLogin = "zsh-login";
        t.Bash = "bash";
        t.Fish = "fish";
        t.FishLogin = "fish-login";
      })(ds ||= {});
      Fs = new Map();
      Fs.set(ds.WindowsPwsh, ["-noexit", "-command", "try { . \"{0}\\out\\vs\\workbench\\contrib\\terminal\\common\\scripts\\shellIntegration.ps1\" } catch {}{1}"]);
      Fs.set(ds.WindowsPwshLogin, ["-l", "-noexit", "-command", "try { . \"{0}\\out\\vs\\workbench\\contrib\\terminal\\common\\scripts\\shellIntegration.ps1\" } catch {}{1}"]);
      Fs.set(ds.Pwsh, ["-noexit", "-command", ". \"{0}/out/vs/workbench/contrib/terminal/common/scripts/shellIntegration.ps1\"{1}"]);
      Fs.set(ds.PwshLogin, ["-l", "-noexit", "-command", ". \"{0}/out/vs/workbench/contrib/terminal/common/scripts/shellIntegration.ps1\""]);
      Fs.set(ds.Zsh, ["-i"]);
      Fs.set(ds.ZshLogin, ["-il"]);
      Fs.set(ds.Bash, ["--init-file", "{0}/out/vs/workbench/contrib/terminal/common/scripts/shellIntegration-bash.sh"]);
      Fs.set(ds.Fish, ["--init-command", "source \"{0}/out/vs/workbench/contrib/terminal/common/scripts/shellIntegration.fish\""]);
      Fs.set(ds.FishLogin, ["-l", "--init-command", "source \"{0}/out/vs/workbench/contrib/terminal/common/scripts/shellIntegration.fish\""]);
    }
  });
  import * as QC from "fs";
  import * as e_ from "child_process";
  import { dirname as t_, resolve as i_ } from "path";
  function s_(t, e, i, s, r = process.env, n, o, a, c) {
    n = n || {
      existsFile: jt.existsFile,
      readFile: QC.promises.readFile
    };
    if (j) {
      return r_(i, n, r, o, s.getValue("terminal.integrated.useWslProfiles") !== false, t && typeof t == "object" ? {
        ...t
      } : s.getValue("terminal.integrated.profiles.windows"), typeof e == "string" ? e : s.getValue("terminal.integrated.defaultProfile.windows"), c, a);
    } else {
      return h_(n, o, i, t && typeof t == "object" ? {
        ...t
      } : s.getValue(Se ? "terminal.integrated.profiles.linux" : "terminal.integrated.profiles.osx"), typeof e == "string" ? e : s.getValue(Se ? "terminal.integrated.defaultProfile.linux" : "terminal.integrated.defaultProfile.osx"), c, a, r);
    }
  }
  async function r_(t, e, i, s, r, n, o, a, c) {
    const l = process.env.hasOwnProperty("PROCESSOR_ARCHITEW6432");
    const u = `${process.env.windir}\\${l ? "Sysnative" : "System32"}`;
    let d = false;
    if (YC() >= 16299) {
      d = true;
    }
    await o_(a);
    const f = new Map();
    if (t) {
      f.set("PowerShell", {
        source: "PowerShell",
        icon: Si.terminalPowershell,
        isAutoDetected: true
      });
      f.set("Windows PowerShell", {
        path: `${u}\\WindowsPowerShell\\v1.0\\powershell.exe`,
        icon: Si.terminalPowershell,
        isAutoDetected: true
      });
      f.set("Git Bash", {
        source: "Git Bash",
        isAutoDetected: true
      });
      f.set("Command Prompt", {
        path: `${u}\\cmd.exe`,
        icon: Si.terminalCmd,
        isAutoDetected: true
      });
      f.set("Cygwin", {
        path: [{
          path: `${process.env.HOMEDRIVE}\\cygwin64\\bin\\bash.exe`,
          isUnsafe: true
        }, {
          path: `${process.env.HOMEDRIVE}\\cygwin\\bin\\bash.exe`,
          isUnsafe: true
        }],
        args: ["--login"],
        isAutoDetected: true
      });
      f.set("bash (MSYS2)", {
        path: [{
          path: `${process.env.HOMEDRIVE}\\msys64\\usr\\bin\\bash.exe`,
          isUnsafe: true
        }],
        args: ["--login", "-i"],
        env: {
          CHERE_INVOKING: "1"
        },
        icon: Si.terminalBash,
        isAutoDetected: true
      });
      const w = `${process.env.CMDER_ROOT || `${process.env.HOMEDRIVE}\\cmder`}\\vendor\\bin\\vscode_init.cmd`;
      f.set("Cmder", {
        path: `${u}\\cmd.exe`,
        args: ["/K", w],
        requiresPath: process.env.CMDER_ROOT ? w : {
          path: w,
          isUnsafe: true
        },
        isAutoDetected: true
      });
    }
    k7(n, f);
    const p = await S7(f.entries(), o, e, i, s, c);
    if (t && r) {
      try {
        const w = await l_(`${u}\\${d ? "wsl" : "bash"}.exe`, o);
        for (const m of w) {
          if (!n || !(m.profileName in n)) {
            p.push(m);
          }
        }
      } catch {
        if (hm) {
          s?.trace("WSL is not installed, so could not detect WSL profiles");
          hm = false;
        }
      }
    }
    return p;
  }
  async function S7(t, e, i, s = process.env, r, n) {
    const o = [];
    for (const [a, c] of t) {
      o.push(n_(a, c, e, i, s, r, n));
    }
    return (await Promise.all(o)).filter(a => !!a);
  }
  async function n_(t, e, i, s, r = process.env, n, o) {
    if (e === null) {
      return;
    }
    let a;
    let c;
    let l;
    if ("source" in e && !("path" in e)) {
      const p = el?.get(e.source);
      if (!p) {
        return;
      }
      a = p.paths;
      c = e.args || p.args;
      if (e.icon) {
        l = E7(e.icon);
      } else if (p.icon) {
        l = p.icon;
      }
    } else {
      a = Array.isArray(e.path) ? e.path : [e.path];
      c = j || Array.isArray(e.args) ? e.args : undefined;
      l = E7(e.icon);
    }
    let u;
    if (o) {
      const p = a.map(m => typeof m == "string" ? m : m.path);
      const w = await o(p);
      u = new Array(a.length);
      for (let m = 0; m < a.length; m++) {
        if (typeof a[m] == "string") {
          u[m] = w[m];
        } else {
          u[m] = {
            path: w[m],
            isUnsafe: true
          };
        }
      }
    } else {
      u = a.slice();
    }
    let d;
    if (e.requiresPath) {
      let p;
      if (wt(e.requiresPath)) {
        p = e.requiresPath;
      } else {
        p = e.requiresPath.path;
        if (e.requiresPath.isUnsafe) {
          d = p;
        }
      }
      if (!(await s.existsFile(p))) {
        return;
      }
    }
    const f = await xd(t, i, u, s, r, c, e.env, e.overrideName, e.isAutoDetected, d);
    if (!f) {
      n?.debug("Terminal profile not validated", t, a);
      return;
    }
    f.isAutoDetected = e.isAutoDetected;
    f.icon = l;
    f.color = e.color;
    return f;
  }
  function E7(t) {
    if (typeof t == "string") {
      return {
        id: t
      };
    } else {
      return t;
    }
  }
  async function o_(t) {
    if (el && !t) {
      return;
    }
    const [e, i] = await Promise.all([a_(), t || c_()]);
    el = new Map();
    el.set("Git Bash", {
      profileName: "Git Bash",
      paths: e,
      args: ["--login", "-i"]
    });
    el.set("PowerShell", {
      profileName: "PowerShell",
      paths: i,
      icon: Si.terminalPowershell
    });
  }
  async function a_() {
    const t = new Set();
    const e = await y7("git.exe");
    if (e) {
      const r = t_(e);
      t.add(i_(r, "../.."));
    }
    function i(r, n) {
      if (n) {
        r.add(n);
      }
    }
    i(t, process.env.ProgramW6432);
    i(t, process.env.ProgramFiles);
    i(t, process.env["ProgramFiles(X86)"]);
    i(t, `${process.env.LocalAppData}\\Program`);
    const s = [];
    for (const r of t) {
      s.push(`${r}\\Git\\bin\\bash.exe`, `${r}\\Git\\usr\\bin\\bash.exe`, `${r}\\usr\\bin\\bash.exe`);
    }
    s.push(`${process.env.UserProfile}\\scoop\\apps\\git\\current\\bin\\bash.exe`);
    s.push(`${process.env.UserProfile}\\scoop\\apps\\git-with-openssh\\current\\bin\\bash.exe`);
    return s;
  }
  async function c_() {
    const t = [];
    for await (const e of E5()) {
      t.push(e.exePath);
    }
    return t;
  }
  async function l_(t, e) {
    const i = [];
    const s = await new Promise((o, a) => {
      e_.exec("wsl.exe -l -q", {
        encoding: "utf16le",
        timeout: 1000
      }, (c, l) => {
        if (c) {
          return a("Problem occurred when getting wsl distros");
        }
        o(l);
      });
    });
    if (!s) {
      return [];
    }
    const r = new RegExp(/[\r?\n]/);
    const n = s.split(r).filter(o => o.trim().length > 0 && o !== "");
    for (const o of n) {
      if (o === "" || o.startsWith("docker-desktop")) {
        continue;
      }
      const a = `${o} (WSL)`;
      const c = {
        profileName: a,
        path: t,
        args: ["-d", `${o}`],
        isDefault: a === e,
        icon: u_(o),
        isAutoDetected: false
      };
      i.push(c);
    }
    return i;
  }
  function u_(t) {
    if (t.includes("Ubuntu")) {
      return Si.terminalUbuntu;
    } else if (t.includes("Debian")) {
      return Si.terminalDebian;
    } else {
      return Si.terminalLinux;
    }
  }
  async function h_(t, e, i, s, r, n, o, a) {
    const c = new Map();
    if (i && (await t.existsFile("/etc/shells"))) {
      const l = (await t.readFile("/etc/shells")).toString();
      const u = (n || l.split(`
  `)).map(f => {
        const p = f.indexOf("#");
        if (p === -1) {
          return f;
        } else {
          return f.substring(0, p);
        }
      }).filter(f => f.trim().length > 0);
      const d = new Map();
      for (const f of u) {
        let p = Ue(f);
        let w = d.get(p) || 0;
        w++;
        if (w > 1) {
          p = `${p} (${w})`;
        }
        d.set(p, w);
        c.set(p, {
          path: f,
          isAutoDetected: true
        });
      }
    }
    k7(s, c);
    return await S7(c.entries(), r, t, a, e, o);
  }
  function k7(t, e) {
    if (t) {
      for (const [i, s] of Object.entries(t)) {
        if (s === null || typeof s != "object" || !("path" in s) && !("source" in s)) {
          e.delete(i);
        } else {
          s.icon = s.icon || e.get(i)?.icon;
          e.set(i, s);
        }
      }
    }
  }
  async function xd(t, e, i, s, r, n, o, a, c, l) {
    if (i.length === 0) {
      return Promise.resolve(undefined);
    }
    const u = i.shift();
    if (u === "") {
      return xd(t, e, i, s, r, n, o, a, c);
    }
    const d = typeof u != "string" && u.isUnsafe;
    const f = typeof u == "string" ? u : u.path;
    const p = {
      profileName: t,
      path: f,
      args: n,
      env: o,
      overrideName: a,
      isAutoDetected: c,
      isDefault: t === e,
      isUnsafePath: d,
      requiresUnsafePath: l
    };
    if (Ue(f) === f) {
      const m = r.PATH ? r.PATH.split(Zl) : undefined;
      const y = await y7(f, undefined, m, undefined, s.existsFile);
      if (y) {
        p.path = y;
        p.isFromPath = true;
        return p;
      } else {
        return xd(t, e, i, s, r, n);
      }
    }
    if (await s.existsFile(pi(f))) {
      return p;
    } else {
      return xd(t, e, i, s, r, n, o, a, c);
    }
  }
  var x7;
  var el;
  var hm;
  var d_ = g({
    "out-build/vs/platform/terminal/node/terminalProfiles.js"() {
      "use strict";
  
      nd();
      we();
      H();
      _e();
      _t();
      P5();
      XC();
      (function (t) {
        t.UnixShellsPath = "/etc/shells";
      })(x7 ||= {});
      hm = true;
    }
  });
  var dm;
  var Dd;
  var f_ = g({
    "out-build/vs/platform/terminal/node/ptyHostService.js"() {
      "use strict";
  
      B();
      M();
      H();
      xs();
      Ke();
      X();
      WC();
      cg();
      TC();
      p7();
      VC();
      d_();
      C5();
      Kn();
      (function (t) {
        t[t.MaxRestarts = 5] = "MaxRestarts";
      })(dm ||= {});
      Dd = class extends T {
        get c() {
          this.h();
          return this.a;
        }
        get f() {
          this.h();
          return this.b;
        }
        get g() {
          return this.b;
        }
        h() {
          if (!this.a) {
            this.U();
          }
        }
        constructor(e, i, s, r) {
          super();
          this.M = e;
          this.N = i;
          this.O = s;
          this.P = r;
          this.m = false;
          this.n = 0;
          this.q = true;
          this.t = this.D(new $());
          this.onPtyHostExit = this.t.event;
          this.u = this.D(new $());
          this.onPtyHostStart = this.u.event;
          this.w = this.D(new $());
          this.onPtyHostUnresponsive = this.w.event;
          this.y = this.D(new $());
          this.onPtyHostResponsive = this.y.event;
          this.z = this.D(new $());
          this.onPtyHostRequestResolveVariables = this.z.event;
          this.C = this.D(new $());
          this.onProcessData = this.C.event;
          this.F = this.D(new $());
          this.onProcessReady = this.F.event;
          this.G = this.D(new $());
          this.onProcessReplay = this.G.event;
          this.H = this.D(new $());
          this.onProcessOrphanQuestion = this.H.event;
          this.I = this.D(new $());
          this.onDidRequestDetach = this.I.event;
          this.J = this.D(new $());
          this.onDidChangeProperty = this.J.event;
          this.L = this.D(new $());
          this.onProcessExit = this.L.event;
          zC();
          this.D(this.M);
          this.D(xe(() => this.W()));
          this.j = this.D(new Sd(undefined, this.O));
          this.D(this.j.onCreateRequest(this.z.fire, this.z));
          if (this.M.onRequestConnection) {
            this.D(x.once(this.M.onRequestConnection)(() => this.h()));
          }
          if (this.M.onWillShutdown) {
            this.D(this.M.onWillShutdown(() => this.m = true));
          }
        }
        get Q() {
          return this.N.getValue("terminal.integrated.ignoreProcessNames");
        }
        async R() {
          return this.g?.refreshIgnoreProcessNames?.(this.Q);
        }
        async S() {
          if (j) {
            return process.env;
          }
          try {
            return await ag(this.N, this.O, {
              _: []
            }, process.env);
          } catch (e) {
            this.O.error("ptyHost was unable to resolve shell environment", e);
            return {};
          }
        }
        U() {
          const e = this.M.start();
          const i = e.client;
          if (this.O.getLevel() === J.Trace) {
            this.O.trace("PtyHostService#_startPtyHost", new Error().stack?.replace(/^Error/, ""));
          }
          ze.toService(i.getChannel(Xo.Heartbeat)).onBeat(() => this.X());
          this.X(true);
          this.D(e.onDidProcessExit(n => {
            this.t.fire(n.code);
            if (!this.m && !this.B.isDisposed) {
              if (this.n <= dm.MaxRestarts) {
                this.O.error(`ptyHost terminated unexpectedly with code ${n.code}`);
                this.n++;
                this.restartPtyHost();
              } else {
                this.O.error(`ptyHost terminated unexpectedly with code ${n.code}, giving up`);
              }
            }
          }));
          const r = ze.toService(i.getChannel(Xo.PtyHost));
          this.D(r.onProcessData(n => this.C.fire(n)));
          this.D(r.onProcessReady(n => this.F.fire(n)));
          this.D(r.onProcessExit(n => this.L.fire(n)));
          this.D(r.onDidChangeProperty(n => this.J.fire(n)));
          this.D(r.onProcessReplay(n => this.G.fire(n)));
          this.D(r.onProcessOrphanQuestion(n => this.H.fire(n)));
          this.D(r.onDidRequestDetach(n => this.I.fire(n)));
          this.D(new g7(this.P, i.getChannel(Xo.Logger)));
          this.a = e;
          this.b = r;
          this.u.fire();
          this.D(this.N.onDidChangeConfiguration(async n => {
            if (n.affectsConfiguration("terminal.integrated.ignoreProcessNames")) {
              await this.R();
            }
          }));
          this.R();
          return [e, r];
        }
        async createProcess(e, i, s, r, n, o, a, c, l, u, d) {
          const f = setTimeout(() => this.$(), Ei.CreateProcessTimeout);
          const p = await this.f.createProcess(e, i, s, r, n, o, a, c, l, u, d);
          clearTimeout(f);
          return p;
        }
        updateTitle(e, i, s) {
          return this.f.updateTitle(e, i, s);
        }
        updateIcon(e, i, s, r) {
          return this.f.updateIcon(e, i, s, r);
        }
        attachToProcess(e) {
          return this.f.attachToProcess(e);
        }
        detachFromProcess(e, i) {
          return this.f.detachFromProcess(e, i);
        }
        shutdownAll() {
          return this.f.shutdownAll();
        }
        listProcesses() {
          return this.f.listProcesses();
        }
        async getPerformanceMarks() {
          return this.g?.getPerformanceMarks() ?? [];
        }
        async reduceConnectionGraceTime() {
          return this.g?.reduceConnectionGraceTime();
        }
        start(e) {
          return this.f.start(e);
        }
        shutdown(e, i) {
          return this.f.shutdown(e, i);
        }
        input(e, i) {
          return this.f.input(e, i);
        }
        processBinary(e, i) {
          return this.f.processBinary(e, i);
        }
        resize(e, i, s) {
          return this.f.resize(e, i, s);
        }
        clearBuffer(e) {
          return this.f.clearBuffer(e);
        }
        acknowledgeDataEvent(e, i) {
          return this.f.acknowledgeDataEvent(e, i);
        }
        setUnicodeVersion(e, i) {
          return this.f.setUnicodeVersion(e, i);
        }
        getInitialCwd(e) {
          return this.f.getInitialCwd(e);
        }
        getCwd(e) {
          return this.f.getCwd(e);
        }
        async getLatency() {
          const e = new Jr();
          const i = await this.f.getLatency();
          e.stop();
          return [{
            label: "ptyhostservice<->ptyhost",
            latency: e.elapsed()
          }, ...i];
        }
        orphanQuestionReply(e) {
          return this.f.orphanQuestionReply(e);
        }
        installAutoReply(e, i) {
          return this.f.installAutoReply(e, i);
        }
        uninstallAllAutoReplies() {
          return this.f.uninstallAllAutoReplies();
        }
        getDefaultSystemShell(e) {
          return this.g?.getDefaultSystemShell(e) ?? A5(e ?? Wi, process.env);
        }
        async getProfiles(e, i, s, r = false) {
          const n = await this.S();
          return s_(i, s, r, this.N, n, undefined, this.O, this.bb.bind(this, e));
        }
        async getEnvironment() {
          if (this.b) {
            return this.f.getEnvironment();
          } else {
            return {
              ...process.env
            };
          }
        }
        getWslPath(e, i) {
          return this.f.getWslPath(e, i);
        }
        getRevivedPtyNewId(e, i) {
          return this.f.getRevivedPtyNewId(e, i);
        }
        setTerminalLayoutInfo(e) {
          return this.f.setTerminalLayoutInfo(e);
        }
        async getTerminalLayoutInfo(e) {
          return this.g?.getTerminalLayoutInfo(e);
        }
        async requestDetachInstance(e, i) {
          return this.f.requestDetachInstance(e, i);
        }
        async acceptDetachInstanceReply(e, i) {
          return this.f.acceptDetachInstanceReply(e, i);
        }
        async freePortKillProcess(e) {
          if (!this.f.freePortKillProcess) {
            throw new Error("freePortKillProcess does not exist on the pty proxy");
          }
          return this.f.freePortKillProcess(e);
        }
        async serializeTerminalState(e) {
          return this.f.serializeTerminalState(e);
        }
        async reviveTerminalProcesses(e, i, s) {
          return this.f.reviveTerminalProcesses(e, i, s);
        }
        async refreshProperty(e, i) {
          return this.f.refreshProperty(e, i);
        }
        async updateProperty(e, i, s) {
          return this.f.updateProperty(e, i, s);
        }
        async restartPtyHost() {
          this.W();
          this.q = true;
          this.U();
        }
        W() {
          this.f.shutdownAll();
          this.c.store.dispose();
        }
        X(e) {
          this.ab();
          this.r = setTimeout(() => this.Y(), e ? Ei.ConnectingBeatInterval : Ei.BeatInterval * Ei.FirstWaitMultiplier);
          if (!this.q) {
            this.q = true;
            this.y.fire();
          }
        }
        Y() {
          this.O.warn(`No ptyHost heartbeat after ${Ei.BeatInterval * Ei.FirstWaitMultiplier / 1000} seconds`);
          this.r = undefined;
          this.s = setTimeout(() => this.Z(), Ei.BeatInterval * Ei.SecondWaitMultiplier);
        }
        Z() {
          this.O.error(`No ptyHost heartbeat after ${(Ei.BeatInterval * Ei.FirstWaitMultiplier + Ei.BeatInterval * Ei.FirstWaitMultiplier) / 1000} seconds`);
          this.s = undefined;
          if (this.q) {
            this.q = false;
            this.w.fire();
          }
        }
        $() {
          this.ab();
          this.O.error(`No ptyHost response to createProcess after ${Ei.CreateProcessTimeout / 1000} seconds`);
          if (this.q) {
            this.q = false;
            this.w.fire();
          }
        }
        ab() {
          if (this.r) {
            clearTimeout(this.r);
            this.r = undefined;
          }
          if (this.s) {
            clearTimeout(this.s);
            this.s = undefined;
          }
        }
        bb(e, i) {
          return this.j.createRequest({
            workspaceId: e,
            originalText: i
          });
        }
        async acceptPtyHostResolvedVariables(e, i) {
          this.j.acceptReply(e, i);
        }
      };
      Dd = __decorate([__param(1, Je), __param(2, V), __param(3, sc)], Dd);
    }
  });
  var fm;
  var D7;
  var P7;
  var p_ = g({
    "out-build/vs/platform/remote/common/electronRemoteResources.js"() {
      "use strict";
  
      fm = "request";
      D7 = "remoteResourceHandler";
      P7 = class {
        async routeCall(t, e, i) {
          if (e !== fm) {
            throw new Error(`Call not found: ${e}`);
          }
          const s = i[0];
          if (s?.authority) {
            const r = t.connections.find(n => n.ctx === s.authority);
            if (r) {
              return r;
            }
          }
          throw new Error("Caller not found");
        }
        routeEvent(t, e) {
          throw new Error(`Event not found: ${e}`);
        }
      };
    }
  });
  import { BrowserWindow as g_ } from "electron";
  var Pd;
  var m_ = g({
    "out-build/vs/platform/auxiliaryWindow/electron-main/auxiliaryWindow.js"() {
      "use strict";
  
      H();
      Ke();
      vt();
      ct();
      X();
      Ti();
      fn();
      x6();
      Pd = class extends Yg {
        get win() {
          if (!super.win) {
            this.tryClaimWindow();
          }
          return super.win;
        }
        get webContents() {
          return this.r;
        }
        constructor(e, i, s, r, n, o) {
          super(r, n, i, s);
          this.r = e;
          this.S = o;
          this.id = this.webContents.id;
          this.parentId = -1;
          this.Q = false;
          this.tryClaimWindow();
        }
        tryClaimWindow(e) {
          if (!this.B.isDisposed && !this.webContents.isDestroyed()) {
            this.U(e);
            if (e && !this.Q) {
              this.Q = true;
              this.C({
                x: e.x,
                y: e.y,
                width: e.width,
                height: e.height,
                mode: e.show === false ? 0 : 1
              }, {
                hideBecauseShadowWindow: false
              });
            }
          }
        }
        U(e) {
          if (this.q) {
            return;
          }
          const i = g_.fromWebContents(this.webContents);
          if (i) {
            this.z.trace("[aux window] Claimed browser window instance");
            this.s(i, e);
            i.setMenu(null);
            if ((j || Se) && dn(this.t, e?.titleBarStyle === "hidden" ? "custom" : undefined)) {
              i.setAutoHideMenuBar(true);
            }
            this.S.registerAuxWindow(this);
          }
        }
        matches(e) {
          return this.webContents.id === e.id;
        }
      };
      Pd = __decorate([__param(1, ot), __param(2, V), __param(3, Je), __param(4, Oi), __param(5, Te)], Pd);
    }
  });
  import { BrowserWindow as w_, app as v_ } from "electron";
  var $d;
  var b_ = g({
    "out-build/vs/platform/auxiliaryWindow/electron-main/auxiliaryWindowsMainService.js"() {
      "use strict";
  
      B();
      M();
      Ie();
      as();
      m_();
      Y();
      X();
      mc();
      Lt();
      $d = class extends T {
        constructor(e, i) {
          super();
          this.h = e;
          this.j = i;
          this.a = this.D(new $());
          this.onDidMaximizeWindow = this.a.event;
          this.b = this.D(new $());
          this.onDidUnmaximizeWindow = this.b.event;
          this.c = this.D(new $());
          this.onDidChangeFullScreen = this.c.event;
          this.f = this.D(new $());
          this.onDidTriggerSystemContextMenu = this.f.event;
          this.g = new Map();
          this.m();
        }
        m() {
          v_.on("browser-window-created", (e, i) => {
            const s = this.getWindowByWebContents(i.webContents);
            if (s) {
              this.j.trace("[aux window] app.on(\"browser-window-created\"): Trying to claim auxiliary window");
              s.tryClaimWindow();
            } else {
              const r = new De();
              r.add(x.fromNodeEventEmitter(i.webContents, "did-create-window", (n, o) => ({
                browserWindow: n,
                details: o
              }))(({
                browserWindow: n,
                details: o
              }) => {
                const a = this.getWindowByWebContents(n.webContents);
                if (a) {
                  this.j.trace("[aux window] window.on(\"did-create-window\"): Trying to claim auxiliary window");
                  a.tryClaimWindow(o.options);
                }
              }));
              r.add(x.fromNodeEventEmitter(i, "closed")(() => r.dispose()));
            }
          });
          it.handle("vscode:registerAuxiliaryWindow", async (e, i) => {
            const s = this.getWindowByWebContents(e.sender);
            if (s) {
              this.j.trace("[aux window] vscode:registerAuxiliaryWindow: Registering auxiliary window to main window");
              s.parentId = i;
            }
            return e.sender.id;
          });
        }
        createWindow(e) {
          const {
            state: i,
            overrides: s
          } = this.n(e);
          return this.h.invokeFunction(rh, i, s, {
            preload: Ct.asFileUri("vs/base/parts/sandbox/electron-sandbox/preload-aux.js").fsPath
          });
        }
        n(e) {
          const i = {};
          const s = {
            hideBecauseShadowWindow: false
          };
          const r = e.features.split(",");
          for (const o of r) {
            const [a, c] = o.split("=");
            switch (a) {
              case "width":
                i.width = parseInt(c, 10);
                break;
              case "height":
                i.height = parseInt(c, 10);
                break;
              case "left":
                i.x = parseInt(c, 10);
                break;
              case "top":
                i.y = parseInt(c, 10);
                break;
              case "window-maximized":
                i.mode = 0;
                break;
              case "window-fullscreen":
                i.mode = 3;
                break;
              case "window-disable-fullscreen":
                s.disableFullscreen = true;
                break;
              case "window-native-titlebar":
                s.forceNativeTitlebar = true;
                break;
            }
          }
          const n = nh.validateWindowState(this.j, i) ?? T4();
          this.j.trace("[aux window] using window state", n);
          return {
            state: n,
            overrides: s
          };
        }
        registerWindow(e) {
          const i = new De();
          const s = this.h.createInstance(Pd, e);
          this.g.set(s.id, s);
          i.add(xe(() => this.g.delete(s.id)));
          i.add(s.onDidMaximize(() => this.a.fire(s)));
          i.add(s.onDidUnmaximize(() => this.b.fire(s)));
          i.add(s.onDidEnterFullScreen(() => this.c.fire({
            window: s,
            fullscreen: true
          })));
          i.add(s.onDidLeaveFullScreen(() => this.c.fire({
            window: s,
            fullscreen: false
          })));
          i.add(s.onDidTriggerSystemContextMenu(({
            x: r,
            y: n
          }) => this.f.fire({
            window: s,
            x: r,
            y: n
          })));
          x.once(s.onDidClose)(() => i.dispose());
        }
        getWindowByWebContents(e) {
          const i = this.g.get(e.id);
          if (i?.matches(e)) {
            return i;
          } else {
            return undefined;
          }
        }
        getFocusedWindow() {
          const e = w_.getFocusedWindow();
          if (e) {
            return this.getWindowByWebContents(e.webContents);
          }
        }
        getLastActiveWindow() {
          return q4(Array.from(this.g.values()));
        }
        getWindows() {
          return Array.from(this.g.values());
        }
      };
      $d = __decorate([__param(0, Ss), __param(1, V)], $d);
    }
  });
  function Qo(t) {
    switch (gm.call(t)) {
      case "[object Error]":
      case "[object Exception]":
      case "[object DOMException]":
      case "[object WebAssembly.Exception]":
        return true;
      default:
        return Cn(t, Error);
    }
  }
  function pm(t, e) {
    return gm.call(t) === `[object ${e}]`;
  }
  function Id(t) {
    return pm(t, "String");
  }
  function Ad(t) {
    return pm(t, "Object");
  }
  function y_(t) {
    return typeof Event !== "undefined" && Cn(t, Event);
  }
  function S_(t) {
    return typeof Element !== "undefined" && Cn(t, Element);
  }
  function E_(t) {
    return pm(t, "RegExp");
  }
  function $7(t) {
    return !!t && !!t.then && typeof t.then == "function";
  }
  function k_(t) {
    return Ad(t) && "nativeEvent" in t && "preventDefault" in t && "stopPropagation" in t;
  }
  function Cn(t, e) {
    try {
      return t instanceof e;
    } catch {
      return false;
    }
  }
  function I7(t) {
    return typeof t == "object" && t !== null && (!!t.__isVue || !!t._isVue);
  }
  var gm;
  var fs = g({
    "out-build/external/sentry/utils/is.js"() {
      "use strict";
  
      gm = Object.prototype.toString;
    }
  });
  var x_ = g({
    "out-build/external/sentry/utils/vendor/escapeStringForRegex.js"() {
      "use strict";
    }
  });
  function mm(t, e = 0) {
    if (typeof t != "string" || e === 0 || t.length <= e) {
      return t;
    } else {
      return `${t.slice(0, e)}...`;
    }
  }
  function A7(t, e) {
    if (!Array.isArray(t)) {
      return "";
    }
    const i = [];
    for (let s = 0; s < t.length; s++) {
      const r = t[s];
      try {
        if (I7(r)) {
          i.push("[VueViewModel]");
        } else {
          i.push(String(r));
        }
      } catch {
        i.push("[value cannot be serialized]");
      }
    }
    return i.join(e);
  }
  function D_(t, e, i = false) {
    if (Id(t)) {
      if (E_(e)) {
        return e.test(t);
      } else if (Id(e)) {
        if (i) {
          return t === e;
        } else {
          return t.includes(e);
        }
      } else {
        return false;
      }
    } else {
      return false;
    }
  }
  function Cd(t, e = [], i = false) {
    return e.some(s => D_(t, s, i));
  }
  var _d = g({
    "out-build/external/sentry/utils/string.js"() {
      "use strict";
  
      fs();
      x_();
    }
  });
  function P_(t, e, i = 250, s, r, n, o) {
    if (!n.exception || !n.exception.values || !o || !Cn(o.originalException, Error)) {
      return;
    }
    const a = n.exception.values.length > 0 ? n.exception.values[n.exception.values.length - 1] : undefined;
    if (a) {
      n.exception.values = $_(wm(t, e, r, o.originalException, s, n.exception.values, a, 0), i);
    }
  }
  function wm(t, e, i, s, r, n, o, a) {
    if (n.length >= i + 1) {
      return n;
    }
    let c = [...n];
    if (Cn(s[r], Error)) {
      C7(o, a);
      const l = t(e, s[r]);
      const u = c.length;
      _7(l, r, u, a);
      c = wm(t, e, i, s[r], r, [l, ...c], l, u);
    }
    if (Array.isArray(s.errors)) {
      s.errors.forEach((l, u) => {
        if (Cn(l, Error)) {
          C7(o, a);
          const d = t(e, l);
          const f = c.length;
          _7(d, `errors[${u}]`, f, a);
          c = wm(t, e, i, l, r, [d, ...c], d, f);
        }
      });
    }
    return c;
  }
  function C7(t, e) {
    t.mechanism = t.mechanism || {
      type: "generic",
      handled: true
    };
    t.mechanism = {
      ...t.mechanism,
      ...(t.type === "AggregateError" && {
        is_exception_group: true
      }),
      exception_id: e
    };
  }
  function _7(t, e, i, s) {
    t.mechanism = t.mechanism || {
      type: "generic",
      handled: true
    };
    t.mechanism = {
      ...t.mechanism,
      type: "chained",
      source: e,
      exception_id: i,
      parent_id: s
    };
  }
  function $_(t, e) {
    return t.map(i => {
      i.value &&= mm(i.value, e);
      return i;
    });
  }
  var I_ = g({
    "out-build/external/sentry/utils/aggregate-errors.js"() {
      "use strict";
  
      fs();
      _d();
    }
  });
  var A_ = g({
    "out-build/external/sentry/utils/array.js"() {
      "use strict";
    }
  });
  var C_ = g({
    "out-build/external/sentry/utils/breadcrumb-log-level.js"() {
      "use strict";
    }
  });
  var ea;
  var R7 = g({
    "out-build/external/sentry/utils/version.js"() {
      "use strict";
  
      ea = "8.35.0-cursor";
    }
  });
  function vm(t, e, i) {
    const s = i || yt;
    const r = s.__SENTRY__ = s.__SENTRY__ || {};
    const n = r[ea] = r[ea] || {};
    return n[t] ||= e();
  }
  var yt;
  var Fi = g({
    "out-build/external/sentry/utils/worldwide.js"() {
      "use strict";
  
      R7();
      yt = globalThis;
    }
  });
  function __(t, e = {}) {
    if (!t) {
      return "<unknown>";
    }
    try {
      let i = t;
      const s = 5;
      const r = [];
      let n = 0;
      let o = 0;
      const a = " > ";
      const c = a.length;
      let l;
      const u = Array.isArray(e) ? e : e.keyAttrs;
      const d = !Array.isArray(e) && e.maxStringLength || L7;
      while (i && n++ < s && (l = R_(i, u), l !== "html" && (!(n > 1) || !(o + r.length * c + l.length >= d)))) {
        r.push(l);
        o += l.length;
        i = i.parentNode;
      }
      return r.reverse().join(a);
    } catch {
      return "<unknown>";
    }
  }
  function R_(t, e) {
    const i = t;
    const s = [];
    if (!i || !i.tagName) {
      return "";
    }
    if (O7.HTMLElement && i instanceof HTMLElement && i.dataset) {
      if (i.dataset.sentryComponent) {
        return i.dataset.sentryComponent;
      }
      if (i.dataset.sentryElement) {
        return i.dataset.sentryElement;
      }
    }
    s.push(i.tagName.toLowerCase());
    const r = e && e.length ? e.filter(o => i.getAttribute(o)).map(o => [o, i.getAttribute(o)]) : null;
    if (r && r.length) {
      r.forEach(o => {
        s.push(`[${o[0]}="${o[1]}"]`);
      });
    } else {
      if (i.id) {
        s.push(`#${i.id}`);
      }
      const o = i.className;
      if (o && Id(o)) {
        const a = o.split(/\s+/);
        for (const c of a) {
          s.push(`.${c}`);
        }
      }
    }
    const n = ["aria-label", "type", "name", "title", "alt"];
    for (const o of n) {
      const a = i.getAttribute(o);
      if (a) {
        s.push(`[${o}="${a}"]`);
      }
    }
    return s.join("");
  }
  var O7;
  var L7;
  var M7 = g({
    "out-build/external/sentry/utils/browser.js"() {
      "use strict";
  
      fs();
      Fi();
      O7 = yt;
      L7 = 80;
    }
  });
  var Rd;
  var _n = g({
    "out-build/external/sentry/utils/debug-build.js"() {
      "use strict";
  
      Rd = false;
    }
  });
  function F7(t) {
    if (!("console" in yt)) {
      return t();
    }
    const e = yt.console;
    const i = {};
    const s = Object.keys(il);
    s.forEach(r => {
      const n = il[r];
      i[r] = e[r];
      e[r] = n;
    });
    try {
      return t();
    } finally {
      s.forEach(r => {
        e[r] = i[r];
      });
    }
  }
  function O_() {
    let t = false;
    const e = {
      enable: () => {
        t = true;
      },
      disable: () => {
        t = false;
      },
      isEnabled: () => t
    };
    if (Rd) {
      tl.forEach(i => {
        e[i] = (...s) => {
          if (t) {
            F7(() => {
              yt.console[i](`${N7}[${i}]:`, ...s);
            });
          }
        };
      });
    } else {
      tl.forEach(i => {
        e[i] = () => {};
      });
    }
    return e;
  }
  var N7;
  var tl;
  var il;
  var oi;
  var Fr = g({
    "out-build/external/sentry/utils/logger.js"() {
      "use strict";
  
      _n();
      Fi();
      N7 = "Sentry Logger ";
      tl = ["debug", "info", "warn", "error", "log", "assert", "trace"];
      il = {};
      oi = vm("logger", O_);
    }
  });
  var W7 = g({
    "out-build/external/sentry/utils/dsn.js"() {
      "use strict";
  
      _n();
      Fr();
    }
  });
  var bm;
  var ym = g({
    "out-build/external/sentry/utils/error.js"() {
      "use strict";
  
      bm = class extends Error {
        constructor(t, e = "warn") {
          super(t);
          this.message = t;
          this.name = new.target.prototype.constructor.name;
          Object.setPrototypeOf(this, new.target.prototype);
          this.logLevel = e;
        }
      };
    }
  });
  function L_(t, e, i) {
    if (!(e in t)) {
      return;
    }
    const s = t[e];
    const r = i(s);
    if (typeof r == "function") {
      M_(r, s);
    }
    t[e] = r;
  }
  function Sm(t, e, i) {
    try {
      Object.defineProperty(t, e, {
        value: i,
        writable: true,
        configurable: true
      });
    } catch {
      if (Rd) {
        oi.log(`Failed to add non-enumerable property "${e}" to object`, t);
      }
    }
  }
  function M_(t, e) {
    try {
      const i = e.prototype || {};
      t.prototype = e.prototype = i;
      Sm(t, "__sentry_original__", e);
    } catch {}
  }
  function F_(t) {
    return t.__sentry_original__;
  }
  function N_(t) {
    return Object.keys(t).map(e => `${encodeURIComponent(e)}=${encodeURIComponent(t[e])}`).join("&");
  }
  function W_(t) {
    if (Qo(t)) {
      return {
        message: t.message,
        name: t.name,
        stack: t.stack,
        ...j7(t)
      };
    }
    if (y_(t)) {
      const e = {
        type: t.type,
        target: T7(t.target),
        currentTarget: T7(t.currentTarget),
        ...j7(t)
      };
      if (typeof CustomEvent !== "undefined" && Cn(t, CustomEvent)) {
        e.detail = t.detail;
      }
      return e;
    } else {
      return t;
    }
  }
  function T7(t) {
    try {
      if (S_(t)) {
        return __(t);
      } else {
        return Object.prototype.toString.call(t);
      }
    } catch {
      return "<unknown>";
    }
  }
  function j7(t) {
    if (typeof t == "object" && t !== null) {
      const e = {};
      for (const i in t) {
        if (Object.prototype.hasOwnProperty.call(t, i)) {
          e[i] = t[i];
        }
      }
      return e;
    } else {
      return {};
    }
  }
  var Nr = g({
    "out-build/external/sentry/utils/object.js"() {
      "use strict";
  
      M7();
      _n();
      fs();
      Fr();
      _d();
    }
  });
  function U7(t) {
    try {
      if (!t || typeof t != "function") {
        return Od;
      } else {
        return t.name || Od;
      }
    } catch {
      return Od;
    }
  }
  function Em(t) {
    const e = t.exception;
    if (e) {
      const i = [];
      try {
        e.values.forEach(s => {
          if (s.stacktrace.frames) {
            i.push(...s.stacktrace.frames);
          }
        });
        return i;
      } catch {
        return;
      }
    }
  }
  var Od;
  var sl = g({
    "out-build/external/sentry/utils/stacktrace.js"() {
      "use strict";
  
      Od = "<anonymous>";
    }
  });
  function T_(t, e) {
    rl[t] = rl[t] || [];
    rl[t].push(e);
  }
  function j_(t, e) {
    if (!km[t]) {
      e();
      km[t] = true;
    }
  }
  function U_(t, e) {
    const i = t && rl[t];
    if (i) {
      for (const s of i) {
        try {
          s(e);
        } catch (r) {
          if (Rd) {
            oi.error(`Error while triggering instrumentation handler.
  Type: ${t}
  Name: ${U7(s)}
  Error:`, r);
          }
        }
      }
    }
  }
  var rl;
  var km;
  var nl = g({
    "out-build/external/sentry/utils/instrument/handlers.js"() {
      "use strict";
  
      _n();
      Fr();
      sl();
      rl = {};
      km = {};
    }
  });
  function B_(t) {
    const e = "console";
    T_(e, t);
    j_(e, q_);
  }
  function q_() {
    if ("console" in yt) {
      tl.forEach(function (t) {
        if (t in yt.console) {
          L_(yt.console, t, function (e) {
            il[t] = e;
            return function (...i) {
              U_("console", {
                args: i,
                level: t
              });
              const r = il[t];
              if (r) {
                r.apply(yt.console, i);
              }
            };
          });
        }
      });
    }
  }
  var z_ = g({
    "out-build/external/sentry/utils/instrument/console.js"() {
      "use strict";
  
      Fr();
      Nr();
      Fi();
      nl();
    }
  });
  var H_ = g({
    "out-build/external/sentry/utils/vendor/supportsHistory.js"() {
      "use strict";
  
      Fi();
    }
  });
  var B7 = g({
    "out-build/external/sentry/utils/supports.js"() {
      "use strict";
  
      _n();
      Fr();
      Fi();
      H_();
    }
  });
  function q7() {
    return Date.now() / xm;
  }
  function V_() {
    const {
      performance: t
    } = yt;
    if (!t || !t.now) {
      return q7;
    }
    const e = Date.now() - t.now();
    const i = t.timeOrigin == null ? e : t.timeOrigin;
    return () => (i + t.now()) / xm;
  }
  var xm;
  var Ld;
  var Md;
  var G_;
  var Dm = g({
    "out-build/external/sentry/utils/time.js"() {
      "use strict";
  
      Fi();
      xm = 1000;
      Ld = V_();
      G_ = (() => {
        const {
          performance: t
        } = yt;
        if (!t || !t.now) {
          Md = "none";
          return;
        }
        const e = 3600000;
        const i = t.now();
        const s = Date.now();
        const r = t.timeOrigin ? Math.abs(t.timeOrigin + i - s) : e;
        const n = r < e;
        const o = t.timing && t.timing.navigationStart;
        const c = typeof o == "number" ? Math.abs(o + i - s) : e;
        const l = c < e;
        if (n || l) {
          if (r <= c) {
            Md = "timeOrigin";
            return t.timeOrigin;
          } else {
            Md = "navigationStart";
            return o;
          }
        } else {
          Md = "dateNow";
          return s;
        }
      })();
    }
  });
  var J_ = g({
    "out-build/external/sentry/utils/instrument/fetch.js"() {
      "use strict";
  
      fs();
      Nr();
      B7();
      Dm();
      Fi();
      nl();
    }
  });
  var K_ = g({
    "out-build/external/sentry/utils/instrument/globalError.js"() {
      "use strict";
  
      Fi();
      nl();
    }
  });
  var Z_ = g({
    "out-build/external/sentry/utils/instrument/globalUnhandledRejection.js"() {
      "use strict";
  
      Fi();
      nl();
    }
  });
  var Y_ = g({
    "out-build/external/sentry/utils/instrument/index.js"() {
      "use strict";
  
      z_();
      J_();
      K_();
      Z_();
      nl();
    }
  });
  var z7 = g({
    "out-build/external/sentry/utils/env.js"() {
      "use strict";
    }
  });
  var H7 = g({
    "out-build/external/sentry/utils/node.js"() {
      "use strict";
  
      z7();
    }
  });
  var X_ = g({
    "out-build/external/sentry/utils/isBrowser.js"() {
      "use strict";
  
      H7();
      Fi();
    }
  });
  function Q_() {
    const t = typeof WeakSet == "function";
    const e = t ? new WeakSet() : [];
    function i(r) {
      if (t) {
        if (e.has(r)) {
          return true;
        } else {
          e.add(r);
          return false;
        }
      }
      for (let n = 0; n < e.length; n++) {
        if (e[n] === r) {
          return true;
        }
      }
      e.push(r);
      return false;
    }
    function s(r) {
      if (t) {
        e.delete(r);
      } else {
        for (let n = 0; n < e.length; n++) {
          if (e[n] === r) {
            e.splice(n, 1);
            break;
          }
        }
      }
    }
    return [i, s];
  }
  var V7 = g({
    "out-build/external/sentry/utils/memo.js"() {
      "use strict";
    }
  });
  function ta() {
    const t = yt;
    const e = t.crypto || t.msCrypto;
    let i = () => Math.random() * 16;
    try {
      if (e && e.randomUUID) {
        return e.randomUUID().replace(/-/g, "");
      }
      if (e && e.getRandomValues) {
        i = () => {
          const s = new Uint8Array(1);
          e.getRandomValues(s);
          return s[0];
        };
      }
    } catch {}
    return "10000000100040008000100000000000".replace(/[018]/g, s => (s ^ (i() & 15) >> s / 4).toString(16));
  }
  function G7(t) {
    if (t.exception && t.exception.values) {
      return t.exception.values[0];
    } else {
      return undefined;
    }
  }
  function Rn(t) {
    const {
      message: e,
      event_id: i
    } = t;
    if (e) {
      return e;
    }
    const s = G7(t);
    if (s) {
      if (s.type && s.value) {
        return `${s.type}: ${s.value}`;
      } else {
        return s.type || s.value || i || "<unknown>";
      }
    } else {
      return i || "<unknown>";
    }
  }
  function eR(t, e) {
    const i = G7(t);
    if (!i) {
      return;
    }
    const s = {
      type: "generic",
      handled: true
    };
    const r = i.mechanism;
    i.mechanism = {
      ...s,
      ...r,
      ...e
    };
    if (e && "data" in e) {
      const n = {
        ...(r && r.data),
        ...e.data
      };
      i.mechanism.data = n;
    }
  }
  var ol = g({
    "out-build/external/sentry/utils/misc.js"() {
      "use strict";
  
      Nr();
      _d();
      Fi();
    }
  });
  function J7(t, e = 100, i = Infinity) {
    try {
      return Pm("", t, e, i);
    } catch (s) {
      return {
        ERROR: `**non-serializable** (${s})`
      };
    }
  }
  function Pm(t, e, i = Infinity, s = Infinity, r = Q_()) {
    const [n, o] = r;
    if (e == null || ["boolean", "string"].includes(typeof e) || typeof e == "number" && Number.isFinite(e)) {
      return e;
    }
    const a = tR(t, e);
    if (!a.startsWith("[object ")) {
      return a;
    }
    if (e.__sentry_skip_normalization__) {
      return e;
    }
    const c = typeof e.__sentry_override_normalization_depth__ == "number" ? e.__sentry_override_normalization_depth__ : i;
    if (c === 0) {
      return a.replace("object ", "");
    }
    if (n(e)) {
      return "[Circular ~]";
    }
    const l = e;
    if (l && typeof l.toJSON == "function") {
      try {
        const p = l.toJSON();
        return Pm("", p, c - 1, s, r);
      } catch {}
    }
    const u = Array.isArray(e) ? [] : {};
    let d = 0;
    const f = W_(e);
    for (const p in f) {
      if (!Object.prototype.hasOwnProperty.call(f, p)) {
        continue;
      }
      if (d >= s) {
        u[p] = "[MaxProperties ~]";
        break;
      }
      const w = f[p];
      u[p] = Pm(p, w, c - 1, s, r);
      d++;
    }
    o(e);
    return u;
  }
  function tR(t, e) {
    try {
      if (t === "domain" && e && typeof e == "object" && e._events) {
        return "[Domain]";
      }
      if (t === "domainEmitter") {
        return "[DomainEmitter]";
      }
      if (typeof global !== "undefined" && e === global) {
        return "[Global]";
      }
      if (typeof window !== "undefined" && e === window) {
        return "[Window]";
      }
      if (typeof document !== "undefined" && e === document) {
        return "[Document]";
      }
      if (I7(e)) {
        return "[VueViewModel]";
      }
      if (k_(e)) {
        return "[SyntheticEvent]";
      }
      if (typeof e == "number" && !Number.isFinite(e)) {
        return `[${e}]`;
      }
      if (typeof e == "function") {
        return `[Function: ${U7(e)}]`;
      }
      if (typeof e == "symbol") {
        return `[${String(e)}]`;
      }
      if (typeof e == "bigint") {
        return `[BigInt: ${String(e)}]`;
      }
      const i = iR(e);
      if (/^HTML(\w*)Element$/.test(i)) {
        return `[HTMLElement: ${i}]`;
      } else {
        return `[object ${i}]`;
      }
    } catch (i) {
      return `**non-serializable** (${i})`;
    }
  }
  function iR(t) {
    const e = Object.getPrototypeOf(t);
    if (e) {
      return e.constructor.name;
    } else {
      return "null prototype";
    }
  }
  var Fd = g({
    "out-build/external/sentry/utils/normalize.js"() {
      "use strict";
  
      fs();
      V7();
      Nr();
      sl();
    }
  });
  function sR(t, e) {
    let i = 0;
    for (let s = t.length - 1; s >= 0; s--) {
      const r = t[s];
      if (r === ".") {
        t.splice(s, 1);
      } else if (r === "..") {
        t.splice(s, 1);
        i++;
      } else if (i) {
        t.splice(s, 1);
        i--;
      }
    }
    if (e) {
      for (; i--; i) {
        t.unshift("..");
      }
    }
    return t;
  }
  function rR(t) {
    const e = t.length > 1024 ? `<truncated>${t.slice(-1024)}` : t;
    const i = Y7.exec(e);
    if (i) {
      return i.slice(1);
    } else {
      return [];
    }
  }
  function K7(...t) {
    let e = "";
    let i = false;
    for (let s = t.length - 1; s >= -1 && !i; s--) {
      const r = s >= 0 ? t[s] : "/";
      if (r) {
        e = `${r}/${e}`;
        i = r.charAt(0) === "/";
      }
    }
    e = sR(e.split("/").filter(s => !!s), !i).join("/");
    return (i ? "/" : "") + e || ".";
  }
  function Z7(t) {
    let e = 0;
    for (; e < t.length && t[e] === ""; e++);
    let i = t.length - 1;
    for (; i >= 0 && t[i] === ""; i--);
    if (e > i) {
      return [];
    } else {
      return t.slice(e, i - e + 1);
    }
  }
  function nR(t, e) {
    t = K7(t).slice(1);
    e = K7(e).slice(1);
    const i = Z7(t.split("/"));
    const s = Z7(e.split("/"));
    const r = Math.min(i.length, s.length);
    let n = r;
    for (let a = 0; a < r; a++) {
      if (i[a] !== s[a]) {
        n = a;
        break;
      }
    }
    let o = [];
    for (let a = n; a < i.length; a++) {
      o.push("..");
    }
    o = o.concat(s.slice(n));
    return o.join("/");
  }
  function oR(t, e) {
    let i = rR(t)[2] || "";
    if (e && i.slice(e.length * -1) === e) {
      i = i.slice(0, i.length - e.length);
    }
    return i;
  }
  var Y7;
  var aR = g({
    "out-build/external/sentry/utils/path.js"() {
      "use strict";
  
      Y7 = /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/;
    }
  });
  function cR(t) {
    return new Nd(e => {
      e(t);
    });
  }
  function lR(t) {
    return new Nd((e, i) => {
      i(t);
    });
  }
  var X7;
  var Nd;
  var Q7 = g({
    "out-build/external/sentry/utils/syncpromise.js"() {
      "use strict";
  
      fs();
      (function (t) {
        t[t.PENDING = 0] = "PENDING";
        t[t.RESOLVED = 1] = "RESOLVED";
        t[t.REJECTED = 2] = "REJECTED";
      })(X7 ||= {});
      Nd = class x0 {
        constructor(e) {
          this._resolve = i => {
            this._setResult(1, i);
          };
          this._reject = i => {
            this._setResult(2, i);
          };
          this._setResult = (i, s) => {
            if (this._state === 0) {
              if ($7(s)) {
                s.then(this._resolve, this._reject);
                return;
              }
              this._state = i;
              this._value = s;
              this._executeHandlers();
            }
          };
          this._executeHandlers = () => {
            if (this._state === 0) {
              return;
            }
            const i = this._handlers.slice();
            this._handlers = [];
            i.forEach(s => {
              if (!s[0]) {
                if (this._state === 1) {
                  s[1](this._value);
                }
                if (this._state === 2) {
                  s[2](this._value);
                }
                s[0] = true;
              }
            });
          };
          this._state = 0;
          this._handlers = [];
          try {
            e(this._resolve, this._reject);
          } catch (i) {
            this._reject(i);
          }
        }
        then(e, i) {
          return new x0((s, r) => {
            this._handlers.push([false, n => {
              if (!e) {
                s(n);
              } else {
                try {
                  s(e(n));
                } catch (o) {
                  r(o);
                }
              }
            }, n => {
              if (!i) {
                r(n);
              } else {
                try {
                  s(i(n));
                } catch (o) {
                  r(o);
                }
              }
            }]);
            this._executeHandlers();
          });
        }
        catch(e) {
          return this.then(i => i, e);
        }
        finally(e) {
          return new x0((i, s) => {
            let r;
            let n;
            return this.then(o => {
              n = false;
              r = o;
              if (e) {
                e();
              }
            }, o => {
              n = true;
              r = o;
              if (e) {
                e();
              }
            }).then(() => {
              if (n) {
                s(r);
                return;
              }
              i(r);
            });
          });
        }
      };
    }
  });
  function uR(t) {
    const e = [];
    function i() {
      return t === undefined || e.length < t;
    }
    function s(o) {
      return e.splice(e.indexOf(o), 1)[0] || Promise.resolve(undefined);
    }
    function r(o) {
      if (!i()) {
        return lR(new bm("Not adding Promise because buffer limit was reached."));
      }
      const a = o();
      if (e.indexOf(a) === -1) {
        e.push(a);
      }
      a.then(() => s(a)).then(null, () => s(a).then(null, () => {}));
      return a;
    }
    function n(o) {
      return new Nd((a, c) => {
        let l = e.length;
        if (!l) {
          return a(true);
        }
        const u = setTimeout(() => {
          if (o && o > 0) {
            a(false);
          }
        }, o);
        e.forEach(d => {
          cR(d).then(() => {
            if (! --l) {
              clearTimeout(u);
              a(true);
            }
          }, c);
        });
      });
    }
    return {
      $: e,
      add: r,
      drain: n
    };
  }
  var e9 = g({
    "out-build/external/sentry/utils/promisebuffer.js"() {
      "use strict";
  
      ym();
      Q7();
    }
  });
  function hR(t) {
    const e = {};
    let i = 0;
    while (i < t.length) {
      const s = t.indexOf("=", i);
      if (s === -1) {
        break;
      }
      let r = t.indexOf(";", i);
      if (r === -1) {
        r = t.length;
      } else if (r < s) {
        i = t.lastIndexOf(";", s - 1) + 1;
        continue;
      }
      const n = t.slice(i, s).trim();
      if (e[n] === undefined) {
        let o = t.slice(s + 1, r).trim();
        if (o.charCodeAt(0) === 34) {
          o = o.slice(1, -1);
        }
        try {
          e[n] = o.indexOf("%") !== -1 ? decodeURIComponent(o) : o;
        } catch {
          e[n] = o;
        }
      }
      i = r + 1;
    }
    return e;
  }
  var dR = g({
    "out-build/external/sentry/utils/cookie.js"() {
      "use strict";
    }
  });
  function fR(t) {
    return t.split(/[?#]/, 1)[0];
  }
  var t9 = g({
    "out-build/external/sentry/utils/url.js"() {
      "use strict";
    }
  });
  function pR(t) {
    return $m.map(r => {
      const n = t[r];
      const o = Array.isArray(n) ? n.join(";") : n;
      if (r === "Forwarded") {
        return gR(o);
      } else {
        return o && o.split(",").map(a => a.trim());
      }
    }).reduce((r, n) => n ? r.concat(n) : r, []).find(r => r !== null && mR(r)) || null;
  }
  function gR(t) {
    if (!t) {
      return null;
    }
    for (const e of t.split(";")) {
      if (e.startsWith("for=")) {
        return e.slice(4);
      }
    }
    return null;
  }
  function mR(t) {
    return /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-fA-F\d]{1,4}:){7}(?:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,2}|:)|(?:[a-fA-F\d]{1,4}:){4}(?:(?::[a-fA-F\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,3}|:)|(?:[a-fA-F\d]{1,4}:){3}(?:(?::[a-fA-F\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,4}|:)|(?:[a-fA-F\d]{1,4}:){2}(?:(?::[a-fA-F\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,5}|:)|(?:[a-fA-F\d]{1,4}:){1}(?:(?::[a-fA-F\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,6}|:)|(?::(?:(?::[a-fA-F\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,7}|:)))(?:%[0-9a-zA-Z]{1,})?$)/.test(t);
  }
  var $m;
  var wR = g({
    "out-build/external/sentry/utils/vendor/getIpAddress.js"() {
      "use strict";
  
      $m = ["X-Client-IP", "X-Forwarded-For", "Fly-Client-IP", "CF-Connecting-IP", "Fastly-Client-Ip", "True-Client-Ip", "X-Real-IP", "X-Cluster-Client-IP", "X-Forwarded", "Forwarded-For", "Forwarded", "X-Vercel-Forwarded-For"];
    }
  });
  function i9(t, e = {}) {
    const i = t.method && t.method.toUpperCase();
    let s = "";
    let r = "url";
    if (e.customRoute || t.route) {
      s = e.customRoute || `${t.baseUrl || ""}${t.route && t.route.path}`;
      r = "route";
    } else if (t.originalUrl || t.url) {
      s = fR(t.originalUrl || t.url || "");
    }
    let n = "";
    if (e.method && i) {
      n += i;
    }
    if (e.method && e.path) {
      n += " ";
    }
    if (e.path && s) {
      n += s;
    }
    return [n, r];
  }
  function vR(t, e) {
    switch (e) {
      case "path":
        return i9(t, {
          path: true
        })[0];
      case "handler":
        return t.route && t.route.stack && t.route.stack[0] && t.route.stack[0].name || "<anonymous>";
      case "methodPath":
      default:
        {
          const i = t._reconstructedRoute ? t._reconstructedRoute : undefined;
          return i9(t, {
            path: true,
            method: true,
            customRoute: i
          })[0];
        }
    }
  }
  function bR(t, e) {
    const i = {};
    (Array.isArray(e) ? e : r9).forEach(r => {
      if (t && r in t) {
        i[r] = t[r];
      }
    });
    return i;
  }
  function yR(t, e = {}) {
    const {
      include: i = Im
    } = e;
    const s = {};
    const r = t.headers || {};
    const n = t.method;
    const o = r.host || t.hostname || t.host || "<no host>";
    const a = t.protocol === "https" || t.socket && t.socket.encrypted ? "https" : "http";
    const c = t.originalUrl || t.url || "";
    const l = c.startsWith(a) ? c : `${a}://${o}${c}`;
    i.forEach(u => {
      switch (u) {
        case "headers":
          {
            s.headers = r;
            if (!i.includes("cookies")) {
              delete s.headers.cookie;
            }
            if (!i.includes("ip")) {
              $m.forEach(d => {
                delete s.headers[d];
              });
            }
            break;
          }
        case "method":
          {
            s.method = n;
            break;
          }
        case "url":
          {
            s.url = l;
            break;
          }
        case "cookies":
          {
            s.cookies = t.cookies || r.cookie && hR(r.cookie) || {};
            break;
          }
        case "query_string":
          {
            s.query_string = ER(t);
            break;
          }
        case "data":
          {
            if (n === "GET" || n === "HEAD") {
              break;
            }
            if (t.body !== undefined) {
              s.data = Id(t.body) ? t.body : JSON.stringify(J7(t.body));
            }
            break;
          }
        default:
          if ({}.hasOwnProperty.call(t, u)) {
            s[u] = t[u];
          }
      }
    });
    return s;
  }
  function SR(t, e, i) {
    const s = {
      ...s9,
      ...(i && i.include)
    };
    if (s.request) {
      const r = Array.isArray(s.request) ? [...s.request] : [...Im];
      if (s.ip) {
        r.push("ip");
      }
      const n = yR(e, {
        include: r
      });
      t.request = {
        ...t.request,
        ...n
      };
    }
    if (s.user) {
      const r = e.user && Ad(e.user) ? bR(e.user, s.user) : {};
      if (Object.keys(r).length) {
        t.user = {
          ...t.user,
          ...r
        };
      }
    }
    if (s.ip) {
      const r = e.headers && pR(e.headers) || e.ip || e.socket && e.socket.remoteAddress;
      if (r) {
        t.user = {
          ...t.user,
          ip_address: r
        };
      }
    }
    if (s.transaction && !t.transaction && t.type === "transaction") {
      t.transaction = vR(e, s.transaction);
    }
    return t;
  }
  function ER(t) {
    let e = t.originalUrl || t.url || "";
    if (e) {
      if (e.startsWith("/")) {
        e = `http://dogs.are.great${e}`;
      }
      try {
        const i = t.query || new URL(e).search.slice(1);
        if (i.length) {
          return i;
        } else {
          return undefined;
        }
      } catch {
        return;
      }
    }
  }
  var s9;
  var Im;
  var r9;
  var kR = g({
    "out-build/external/sentry/utils/requestdata.js"() {
      "use strict";
  
      dR();
      _n();
      fs();
      Fr();
      Fd();
      t9();
      wR();
      s9 = {
        ip: false,
        request: true,
        transaction: true,
        user: true
      };
      Im = ["cookies", "data", "headers", "method", "query_string", "url"];
      r9 = ["id", "username", "email"];
    }
  });
  function xR(t) {
    if (t === "warn") {
      return "warning";
    } else if (n9.includes(t)) {
      return t;
    } else {
      return "log";
    }
  }
  var n9;
  var DR = g({
    "out-build/external/sentry/utils/severity.js"() {
      "use strict";
  
      n9 = ["fatal", "error", "warning", "log", "info", "debug"];
    }
  });
  var o9 = g({
    "out-build/external/sentry/utils/node-stack-trace.js"() {
      "use strict";
  
      sl();
    }
  });
  var a9 = g({
    "out-build/external/sentry/utils/baggage.js"() {
      "use strict";
  
      _n();
      fs();
      Fr();
    }
  });
  var PR;
  var $R = g({
    "out-build/external/sentry/utils/tracing.js"() {
      "use strict";
  
      a9();
      ol();
      PR = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");
    }
  });
  function IR(t, e) {
    const [i, s] = t;
    return [i, [...s, e]];
  }
  function Am(t, e) {
    const i = t[1];
    for (const s of i) {
      const r = s[0].type;
      if (e(s, r)) {
        return true;
      }
    }
    return false;
  }
  var Cm = g({
    "out-build/external/sentry/utils/envelope.js"() {
      "use strict";
  
      W7();
      Fd();
      Nr();
      Fi();
    }
  });
  var AR = g({
    "out-build/external/sentry/utils/clientreport.js"() {
      "use strict";
  
      Cm();
      Dm();
    }
  });
  var CR;
  var _R = g({
    "out-build/external/sentry/utils/ratelimit.js"() {
      "use strict";
  
      CR = 60000;
    }
  });
  var RR = g({
    "out-build/external/sentry/utils/cache.js"() {
      "use strict";
    }
  });
  function OR(t, e) {
    return t(e.stack || "", 1);
  }
  function LR(t, e) {
    const i = {
      type: e.name || e.constructor.name,
      value: e.message
    };
    const s = OR(t, e);
    if (s.length) {
      i.stacktrace = {
        frames: s
      };
    }
    return i;
  }
  var MR = g({
    "out-build/external/sentry/utils/eventbuilder.js"() {
      "use strict";
  
      fs();
      ol();
      Fd();
      Nr();
    }
  });
  var FR = g({
    "out-build/external/sentry/utils/anr.js"() {
      "use strict";
  
      o9();
      Nr();
      sl();
    }
  });
  var NR = g({
    "out-build/external/sentry/utils/lru.js"() {
      "use strict";
    }
  });
  var c9 = g({
    "out-build/external/sentry/utils/buildPolyfills/_nullishCoalesce.js"() {
      "use strict";
    }
  });
  var WR = g({
    "out-build/external/sentry/utils/buildPolyfills/_asyncNullishCoalesce.js"() {
      "use strict";
  
      c9();
    }
  });
  var l9 = g({
    "out-build/external/sentry/utils/buildPolyfills/_asyncOptionalChain.js"() {
      "use strict";
    }
  });
  var TR = g({
    "out-build/external/sentry/utils/buildPolyfills/_asyncOptionalChainDelete.js"() {
      "use strict";
  
      l9();
    }
  });
  var u9 = g({
    "out-build/external/sentry/utils/buildPolyfills/_optionalChain.js"() {
      "use strict";
    }
  });
  var jR = g({
    "out-build/external/sentry/utils/buildPolyfills/_optionalChainDelete.js"() {
      "use strict";
  
      u9();
    }
  });
  var UR = g({
    "out-build/external/sentry/utils/buildPolyfills/index.js"() {
      "use strict";
  
      WR();
      l9();
      TR();
      c9();
      u9();
      jR();
    }
  });
  function h9() {
    return {
      traceId: ta(),
      spanId: ta().substring(16)
    };
  }
  var BR = g({
    "out-build/external/sentry/utils/propagationContext.js"() {
      "use strict";
  
      ol();
    }
  });
  var qR = g({
    "out-build/external/sentry/utils/vercelWaitUntil.js"() {
      "use strict";
  
      Fi();
    }
  });
  var K = g({
    "out-build/external/sentry/utils/index.js"() {
      "use strict";
  
      I_();
      A_();
      C_();
      M7();
      W7();
      ym();
      Fi();
      Y_();
      fs();
      X_();
      Fr();
      V7();
      ol();
      H7();
      Fd();
      Nr();
      aR();
      e9();
      kR();
      DR();
      sl();
      o9();
      _d();
      B7();
      Q7();
      Dm();
      $R();
      z7();
      Cm();
      AR();
      _R();
      a9();
      t9();
      RR();
      MR();
      FR();
      NR();
      UR();
      BR();
      qR();
      R7();
    }
  });
  var ps;
  var Pt = g({
    "out-build/external/sentry/core/debug-build.js"() {
      "use strict";
  
      ps = false;
    }
  });
  function al() {
    _m(yt);
    return yt;
  }
  function _m(t) {
    const e = t.__SENTRY__ = t.__SENTRY__ || {};
    e.version = e.version || ea;
    return e[ea] = e[ea] || {};
  }
  var On = g({
    "out-build/external/sentry/core/carrier.js"() {
      "use strict";
  
      K();
    }
  });
  function zR(t, e = {}) {
    if (e.user) {
      if (!t.ipAddress && e.user.ip_address) {
        t.ipAddress = e.user.ip_address;
      }
      if (!t.did && !e.did) {
        t.did = e.user.id || e.user.email || e.user.username;
      }
    }
    t.timestamp = e.timestamp || Ld();
    if (e.abnormal_mechanism) {
      t.abnormal_mechanism = e.abnormal_mechanism;
    }
    if (e.ignoreDuration) {
      t.ignoreDuration = e.ignoreDuration;
    }
    if (e.sid) {
      t.sid = e.sid.length === 32 ? e.sid : ta();
    }
    if (e.init !== undefined) {
      t.init = e.init;
    }
    if (!t.did && e.did) {
      t.did = `${e.did}`;
    }
    if (typeof e.started == "number") {
      t.started = e.started;
    }
    if (t.ignoreDuration) {
      t.duration = undefined;
    } else if (typeof e.duration == "number") {
      t.duration = e.duration;
    } else {
      const i = t.timestamp - t.started;
      t.duration = i >= 0 ? i : 0;
    }
    if (e.release) {
      t.release = e.release;
    }
    if (e.environment) {
      t.environment = e.environment;
    }
    if (!t.ipAddress && e.ipAddress) {
      t.ipAddress = e.ipAddress;
    }
    if (!t.userAgent && e.userAgent) {
      t.userAgent = e.userAgent;
    }
    if (typeof e.errors == "number") {
      t.errors = e.errors;
    }
    if (e.status) {
      t.status = e.status;
    }
  }
  var Wd = g({
    "out-build/external/sentry/core/session.js"() {
      "use strict";
  
      K();
    }
  });
  function d9(t, e) {
    if (e) {
      Sm(t, Td, e);
    } else {
      delete t[Td];
    }
  }
  function Rm(t) {
    return t[Td];
  }
  var Td;
  var cl = g({
    "out-build/external/sentry/core/utils/spanOnScope.js"() {
      "use strict";
  
      K();
      Td = "_sentrySpan";
    }
  });
  var f9;
  var p9;
  var Ln;
  var ll = g({
    "out-build/external/sentry/core/scope.js"() {
      "use strict";
  
      K();
      Wd();
      cl();
      f9 = 100;
      p9 = class hS {
        constructor() {
          this._notifyingListeners = false;
          this._scopeListeners = [];
          this._eventProcessors = [];
          this._breadcrumbs = [];
          this._attachments = [];
          this._user = {};
          this._tags = {};
          this._extra = {};
          this._contexts = {};
          this._sdkProcessingMetadata = {};
          this._propagationContext = h9();
        }
        clone() {
          const e = new hS();
          e._breadcrumbs = [...this._breadcrumbs];
          e._tags = {
            ...this._tags
          };
          e._extra = {
            ...this._extra
          };
          e._contexts = {
            ...this._contexts
          };
          e._user = this._user;
          e._level = this._level;
          e._session = this._session;
          e._transactionName = this._transactionName;
          e._fingerprint = this._fingerprint;
          e._eventProcessors = [...this._eventProcessors];
          e._requestSession = this._requestSession;
          e._attachments = [...this._attachments];
          e._sdkProcessingMetadata = {
            ...this._sdkProcessingMetadata
          };
          e._propagationContext = {
            ...this._propagationContext
          };
          e._client = this._client;
          e._lastEventId = this._lastEventId;
          d9(e, Rm(this));
          return e;
        }
        setClient(e) {
          this._client = e;
        }
        setLastEventId(e) {
          this._lastEventId = e;
        }
        getClient() {
          return this._client;
        }
        lastEventId() {
          return this._lastEventId;
        }
        addScopeListener(e) {
          this._scopeListeners.push(e);
        }
        addEventProcessor(e) {
          this._eventProcessors.push(e);
          return this;
        }
        setUser(e) {
          this._user = e || {
            email: undefined,
            id: undefined,
            ip_address: undefined,
            username: undefined
          };
          if (this._session) {
            zR(this._session, {
              user: e
            });
          }
          this._notifyScopeListeners();
          return this;
        }
        getUser() {
          return this._user;
        }
        getRequestSession() {
          return this._requestSession;
        }
        setRequestSession(e) {
          this._requestSession = e;
          return this;
        }
        setTags(e) {
          this._tags = {
            ...this._tags,
            ...e
          };
          this._notifyScopeListeners();
          return this;
        }
        setTag(e, i) {
          this._tags = {
            ...this._tags,
            [e]: i
          };
          this._notifyScopeListeners();
          return this;
        }
        setExtras(e) {
          this._extra = {
            ...this._extra,
            ...e
          };
          this._notifyScopeListeners();
          return this;
        }
        setExtra(e, i) {
          this._extra = {
            ...this._extra,
            [e]: i
          };
          this._notifyScopeListeners();
          return this;
        }
        setFingerprint(e) {
          this._fingerprint = e;
          this._notifyScopeListeners();
          return this;
        }
        setLevel(e) {
          this._level = e;
          this._notifyScopeListeners();
          return this;
        }
        setTransactionName(e) {
          this._transactionName = e;
          this._notifyScopeListeners();
          return this;
        }
        setContext(e, i) {
          if (i === null) {
            delete this._contexts[e];
          } else {
            this._contexts[e] = i;
          }
          this._notifyScopeListeners();
          return this;
        }
        setSession(e) {
          if (e) {
            this._session = e;
          } else {
            delete this._session;
          }
          this._notifyScopeListeners();
          return this;
        }
        getSession() {
          return this._session;
        }
        update(e) {
          if (!e) {
            return this;
          }
          const i = typeof e == "function" ? e(this) : e;
          const [s, r] = i instanceof Ln ? [i.getScopeData(), i.getRequestSession()] : Ad(i) ? [e, e.requestSession] : [];
          const {
            tags: n,
            extra: o,
            user: a,
            contexts: c,
            level: l,
            fingerprint: u = [],
            propagationContext: d
          } = s || {};
          this._tags = {
            ...this._tags,
            ...n
          };
          this._extra = {
            ...this._extra,
            ...o
          };
          this._contexts = {
            ...this._contexts,
            ...c
          };
          if (a && Object.keys(a).length) {
            this._user = a;
          }
          if (l) {
            this._level = l;
          }
          if (u.length) {
            this._fingerprint = u;
          }
          if (d) {
            this._propagationContext = d;
          }
          if (r) {
            this._requestSession = r;
          }
          return this;
        }
        clear() {
          this._breadcrumbs = [];
          this._tags = {};
          this._extra = {};
          this._user = {};
          this._contexts = {};
          this._level = undefined;
          this._transactionName = undefined;
          this._fingerprint = undefined;
          this._requestSession = undefined;
          this._session = undefined;
          d9(this, undefined);
          this._attachments = [];
          this._propagationContext = h9();
          this._notifyScopeListeners();
          return this;
        }
        addBreadcrumb(e, i) {
          const s = typeof i == "number" ? i : f9;
          if (s <= 0) {
            return this;
          }
          const r = {
            timestamp: q7(),
            ...e
          };
          const n = this._breadcrumbs;
          n.push(r);
          this._breadcrumbs = n.length > s ? n.slice(-s) : n;
          this._notifyScopeListeners();
          return this;
        }
        getLastBreadcrumb() {
          return this._breadcrumbs[this._breadcrumbs.length - 1];
        }
        clearBreadcrumbs() {
          this._breadcrumbs = [];
          this._notifyScopeListeners();
          return this;
        }
        addAttachment(e) {
          this._attachments.push(e);
          return this;
        }
        clearAttachments() {
          this._attachments = [];
          return this;
        }
        getScopeData() {
          return {
            breadcrumbs: this._breadcrumbs,
            attachments: this._attachments,
            contexts: this._contexts,
            tags: this._tags,
            extra: this._extra,
            user: this._user,
            level: this._level,
            fingerprint: this._fingerprint || [],
            eventProcessors: this._eventProcessors,
            propagationContext: this._propagationContext,
            sdkProcessingMetadata: this._sdkProcessingMetadata,
            transactionName: this._transactionName,
            span: Rm(this)
          };
        }
        setSDKProcessingMetadata(e) {
          this._sdkProcessingMetadata = {
            ...this._sdkProcessingMetadata,
            ...e
          };
          return this;
        }
        setPropagationContext(e) {
          this._propagationContext = e;
          return this;
        }
        getPropagationContext() {
          return this._propagationContext;
        }
        captureException(e, i) {
          const s = i && i.event_id ? i.event_id : ta();
          if (!this._client) {
            oi.warn("No client configured on scope - will not capture exception!");
            return s;
          }
          const r = new Error("Sentry syntheticException");
          this._client.captureException(e, {
            originalException: e,
            syntheticException: r,
            ...i,
            event_id: s
          }, this);
          return s;
        }
        captureMessage(e, i, s) {
          const r = s && s.event_id ? s.event_id : ta();
          if (!this._client) {
            oi.warn("No client configured on scope - will not capture message!");
            return r;
          }
          const n = new Error(e);
          this._client.captureMessage(e, i, {
            originalException: e,
            syntheticException: n,
            ...s,
            event_id: r
          }, this);
          return r;
        }
        captureEvent(e, i) {
          const s = i && i.event_id ? i.event_id : ta();
          if (this._client) {
            this._client.captureEvent(e, {
              ...i,
              event_id: s
            }, this);
            return s;
          } else {
            oi.warn("No client configured on scope - will not capture event!");
            return s;
          }
        }
        _notifyScopeListeners() {
          if (!this._notifyingListeners) {
            this._notifyingListeners = true;
            this._scopeListeners.forEach(e => {
              e(this);
            });
            this._notifyingListeners = false;
          }
        }
      };
      Ln = p9;
    }
  });
  function HR() {
    return vm("defaultCurrentScope", () => new Ln());
  }
  function VR() {
    return vm("defaultIsolationScope", () => new Ln());
  }
  var g9 = g({
    "out-build/external/sentry/core/defaultScopes.js"() {
      "use strict";
  
      K();
      ll();
    }
  });
  function ia() {
    const t = al();
    const e = _m(t);
    return e.stack = e.stack || new w9(HR(), VR());
  }
  function GR(t) {
    return ia().withScope(t);
  }
  function JR(t, e) {
    const i = ia();
    return i.withScope(() => {
      i.getStackTop().scope = t;
      return e(t);
    });
  }
  function m9(t) {
    return ia().withScope(() => t(ia().getIsolationScope()));
  }
  function KR() {
    return {
      withIsolationScope: m9,
      withScope: GR,
      withSetScope: JR,
      withSetIsolationScope: (t, e) => m9(e),
      getCurrentScope: () => ia().getScope(),
      getIsolationScope: () => ia().getIsolationScope()
    };
  }
  var w9;
  var ZR = g({
    "out-build/external/sentry/core/asyncContext/stackStrategy.js"() {
      "use strict";
  
      K();
      g9();
      ll();
      On();
      w9 = class {
        constructor(t, e) {
          let i;
          if (t) {
            i = t;
          } else {
            i = new Ln();
          }
          let s;
          if (e) {
            s = e;
          } else {
            s = new Ln();
          }
          this._stack = [{
            scope: i
          }];
          this._isolationScope = s;
        }
        withScope(t) {
          const e = this._pushScope();
          let i;
          try {
            i = t(e);
          } catch (s) {
            this._popScope();
            throw s;
          }
          if ($7(i)) {
            return i.then(s => {
              this._popScope();
              return s;
            }, s => {
              this._popScope();
              throw s;
            });
          } else {
            this._popScope();
            return i;
          }
        }
        getClient() {
          return this.getStackTop().client;
        }
        getScope() {
          return this.getStackTop().scope;
        }
        getIsolationScope() {
          return this._isolationScope;
        }
        getStackTop() {
          return this._stack[this._stack.length - 1];
        }
        _pushScope() {
          const t = this.getScope().clone();
          this._stack.push({
            client: this.getClient(),
            scope: t
          });
          return t;
        }
        _popScope() {
          if (this._stack.length <= 1) {
            return false;
          } else {
            return !!this._stack.pop();
          }
        }
      };
    }
  });
  function jd(t) {
    const e = _m(t);
    if (e.acs) {
      return e.acs;
    } else {
      return KR();
    }
  }
  var ul = g({
    "out-build/external/sentry/core/asyncContext/index.js"() {
      "use strict";
  
      On();
      ZR();
    }
  });
  function Mn() {
    const t = al();
    return jd(t).getCurrentScope();
  }
  function Wr() {
    const t = al();
    return jd(t).getIsolationScope();
  }
  function YR(...t) {
    const e = al();
    const i = jd(e);
    if (t.length === 2) {
      const [s, r] = t;
      if (s) {
        return i.withSetScope(s, r);
      } else {
        return i.withScope(r);
      }
    }
    return i.withScope(t[0]);
  }
  function hl() {
    return Mn().getClient();
  }
  var st = g({
    "out-build/external/sentry/core/currentScopes.js"() {
      "use strict";
  
      K();
      ul();
      On();
      ll();
    }
  });
  var Om = g({
    "out-build/external/sentry/core/metrics/metric-summary.js"() {
      "use strict";
  
      K();
    }
  });
  var Ns = g({
    "out-build/external/sentry/core/semanticAttributes.js"() {
      "use strict";
    }
  });
  var v9;
  var sa = g({
    "out-build/external/sentry/core/tracing/spanstatus.js"() {
      "use strict";
  
      v9 = 2;
    }
  });
  function XR(t) {
    return t[b9] || t;
  }
  function QR() {
    const t = al();
    const e = jd(t);
    if (e.getActiveSpan) {
      return e.getActiveSpan();
    } else {
      return Rm(Mn());
    }
  }
  var b9;
  var Zt = g({
    "out-build/external/sentry/core/utils/spanUtils.js"() {
      "use strict";
  
      K();
      ul();
      On();
      st();
      Om();
      Ns();
      sa();
      cl();
      b9 = "_sentryRootSpan";
    }
  });
  function eO() {
    const t = QR();
    const e = t && XR(t);
    if (e) {
      const i = "internal_error";
      if (ps) {
        oi.log(`[Tracing] Root span: ${i} -> Global error occured`);
      }
      e.setStatus({
        code: v9,
        message: i
      });
    }
  }
  var y9 = g({
    "out-build/external/sentry/core/tracing/errors.js"() {
      "use strict";
  
      K();
      Pt();
      Zt();
      sa();
      eO.tag = "sentry_tracingErrorCallback";
    }
  });
  var Lm = g({
    "out-build/external/sentry/core/tracing/utils.js"() {
      "use strict";
  
      K();
      K();
    }
  });
  var tO = g({
    "out-build/external/sentry/core/tracing/hubextensions.js"() {
      "use strict";
  
      y9();
    }
  });
  var ra = g({
    "out-build/external/sentry/core/utils/hasTracingEnabled.js"() {
      "use strict";
  
      st();
    }
  });
  var Ud = g({
    "out-build/external/sentry/core/tracing/sentryNonRecordingSpan.js"() {
      "use strict";
  
      K();
      Zt();
    }
  });
  var Mm = g({
    "out-build/external/sentry/core/utils/handleCallbackErrors.js"() {
      "use strict";
  
      K();
    }
  });
  var Bd = g({
    "out-build/external/sentry/core/constants.js"() {
      "use strict";
    }
  });
  var na = g({
    "out-build/external/sentry/core/tracing/dynamicSamplingContext.js"() {
      "use strict";
  
      K();
      Bd();
      st();
      Ns();
      ra();
      Zt();
    }
  });
  var Fm = g({
    "out-build/external/sentry/core/tracing/logSpans.js"() {
      "use strict";
  
      K();
      Pt();
      Zt();
    }
  });
  var Nm = g({
    "out-build/external/sentry/core/utils/parseSampleRate.js"() {
      "use strict";
  
      K();
      Pt();
    }
  });
  var S9 = g({
    "out-build/external/sentry/core/tracing/sampling.js"() {
      "use strict";
  
      K();
      Pt();
      ra();
      Nm();
    }
  });
  var Wm = g({
    "out-build/external/sentry/core/envelope.js"() {
      "use strict";
  
      K();
      K();
      na();
      Zt();
    }
  });
  var E9 = g({
    "out-build/external/sentry/core/tracing/measurement.js"() {
      "use strict";
  
      Ns();
      Zt();
    }
  });
  var k9 = g({
    "out-build/external/sentry/core/tracing/sentrySpan.js"() {
      "use strict";
  
      K();
      st();
      Pt();
      Wm();
      Om();
      Ns();
      Zt();
      na();
      Fm();
      E9();
      Lm();
    }
  });
  var x9 = g({
    "out-build/external/sentry/core/tracing/trace.js"() {
      "use strict";
  
      K();
      On();
      st();
      ul();
      Pt();
      Ns();
      Mm();
      ra();
      cl();
      Zt();
      na();
      Fm();
      S9();
      Ud();
      k9();
      sa();
      Lm();
    }
  });
  var iO = g({
    "out-build/external/sentry/core/tracing/idleSpan.js"() {
      "use strict";
  
      K();
      st();
      Pt();
      Ns();
      ra();
      cl();
      Zt();
      Ud();
      sa();
      x9();
    }
  });
  var oa = g({
    "out-build/external/sentry/core/tracing/index.js"() {
      "use strict";
  
      y9();
      Lm();
      tO();
      iO();
      k9();
      Ud();
      sa();
      sa();
      x9();
      na();
      E9();
      S9();
      Fm();
    }
  });
  var D9 = g({
    "out-build/external/sentry/core/eventProcessors.js"() {
      "use strict";
  
      K();
      Pt();
    }
  });
  var P9 = g({
    "out-build/external/sentry/core/utils/applyScopeDataToEvent.js"() {
      "use strict";
  
      K();
      na();
      Zt();
    }
  });
  function sO(t) {
    if (t) {
      if (rO(t)) {
        return {
          captureContext: t
        };
      } else if (nO(t)) {
        return {
          captureContext: t
        };
      } else {
        return t;
      }
    }
  }
  function rO(t) {
    return t instanceof Ln || typeof t == "function";
  }
  function nO(t) {
    return Object.keys(t).some(e => $9.includes(e));
  }
  var $9;
  var Tm = g({
    "out-build/external/sentry/core/utils/prepareEvent.js"() {
      "use strict";
  
      K();
      Bd();
      st();
      D9();
      ll();
      P9();
      $9 = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"];
    }
  });
  function oO(t, e) {
    return Mn().captureException(t, sO(e));
  }
  function I9(t, e) {
    const i = typeof e == "string" ? e : undefined;
    const s = typeof e != "string" ? {
      captureContext: e
    } : undefined;
    return Mn().captureMessage(t, i, s);
  }
  var dl = g({
    "out-build/external/sentry/core/exports.js"() {
      "use strict";
  
      K();
      Bd();
      st();
      Pt();
      Wd();
      Tm();
    }
  });
  var A9 = g({
    "out-build/external/sentry/core/sessionflusher.js"() {
      "use strict";
  
      K();
      st();
    }
  });
  function aO(t) {
    const e = t.protocol ? `${t.protocol}:` : "";
    const i = t.port ? `:${t.port}` : "";
    return `${e}//${t.host}${i}${t.path ? `/${t.path}` : ""}/api/`;
  }
  function cO(t) {
    return `${aO(t)}${t.projectId}/envelope/`;
  }
  function lO(t, e) {
    return N_({
      sentry_key: t.publicKey,
      sentry_version: C9,
      ...(e && {
        sentry_client: `${e.name}/${e.version}`
      })
    });
  }
  function uO(t, e, i) {
    return e || `${cO(t)}?${lO(t, i)}`;
  }
  var C9;
  var jm = g({
    "out-build/external/sentry/core/api.js"() {
      "use strict";
  
      K();
      C9 = "7";
    }
  });
  function RT(t) {
    return t;
  }
  var ai = g({
    "out-build/external/sentry/core/integration.js"() {
      "use strict";
  
      K();
      st();
      Pt();
    }
  });
  var _9 = g({
    "out-build/external/sentry/core/baseclient.js"() {
      "use strict";
  
      K();
      jm();
      st();
      Pt();
      Wm();
      ai();
      ai();
      Wd();
      na();
      Nm();
      Tm();
    }
  });
  var R9 = g({
    "out-build/external/sentry/core/checkin.js"() {
      "use strict";
  
      K();
    }
  });
  var hO = g({
    "out-build/external/sentry/core/server-runtime-client.js"() {
      "use strict";
  
      K();
      _9();
      R9();
      st();
      Pt();
      A9();
      oa();
      cl();
      Zt();
    }
  });
  var dO = g({
    "out-build/external/sentry/core/sdk.js"() {
      "use strict";
  
      K();
      st();
      Pt();
    }
  });
  var fO = g({
    "out-build/external/sentry/core/transports/base.js"() {
      "use strict";
  
      K();
      Pt();
    }
  });
  var pO = g({
    "out-build/external/sentry/core/transports/offline.js"() {
      "use strict";
  
      K();
      Pt();
    }
  });
  var gO = g({
    "out-build/external/sentry/core/transports/multiplexed.js"() {
      "use strict";
  
      K();
      jm();
    }
  });
  var mO = g({
    "out-build/external/sentry/core/utils/isSentryRequestUrl.js"() {
      "use strict";
    }
  });
  var wO = g({
    "out-build/external/sentry/core/utils/parameterize.js"() {
      "use strict";
    }
  });
  var vO = g({
    "out-build/external/sentry/core/utils/sdkMetadata.js"() {
      "use strict";
  
      K();
    }
  });
  var O9 = g({
    "out-build/external/sentry/core/utils/traceData.js"() {
      "use strict";
  
      K();
      ul();
      On();
      st();
      dl();
      oa();
      Zt();
    }
  });
  var bO = g({
    "out-build/external/sentry/core/utils/meta.js"() {
      "use strict";
  
      O9();
    }
  });
  var L9 = g({
    "out-build/external/sentry/core/breadcrumbs.js"() {
      "use strict";
  
      K();
      st();
    }
  });
  var M9;
  var F9;
  var Um;
  var N9;
  var yO;
  var SO = g({
    "out-build/external/sentry/core/integrations/functiontostring.js"() {
      "use strict";
  
      K();
      st();
      ai();
      F9 = "FunctionToString";
      Um = new WeakMap();
      N9 = () => ({
        name: F9,
        setupOnce() {
          M9 = Function.prototype.toString;
          try {
            Function.prototype.toString = function (...t) {
              const e = F_(this);
              const i = Um.has(hl()) && e !== undefined ? e : this;
              return M9.apply(i, t);
            };
          } catch {}
        },
        setup(t) {
          Um.set(t, true);
        }
      });
      yO = N9;
    }
  });
  function EO(t = {}, e = {}) {
    return {
      allowUrls: [...(t.allowUrls || []), ...(e.allowUrls || [])],
      denyUrls: [...(t.denyUrls || []), ...(e.denyUrls || [])],
      ignoreErrors: [...(t.ignoreErrors || []), ...(e.ignoreErrors || []), ...(t.disableErrorDefaults ? [] : W9)],
      ignoreTransactions: [...(t.ignoreTransactions || []), ...(e.ignoreTransactions || [])],
      ignoreInternal: t.ignoreInternal !== undefined ? t.ignoreInternal : true
    };
  }
  function kO(t, e) {
    if (e.ignoreInternal && AO(t)) {
      if (ps) {
        oi.warn(`Event dropped due to being internal Sentry Error.
  Event: ${Rn(t)}`);
      }
      return true;
    } else if (xO(t, e.ignoreErrors)) {
      if (ps) {
        oi.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
  Event: ${Rn(t)}`);
      }
      return true;
    } else if (_O(t)) {
      if (ps) {
        oi.warn(`Event dropped due to not having an error message, error type or stacktrace.
  Event: ${Rn(t)}`);
      }
      return true;
    } else if (DO(t, e.ignoreTransactions)) {
      if (ps) {
        oi.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
  Event: ${Rn(t)}`);
      }
      return true;
    } else if (PO(t, e.denyUrls)) {
      if (ps) {
        oi.warn(`Event dropped due to being matched by \`denyUrls\` option.
  Event: ${Rn(t)}.
  Url: ${qd(t)}`);
      }
      return true;
    } else if ($O(t, e.allowUrls)) {
      return false;
    } else {
      if (ps) {
        oi.warn(`Event dropped due to not being matched by \`allowUrls\` option.
  Event: ${Rn(t)}.
  Url: ${qd(t)}`);
      }
      return true;
    }
  }
  function xO(t, e) {
    if (t.type || !e || !e.length) {
      return false;
    } else {
      return IO(t).some(i => Cd(i, e));
    }
  }
  function DO(t, e) {
    if (t.type !== "transaction" || !e || !e.length) {
      return false;
    }
    const i = t.transaction;
    if (i) {
      return Cd(i, e);
    } else {
      return false;
    }
  }
  function PO(t, e) {
    if (!e || !e.length) {
      return false;
    }
    const i = qd(t);
    if (i) {
      return Cd(i, e);
    } else {
      return false;
    }
  }
  function $O(t, e) {
    if (!e || !e.length) {
      return true;
    }
    const i = qd(t);
    if (i) {
      return Cd(i, e);
    } else {
      return true;
    }
  }
  function IO(t) {
    const e = [];
    if (t.message) {
      e.push(t.message);
    }
    let i;
    try {
      i = t.exception.values[t.exception.values.length - 1];
    } catch {}
    if (i && i.value) {
      e.push(i.value);
      if (i.type) {
        e.push(`${i.type}: ${i.value}`);
      }
    }
    return e;
  }
  function AO(t) {
    try {
      return t.exception.values[0].type === "SentryError";
    } catch {}
    return false;
  }
  function CO(t = []) {
    for (let e = t.length - 1; e >= 0; e--) {
      const i = t[e];
      if (i && i.filename !== "<anonymous>" && i.filename !== "[native code]") {
        return i.filename || null;
      }
    }
    return null;
  }
  function qd(t) {
    try {
      let e;
      try {
        e = t.exception.values[0].stacktrace.frames;
      } catch {}
      if (e) {
        return CO(e);
      } else {
        return null;
      }
    } catch {
      if (ps) {
        oi.error(`Cannot extract url for event ${Rn(t)}`);
      }
      return null;
    }
  }
  function _O(t) {
    if (t.type || !t.exception || !t.exception.values || t.exception.values.length === 0) {
      return false;
    } else {
      return !t.message && !t.exception.values.some(e => e.stacktrace || e.type && e.type !== "Error" || e.value);
    }
  }
  var W9;
  var T9;
  var j9;
  var RO;
  var OO = g({
    "out-build/external/sentry/core/integrations/inboundfilters.js"() {
      "use strict";
  
      K();
      Pt();
      ai();
      W9 = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/, "undefined is not an object (evaluating 'a.L')", `can't redefine non-configurable property "solana"`, "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", "Can't find variable: _AutofillCallbackHandler"];
      T9 = "InboundFilters";
      j9 = (t = {}) => ({
        name: T9,
        processEvent(e, i, s) {
          const r = s.getOptions();
          const n = EO(t, r);
          if (kO(e, n)) {
            return null;
          } else {
            return e;
          }
        }
      });
      RO = j9;
    }
  });
  var U9;
  var B9;
  var q9;
  var z9;
  var LO;
  var MO = g({
    "out-build/external/sentry/core/integrations/linkederrors.js"() {
      "use strict";
  
      K();
      ai();
      U9 = "cause";
      B9 = 5;
      q9 = "LinkedErrors";
      z9 = (t = {}) => {
        const e = t.limit || B9;
        const i = t.key || U9;
        return {
          name: q9,
          preprocessEvent(s, r, n) {
            const o = n.getOptions();
            P_(LR, o.stackParser, o.maxValueLength, i, e, s, r);
          }
        };
      };
      LO = z9;
    }
  });
  function FO(t) {
    if (yt._sentryModuleMetadata) {
      for (const e of Object.keys(yt._sentryModuleMetadata)) {
        const i = yt._sentryModuleMetadata[e];
        if (qm.has(e)) {
          continue;
        }
        qm.add(e);
        const s = t(e);
        for (const r of s.reverse()) {
          if (r.filename) {
            Bm.set(r.filename, i);
            break;
          }
        }
      }
    }
  }
  function NO(t, e) {
    FO(t);
    return Bm.get(e);
  }
  function H9(t, e) {
    try {
      e.exception.values.forEach(i => {
        if (i.stacktrace) {
          for (const s of i.stacktrace.frames || []) {
            if (!s.filename || s.module_metadata) {
              continue;
            }
            const r = NO(t, s.filename);
            if (r) {
              s.module_metadata = r;
            }
          }
        }
      });
    } catch {}
  }
  function V9(t) {
    try {
      t.exception.values.forEach(e => {
        if (e.stacktrace) {
          for (const i of e.stacktrace.frames || []) {
            delete i.module_metadata;
          }
        }
      });
    } catch {}
  }
  var Bm;
  var qm;
  var G9 = g({
    "out-build/external/sentry/core/metadata.js"() {
      "use strict";
  
      K();
      Bm = new Map();
      qm = new Set();
    }
  });
  var WO;
  var TO = g({
    "out-build/external/sentry/core/integrations/metadata.js"() {
      "use strict";
  
      K();
      ai();
      G9();
      WO = () => ({
        name: "ModuleMetadata",
        setup(t) {
          t.on("beforeEnvelope", e => {
            Am(e, (i, s) => {
              if (s === "event") {
                const r = Array.isArray(i) ? i[1] : undefined;
                if (r) {
                  V9(r);
                  i[1] = r;
                }
              }
            });
          });
          t.on("applyFrameMetadata", e => {
            if (e.type) {
              return;
            }
            const i = t.getOptions().stackParser;
            H9(i, e);
          });
        }
      });
    }
  });
  function jO(t) {
    const {
      transactionNamingScheme: e,
      include: {
        ip: i,
        user: s,
        ...r
      }
    } = t;
    const n = ["method"];
    for (const [a, c] of Object.entries(r)) {
      if (c) {
        n.push(a);
      }
    }
    let o;
    if (s === undefined) {
      o = true;
    } else if (typeof s == "boolean") {
      o = s;
    } else {
      const a = [];
      for (const [c, l] of Object.entries(s)) {
        if (l) {
          a.push(c);
        }
      }
      o = a;
    }
    return {
      include: {
        ip: i,
        user: o,
        request: n.length !== 0 ? n : undefined,
        transaction: e
      }
    };
  }
  var zd;
  var J9;
  var K9;
  var UO;
  var BO = g({
    "out-build/external/sentry/core/integrations/requestdata.js"() {
      "use strict";
  
      K();
      ai();
      zd = {
        include: {
          cookies: true,
          data: true,
          headers: true,
          ip: false,
          query_string: true,
          url: true,
          user: {
            id: true,
            username: true,
            email: true
          }
        },
        transactionNamingScheme: "methodPath"
      };
      J9 = "RequestData";
      K9 = (t = {}) => {
        const e = {
          ...zd,
          ...t,
          include: {
            ...zd.include,
            ...t.include,
            user: t.include && typeof t.include.user == "boolean" ? t.include.user : {
              ...zd.include.user,
              ...(t.include || {}).user
            }
          }
        };
        return {
          name: J9,
          processEvent(i) {
            const {
              sdkProcessingMetadata: s = {}
            } = i;
            const r = s.request;
            if (!r) {
              return i;
            }
            const n = jO(e);
            return SR(i, r, n);
          }
        };
      };
      UO = K9;
    }
  });
  function qO(t, e) {
    const i = {
      level: xR(e),
      extra: {
        arguments: t
      }
    };
    YR(s => {
      s.addEventProcessor(o => {
        o.logger = "console";
        eR(o, {
          handled: false,
          type: "console"
        });
        return o;
      });
      if (e === "assert") {
        if (!t[0]) {
          const o = `Assertion failed: ${A7(t.slice(1), " ") || "console.assert"}`;
          s.setExtra("arguments", t.slice(1));
          I9(o, i);
        }
        return;
      }
      const r = t.find(o => o instanceof Error);
      if (r) {
        oO(r, i);
        return;
      }
      const n = A7(t, " ");
      I9(n, i);
    });
  }
  var Z9;
  var Y9;
  var zO;
  var HO = g({
    "out-build/external/sentry/core/integrations/captureconsole.js"() {
      "use strict";
  
      K();
      st();
      dl();
      ai();
      Z9 = "CaptureConsole";
      Y9 = (t = {}) => {
        const e = t.levels || tl;
        return {
          name: Z9,
          setup(i) {
            if ("console" in yt) {
              B_(({
                args: s,
                level: r
              }) => {
                if (hl() === i && !!e.includes(r)) {
                  qO(s, r);
                }
              });
            }
          }
        };
      };
      zO = Y9;
    }
  });
  var X9;
  var Q9;
  var VO;
  var GO = g({
    "out-build/external/sentry/core/integrations/debug.js"() {
      "use strict";
  
      K();
      ai();
      X9 = "Debug";
      Q9 = (t = {}) => {
        const e = {
          debugger: false,
          stringify: false,
          ...t
        };
        return {
          name: X9,
          setup(i) {
            i.on("beforeSendEvent", (s, r) => {
              if (e.debugger) {
                debugger;
              }
              F7(() => {
                if (e.stringify) {
                  console.log(JSON.stringify(s, null, 2));
                  if (r && Object.keys(r).length) {
                    console.log(JSON.stringify(r, null, 2));
                  }
                } else {
                  console.log(s);
                  if (r && Object.keys(r).length) {
                    console.log(r);
                  }
                }
              });
            });
          }
        };
      };
      VO = Q9;
    }
  });
  function JO(t, e) {
    if (e) {
      return !!KO(t, e) || !!ZO(t, e);
    } else {
      return false;
    }
  }
  function KO(t, e) {
    const i = t.message;
    const s = e.message;
    return (!!i || !!s) && (!i || !!s) && (!!i || !s) && i === s && !!t8(t, e) && !!e8(t, e);
  }
  function ZO(t, e) {
    const i = i8(e);
    const s = i8(t);
    return !!i && !!s && i.type === s.type && i.value === s.value && !!t8(t, e) && !!e8(t, e);
  }
  function e8(t, e) {
    let i = Em(t);
    let s = Em(e);
    if (!i && !s) {
      return true;
    }
    if (i && !s || !i && s || (i = i, s = s, s.length !== i.length)) {
      return false;
    }
    for (let r = 0; r < s.length; r++) {
      const n = s[r];
      const o = i[r];
      if (n.filename !== o.filename || n.lineno !== o.lineno || n.colno !== o.colno || n.function !== o.function) {
        return false;
      }
    }
    return true;
  }
  function t8(t, e) {
    let i = t.fingerprint;
    let s = e.fingerprint;
    if (!i && !s) {
      return true;
    }
    if (i && !s || !i && s) {
      return false;
    }
    i = i;
    s = s;
    try {
      return i.join("") === s.join("");
    } catch {
      return false;
    }
  }
  function i8(t) {
    return t.exception && t.exception.values && t.exception.values[0];
  }
  var s8;
  var r8;
  var YO;
  var XO = g({
    "out-build/external/sentry/core/integrations/dedupe.js"() {
      "use strict";
  
      K();
      ai();
      Pt();
      s8 = "Dedupe";
      r8 = () => {
        let t;
        return {
          name: s8,
          processEvent(e) {
            if (e.type) {
              return e;
            }
            try {
              if (JO(e, t)) {
                if (ps) {
                  oi.warn("Event dropped due to being a duplicate of previously captured event.");
                }
                return null;
              }
            } catch {}
            return t = e;
          }
        };
      };
      YO = r8;
    }
  });
  function QO(t, e = {}, i, s, r) {
    if (!e.originalException || !Qo(e.originalException)) {
      return t;
    }
    const n = e.originalException.name || e.originalException.constructor.name;
    const o = eL(e.originalException, s, r);
    if (o) {
      const a = {
        ...t.contexts
      };
      const c = J7(o, i);
      if (Ad(c)) {
        Sm(c, "__sentry_skip_normalization__", true);
        a[n] = c;
      }
      return {
        ...t,
        contexts: a
      };
    }
    return t;
  }
  function eL(t, e, i) {
    try {
      const s = ["name", "message", "stack", "line", "column", "fileName", "lineNumber", "columnNumber", "toJSON"];
      const r = {};
      for (const n of Object.keys(t)) {
        if (s.indexOf(n) !== -1) {
          continue;
        }
        const o = t[n];
        r[n] = Qo(o) || typeof o == "string" ? mm(`${o}`, i) : o;
      }
      if (e && t.cause !== undefined) {
        r.cause = Qo(t.cause) ? t.cause.toString() : t.cause;
      }
      if (typeof t.toJSON == "function") {
        const n = t.toJSON();
        for (const o of Object.keys(n)) {
          const a = n[o];
          r[o] = Qo(a) ? a.toString() : a;
        }
      }
      return r;
    } catch (s) {
      if (ps) {
        oi.error("Unable to extract extra data from the Error object:", s);
      }
    }
    return null;
  }
  var n8;
  var o8;
  var tL;
  var iL = g({
    "out-build/external/sentry/core/integrations/extraerrordata.js"() {
      "use strict";
  
      K();
      ai();
      Pt();
      n8 = "ExtraErrorData";
      o8 = (t = {}) => {
        const {
          depth: e = 3,
          captureErrorCause: i = true
        } = t;
        return {
          name: n8,
          processEvent(s, r, n) {
            const {
              maxValueLength: o = 250
            } = n.getOptions();
            return QO(s, r, e, i, o);
          }
        };
      };
      tL = o8;
    }
  });
  function sL({
    isBrowser: t,
    root: e,
    prefix: i
  }) {
    return s => {
      if (!s.filename) {
        return s;
      }
      const r = /^[a-zA-Z]:\\/.test(s.filename) || s.filename.includes("\\") && !s.filename.includes("/");
      const n = /^\//.test(s.filename);
      if (t) {
        if (e) {
          const o = s.filename;
          if (o.indexOf(e) === 0) {
            s.filename = o.replace(e, i);
          }
        }
      } else if (r || n) {
        const o = r ? s.filename.replace(/^[a-zA-Z]:/, "").replace(/\\/g, "/") : s.filename;
        const a = e ? nR(e, o) : oR(o);
        s.filename = `${i}${a}`;
      }
      return s;
    };
  }
  var a8;
  var rL;
  var nL = g({
    "out-build/external/sentry/core/integrations/rewriteframes.js"() {
      "use strict";
  
      K();
      ai();
      a8 = "RewriteFrames";
      rL = (t = {}) => {
        const e = t.root;
        const i = t.prefix || "app:///";
        const s = "window" in yt && yt.window !== undefined;
        const r = t.iteratee || sL({
          isBrowser: s,
          root: e,
          prefix: i
        });
        function n(a) {
          try {
            return {
              ...a,
              exception: {
                ...a.exception,
                values: a.exception.values.map(c => ({
                  ...c,
                  ...(c.stacktrace && {
                    stacktrace: o(c.stacktrace)
                  })
                }))
              }
            };
          } catch {
            return a;
          }
        }
        function o(a) {
          return {
            ...a,
            frames: a && a.frames && a.frames.map(c => r(c))
          };
        }
        return {
          name: a8,
          processEvent(a) {
            let c = a;
            if (a.exception && Array.isArray(a.exception.values)) {
              c = n(c);
            }
            return c;
          }
        };
      };
    }
  });
  var c8;
  var l8;
  var oL;
  var aL = g({
    "out-build/external/sentry/core/integrations/sessiontiming.js"() {
      "use strict";
  
      K();
      ai();
      c8 = "SessionTiming";
      l8 = () => {
        const t = Ld() * 1000;
        return {
          name: c8,
          processEvent(e) {
            const i = Ld() * 1000;
            return {
              ...e,
              extra: {
                ...e.extra,
                "session:start": t,
                "session:duration": i - t,
                "session:end": i
              }
            };
          }
        };
      };
      oL = l8;
    }
  });
  function cL(t) {
    return Qo(t) && t.name === "ZodError" && Array.isArray(t.errors);
  }
  function lL(t) {
    return {
      ...t,
      path: "path" in t && Array.isArray(t.path) ? t.path.join(".") : undefined,
      keys: "keys" in t ? JSON.stringify(t.keys) : undefined,
      unionErrors: "unionErrors" in t ? JSON.stringify(t.unionErrors) : undefined
    };
  }
  function uL(t) {
    const e = new Set();
    for (const s of t.issues) {
      if (s.path && s.path[0]) {
        e.add(s.path[0]);
      }
    }
    const i = Array.from(e);
    return `Failed to validate keys: ${mm(i.join(", "), 100)}`;
  }
  function hL(t, e, i) {
    if (!e.exception || !e.exception.values || !i || !i.originalException || !cL(i.originalException) || i.originalException.issues.length === 0) {
      return e;
    } else {
      return {
        ...e,
        exception: {
          ...e.exception,
          values: [{
            ...e.exception.values[0],
            value: uL(i.originalException)
          }, ...e.exception.values.slice(1)]
        },
        extra: {
          ...e.extra,
          "zoderror.issues": i.originalException.errors.slice(0, t).map(lL)
        }
      };
    }
  }
  var u8;
  var h8;
  var d8;
  var dL;
  var fL = g({
    "out-build/external/sentry/core/integrations/zoderrors.js"() {
      "use strict";
  
      K();
      ai();
      u8 = 10;
      h8 = "ZodErrors";
      d8 = (t = {}) => {
        const e = t.limit || u8;
        return {
          name: h8,
          processEvent(i, s) {
            return hL(e, i, s);
          }
        };
      };
      dL = d8;
    }
  });
  function pL(t) {
    const e = Em(t);
    if (e) {
      return e.filter(i => !!i.filename).map(i => i.module_metadata ? Object.keys(i.module_metadata).filter(s => s.startsWith(zm)).map(s => s.slice(zm.length)) : []);
    }
  }
  var gL;
  var zm;
  var mL = g({
    "out-build/external/sentry/core/integrations/third-party-errors-filter.js"() {
      "use strict";
  
      K();
      ai();
      G9();
      gL = t => ({
        name: "ThirdPartyErrorsFilter",
        setup(e) {
          e.on("beforeEnvelope", i => {
            Am(i, (s, r) => {
              if (r === "event") {
                const n = Array.isArray(s) ? s[1] : undefined;
                if (n) {
                  V9(n);
                  s[1] = n;
                }
              }
            });
          });
          e.on("applyFrameMetadata", i => {
            if (i.type) {
              return;
            }
            const s = e.getOptions().stackParser;
            H9(s, i);
          });
        },
        processEvent(e) {
          const i = pL(e);
          if (i) {
            const s = t.behaviour === "drop-error-if-contains-third-party-frames" || t.behaviour === "apply-tag-if-contains-third-party-frames" ? "some" : "every";
            if (i[s](n => !n.some(o => t.filterKeys.includes(o)))) {
              if (t.behaviour === "drop-error-if-contains-third-party-frames" || t.behaviour === "drop-error-if-exclusively-contains-third-party-frames") {
                return null;
              }
              e.tags = {
                ...e.tags,
                third_party_code: true
              };
            }
          }
          return e;
        }
      });
      zm = "_sentryBundlerPluginAppKey:";
    }
  });
  var f8;
  var p8;
  var g8;
  var m8;
  var Hd = g({
    "out-build/external/sentry/core/metrics/constants.js"() {
      "use strict";
  
      f8 = "c";
      p8 = "g";
      g8 = "s";
      m8 = "d";
    }
  });
  var w8 = g({
    "out-build/external/sentry/core/metrics/exports.js"() {
      "use strict";
  
      K();
      st();
      Pt();
      oa();
      Mm();
      Zt();
      Hd();
    }
  });
  var wL = g({
    "out-build/external/sentry/core/profiling.js"() {
      "use strict";
  
      K();
      st();
      Pt();
    }
  });
  function vL(t) {
    let e = 0;
    for (let i = 0; i < t.length; i++) {
      const s = t.charCodeAt(i);
      e = (e << 5) - e + s;
      e &= e;
    }
    return e >>> 0;
  }
  var Vd = g({
    "out-build/external/sentry/core/metrics/utils.js"() {
      "use strict";
  
      K();
    }
  });
  var v8 = g({
    "out-build/external/sentry/core/metrics/envelope.js"() {
      "use strict";
  
      K();
      Vd();
    }
  });
  var b8;
  var y8;
  var S8;
  var E8;
  var bL;
  var k8 = g({
    "out-build/external/sentry/core/metrics/instance.js"() {
      "use strict";
  
      Hd();
      Vd();
      b8 = class {
        constructor(t) {
          this._value = t;
        }
        get weight() {
          return 1;
        }
        add(t) {
          this._value += t;
        }
        toString() {
          return `${this._value}`;
        }
      };
      y8 = class {
        constructor(t) {
          this._last = t;
          this._min = t;
          this._max = t;
          this._sum = t;
          this._count = 1;
        }
        get weight() {
          return 5;
        }
        add(t) {
          this._last = t;
          if (t < this._min) {
            this._min = t;
          }
          if (t > this._max) {
            this._max = t;
          }
          this._sum += t;
          this._count++;
        }
        toString() {
          return `${this._last}:${this._min}:${this._max}:${this._sum}:${this._count}`;
        }
      };
      S8 = class {
        constructor(t) {
          this._value = [t];
        }
        get weight() {
          return this._value.length;
        }
        add(t) {
          this._value.push(t);
        }
        toString() {
          return this._value.join(":");
        }
      };
      E8 = class {
        constructor(t) {
          this.first = t;
          this._value = new Set([t]);
        }
        get weight() {
          return this._value.size;
        }
        add(t) {
          this._value.add(t);
        }
        toString() {
          return Array.from(this._value).map(t => typeof t == "string" ? vL(t) : t).join(":");
        }
      };
      bL = {
        [f8]: b8,
        [p8]: y8,
        [m8]: S8,
        [g8]: E8
      };
    }
  });
  var yL = g({
    "out-build/external/sentry/core/metrics/aggregator.js"() {
      "use strict";
  
      K();
      Zt();
      Hd();
      v8();
      k8();
      Vd();
    }
  });
  var SL = g({
    "out-build/external/sentry/core/metrics/exports-default.js"() {
      "use strict";
  
      yL();
      w8();
    }
  });
  var EL = g({
    "out-build/external/sentry/core/metrics/browser-aggregator.js"() {
      "use strict";
  
      K();
      Zt();
      Hd();
      v8();
      k8();
      Vd();
    }
  });
  var kL = g({
    "out-build/external/sentry/core/fetch.js"() {
      "use strict";
  
      K();
      st();
      Ns();
      oa();
      Ud();
      ra();
      Zt();
    }
  });
  var xL = g({
    "out-build/external/sentry/core/trpc.js"() {
      "use strict";
  
      K();
      st();
      dl();
      Ns();
      oa();
    }
  });
  var DL = g({
    "out-build/external/sentry/core/feedback.js"() {
      "use strict";
  
      K();
      st();
    }
  });
  var PL = g({
    "out-build/external/sentry/core/getCurrentHubShim.js"() {
      "use strict";
  
      L9();
      st();
      dl();
    }
  });
  var $L = g({
    "out-build/external/sentry/core/index.js"() {
      "use strict";
  
      oa();
      Ns();
      Wm();
      dl();
      st();
      g9();
      ul();
      On();
      Wd();
      A9();
      ll();
      D9();
      jm();
      _9();
      hO();
      dO();
      fO();
      pO();
      gO();
      ai();
      P9();
      Tm();
      R9();
      ra();
      mO();
      Mm();
      wO();
      Zt();
      Nm();
      vO();
      O9();
      bO();
      Bd();
      L9();
      SO();
      OO();
      MO();
      TO();
      BO();
      HO();
      GO();
      XO();
      iL();
      nL();
      aL();
      fL();
      mL();
      w8();
      wL();
      SL();
      EL();
      Om();
      kL();
      xL();
      DL();
      PL();
      K();
    }
  });
  function x8(t) {
    let e;
    const i = [];
    let s;
    Am(t, (r, n) => {
      if (n === "event" || n === "transaction" || n === "feedback") {
        e = Array.isArray(r) ? r[1] : undefined;
      } else if (n === "attachment") {
        const [o, a] = r;
        i.push({
          filename: o.filename,
          attachmentType: o.attachment_type,
          contentType: o.content_type,
          data: a
        });
      } else if (n === "profile") {
        s = r[1];
      }
    });
    if (e) {
      return [e, i, s];
    } else {
      return undefined;
    }
  }
  var IL = g({
    "out-build/external/sentry/electron/common/envelope.js"() {
      "use strict";
  
      K();
    }
  });
  var Hm = g({
    "out-build/vs/platform/tracing/common/sentry.js"() {
      "use strict";
  
      $L();
      Ns();
      IL();
      Cm();
      ym();
      ol();
      e9();
    }
  });
  function AL(t, e) {
    return e.onProcessConfigUpdate(i => {
      qt().enabled = i.enabled;
      qt().loggerSampleRate = i.loggerSampleRate;
      qt().tracesSampleRate = i.tracesSampleRate;
      qt().profilesSampleRate = i.profilesSampleRate;
      qt().jsonStringifySampleRate = i.jsonStringifySampleRate;
    });
  }
  function CL(t, e, i = uR(64)) {
    const s = {
      flush: n => i.drain(n),
      send: n => i.add(() => e.sendEnvelope(t, n)).then(o => ({
        statusCode: 200
      }), o => {
        if (o instanceof bm) {
          return {};
        }
        throw o;
      })
    };
    const r = qt().buffer;
    for (const n of r) {
      s.send(n);
    }
    qt().buffer = [];
    qt().transport = s;
    return T.None;
  }
  function _L(t, e) {
    if (t === "main") {
      return T.None;
    }
    const i = s => {
      const r = {};
      if (s.breadcrumbs.length > 0) {
        r.breadcrumbs = s.breadcrumbs;
      }
      if (Object.keys(r).length > 0) {
        e.sendScopeUpdate(t, r);
      }
    };
    Wr().addScopeListener(s => {
      i(s.getScopeData());
      Wr().clearBreadcrumbs();
    });
    i(Wr().getScopeData());
    Wr().clearBreadcrumbs();
    return T.None;
  }
  function RL(t, e) {
    const i = new De();
    i.add(AL(t, e));
    i.add(CL(t, e));
    i.add(_L(t, e));
    return i;
  }
  var OL = g({
    "out-build/vs/platform/tracing/common/register.js"() {
      "use strict";
  
      M();
      va();
      Hm();
    }
  });
  var D8;
  var LL = g({
    "out-build/vs/platform/tracing/node/rateLimiter.js"() {
      "use strict";
  
      D8 = class {
        constructor(t) {
          this.c = t;
          this.a = new Map();
          this.b = this.d();
        }
        increment(t, e = 1) {
          const i = this.d();
          if (i !== this.b) {
            this.a.clear();
            this.b = i;
          }
          const r = (this.a.get(t) ?? 0) + e;
          this.a.set(t, r);
          return r;
        }
        d() {
          return Math.floor(Date.now() / this.c);
        }
      };
    }
  });
  import { app as ML, webContents as Vm } from "electron";
  import ci from "fs";
  import FL from "node-fetch";
  import { tmpdir as P8 } from "os";
  import Fn from "path";
  var fl;
  var Gd;
  var NL = g({
    "out-build/vs/platform/tracing/electron-main/tracingService.js"() {
      "use strict";
  
      B();
      M();
      $i();
      Ri();
      X();
      ht();
      Lt();
      va();
      OL();
      Hm();
      LL();
      Gd = class extends T {
        static {
          fl = this;
        }
        static {
          this.a = {
            errorRateLimit: 10,
            jsonStringifySampleRate: 0,
            loggerSampleRate: 1,
            minidumpSampleRate: 1,
            performanceUnitRateLimit: 100,
            profilesSampleRate: 0,
            tracesSampleRate: 0.01,
            globalSampleRate: 1
          };
        }
        static {
          this.b = 64;
        }
        static {
          this.c = 128;
        }
        constructor(e, i, s, r) {
          super();
          this.y = e;
          this.z = i;
          this.C = s;
          this.F = r;
          this.f = [];
          this.g = {
            ...fl.a
          };
          this.h = null;
          this.j = null;
          this.m = null;
          this.n = null;
          this.q = null;
          this.r = new Map();
          this.s = [];
          this.t = new Da(100);
          this.u = new D8(60000);
          this.w = new $();
          this.onProcessConfigUpdate = this.w.event;
          this.H().then(() => this.D(RL("main", this))).catch(n => this.z.error("TracingService: failed to initialize transport", n));
        }
        async captureAndSendDebuggingData(e, i) {
          const s = i.uploadUrl ?? this.h;
          if (s === null || s === "") {
            this.z.warn("TracingService: no upload url found");
            return;
          }
          const r = (await import("archiver")).default;
          const n = P8();
          const o = i.rendererHeapSnapshotFile ?? Fn.join(n, `renderer-${e}-${Date.now()}.heapsnapshot`);
          if (i.rendererHeapSnapshotFile === undefined && this.j === false) {
            const l = Vm.getAllWebContents().filter(u => u.getOSProcessId() === e)[0];
            if (l !== undefined) {
              try {
                this.z.info("TracingService: taking heap snapshot");
                await l.takeHeapSnapshot(o);
              } catch (u) {
                this.z.warn("TracingService: failed to take heap snapshot", u);
              }
            }
          }
          const a = Fn.join(n, `metadata-${Date.now()}.json`);
          this.z.info("TracingService: writing metadata file");
          try {
            await ci.promises.writeFile(a, JSON.stringify({
              debuggerEvent: i.debuggerEvent,
              debuggerScripts: i.debuggerScripts,
              heapStatistics: i.rendererHeapStatistics,
              sentryTraceId: this.j === false ? Mn().getPropagationContext().traceId : undefined,
              version: this.C.version,
              workspaceId: this.j === false ? i.workspaceId : undefined
            }, null, 2));
          } catch (l) {
            this.z.warn("TracingService: failed to write metadata file", l);
          }
          const c = Fn.join(n, `debugging-data-${Date.now()}.zip`);
          try {
            this.z.info("TracingService: creating debugging data zip");
            await new Promise((l, u) => {
              const d = r("zip");
              const f = ci.createWriteStream(c);
              f.on("close", () => l());
              d.on("error", y => u(y));
              d.pipe(f);
              if (this.j === false && ci.existsSync(o)) {
                d.file(o, {
                  name: "snapshots/renderer.heapsnapshot"
                });
              }
              const p = ML.getPath("userData");
              const w = Fn.join(p, "logs");
              if (ci.existsSync(w)) {
                const y = ci.readdirSync(w).sort().pop();
                if (y !== undefined) {
                  d.directory(Fn.join(w, y), "logs");
                }
              }
              const m = Fn.join(p, "User");
              if (this.j === false && ci.existsSync(m)) {
                d.directory(m, "user");
              }
              if (ci.existsSync(a)) {
                d.file(a, {
                  name: "metadata.json"
                });
              }
              d.finalize();
            });
          } catch (l) {
            this.z.warn("TracingService: failed to create debugging data zip", l);
          }
          try {
            this.z.info("TracingService: uploading debugging data");
            const l = ci.createReadStream(c);
            if ((await FL(s, {
              method: "PUT",
              body: l,
              headers: {
                "Content-Length": ci.statSync(c).size.toString()
              }
            })).ok) {
              this.z.info("TracingService: successfully uploaded debugging data");
            }
          } catch (l) {
            this.z.warn("TracingService: failed to upload debugging data", l);
          }
          if (ci.existsSync(o)) {
            await ci.promises.unlink(o);
          }
          if (ci.existsSync(c)) {
            await ci.promises.unlink(c);
          }
          if (ci.existsSync(a)) {
            await ci.promises.unlink(a);
          }
        }
        getIsWatchingForCrashes() {
          return Promise.resolve(this.r.size > 0);
        }
        async sendEnvelope(e, i) {
          if (this.j === null) {
            if (this.f.length < fl.b) {
              this.f.push([e, i]);
            }
            return;
          }
          if (e === "main") {
            return this.J(i);
          } else {
            return this.I(e, i);
          }
        }
        async sendScopeUpdate(e, i) {
          if (e === "main") {
            this.z.warn("TracingService: unexpected scope update from main");
            return;
          }
          const s = Wr();
          if (i.breadcrumbs !== undefined) {
            i.breadcrumbs.forEach(r => s?.addBreadcrumb(r));
          }
        }
        async setClientTracingConfig(e) {
          this.g = {
            globalSampleRate: Math.min(1, Math.max(0, e.globalSampleRate)),
            tracesSampleRate: Math.min(1, Math.max(0, e.tracesSampleRate)),
            loggerSampleRate: Math.min(1, Math.max(0, e.loggerSampleRate)),
            minidumpSampleRate: Math.min(1, Math.max(0, e.minidumpSampleRate)),
            errorRateLimit: Math.max(0, e.errorRateLimit),
            performanceUnitRateLimit: Math.max(0, e.performanceUnitRateLimit),
            profilesSampleRate: Math.min(1, Math.max(0, e.profilesSampleRate)),
            jsonStringifySampleRate: Math.min(1, Math.max(0, e.jsonStringifySampleRate))
          };
          this.z.debug(`TracingService: set client tracing config to ${JSON.stringify(this.g)}`);
          this.G();
        }
        async setDebuggingDataUploadUrl(e) {
          this.h = e;
        }
        async setIsPrivacyMode(e) {
          const i = this.j;
          this.j = e;
          if (this.f.length > 0) {
            this.z.debug(`TracingService: flushing buffer with ${this.f.length} items`);
            this.f.forEach(([s, r]) => this.sendEnvelope(s, r));
            this.f = [];
          }
          if (i !== this.j) {
            this.z.debug(`TracingService: set is privacy mode to ${e}`);
            this.G();
          }
        }
        async setUser(e, i) {
          const s = this.n;
          const r = this.q;
          this.n = e;
          this.q = i;
          if (this.n !== null || this.q !== null) {
            Wr().setUser({
              email: this.n ?? undefined,
              id: this.q ?? undefined
            });
          } else {
            Wr().setUser(null);
          }
          if (s !== this.n || r !== this.q) {
            this.z.debug(`TracingService: set user to ${JSON.stringify(Wr()?.getUser())}`);
          }
        }
        async toggleWatchForCrashes() {
          if (this.r.size > 0) {
            this.U();
            return false;
          } else {
            this.S();
            return true;
          }
        }
        G() {
          const e = {
            enabled: this.j !== true ? this.g.globalSampleRate > 0 : false,
            loggerSampleRate: this.j !== true ? this.g.loggerSampleRate : 0,
            tracesSampleRate: this.j !== true ? this.g.tracesSampleRate : 0,
            profilesSampleRate: this.j !== true ? this.g.profilesSampleRate : 0,
            jsonStringifySampleRate: this.j !== true ? this.g.jsonStringifySampleRate : 0
          };
          this.w.fire(e);
          this.z.debug(`TracingService: fired process config update ${JSON.stringify(e)}`);
        }
        async H() {
          if (this.m !== null) {
            return;
          }
          const e = hl()?.getDsn();
          if (e === undefined) {
            this.z.warn("TracingService: no dsn found");
            return;
          }
          const i = qt().sentry.makeElectronOfflineTransport;
          if (i === undefined || typeof i != "function") {
            this.z.warn("TracingService: transport constructor is not available");
            return;
          }
          this.m = i()({
            bufferSize: fl.c,
            url: uO(e, hl()?.getOptions().tunnel, hl()?.getSdkMetadata()?.sdk),
            recordDroppedEvent: (s, r) => {
              this.z.debug(`TracingService: dropped ${r} event due to ${s}`);
            }
          });
          this.z.debug("TracingService: created transport");
        }
        I(e, i) {
          const s = x8(i);
          if (s === undefined) {
            this.z.warn("TracingService: dropping unsupported envelope");
            return;
          }
          const [r, n, o] = s;
          delete r.environment;
          delete r.sdk?.name;
          delete r.sdk?.version;
          delete r.sdk?.packages;
          r.tags = {
            ...r.tags,
            "event.process": e
          };
          if (r.event_id !== undefined && o !== undefined) {
            this.t.set(r.event_id, o);
          }
          Mn()?.captureEvent(r, {
            attachments: n
          });
        }
        J(e) {
          const i = x8(e);
          if (i === undefined) {
            return this.P(e);
          }
          const [s, r] = i;
          if (this.L(s, r)) {
            return;
          }
          const n = s.tags?.["event.process"];
          if (n === undefined || n === "browser") {
            s.tags = {
              ...s.tags,
              "event.process": "main"
            };
          }
          if (s.event_id !== undefined) {
            const o = this.t.get(s.event_id);
            if (o !== undefined) {
              this.t.remove(s.event_id);
              e = IR(e, [{
                type: "profile"
              }, o]);
            }
          }
          this.P(e);
        }
        L(e, i) {
          if (this.j !== false && !i.some(s => s.attachmentType === "event.minidump") && this.C.applicationName !== "cursor-nightly") {
            return true;
          }
          if (e.exception?.values !== undefined) {
            for (const s of e.exception.values) {
              if (this.M(s)) {
                return true;
              }
            }
          }
          for (const s of i) {
            if (this.N(s)) {
              return true;
            }
          }
          return this.O(e);
        }
        M(e) {
          return false;
        }
        N(e) {
          if (e.attachmentType === "event.minidump") {
            return Math.random() >= this.g.minidumpSampleRate;
          } else {
            return false;
          }
        }
        O(e) {
          const i = this.g.errorRateLimit;
          const s = this.g.performanceUnitRateLimit;
          if (e.type === "transaction") {
            return this.u.increment("performanceUnit", 1) > s;
          } else {
            return this.u.increment("error", 1) > i;
          }
        }
        P(e) {
          if (this.j !== false) {
            return;
          }
          const i = this.g.globalSampleRate;
          if (i <= 0 || i < 1 && Math.random() >= i) {
            this.z.debug("TracingService: dropping envelope due to global sample rate");
            return;
          }
          this.m?.send(e);
        }
        async Q(e) {
          const i = Vm.fromId(e);
          if (i === undefined || i.getType() !== "window") {
            return;
          }
          const s = i.debugger;
          if (s.isAttached()) {
            return;
          }
          const r = [];
          this.r.set(i.id, r);
          this.z.debug(`TracingService: watching renderer process ${e}`);
          const n = i.getOSProcessId();
          const o = Fn.join(P8(), `renderer-${n}-${Date.now()}.heapsnapshot`);
          const a = [];
          const c = f => {
            if (f.reason !== "OOM") {
              this.z.debug("TracingService: ignoring non-OOM debugger pause", f);
              if (!i.isDevToolsOpened()) {
                s.sendCommand("Debugger.resume").catch(() => {});
              }
              return;
            }
            this.z.info("TracingService: paused renderer before crash");
            if (this.j !== false) {
              this.captureAndSendDebuggingData(i.getOSProcessId(), {
                debuggerEvent: f,
                debuggerScripts: a
              }).catch(() => {});
              return;
            }
            this.z.info("TracingService: taking heap snapshot");
            s.sendCommand("HeapProfiler.takeHeapSnapshot").catch(() => {}).finally(() => {
              if (!i.isDevToolsOpened()) {
                s.sendCommand("Debugger.resume").catch(() => {});
              }
              setTimeout(() => {
                this.captureAndSendDebuggingData(i.getOSProcessId(), {
                  debuggerEvent: f,
                  debuggerScripts: a,
                  rendererHeapSnapshotFile: o
                }).catch(() => {});
              }, 1000);
            });
          };
          const l = f => {
            a.push({
              scriptId: f?.scriptId,
              url: f?.url
            });
          };
          const u = f => {
            ci.appendFileSync(o, f.chunk);
          };
          s.attach();
          r.push({
            dispose: () => s.detach()
          });
          this.z.debug(`TracingService: attached to renderer process ${e}`);
          const d = (f, p, w) => {
            switch (p) {
              case "Debugger.paused":
                c(w);
                break;
              case "Debugger.scriptParsed":
                l(w);
                break;
              case "HeapProfiler.addHeapSnapshotChunk":
                u(w);
                break;
            }
          };
          s.on("message", d);
          r.push({
            dispose: () => s.removeListener("message", d)
          });
          await s.sendCommand("Debugger.enable");
          await s.sendCommand("Debugger.setPauseOnExceptions", {
            state: "none"
          });
          r.push({
            dispose: () => s.sendCommand("Debugger.disable").catch(() => {})
          });
          this.z.debug(`TracingService: enabled debugger for renderer process ${e}`);
        }
        async R(e) {
          const i = this.r.get(e);
          if (i !== undefined) {
            while (i.length > 0) {
              i.pop()?.dispose();
            }
            this.r.delete(e);
            this.z.debug(`TracingService: unwatching renderer process ${e}`);
          }
        }
        S() {
          this.s.push(this.F.onDidChangeWindowsCount(() => {
            const e = new Set(this.F.getWindows().map(i => i.id));
            for (const i of [...this.r.keys()]) {
              if (!e.has(i)) {
                this.R(i).catch(() => {});
              }
            }
            for (const i of e) {
              if (!this.r.has(i)) {
                this.Q(i).catch(() => {});
              }
            }
          }));
          this.F.getWindows().forEach(e => {
            this.Q(e.id).catch(() => {});
          });
        }
        U() {
          this.s.forEach(e => e.dispose());
          this.s = [];
          for (const e of [...this.r.keys()]) {
            this.R(e).catch(() => {});
          }
        }
        async attemptGarbageCollection(e) {
          const i = Vm.getAllWebContents().find(r => r.getOSProcessId() === e);
          if (!i) {
            this.z.warn(`[TracingService] attemptGarbageCollection: Could not find webContents for pid ${e}`);
            return;
          }
          const s = i.debugger;
          if (!s.isAttached()) {
            this.z.trace(`[TracingService] attemptGarbageCollection: Debugger not attached for pid ${e}, cannot trigger GC.`);
            return;
          }
          try {
            this.z.trace(`[TracingService] attemptGarbageCollection: Sending HeapProfiler.collectGarbage command to pid ${e}`);
            await s.sendCommand("HeapProfiler.collectGarbage");
            this.z.trace(`[TracingService] attemptGarbageCollection: Command sent successfully for pid ${e}`);
          } catch (r) {
            this.z.warn(`[TracingService] attemptGarbageCollection: Error sending command for pid ${e}:`, r);
          }
        }
      };
      Gd = fl = __decorate([__param(0, Yi), __param(1, V), __param(2, Ve), __param(3, dt)], Gd);
    }
  });
  var Gm;
  var WL = g({
    "out-build/vs/platform/tracing/common/tracingService.js"() {
      "use strict";
  
      Y();
      Gm = q("tracingService");
    }
  });
  var Jm;
  var TL = g({
    "out-build/vs/platform/abuse/common/abuseService.js"() {
      "use strict";
  
      Y();
      Jm = q("abuseService");
    }
  });
  var Jd;
  var jL = g({
    "out-build/vs/platform/abuse/node/abuseService.js"() {
      "use strict";
  
      _c();
      xt();
      Jd = class {
        constructor(e) {
          this.c = e;
          this.d().then(i => this.a = i).catch(() => {});
          this.e().then(i => this.b = i).catch(() => {});
        }
        async getMachineId() {
          return this.a ?? this.c.machineId;
        }
        async getMacMachineId() {
          return this.b ?? this.c.macMachineId;
        }
        async d() {
          let e;
          try {
            e = await P2(true);
          } catch {
            return;
          }
          try {
            return (await import("crypto")).createHash("sha256").update(e, "utf8").digest("hex");
          } catch {
            return;
          }
        }
        async e() {
          return D2(() => {});
        }
      };
      Jd = __decorate([__param(0, Ot)], Jd);
    }
  });
  var $8;
  var Kd;
  var UL = g({
    "out-build/vs/platform/extensionManagement/node/extensionSignatureVerificationService.js"() {
      "use strict";
  
      $e();
      Y();
      X();
      xt();
      Vu();
      $8 = q("IExtensionSignatureVerificationService");
      Kd = class {
        constructor(e, i) {
          this.b = e;
          this.c = i;
        }
        d() {
          this.a ||= this.f();
          return this.a;
        }
        async f() {
          return import("@vscode/vsce-sign");
        }
        async verify(e, i, s, r, n) {
          let o;
          try {
            o = await this.d();
          } catch (u) {
            this.b.error("Could not load vsce-sign module", Vi(u));
            this.b.info(`Extension signature verification is not done: ${e}`);
            return;
          }
          const a = new Date().getTime();
          let c;
          try {
            this.b.trace(`Verifying extension signature for ${e}...`);
            c = await o.verify(s, r, this.b.getLevel() === J.Trace);
          } catch (u) {
            c = {
              code: $1.UnknownError,
              didExecute: false,
              output: Vi(u)
            };
          }
          const l = new Date().getTime() - a;
          this.b.info(`Extension signature verification result for ${e}: ${c.code}. Executed: ${c.didExecute}. Duration: ${l}ms.`);
          this.b.trace(`Extension signature verification output for ${e}:
  ${c.output}`);
          this.c.publicLog2("extensionsignature:verification", {
            extensionId: e,
            extensionVersion: i,
            code: c.code,
            internalCode: c.internalCode,
            duration: l,
            didExecute: c.didExecute,
            clientTargetPlatform: n
          });
          return {
            code: c.code
          };
        }
      };
      Kd = __decorate([__param(0, V), __param(1, Ot)], Kd);
    }
  });
  import aa from "fs";
  import { tmpdir as BL } from "os";
  import Km from "path";
  import { createGzip as qL } from "zlib";
  var I8;
  var Zd;
  var zL = g({
    "out-build/vs/platform/continuousProfiling/electron-main/continuousProfilingService.js"() {
      "use strict";
  
      B();
      M();
      _i();
      Ri();
      X();
      ht();
      Lt();
      Wg();
      I8 = class {
        constructor(t, e, i, s, r, n) {
          this.captureId = t;
          this.targetId = e;
          this.profileTypes = i;
          this.processType = s;
          this.startTime = Date.now();
          this.duration = r;
          this.profileConfig = n;
        }
        hasConflictWith(t, e) {
          if (this.targetId !== t) {
            return false;
          } else {
            return e.some(i => this.profileTypes.includes(i));
          }
        }
        getDescription() {
          return `Profile ${this.captureId} (target: ${this.targetId}, types: ${this.profileTypes.join(", ")}, duration: ${this.duration}s)`;
        }
      };
      Zd = class extends T {
        constructor(e, i, s, r) {
          super();
          this.f = e;
          this.g = i;
          this.h = s;
          this.j = r;
          this.a = false;
          this.b = new Map();
          this.c = new $();
          this.onProfileCaptureStatusChange = this.c.event;
          this.g.debug("ContinuousProfilingMainService: initialized in main process");
        }
        async captureProfile(e) {
          if (this.a) {
            this.g.debug("ContinuousProfilingMainService: skipping profile capture due to privacy mode");
            return "";
          }
          const i = this.m(e.profileConfig);
          if (i.length === 0) {
            this.g.warn(`ContinuousProfilingMainService: No profile types (CPU or Heap) configured for capture. (captureId: ${e.captureId})`);
            return "";
          }
          const s = e.captureId ?? ti();
          let r;
          let n;
          let o;
          try {
            if (e.processType === "renderer") {
              if (typeof e.windowId != "number") {
                throw new Error("windowId must be provided for renderer profiling");
              }
              const u = this.j.getWindowById(e.windowId);
              if (!u?.win?.webContents) {
                throw new Error(`Could not find webContents for windowId ${e.windowId}`);
              }
              r = u.win.webContents;
              n = r.id;
              o = u.remoteAuthority ? Bh(u.remoteAuthority) : undefined;
            } else {
              throw e.processType === "main" ? new Error("Main process profiling not yet implemented") : new Error(`Unknown process type: ${e.processType}`);
            }
            if (!r || typeof n != "number") {
              throw new Error("Target webContents could not be determined.");
            }
            let a = false;
            if (r.debugger.isAttached()) {
              this.g.debug(`ContinuousProfilingMainService: Debugger already attached to target ${n}. Reusing existing attachment for capture ${s}.`);
              a = false;
            } else {
              try {
                r.debugger.attach("1.3");
                a = true;
                this.g.debug(`ContinuousProfilingMainService: Successfully attached debugger to target ${n} for capture ${s}.`);
              } catch (u) {
                const d = `Failed to attach debugger to target ${n} for capture ${s}. Error: ${u.message}`;
                this.g.debug(`ContinuousProfilingMainService: ${d}`);
                this.c.fire({
                  state: "error",
                  captureId: s,
                  error: d,
                  cause: "DEBUGGER_ATTACH_FAILED"
                });
                return "";
              }
            }
            this.g.debug(`ContinuousProfilingMainService: starting profile capture ${s} (types: ${i.join(", ")}, targetId: ${n}, duration: ${e.duration}s)`);
            const c = new I8(s, n, i, e.processType, e.duration, e.profileConfig);
            this.b.set(s, c);
            this.g.debug(`ContinuousProfilingMainService: Created session for ${c.getDescription()}`);
            const l = {
              state: "started",
              captureId: s
            };
            this.c.fire(l);
            e._internals = {
              didAttachDebugger: a
            };
            await this.n(s, r, e, o);
            return s;
          } catch (a) {
            this.g.debug(`ContinuousProfilingMainService: failed to capture profile ${s}`, a);
            const c = {
              state: "error",
              captureId: s,
              error: String(a)
            };
            this.c.fire(c);
            this.r(s);
            if (r?.debugger.isAttached()) {
              try {
                r.debugger.detach();
              } catch {}
            }
            return s;
          }
        }
        async setIsPrivacyMode(e) {
          this.a = e;
          this.g.debug(`ContinuousProfilingMainService: set privacy mode to ${e}`);
        }
        async cancelProfile(e, i = "Canceled by user or configuration change") {
          const s = this.b.get(e);
          if (!s) {
            this.g.debug(`ContinuousProfilingMainService: No active profile found for ID ${e} during cancellation`);
            return;
          }
          this.g.debug(`ContinuousProfilingMainService: Canceling ${s.getDescription()} with reason: ${i}`);
          let r = false;
          const n = this.j.getWindows().flatMap(c => c.win?.webContents).find(c => c && !c.isDestroyed() && c.id === s.targetId);
          if (n && n.debugger.isAttached()) {
            try {
              n.debugger.detach();
              r = true;
              this.g.debug(`ContinuousProfilingMainService: Detached debugger during cancel for session ${e}.`);
            } catch (c) {
              this.g.warn(`ContinuousProfilingMainService: Failed to detach debugger during cancel for session ${e}`, c);
            }
          } else {
            this.g.debug(`ContinuousProfilingMainService: Target webContents ${s.targetId} not found or debugger not attached during cancel for session ${e}.`);
          }
          const o = this.r(e);
          this.g.debug(`ContinuousProfilingMainService: Session entry for ${e} removed during cancel: ${o}. Debugger detached: ${r}.`);
          const a = {
            state: "canceled",
            captureId: e,
            reason: i
          };
          this.c.fire(a);
        }
        async cancelAllProfiles() {
          const e = Array.from(this.b.values());
          if (e.length !== 0) {
            this.g.debug(`ContinuousProfilingMainService: Canceling all ${e.length} active profiles`);
            for (const i of e) {
              await this.cancelProfile(i.captureId);
            }
          }
        }
        m(e) {
          const i = [];
          if (e.cpu) {
            i.push("cpu");
          }
          if (e.heap) {
            i.push("heap");
          }
          return i;
        }
        async n(e, i, s, r) {
          const n = i.id;
          const o = this.b.get(e);
          const a = s._internals?.didAttachDebugger ?? false;
          if (!o) {
            this.g.warn(`ContinuousProfilingMainService: No session found for ${e} at start of _captureAndCompressProfile. Attempting cleanup.`);
            if (a && i.debugger.isAttached()) {
              try {
                i.debugger.detach();
              } catch (u) {
                this.g.warn(`Cleanup detach failed: ${u}`);
              }
            }
            return;
          }
          const c = Km.join(BL(), `vscode-profile-${e}`);
          const l = [];
          try {
            await aa.promises.mkdir(c, {
              recursive: true
            });
            if (o.profileConfig.cpu) {
              const d = Km.join(c, "profile.cpuprofile");
              await i.debugger.sendCommand("Profiler.enable");
              const f = o.profileConfig.cpu.interval ?? 1000;
              await i.debugger.sendCommand("Profiler.setSamplingInterval", {
                interval: f
              });
              await i.debugger.sendCommand("Profiler.start");
              this.g.debug(`ContinuousProfilingMainService: CPU Profiler started on wc ${i.id}, duration ${o.duration}s`);
              l.push({
                type: "cpu",
                file: d
              });
            }
            if (o.profileConfig.heap) {
              const d = Km.join(c, "profile.heapprofile");
              await i.debugger.sendCommand("HeapProfiler.enable");
              const f = o.profileConfig.heap.samplingInterval ?? 32768;
              const p = o.profileConfig.heap.includeObjectsCollectedByMajorGC ?? false;
              const w = o.profileConfig.heap.includeObjectsCollectedByMinorGC ?? false;
              await i.debugger.sendCommand("HeapProfiler.startSampling", {
                samplingInterval: f,
                includeObjectsCollectedByMajorGC: p,
                includeObjectsCollectedByMinorGC: w
              });
              this.g.debug(`ContinuousProfilingMainService: Heap Profiler started on wc ${i.id}, duration ${o.duration}s, samplingInterval: ${f}`);
              l.push({
                type: "heap",
                file: d
              });
            }
            if (l.length === 0) {
              throw new Error("No profile types configured for capture");
            }
            await new Promise(d => setTimeout(d, o.duration * 1000));
            if (i.isDestroyed()) {
              this.g.warn(`ContinuousProfilingMainService: Target webContents ${n} destroyed before profile ${e} could be stopped/saved.`);
            } else {
              for (const d of l) {
                if (d.type === "cpu") {
                  try {
                    const f = await i.debugger.sendCommand("Profiler.stop");
                    await i.debugger.sendCommand("Profiler.disable");
                    this.g.debug(`ContinuousProfilingMainService: CPU Profiler stopped on wc ${n}`);
                    await aa.promises.writeFile(d.file, JSON.stringify(f.profile));
                    this.g.debug(`ContinuousProfilingMainService: CPU Profile saved to ${d.file}`);
                  } catch (f) {
                    this.g.error(`ContinuousProfilingMainService: Error stopping/saving CPU profile for ${e}`, f);
                  }
                } else if (d.type === "heap") {
                  try {
                    const f = await i.debugger.sendCommand("HeapProfiler.stopSampling");
                    await i.debugger.sendCommand("HeapProfiler.disable");
                    this.g.debug(`ContinuousProfilingMainService: Heap Profiler stopped on wc ${n}`);
                    await aa.promises.writeFile(d.file, JSON.stringify(f.profile));
                    this.g.debug(`ContinuousProfilingMainService: Heap Profile saved to ${d.file}`);
                  } catch (f) {
                    this.g.error(`ContinuousProfilingMainService: Error stopping/saving Heap profile for ${e}`, f);
                  }
                }
              }
            }
            const u = [];
            for (const d of l) {
              try {
                if (await aa.promises.stat(d.file)) {
                  const f = `${d.file}.gz`;
                  await this.q(d.file, f);
                  this.g.debug(`ContinuousProfilingMainService: Profile compressed to ${f}`);
                  u.push(f);
                } else {
                  this.g.warn(`ContinuousProfilingMainService: Raw profile file ${d.file} not found for compression.`);
                }
              } catch (f) {
                if (f.code !== "ENOENT") {
                  this.g.error(`ContinuousProfilingMainService: Error compressing profile file ${d.file}`, f);
                }
              }
            }
            for (const d of u) {
              const f = {
                state: "completed",
                captureId: e,
                filePath: d,
                timestamp: Date.now(),
                duration: o.duration * 1000,
                profileConfig: o.profileConfig,
                bcId: r
              };
              this.c.fire(f);
            }
          } catch (u) {
            this.g.debug(`ContinuousProfilingMainService: Error during profile capture ${e}`, u);
            const d = {
              state: "error",
              captureId: e,
              error: String(u)
            };
            this.c.fire(d);
          } finally {
            this.g.debug(`ContinuousProfilingMainService: Entering finally block for capture ${e}. Attempting cleanup.`);
            let u = false;
            if (a && !i.isDestroyed() && i.debugger.isAttached()) {
              try {
                i.debugger.detach();
                u = true;
                this.g.debug(`ContinuousProfilingMainService: Detached debugger during cleanup for capture ${e}.`);
              } catch (d) {
                this.g.debug(`ContinuousProfilingMainService: Error during cleanup for capture ${e}`, d);
              }
            }
          }
        }
        async q(e, i) {
          return new Promise((s, r) => {
            const n = qL();
            const o = aa.createReadStream(e);
            const a = aa.createWriteStream(i);
            o.pipe(n).pipe(a);
            a.on("finish", () => {
              s();
            });
            a.on("error", c => {
              r(c);
            });
          });
        }
        r(e) {
          const i = this.b.get(e);
          if (i) {
            const s = this.b.delete(e);
            if (s) {
              this.g.debug(`ContinuousProfilingMainService: Successfully ended session for ${i.getDescription()}`);
            } else {
              this.g.warn(`ContinuousProfilingMainService: Failed to delete session entry for ${e} after finding it.`);
            }
            return s;
          } else {
            this.g.debug(`ContinuousProfilingMainService: No active session found for ${e} during _endSession.`);
            return false;
          }
        }
        dispose() {
          this.cancelAllProfiles();
          super.dispose();
        }
      };
      Zd = __decorate([__param(0, Yi), __param(1, V), __param(2, Ve), __param(3, dt)], Zd);
    }
  });
  function HL(t, e, i, s) {
    try {
      const r = t.get(ot);
      const n = t.get(V);
      const o = t.get(Ve);
      const a = t.get(dt);
      const c = new Zd(r, n, o, a);
      const l = ze.fromService(c, s);
      e.registerChannel("continuousProfiling", l);
      i.then(u => {
        u.registerChannel("continuousProfiling", l);
      });
    } catch (r) {
      console.error("Failed to initialize continuous profiling service:", r);
    }
  }
  var VL = g({
    "out-build/vs/platform/continuousProfiling/electron-main/initializeMain.js"() {
      "use strict";
  
      xs();
      zL();
      vt();
      X();
      ht();
      Lt();
    }
  });
  import { app as Nn, BrowserWindow as GL, protocol as A8, session as ca, systemPreferences as C8 } from "electron";
  import { hostname as JL, release as KL } from "os";
  var Zm;
  var Yd;
  var ZL = g({
    "out-build/vs/code/electron-main/app.js"() {
      "use strict";
  
      wa();
      as();
      Ze();
      en();
      $e();
      B();
      F0();
      Sr();
      M();
      Ie();
      we();
      H();
      _e();
      se();
      _i();
      rx();
      xs();
      ox();
      zb();
      H4();
      be();
      wc();
      wD();
      Ke();
      SD();
      K1();
      y5();
      wn();
      Kb();
      eP();
      vt();
      kc();
      cg();
      yP();
      SP();
      EP();
      PP();
      jP();
      He();
      u$();
      kg();
      Ah();
      Y();
      xg();
      h$();
      Z$();
      Y$();
      Q$();
      ct();
      X();
      rI();
      Nc();
      ht();
      Sc();
      mI();
      Hg();
      Ti();
      bI();
      eh();
      X2();
      xt();
      yI();
      EI();
      $n();
      Lr();
      kI();
      $I();
      AI();
      OI();
      jI();
      T2();
      UI();
      BI();
      qI();
      zI();
      JI();
      fn();
      Lt();
      hA();
      dA();
      ri();
      sg();
      zh();
      fA();
      vn();
      Ls();
      pA();
      un();
      fd();
      G6();
      wC();
      vC();
      bC();
      ce();
      AC();
      CC();
      _C();
      zc();
      RC();
      OC();
      p7();
      NC();
      f_();
      p_();
      Ta();
      Mh();
      b_();
      ou();
      Cc();
      NL();
      WL();
      TL();
      jL();
      UL();
      VL();
      Yd = class extends T {
        static {
          Zm = this;
        }
        static {
          this.a = {
            [R.file]: "security.promptForLocalFileProtocolHandling",
            [R.vscodeRemote]: "security.promptForRemoteFileProtocolHandling"
          };
        }
        constructor(e, i, s, r, n, o, a, c, l, u, d, f) {
          super();
          this.g = e;
          this.h = i;
          this.j = s;
          this.m = r;
          this.n = n;
          this.q = o;
          this.s = a;
          this.t = c;
          this.u = l;
          this.w = u;
          this.y = d;
          this.z = f;
          this.C();
          this.F();
        }
        C() {
          const e = f => f?.startsWith(`${R.vscodeFileResource}://${za}`);
          const i = f => f?.startsWith(`${R.vscodeWebview}://`);
          const s = new Set(["pointerLock"]);
          const r = new Set([...s, "clipboard-read", "clipboard-sanitized-write", "deprecated-sync-clipboard-read"]);
          const n = new Set([...s, "media", "local-fonts", "deprecated-sync-clipboard-read"]);
          ca.defaultSession.setPermissionRequestHandler((f, p, w, m) => i(m.requestingUrl) ? w(r.has(p)) : e(m.requestingUrl) ? w(n.has(p)) : w(false));
          ca.defaultSession.setPermissionCheckHandler((f, p, w, m) => i(m.requestingUrl) ? r.has(p) : e(m.requestingUrl) ? n.has(p) : false);
          const o = new Set([R.file, R.vscodeFileResource, R.vscodeRemoteResource, R.vscodeManagedRemoteResource, "devtools"]);
          const a = f => {
            for (let p = f; p; p = p.parent) {
              if (p.url.startsWith(`${R.vscodeWebview}://`)) {
                return true;
              }
            }
            return false;
          };
          const c = f => f.resourceType === "xhr" || a(f.frame);
          const l = f => {
            const p = f.frame;
            if (!p || !this.b) {
              return false;
            }
            const w = GL.getAllWindows();
            for (const y of w) {
              if (p.processId === y.webContents.mainFrame.processId) {
                return true;
              }
            }
            const m = this.b.getWindows();
            for (const y of m) {
              const b = y.webContents;
              if (b !== undefined && p.processId === b.mainFrame.processId) {
                return true;
              }
            }
            return false;
          };
          const u = (f, p) => {
            if (f.path !== "/index.html") {
              return true;
            }
            const w = p.frame;
            if (!w || !this.b) {
              return false;
            }
            for (const m of this.b.getWindows()) {
              if (m.win && w.processId === m.win.webContents.mainFrame.processId) {
                return true;
              }
            }
            return false;
          };
          ca.defaultSession.webRequest.onBeforeRequest((f, p) => {
            const w = P.parse(f.url);
            if (w.scheme === R.vscodeWebview && !u(w, f)) {
              this.m.error("Blocked vscode-webview request", f.url);
              return p({
                cancel: true
              });
            } else if (w.scheme === R.vscodeFileResource && !l(f)) {
              this.m.error("Blocked vscode-file request", f.url);
              return p({
                cancel: true
              });
            } else if (w.path.endsWith(".svg") && !o.has(w.scheme)) {
              return p({
                cancel: !c(f)
              });
            } else {
              return p({
                cancel: false
              });
            }
          });
          ca.defaultSession.webRequest.onHeadersReceived((f, p) => {
            const w = f.responseHeaders;
            const m = w["content-type"] || w["Content-Type"];
            if (m && Array.isArray(m)) {
              const y = P.parse(f.url);
              if (y.path.endsWith(".svg") && o.has(y.scheme)) {
                w["Content-Type"] = ["image/svg+xml"];
                return p({
                  cancel: false,
                  responseHeaders: w
                });
              }
              if (!y.path.endsWith(R.vscodeRemoteResource) && m.some(b => b.toLowerCase().includes("image/svg"))) {
                return p({
                  cancel: !c(f)
                });
              }
            }
            return p({
              cancel: false
            });
          });
          ca.defaultSession.webRequest.onHeadersReceived((f, p) => {
            if (f.url.startsWith("https://vscode.download.prss.microsoft.com/")) {
              const w = f.responseHeaders ?? Object.create(null);
              if (w["Access-Control-Allow-Origin"] === undefined) {
                w["Access-Control-Allow-Origin"] = ["*"];
                return p({
                  cancel: false,
                  responseHeaders: w
                });
              }
            }
            return p({
              cancel: false
            });
          });
          const d = ca.defaultSession;
          if (typeof d.setCodeCachePath == "function" && this.q.codeCachePath) {
            d.setCodeCachePath(F(this.q.codeCachePath, "chrome"));
          }
          if (j) {
            if (this.t.getValue("security.restrictUNCAccess") === false) {
              CS();
            } else {
              ma(this.t.getValue("security.allowedUNCHosts"));
            }
          }
        }
        F() {
          lw(s => this.G(s));
          process.on("uncaughtException", s => {
            if (!zS(s)) {
              Ft(s);
            }
          });
          process.on("unhandledRejection", s => Ft(s));
          x.once(this.s.onWillShutdown)(() => this.dispose());
          sx();
          Nn.on("accessibility-support-changed", (s, r) => {
            this.b?.sendToAll("vscode:accessibilitySupportChanged", r);
          });
          Nn.on("activate", async (s, r) => {
            this.m.trace("app#activate");
            if (!r) {
              await this.b?.openEmptyWindow({
                context: 1
              });
            }
          });
          Nn.on("web-contents-created", (s, r) => {
            if (r?.opener?.url.startsWith(`${R.vscodeFileResource}://${za}/`)) {
              this.m.trace("[aux window]  app.on(\"web-contents-created\"): Registering auxiliary window");
              this.c?.registerWindow(r);
            }
            r.on("will-navigate", n => {
              this.m.error("webContents#will-navigate: Prevented webcontent navigation");
              n.preventDefault();
            });
            r.setWindowOpenHandler(n => n.url === "about:blank" ? (this.m.trace("[aux window] webContents#setWindowOpenHandler: Allowing auxiliary window to open on about:blank"), {
              action: "allow",
              overrideBrowserWindowOptions: this.c?.createWindow(n)
            }) : (this.m.trace(`webContents#setWindowOpenHandler: Prevented opening window with URL ${n.url}}`), this.f?.openExternal(undefined, n.url), {
              action: "deny"
            }));
          });
          let e = [];
          let i;
          Nn.on("open-file", (s, r) => {
            r = io(r);
            this.m.trace("app#open-file: ", r);
            s.preventDefault();
            e.push(ln(r) ? {
              workspaceUri: P.file(r)
            } : {
              fileUri: P.file(r)
            });
            if (i !== undefined) {
              clearTimeout(i);
              i = undefined;
            }
            i = setTimeout(async () => {
              await this.b?.open({
                context: 1,
                cli: this.q.args,
                urisToOpen: e,
                gotoLineMode: false,
                preferNewWindow: true
              });
              e = [];
              i = undefined;
            }, 100);
          });
          Nn.on("new-window-for-tab", async () => {
            await this.b?.openEmptyWindow({
              context: 4
            });
          });
          it.handle("vscode:fetchShellEnv", s => {
            const r = this.b?.getWindowByWebContents(s.sender);
            let n;
            let o;
            if (r?.config) {
              n = r.config;
              o = {
                ...process.env,
                ...r.config.userEnv
              };
            } else {
              n = this.q.args;
              o = process.env;
            }
            return this.W(n, o, false);
          });
          it.on("vscode:toggleDevTools", s => s.sender.toggleDevTools());
          it.on("vscode:openDevTools", s => s.sender.openDevTools());
          it.on("vscode:reloadWindow", s => s.sender.reload());
          it.handle("vscode:notifyZoomLevel", async (s, r) => {
            const n = this.b?.getWindowByWebContents(s.sender);
            if (n) {
              n.notifyZoomLevel(r);
            }
          });
        }
        G(e) {
          if (e) {
            const i = {
              message: `[uncaught exception in main]: ${e.message}`,
              stack: e.stack
            };
            this.b?.sendToFocused("vscode:reportError", JSON.stringify(i));
          }
          this.m.error(`[uncaught exception in main]: ${e}`, e);
        }
        async startup() {
          this.m.debug("Starting VS Code");
          this.m.debug(`from: ${this.q.appRoot}`);
          this.m.debug("args:", this.q.args);
          const e = this.y.win32AppUserModelId;
          if (j && e) {
            Nn.setAppUserModelId(e);
          }
          try {
            if (N && this.t.getValue("window.nativeTabs") === true && !C8.getUserDefault("NSUseImprovedLayoutPass", "boolean")) {
              C8.setUserDefault("NSUseImprovedLayoutPass", "boolean", true);
            }
          } catch (f) {
            this.m.error(f);
          }
          const i = new Ub();
          x.once(this.s.onWillShutdown)(f => {
            if (f.reason === 2) {
              i.dispose();
            }
          });
          this.m.trace("Resolving machine identifier...");
          const [s, r, n, o] = await Promise.all([xC(this.u, this.m), DC(this.u, this.m), PC(this.u, this.m), $C(this.u, this.m)]);
          this.m.trace(`Resolved machine identifier: ${s}`);
          const {
            sharedProcessReady: a,
            sharedProcessClient: c
          } = this.O(s, r, n, o);
          const l = await this.P(s, r, n, o, a);
          l.invokeFunction(f => f.get(oh));
          this.D(l.createInstance(md));
          l.invokeFunction(f => this.Q(f, i, c));
          const u = await l.invokeFunction(f => this.H(f, i));
          this.I(i);
          this.s.phase = 2;
          await l.invokeFunction(f => this.R(f, u));
          this.s.phase = 3;
          this.S();
          this.D(new os(() => {
            this.D(Rp(() => {
              this.s.phase = 4;
              this.Y();
            }, 2500));
          }, 2500)).schedule();
        }
        async H(e, i) {
          const s = this.b = e.get(dt);
          const r = e.get(Uc);
          const n = this.f = e.get(Or);
          const o = e.get(nr);
          const a = this;
          r.registerHandler({
            async handleURL(p, w) {
              return a.N(s, o, r, p, w);
            }
          });
          const c = this.D(new D6({
            onDidOpenMainWindow: n.onDidOpenMainWindow,
            onDidFocusMainWindow: n.onDidFocusMainWindow,
            getActiveWindowId: () => n.getActiveWindowId(-1)
          }));
          const l = new mb(p => c.getActiveClientId().then(w => p === w));
          const u = new h6(l, this.m);
          const d = i.getChannel("urlHandler", u);
          r.registerHandler(new u6(d));
          const f = await this.J(s, o);
          this.D(new p6(f?.urls, r, s, this.q, this.y, this.m));
          return f;
        }
        I(e) {
          const i = () => ({
            statusCode: 404,
            data: "Not found"
          });
          const s = new vr(() => e.getChannel(D7, new P7()));
          A8.registerBufferProtocol(R.vscodeManagedRemoteResource, (r, n) => {
            const o = P.parse(r.url);
            if (!o.authority.startsWith("window:")) {
              return n(i());
            }
            s.value.call(fm, [o]).then(a => n({
              ...a,
              data: Buffer.from(a.body, "base64")
            }), a => {
              this.m.warn("error dispatching remote resource call", a);
              n({
                statusCode: 500,
                data: String(a)
              });
            });
          });
        }
        async J(e, i) {
          const s = this.q.args["open-url"] ? this.q.args._urls || [] : [];
          if (s.length > 0) {
            this.m.trace("app#resolveInitialProtocolUrls() protocol urls from command line:", s);
          }
          const r = global.getOpenUrls() || [];
          if (r.length > 0) {
            this.m.trace("app#resolveInitialProtocolUrls() protocol urls from macOS 'open-url' event:", r);
          }
          if (s.length + r.length === 0) {
            return;
          }
          const n = [...s, ...r].map(c => {
            try {
              return {
                uri: P.parse(c),
                originalUrl: c
              };
            } catch {
              this.m.trace("app#resolveInitialProtocolUrls() protocol url failed to parse:", c);
              return;
            }
          });
          const o = [];
          const a = [];
          for (const c of n) {
            if (!c) {
              continue;
            }
            const l = this.M(c.uri);
            if (l) {
              if (await this.L(l, e, i)) {
                this.m.trace("app#resolveInitialProtocolUrls() protocol url was blocked:", c.uri.toString(true));
                continue;
              } else {
                this.m.trace("app#resolveInitialProtocolUrls() protocol url will be handled as window to open:", c.uri.toString(true), l);
                o.push(l);
              }
            } else {
              this.m.trace("app#resolveInitialProtocolUrls() protocol url will be passed to active window for handling:", c.uri.toString(true));
              a.push(c);
            }
          }
          return {
            urls: a,
            openables: o
          };
        }
        async L(e, i, s) {
          let r;
          let n;
          if (N1(e)) {
            r = e.workspaceUri;
            n = v(148, null, r.scheme === R.file ? to(r, {
              os: Wi,
              tildify: this.q
            }) : r.toString(true), this.y.nameShort);
          } else if (A4(e)) {
            r = e.folderUri;
            n = v(149, null, r.scheme === R.file ? to(r, {
              os: Wi,
              tildify: this.q
            }) : r.toString(true), this.y.nameShort);
          } else {
            r = e.fileUri;
            n = v(150, null, r.scheme === R.file ? to(r, {
              os: Wi,
              tildify: this.q
            }) : r.toString(true), this.y.nameShort);
          }
          if (r.scheme !== R.file && r.scheme !== R.vscodeRemote || this.t.getValue(Zm.a[r.scheme]) === false) {
            return false;
          }
          const {
            response: a,
            checkboxChecked: c
          } = await s.showMessageBox({
            type: "warning",
            buttons: [v(151, null), v(152, null)],
            message: n,
            detail: v(153, null),
            checkboxLabel: r.scheme === R.file ? v(154, null) : v(155, null),
            cancelId: 1
          });
          if (a !== 0) {
            return true;
          }
          if (c) {
            const l = {
              channel: "vscode:disablePromptForProtocolHandling",
              args: r.scheme === R.file ? "local" : "remote"
            };
            i.sendToFocused(l.channel, l.args);
            i.sendToOpeningWindow(l.channel, l.args);
          }
          return false;
        }
        M(e) {
          if (e.path) {
            if (e.authority === R.file) {
              const i = P.file(e.fsPath);
              if (ln(i)) {
                return {
                  workspaceUri: i
                };
              } else {
                return {
                  fileUri: i
                };
              }
            } else if (e.authority === R.vscodeRemote) {
              const i = e.path.indexOf(ae.sep, 1);
              let s;
              let r;
              if (i !== -1) {
                s = e.path.substring(1, i);
                r = e.path.substring(i);
              } else {
                s = e.path.substring(1);
                r = "/";
              }
              let n = e.query;
              const o = new URLSearchParams(e.query);
              if (o.get("windowId") === "_blank") {
                o.delete("windowId");
                n = o.toString();
              }
              const a = P.from({
                scheme: R.vscodeRemote,
                authority: s,
                path: r,
                query: n,
                fragment: e.fragment
              });
              if (ln(r)) {
                return {
                  workspaceUri: a
                };
              } else if (/:[\d]+$/.test(r)) {
                return {
                  fileUri: a
                };
              } else {
                return {
                  folderUri: a
                };
              }
            }
          }
        }
        async N(e, i, s, r, n) {
          this.m.trace("app#handleProtocolUrl():", r.toString(true), n);
          if (r.scheme === this.y.urlProtocol && r.path === "workspace") {
            r = r.with({
              authority: "file",
              path: P.parse(r.query).path,
              query: ""
            });
          }
          let o = false;
          const a = new URLSearchParams(r.query);
          if (a.get("windowId") === "_blank") {
            this.m.trace("app#handleProtocolUrl() found 'windowId=_blank' as parameter, setting shouldOpenInNewWindow=true:", r.toString(true));
            a.delete("windowId");
            r = r.with({
              query: a.toString()
            });
            o = true;
          } else if (N && e.getWindowCount() === 0) {
            this.m.trace("app#handleProtocolUrl() running on macOS with no window open, setting shouldOpenInNewWindow=true:", r.toString(true));
            o = true;
          }
          const c = a.get("continueOn");
          if (c !== null) {
            this.m.trace("app#handleProtocolUrl() found 'continueOn' as parameter:", r.toString(true));
            a.delete("continueOn");
            r = r.with({
              query: a.toString()
            });
            this.q.continueOn = c ?? undefined;
          }
          const l = this.M(r);
          if (l) {
            if (await this.L(l, e, i)) {
              this.m.trace("app#handleProtocolUrl() protocol url was blocked:", r.toString(true));
              return true;
            } else {
              this.m.trace("app#handleProtocolUrl() opening protocol url as window:", l, r.toString(true));
              (await e.open({
                context: 6,
                cli: {
                  ...this.q.args
                },
                urisToOpen: [l],
                forceNewWindow: o,
                gotoLineMode: true
              })).at(0)?.focus();
              return true;
            }
          } else if (o) {
            this.m.trace("app#handleProtocolUrl() opening empty window and passing in protocol url:", r.toString(true));
            await (await e.open({
              context: 6,
              cli: {
                ...this.q.args
              },
              forceNewWindow: true,
              forceEmpty: true,
              gotoLineMode: true,
              remoteAuthority: Ao(r)
            })).at(0)?.ready();
            return s.open(r, n);
          } else {
            this.m.trace("app#handleProtocolUrl(): not handled", r.toString(true), n);
            return false;
          }
        }
        O(e, i, s, r) {
          const n = this.D(this.j.createInstance(Zh, e, i, s, r));
          this.D(n.onDidCrash(() => this.b?.sendToFocused("vscode:reportSharedProcessCrash")));
          const o = (async () => {
            this.m.trace("Main->SharedProcess#connect");
            const c = await n.connect();
            this.m.trace("Main->SharedProcess#connect: connection established");
            return new Jp(c, "main");
          })();
          return {
            sharedProcessReady: (async () => {
              await n.whenReady();
              return o;
            })(),
            sharedProcessClient: o
          };
        }
        async P(e, i, s, r, n) {
          const o = new Ch();
          switch (process.platform) {
            case "win32":
              o.set(xn, new ue(Vc, [e]));
              break;
            case "linux":
              if (Gf) {
                o.set(xn, new ue(ed, [process.env.SNAP, process.env.SNAP_REVISION]));
              } else {
                o.set(xn, new ue(Xh, [e]));
              }
              break;
            case "darwin":
              o.set(xn, new ue(Mr, [e]));
              break;
          }
          o.set(dt, new ue(ud, [e, i, s, r, this.h], false));
          o.set(To, new ue($d, undefined, false));
          const a = new fh(this.m, this.y);
          o.set(nr, a);
          o.set(Ng, new ue(Uh, undefined, false));
          o.set(vh, new ue(bh, undefined, false));
          o.set(J1, ze.toService(fu(n.then(f => f.getChannel("diagnostics")))));
          o.set(Dg, new ue(Th, [this.h]));
          o.set(yu, new ue(yh));
          o.set(Fg, new ue(jh));
          o.set(Or, new ue(Fc, undefined, false));
          o.set(Gg, new ue(rd));
          o.set(Tg, new ue(Jh));
          o.set(lg, new ue(Dh));
          o.set(yo, new ue(Xu));
          o.set(dc, new ue(Qu));
          const c = new yd({
            graceTime: 60000,
            shortGraceTime: 6000,
            scrollback: this.t.getValue("terminal.integrated.persistentSessionScrollback") ?? 100
          }, this.t, this.q, this.s, this.m);
          const l = new Dd(c, this.t, this.m, this.n);
          o.set(cm, l);
          if (j) {
            o.set(Pc, new ue($h));
          } else if (N) {
            o.set(Pc, new ue(R5));
          } else if (Se) {
            o.set(Pc, new ue(fg));
          }
          const u = new lh(this.q, this.t, this.y, this.m, this.u);
          o.set(xo, u);
          const d = new mh(this.q, this.m, this.z, u, a);
          o.set(Cr, d);
          o.set(ig, new ue(hd, undefined, false));
          o.set(Bc, new ue(qh, undefined, false));
          o.set(Uc, new ue(sd, undefined, false));
          if (Q2(this.y, this.q)) {
            const f = hI(this.y, this.t);
            const p = fu(n.then(k => k.getChannel("telemetryAppender")));
            const w = new n6(p);
            const m = lI(KL(), JL(), process.arch, this.y.commit, this.y.version, e, i, s, r, f);
            const y = dI(this.q);
            const b = {
              appenders: [w],
              commonProperties: m,
              piiPaths: y,
              sendErrorTelemetry: true
            };
            o.set(Ot, new ue(Yh, [b], false));
          } else {
            o.set(Ot, Hc);
          }
          o.set(Zo, new ue(wd, undefined, true));
          o.set(H6, new ue(gd, undefined, true));
          o.set(am, new ue(vd, undefined, true));
          o.set(oh, new ue(ah));
          o.set(Wo, new ue(Rh, undefined, true));
          o.set(Gm, new ue(Gd));
          o.set(Jm, new ue(Jd));
          if (this.y.quality !== "stable") {
            o.set($8, new ue(Kd, undefined, true));
          }
          await Tt.settled([u.initialize(), d.initialize()]);
          return this.j.createChild(o);
        }
        Q(e, i, s) {
          const r = this.D(new De());
          const n = ze.fromService(e.get(Ng), r, {
            disableMarshalling: true
          });
          this.g.registerChannel("launch", n);
          const o = ze.fromService(e.get(vh), r, {
            disableMarshalling: true
          });
          this.g.registerChannel("diagnostics", o);
          const a = ze.fromService(e.get(Gm), r);
          i.registerChannel("tracing", a);
          s.then(O => O.registerChannel("tracing", a));
          HL(e, i, s, r);
          const c = ze.fromService(e.get(Jm), r);
          i.registerChannel("abuse", c);
          const l = r.add(new P6(e.get(Pn)));
          i.registerChannel("policy", l);
          s.then(O => O.registerChannel("policy", l));
          const u = this.w.getProvider(R.file);
          cE(u instanceof Ih);
          const d = r.add(new g2(u, this.m, this.q));
          i.registerChannel(yg, d);
          s.then(O => O.registerChannel(yg, d));
          const f = ze.fromService(e.get(Rs), r);
          i.registerChannel("userDataProfiles", f);
          s.then(O => O.registerChannel("userDataProfiles", f));
          const p = new o6(e.get(xn));
          i.registerChannel("update", p);
          const w = ze.fromService(e.get(Dg), r);
          i.registerChannel("process", w);
          const m = ze.fromService(e.get(yu), r);
          i.registerChannel("encryption", m);
          const y = ze.fromService(e.get(zo), r);
          i.registerChannel("sign", y);
          const b = ze.fromService(e.get(Fg), r);
          i.registerChannel("keyboardLayout", b);
          this.f = e.get(Or);
          const k = ze.fromService(this.f, r);
          i.registerChannel("nativeHost", k);
          s.then(O => O.registerChannel("nativeHost", k));
          const A = ze.fromService(e.get(ig), r);
          i.registerChannel("workspaces", A);
          const C = ze.fromService(e.get(Tg), r);
          i.registerChannel("menubar", C);
          const _ = ze.fromService(e.get(Uc), r);
          i.registerChannel("url", _);
          const Z = ze.fromService(e.get(Gg), r);
          i.registerChannel("webview", Z);
          const ie = r.add(new r6(this.m, e.get(yo)));
          i.registerChannel("storage", ie);
          s.then(O => O.registerChannel("storage", ie));
          const me = r.add(new J6(e.get(yo), e.get(Rs), this.m));
          s.then(O => O.registerChannel("profileStorageListener", me));
          const W = ze.fromService(e.get(cm), r);
          i.registerChannel(Xo.LocalPty, W);
          const Ee = ze.fromService(e.get(Pc), r);
          i.registerChannel("externalTerminal", Ee);
          const Ye = new Z6(e.get(qo));
          i.registerChannel("logger", Ye);
          s.then(O => O.registerChannel("logger", Ye));
          const re = new Z4(e.get(dt));
          i.registerChannel("extensionhostdebugservice", re);
          const St = ze.fromService(e.get(lg), r);
          i.registerChannel(_5, St);
          const L = ze.fromService(e.get(am), r);
          i.registerChannel(Y6, L);
        }
        async R(e, i) {
          const s = this.b = e.get(dt);
          this.c = e.get(To);
          const r = bn(process.env) ? 0 : 4;
          const n = this.q.args;
          if (i) {
            if (i.openables.length > 0) {
              return s.open({
                context: r,
                cli: n,
                urisToOpen: i.openables,
                gotoLineMode: true,
                initialStartup: true
              });
            }
            if (i.urls.length > 0) {
              for (const m of i.urls) {
                const y = new URLSearchParams(m.uri.query);
                if (y.get("windowId") === "_blank") {
                  y.delete("windowId");
                  m.originalUrl = m.uri.toString(true);
                  m.uri = m.uri.with({
                    query: y.toString()
                  });
                  return s.open({
                    context: r,
                    cli: n,
                    forceNewWindow: true,
                    forceEmpty: true,
                    gotoLineMode: true,
                    initialStartup: true
                  });
                }
              }
            }
          }
          const o = global.macOpenFiles;
          const a = n._.length;
          const c = !!n["folder-uri"];
          const l = !!n["file-uri"];
          const u = n["skip-add-to-recently-opened"] === true;
          const d = n.wait && n.waitMarkerFilePath ? P.file(n.waitMarkerFilePath) : undefined;
          const f = n.remote || undefined;
          const p = n.profile;
          const w = n["profile-temp"];
          if (!a && !c && !l) {
            if (n["new-window"] || p || w) {
              return s.open({
                context: r,
                cli: n,
                forceNewWindow: true,
                forceEmpty: true,
                noRecentEntry: u,
                waitMarkerFileURI: d,
                initialStartup: true,
                remoteAuthority: f,
                forceProfile: p,
                forceTempProfile: w
              });
            }
            if (o.length) {
              return s.open({
                context: 1,
                cli: n,
                urisToOpen: o.map(m => {
                  m = io(m);
                  if (ln(m)) {
                    return {
                      workspaceUri: P.file(m)
                    };
                  } else {
                    return {
                      fileUri: P.file(m)
                    };
                  }
                }),
                noRecentEntry: u,
                waitMarkerFileURI: d,
                initialStartup: true
              });
            }
          }
          return s.open({
            context: r,
            cli: n,
            forceNewWindow: n["new-window"],
            diffMode: n.diff,
            mergeMode: n.merge,
            noRecentEntry: u,
            waitMarkerFileURI: d,
            gotoLineMode: n.goto,
            initialStartup: true,
            remoteAuthority: f,
            forceProfile: p,
            forceTempProfile: w
          });
        }
        S() {
          this.U();
          A8.registerHttpProtocol(R.vscodeRemoteResource, (e, i) => {
            i({
              url: e.url.replace(/^vscode-remote-resource:/, "http:"),
              method: e.method
            });
          });
          this.W(this.q.args, process.env, true);
          this.X();
          if (N && Nn.runningUnderARM64Translation) {
            this.b?.sendToFocused("vscode:showTranslatedBuildWarning");
          }
        }
        async U() {
          const e = this.y.win32MutexName;
          if (j && e) {
            try {
              const i = await import("@vscode/windows-mutex");
              const s = new i.Mutex(e);
              x.once(this.s.onWillShutdown)(() => s.release());
            } catch (i) {
              this.m.error(i);
            }
          }
        }
        async W(e, i, s) {
          try {
            return await ag(this.t, this.m, e, i);
          } catch (r) {
            const n = Ki(r);
            if (s) {
              this.b?.sendToFocused("vscode:showResolveShellEnvError", n);
            } else {
              this.m.error(n);
            }
          }
          return {};
        }
        async X() {
          try {
            const i = (await this.w.readFile(this.q.argvResource)).value.toString();
            const s = L0(i);
            const n = Bg(this.t) >= 1;
            if (s["enable-crash-reporter"] === undefined) {
              const o = ["", "\t// Allows to disable crash reporting.", "\t// Should restart the app if the value is changed.", `	"enable-crash-reporter": ${n},`, "", "\t// Unique id used for correlating crash reports sent from this instance.", "\t// Do not edit this value.", `	"crash-reporter-id": "${ti()}"`, "}"];
              const a = i.substring(0, i.length - 2).concat(`,
  `, o.join(`
  `));
              await this.w.writeFile(this.q.argvResource, z.fromString(a));
            } else {
              const o = i.replace(/"enable-crash-reporter": .*,/, `"enable-crash-reporter": ${n},`);
              if (o !== i) {
                await this.w.writeFile(this.q.argvResource, z.fromString(o));
              }
            }
          } catch (e) {
            this.m.error(e);
            this.b?.sendToFocused("vscode:showArgvParseWarning");
          }
        }
        Y() {
          IC(this.u, this.m);
        }
      };
      Yd = Zm = __decorate([__param(2, Ss), __param(3, V), __param(4, sc), __param(5, ot), __param(6, Te), __param(7, Je), __param(8, Oi), __param(9, at), __param(10, Ve), __param(11, Rs)], Yd);
    }
  });
  function pl(t) {
    if (Object.isFrozen(t)) {
      return t;
    } else {
      return kD(t);
    }
  }
  function Tr(t, e) {
    const {
      added: i,
      removed: s,
      updated: r
    } = _8(e?.rawConfiguration, t?.rawConfiguration);
    const n = [];
    const o = t?.getAllOverrideIdentifiers() || [];
    const a = e?.getAllOverrideIdentifiers() || [];
    if (e) {
      const c = a.filter(l => !o.includes(l));
      for (const l of c) {
        n.push([l, e.getKeysForOverrideIdentifier(l)]);
      }
    }
    if (t) {
      const c = o.filter(l => !a.includes(l));
      for (const l of c) {
        n.push([l, t.getKeysForOverrideIdentifier(l)]);
      }
    }
    if (e && t) {
      for (const c of o) {
        if (a.includes(c)) {
          const l = _8({
            contents: t.getOverrideValue(undefined, c) || {},
            keys: t.getKeysForOverrideIdentifier(c)
          }, {
            contents: e.getOverrideValue(undefined, c) || {},
            keys: e.getKeysForOverrideIdentifier(c)
          });
          n.push([c, [...l.added, ...l.removed, ...l.updated]]);
        }
      }
    }
    return {
      added: i,
      removed: s,
      updated: r,
      overrides: n
    };
  }
  function _8(t, e) {
    const i = t ? e ? t.keys.filter(n => e.keys.indexOf(n) === -1) : [...t.keys] : [];
    const s = e ? t ? e.keys.filter(n => t.keys.indexOf(n) === -1) : [...e.keys] : [];
    const r = [];
    if (t && e) {
      for (const n of e.keys) {
        if (t.keys.indexOf(n) !== -1) {
          const o = Ql(e.contents, n);
          const a = Ql(t.contents, n);
          if (!Os(o, a)) {
            r.push(n);
          }
        }
      }
    }
    return {
      added: i,
      removed: s,
      updated: r
    };
  }
  var ft;
  var Ym;
  var R8;
  var O8;
  var Xd;
  var L8;
  var M8 = g({
    "out-build/vs/platform/configuration/common/configurationModels.js"() {
      "use strict";
  
      zt();
      B();
      rr();
      M();
      $i();
      us();
      _e();
      se();
      Ke();
      Xr();
      Zs();
      ft = class Un {
        static createEmptyModel(e) {
          return new Un({}, [], [], undefined, e);
        }
        constructor(e, i, s, r, n) {
          this.b = e;
          this.c = i;
          this.d = s;
          this.raw = r;
          this.f = n;
          this.a = new Map();
        }
        get rawConfiguration() {
          if (!this.g) {
            if (this.raw?.length) {
              const e = this.raw.map(i => {
                if (i instanceof Un) {
                  return i;
                }
                const s = new Ym("", this.f);
                s.parseRaw(i);
                return s.configurationModel;
              });
              this.g = e.reduce((i, s) => s === i ? s : i.merge(s), e[0]);
            } else {
              this.g = this;
            }
          }
          return this.g;
        }
        get contents() {
          return this.b;
        }
        get overrides() {
          return this.d;
        }
        get keys() {
          return this.c;
        }
        isEmpty() {
          return this.c.length === 0 && Object.keys(this.b).length === 0 && this.d.length === 0;
        }
        getValue(e) {
          if (e) {
            return Ql(this.contents, e);
          } else {
            return this.contents;
          }
        }
        inspect(e, i) {
          const s = this;
          return {
            get value() {
              return pl(s.rawConfiguration.getValue(e));
            },
            get override() {
              if (i) {
                return pl(s.rawConfiguration.getOverrideValue(e, i));
              } else {
                return undefined;
              }
            },
            get merged() {
              return pl(i ? s.rawConfiguration.override(i).getValue(e) : s.rawConfiguration.getValue(e));
            },
            get overrides() {
              const r = [];
              for (const {
                contents: n,
                identifiers: o,
                keys: a
              } of s.rawConfiguration.overrides) {
                const c = new Un(n, a, [], undefined, s.f).getValue(e);
                if (c !== undefined) {
                  r.push({
                    identifiers: o,
                    value: c
                  });
                }
              }
              if (r.length) {
                return pl(r);
              } else {
                return undefined;
              }
            }
          };
        }
        getOverrideValue(e, i) {
          const s = this.j(i);
          if (s) {
            if (e) {
              return Ql(s, e);
            } else {
              return s;
            }
          } else {
            return undefined;
          }
        }
        getKeysForOverrideIdentifier(e) {
          const i = [];
          for (const s of this.overrides) {
            if (s.identifiers.includes(e)) {
              i.push(...s.keys);
            }
          }
          return ss(i);
        }
        getAllOverrideIdentifiers() {
          const e = [];
          for (const i of this.overrides) {
            e.push(...i.identifiers);
          }
          return ss(e);
        }
        override(e) {
          let i = this.a.get(e);
          if (!i) {
            i = this.h(e);
            this.a.set(e, i);
          }
          return i;
        }
        merge(...e) {
          const i = ls(this.contents);
          const s = ls(this.overrides);
          const r = [...this.keys];
          const n = this.raw?.length ? [...this.raw] : [this];
          for (const o of e) {
            n.push(...(o.raw?.length ? o.raw : [o]));
            if (!o.isEmpty()) {
              this.i(i, o.contents);
              for (const a of o.overrides) {
                const [c] = s.filter(l => xa(l.identifiers, a.identifiers));
                if (c) {
                  this.i(c.contents, a.contents);
                  c.keys.push(...a.keys);
                  c.keys = ss(c.keys);
                } else {
                  s.push(ls(a));
                }
              }
              for (const a of o.keys) {
                if (r.indexOf(a) === -1) {
                  r.push(a);
                }
              }
            }
          }
          return new Un(i, r, s, n.every(o => o instanceof Un) ? undefined : n, this.f);
        }
        h(e) {
          const i = this.j(e);
          if (!i || typeof i != "object" || !Object.keys(i).length) {
            return this;
          }
          const s = {};
          for (const r of ss([...Object.keys(this.contents), ...Object.keys(i)])) {
            let n = this.contents[r];
            const o = i[r];
            if (o) {
              if (typeof n == "object" && typeof o == "object") {
                n = ls(n);
                this.i(n, o);
              } else {
                n = o;
              }
            }
            s[r] = n;
          }
          return new Un(s, this.keys, this.overrides, undefined, this.f);
        }
        i(e, i) {
          for (const s of Object.keys(i)) {
            if (s in e && Nt(e[s]) && Nt(i[s])) {
              this.i(e[s], i[s]);
              continue;
            }
            e[s] = ls(i[s]);
          }
        }
        j(e) {
          let i = null;
          let s = null;
          const r = n => {
            if (n) {
              if (s) {
                this.i(s, n);
              } else {
                s = ls(n);
              }
            }
          };
          for (const n of this.overrides) {
            if (n.identifiers.length === 1 && n.identifiers[0] === e) {
              i = n.contents;
            } else if (n.identifiers.includes(e)) {
              r(n.contents);
            }
          }
          r(i);
          return s;
        }
        toJSON() {
          return {
            contents: this.contents,
            overrides: this.overrides,
            keys: this.keys
          };
        }
        addValue(e, i) {
          this.k(e, i, true);
        }
        setValue(e, i) {
          this.k(e, i, false);
        }
        removeValue(e) {
          const i = this.keys.indexOf(e);
          if (i !== -1) {
            this.keys.splice(i, 1);
            yE(this.contents, e);
            if (Es.test(e)) {
              this.overrides.splice(this.overrides.findIndex(s => xa(s.identifiers, Ca(e))), 1);
            }
          }
        }
        k(e, i, s) {
          sv(this.contents, e, i, r => this.f.error(r));
          s = s || this.keys.indexOf(e) === -1;
          if (s) {
            this.keys.push(e);
          }
          if (Es.test(e)) {
            const r = Ca(e);
            const n = {
              identifiers: r,
              keys: Object.keys(this.contents[e]),
              contents: dp(this.contents[e], a => this.f.error(a))
            };
            const o = this.overrides.findIndex(a => xa(a.identifiers, r));
            if (o !== -1) {
              this.overrides[o] = n;
            } else {
              this.overrides.push(n);
            }
          }
        }
      };
      Ym = class {
        constructor(t, e) {
          this.f = t;
          this.g = e;
          this.a = null;
          this.b = null;
          this.c = [];
          this.d = [];
        }
        get configurationModel() {
          return this.b || ft.createEmptyModel(this.g);
        }
        get restrictedConfigurations() {
          return this.c;
        }
        get errors() {
          return this.d;
        }
        parse(t, e) {
          if (!Qt(t)) {
            const i = this.h(t);
            this.parseRaw(i, e);
          }
        }
        reparse(t) {
          if (this.a) {
            this.parseRaw(this.a, t);
          }
        }
        parseRaw(t, e) {
          this.a = t;
          const {
            contents: i,
            keys: s,
            overrides: r,
            restricted: n,
            hasExcludedProperties: o
          } = this.i(t, e);
          this.b = new ft(i, s, r, o ? [t] : undefined, this.g);
          this.c = n || [];
        }
        h(t) {
          let e = {};
          let i = null;
          let s = [];
          const r = [];
          const n = [];
          function o(c) {
            if (Array.isArray(s)) {
              s.push(c);
            } else if (i !== null) {
              s[i] = c;
            }
          }
          const a = {
            onObjectBegin: () => {
              const c = {};
              o(c);
              r.push(s);
              s = c;
              i = null;
            },
            onObjectProperty: c => {
              i = c;
            },
            onObjectEnd: () => {
              s = r.pop();
            },
            onArrayBegin: () => {
              const c = [];
              o(c);
              r.push(s);
              s = c;
              i = null;
            },
            onArrayEnd: () => {
              s = r.pop();
            },
            onLiteralValue: o,
            onError: (c, l, u) => {
              n.push({
                error: c,
                offset: l,
                length: u
              });
            }
          };
          if (t) {
            try {
              hh(t, a);
              e = s[0] || {};
            } catch (c) {
              this.g.error(`Error while parsing settings file ${this.f}: ${c}`);
              this.d = [c];
            }
          }
          return e;
        }
        i(t, e) {
          const i = Gt.as(Ai.Configuration).getConfigurationProperties();
          const s = this.j(t, i, true, e);
          t = s.raw;
          const r = dp(t, a => this.g.error(`Conflict in settings file ${this.f}: ${a}`));
          const n = Object.keys(t);
          const o = this.m(t, a => this.g.error(`Conflict in settings file ${this.f}: ${a}`));
          return {
            contents: r,
            keys: n,
            overrides: o,
            restricted: s.restricted,
            hasExcludedProperties: s.hasExcludedProperties
          };
        }
        j(t, e, i, s) {
          let r = false;
          if (!s?.scopes && !s?.skipRestricted && !s?.exclude?.length) {
            return {
              raw: t,
              restricted: [],
              hasExcludedProperties: r
            };
          }
          const n = {};
          const o = [];
          for (const a in t) {
            if (Es.test(a) && i) {
              const c = this.j(t[a], e, false, s);
              n[a] = c.raw;
              r = r || c.hasExcludedProperties;
              o.push(...c.restricted);
            } else {
              const c = e[a];
              if (c?.restricted) {
                o.push(a);
              }
              if (this.l(a, c, s)) {
                n[a] = t[a];
              } else {
                r = true;
              }
            }
          }
          return {
            raw: n,
            restricted: o,
            hasExcludedProperties: r
          };
        }
        l(t, e, i) {
          if (i.exclude?.includes(t)) {
            return false;
          }
          if (i.include?.includes(t)) {
            return true;
          }
          if (i.skipRestricted && e?.restricted || i.skipUnregistered && !e) {
            return false;
          }
          const s = e ? typeof e.scope !== "undefined" ? e.scope : 3 : undefined;
          if (s === undefined || i.scopes === undefined) {
            return true;
          } else {
            return i.scopes.includes(s);
          }
        }
        m(t, e) {
          const i = [];
          for (const s of Object.keys(t)) {
            if (Es.test(s)) {
              const r = {};
              for (const n in t[s]) {
                r[n] = t[s][n];
              }
              i.push({
                identifiers: Ca(s),
                keys: Object.keys(r),
                contents: dp(r, e)
              });
            }
          }
          return i;
        }
      };
      R8 = class extends T {
        constructor(t, e, i, s, r) {
          super();
          this.c = t;
          this.f = e;
          this.g = s;
          this.h = r;
          this.b = this.D(new $());
          this.onDidChange = this.b.event;
          this.a = new Ym(this.c.toString(), r);
          this.D(this.g.watch(i.dirname(this.c)));
          this.D(this.g.watch(this.c));
          this.D(x.any(x.filter(this.g.onDidFilesChange, n => n.contains(this.c)), x.filter(this.g.onDidRunOperation, n => (n.isOperation(0) || n.isOperation(3) || n.isOperation(1) || n.isOperation(4)) && i.isEqual(n.resource, t)))(() => this.b.fire()));
        }
        async loadConfiguration() {
          try {
            const t = await this.g.readFile(this.c);
            this.a.parse(t.value.toString() || "{}", this.f);
            return this.a.configurationModel;
          } catch {
            return ft.createEmptyModel(this.h);
          }
        }
        reparse(t) {
          if (t) {
            this.f = t;
          }
          this.a.reparse(this.f);
          return this.a.configurationModel;
        }
        getRestrictedSettings() {
          return this.a.restrictedConfigurations;
        }
      };
      O8 = class {
        constructor(t, e, i, s, r, n, o, a, c, l, u, d, f) {
          this.a = t;
          this.b = e;
          this.c = i;
          this.overrideIdentifiers = s;
          this.d = r;
          this.f = n;
          this.g = o;
          this.h = a;
          this.i = c;
          this.j = l;
          this.k = u;
          this.l = d;
          this.m = f;
        }
        get value() {
          return pl(this.c);
        }
        n(t) {
          if (t?.value !== undefined || t?.override !== undefined || t?.overrides !== undefined) {
            return t;
          } else {
            return undefined;
          }
        }
        get q() {
          this.p ||= this.d.inspect(this.a, this.b.overrideIdentifier);
          return this.p;
        }
        get defaultValue() {
          return this.q.merged;
        }
        get default() {
          return this.n(this.q);
        }
        get s() {
          if (this.r === undefined) {
            this.r = this.f ? this.f.inspect(this.a) : null;
          }
          return this.r;
        }
        get policyValue() {
          return this.s?.merged;
        }
        get policy() {
          if (this.s?.value !== undefined) {
            return {
              value: this.s.value
            };
          } else {
            return undefined;
          }
        }
        get u() {
          if (this.t === undefined) {
            this.t = this.g ? this.g.inspect(this.a) : null;
          }
          return this.t;
        }
        get applicationValue() {
          return this.u?.merged;
        }
        get application() {
          return this.n(this.u);
        }
        get w() {
          this.v ||= this.h.inspect(this.a, this.b.overrideIdentifier);
          return this.v;
        }
        get userValue() {
          return this.w.merged;
        }
        get user() {
          return this.n(this.w);
        }
        get y() {
          this.x ||= this.i.inspect(this.a, this.b.overrideIdentifier);
          return this.x;
        }
        get userLocalValue() {
          return this.y.merged;
        }
        get userLocal() {
          return this.n(this.y);
        }
        get A() {
          this.z ||= this.j.inspect(this.a, this.b.overrideIdentifier);
          return this.z;
        }
        get userRemoteValue() {
          return this.A.merged;
        }
        get userRemote() {
          return this.n(this.A);
        }
        get D() {
          if (this.B === undefined) {
            this.B = this.k ? this.k.inspect(this.a, this.b.overrideIdentifier) : null;
          }
          return this.B;
        }
        get workspaceValue() {
          return this.D?.merged;
        }
        get workspace() {
          return this.n(this.D);
        }
        get F() {
          if (this.E === undefined) {
            this.E = this.l ? this.l.inspect(this.a, this.b.overrideIdentifier) : null;
          }
          return this.E;
        }
        get workspaceFolderValue() {
          return this.F?.merged;
        }
        get workspaceFolder() {
          return this.n(this.F);
        }
        get H() {
          if (this.G === undefined) {
            this.G = this.m.inspect(this.a, this.b.overrideIdentifier);
          }
          return this.G;
        }
        get memoryValue() {
          return this.H.merged;
        }
        get memory() {
          return this.n(this.H);
        }
      };
      Xd = class dS {
        constructor(e, i, s, r, n, o, a, c, l, u) {
          this.j = e;
          this.l = i;
          this.m = s;
          this.n = r;
          this.p = n;
          this.q = o;
          this.r = a;
          this.s = c;
          this.t = l;
          this.u = u;
          this.h = null;
          this.i = new Ht();
          this.v = null;
        }
        getValue(e, i, s) {
          return this.w(e, i, s).getValue(e);
        }
        updateValue(e, i, s = {}) {
          let r;
          if (s.resource) {
            r = this.t.get(s.resource);
            if (!r) {
              r = ft.createEmptyModel(this.u);
              this.t.set(s.resource, r);
            }
          } else {
            r = this.s;
          }
          if (i === undefined) {
            r.removeValue(e);
          } else {
            r.setValue(e, i);
          }
          if (!s.resource) {
            this.h = null;
          }
        }
        inspect(e, i, s) {
          const r = this.w(e, i, s);
          const n = this.A(i.resource, s);
          const o = i.resource ? this.t.get(i.resource) || this.s : this.s;
          const a = new Set();
          for (const c of r.overrides) {
            for (const l of c.identifiers) {
              if (r.getOverrideValue(e, l) !== undefined) {
                a.add(l);
              }
            }
          }
          return new O8(e, i, r.getValue(e), a.size ? [...a] : undefined, this.j, this.l.isEmpty() ? undefined : this.l, this.applicationConfiguration.isEmpty() ? undefined : this.applicationConfiguration, this.userConfiguration, this.localUserConfiguration, this.remoteUserConfiguration, s ? this.q : undefined, n || undefined, o);
        }
        keys(e) {
          const i = this.A(undefined, e);
          return {
            default: this.j.keys.slice(0),
            user: this.userConfiguration.keys.slice(0),
            workspace: this.q.keys.slice(0),
            workspaceFolder: i ? i.keys.slice(0) : []
          };
        }
        updateDefaultConfiguration(e) {
          this.j = e;
          this.h = null;
          this.i.clear();
        }
        updatePolicyConfiguration(e) {
          this.l = e;
        }
        updateApplicationConfiguration(e) {
          this.m = e;
          this.h = null;
          this.i.clear();
        }
        updateLocalUserConfiguration(e) {
          this.n = e;
          this.v = null;
          this.h = null;
          this.i.clear();
        }
        updateRemoteUserConfiguration(e) {
          this.p = e;
          this.v = null;
          this.h = null;
          this.i.clear();
        }
        updateWorkspaceConfiguration(e) {
          this.q = e;
          this.h = null;
          this.i.clear();
        }
        updateFolderConfiguration(e, i) {
          this.r.set(e, i);
          this.i.delete(e);
        }
        deleteFolderConfiguration(e) {
          this.folderConfigurations.delete(e);
          this.i.delete(e);
        }
        compareAndUpdateDefaultConfiguration(e, i) {
          const s = [];
          if (!i) {
            const {
              added: r,
              updated: n,
              removed: o
            } = Tr(this.j, e);
            i = [...r, ...n, ...o];
          }
          for (const r of i) {
            for (const n of Ca(r)) {
              const o = this.j.getKeysForOverrideIdentifier(n);
              const a = e.getKeysForOverrideIdentifier(n);
              const c = [...a.filter(l => o.indexOf(l) === -1), ...o.filter(l => a.indexOf(l) === -1), ...o.filter(l => !Os(this.j.override(n).getValue(l), e.override(n).getValue(l)))];
              s.push([n, c]);
            }
          }
          this.updateDefaultConfiguration(e);
          return {
            keys: i,
            overrides: s
          };
        }
        compareAndUpdatePolicyConfiguration(e) {
          const {
            added: i,
            updated: s,
            removed: r
          } = Tr(this.l, e);
          const n = [...i, ...s, ...r];
          if (n.length) {
            this.updatePolicyConfiguration(e);
          }
          return {
            keys: n,
            overrides: []
          };
        }
        compareAndUpdateApplicationConfiguration(e) {
          const {
            added: i,
            updated: s,
            removed: r,
            overrides: n
          } = Tr(this.applicationConfiguration, e);
          const o = [...i, ...s, ...r];
          if (o.length) {
            this.updateApplicationConfiguration(e);
          }
          return {
            keys: o,
            overrides: n
          };
        }
        compareAndUpdateLocalUserConfiguration(e) {
          const {
            added: i,
            updated: s,
            removed: r,
            overrides: n
          } = Tr(this.localUserConfiguration, e);
          const o = [...i, ...s, ...r];
          if (o.length) {
            this.updateLocalUserConfiguration(e);
          }
          return {
            keys: o,
            overrides: n
          };
        }
        compareAndUpdateRemoteUserConfiguration(e) {
          const {
            added: i,
            updated: s,
            removed: r,
            overrides: n
          } = Tr(this.remoteUserConfiguration, e);
          const o = [...i, ...s, ...r];
          if (o.length) {
            this.updateRemoteUserConfiguration(e);
          }
          return {
            keys: o,
            overrides: n
          };
        }
        compareAndUpdateWorkspaceConfiguration(e) {
          const {
            added: i,
            updated: s,
            removed: r,
            overrides: n
          } = Tr(this.workspaceConfiguration, e);
          const o = [...i, ...s, ...r];
          if (o.length) {
            this.updateWorkspaceConfiguration(e);
          }
          return {
            keys: o,
            overrides: n
          };
        }
        compareAndUpdateFolderConfiguration(e, i) {
          const s = this.folderConfigurations.get(e);
          const {
            added: r,
            updated: n,
            removed: o,
            overrides: a
          } = Tr(s, i);
          const c = [...r, ...n, ...o];
          if (c.length || !s) {
            this.updateFolderConfiguration(e, i);
          }
          return {
            keys: c,
            overrides: a
          };
        }
        compareAndDeleteFolderConfiguration(e) {
          const i = this.folderConfigurations.get(e);
          if (!i) {
            throw new Error("Unknown folder");
          }
          this.deleteFolderConfiguration(e);
          const {
            added: s,
            updated: r,
            removed: n,
            overrides: o
          } = Tr(i, undefined);
          return {
            keys: [...s, ...r, ...n],
            overrides: o
          };
        }
        get defaults() {
          return this.j;
        }
        get applicationConfiguration() {
          return this.m;
        }
        get userConfiguration() {
          this.v ||= this.p.isEmpty() ? this.n : this.n.merge(this.p);
          return this.v;
        }
        get localUserConfiguration() {
          return this.n;
        }
        get remoteUserConfiguration() {
          return this.p;
        }
        get workspaceConfiguration() {
          return this.q;
        }
        get folderConfigurations() {
          return this.r;
        }
        w(e, i, s) {
          let r = this.x(i, s);
          if (i.overrideIdentifier) {
            r = r.override(i.overrideIdentifier);
          }
          if (!this.l.isEmpty() && this.l.getValue(e) !== undefined) {
            r = r.merge(this.l);
          }
          return r;
        }
        x({
          resource: e
        }, i) {
          let s = this.y();
          if (i && e) {
            const r = i.getFolder(e);
            if (r) {
              s = this.z(r.uri) || s;
            }
            const n = this.t.get(e);
            if (n) {
              s = s.merge(n);
            }
          }
          return s;
        }
        y() {
          this.h ||= this.j.merge(this.applicationConfiguration, this.userConfiguration, this.q, this.s);
          return this.h;
        }
        z(e) {
          let i = this.i.get(e);
          if (!i) {
            const s = this.y();
            const r = this.r.get(e);
            if (r) {
              i = s.merge(r);
              this.i.set(e, i);
            } else {
              i = s;
            }
          }
          return i;
        }
        A(e, i) {
          if (i && e) {
            const s = i.getFolder(e);
            if (s) {
              return this.r.get(s.uri);
            }
          }
        }
        toData() {
          return {
            defaults: {
              contents: this.j.contents,
              overrides: this.j.overrides,
              keys: this.j.keys
            },
            policy: {
              contents: this.l.contents,
              overrides: this.l.overrides,
              keys: this.l.keys
            },
            application: {
              contents: this.applicationConfiguration.contents,
              overrides: this.applicationConfiguration.overrides,
              keys: this.applicationConfiguration.keys
            },
            user: {
              contents: this.userConfiguration.contents,
              overrides: this.userConfiguration.overrides,
              keys: this.userConfiguration.keys
            },
            workspace: {
              contents: this.q.contents,
              overrides: this.q.overrides,
              keys: this.q.keys
            },
            folders: [...this.r.keys()].reduce((e, i) => {
              const {
                contents: s,
                overrides: r,
                keys: n
              } = this.r.get(i);
              e.push([i, {
                contents: s,
                overrides: r,
                keys: n
              }]);
              return e;
            }, [])
          };
        }
        allKeys() {
          const e = new Set();
          this.j.keys.forEach(i => e.add(i));
          this.userConfiguration.keys.forEach(i => e.add(i));
          this.q.keys.forEach(i => e.add(i));
          this.r.forEach(i => i.keys.forEach(s => e.add(s)));
          return [...e.values()];
        }
        B() {
          const e = new Set();
          this.j.getAllOverrideIdentifiers().forEach(i => e.add(i));
          this.userConfiguration.getAllOverrideIdentifiers().forEach(i => e.add(i));
          this.q.getAllOverrideIdentifiers().forEach(i => e.add(i));
          this.r.forEach(i => i.getAllOverrideIdentifiers().forEach(s => e.add(s)));
          return [...e.values()];
        }
        D(e) {
          const i = new Set();
          this.j.getKeysForOverrideIdentifier(e).forEach(s => i.add(s));
          this.userConfiguration.getKeysForOverrideIdentifier(e).forEach(s => i.add(s));
          this.q.getKeysForOverrideIdentifier(e).forEach(s => i.add(s));
          this.r.forEach(s => s.getKeysForOverrideIdentifier(e).forEach(r => i.add(r)));
          return [...i.values()];
        }
        static parse(e, i) {
          const s = this.E(e.defaults, i);
          const r = this.E(e.policy, i);
          const n = this.E(e.application, i);
          const o = this.E(e.user, i);
          const a = this.E(e.workspace, i);
          const c = e.folders.reduce((l, u) => {
            l.set(P.revive(u[0]), this.E(u[1], i));
            return l;
          }, new Ht());
          return new dS(s, r, n, o, ft.createEmptyModel(i), a, c, ft.createEmptyModel(i), new Ht(), i);
        }
        static E(e, i) {
          return new ft(e.contents, e.keys, e.overrides, undefined, i);
        }
      };
      L8 = class {
        constructor(t, e, i, s, r) {
          this.change = t;
          this.f = e;
          this.g = i;
          this.h = s;
          this.i = r;
          this.a = `
  `;
          this.b = this.a.charCodeAt(0);
          this.c = 46;
          this.affectedKeys = new Set();
          this.j = undefined;
          for (const n of t.keys) {
            this.affectedKeys.add(n);
          }
          for (const [, n] of t.overrides) {
            for (const o of n) {
              this.affectedKeys.add(o);
            }
          }
          this.d = this.a;
          for (const n of this.affectedKeys) {
            this.d += n + this.a;
          }
        }
        get previousConfiguration() {
          if (!this.j && this.f) {
            this.j = Xd.parse(this.f.data, this.i);
          }
          return this.j;
        }
        affectsConfiguration(t, e) {
          const i = this.a + t;
          const s = this.d.indexOf(i);
          if (s < 0) {
            return false;
          }
          const r = s + i.length;
          if (r >= this.d.length) {
            return false;
          }
          const n = this.d.charCodeAt(r);
          if (n !== this.b && n !== this.c) {
            return false;
          }
          if (e) {
            const o = this.previousConfiguration ? this.previousConfiguration.getValue(t, e, this.f?.workspace) : undefined;
            const a = this.g.getValue(t, e, this.h);
            return !Os(o, a);
          }
          return true;
        }
      };
    }
  });
  var F8;
  var N8;
  var Qd;
  var YL = g({
    "out-build/vs/platform/configuration/common/configurations.js"() {
      "use strict";
  
      zt();
      B();
      M();
      us();
      _e();
      M8();
      Xr();
      X();
      Ls();
      Zs();
      $e();
      rr();
      F8 = class extends T {
        get configurationModel() {
          return this.b;
        }
        constructor(t) {
          super();
          this.c = t;
          this.a = this.D(new $());
          this.onDidChangeConfiguration = this.a.event;
          this.b = ft.createEmptyModel(this.c);
        }
        async initialize() {
          this.h();
          this.D(Gt.as(Ai.Configuration).onDidUpdateConfiguration(({
            properties: t,
            defaultsOverrides: e
          }) => this.f(Array.from(t), e)));
          return this.configurationModel;
        }
        reload() {
          this.h();
          return this.configurationModel;
        }
        f(t, e) {
          this.j(t, Gt.as(Ai.Configuration).getConfigurationProperties());
          this.a.fire({
            defaults: this.configurationModel,
            properties: t
          });
        }
        g() {
          return {};
        }
        h() {
          this.b = ft.createEmptyModel(this.c);
          const t = Gt.as(Ai.Configuration).getConfigurationProperties();
          this.j(Object.keys(t), t);
        }
        j(t, e) {
          const i = this.g();
          for (const s of t) {
            const r = i[s];
            const n = e[s];
            if (r !== undefined) {
              this.b.setValue(s, r);
            } else if (n) {
              this.b.setValue(s, n.default);
            } else {
              this.b.removeValue(s);
            }
          }
        }
      };
      N8 = class {
        constructor() {
          this.onDidChangeConfiguration = x.None;
          this.configurationModel = ft.createEmptyModel(new ky());
        }
        async initialize() {
          return this.configurationModel;
        }
      };
      Qd = class extends T {
        get configurationModel() {
          return this.b;
        }
        constructor(e, i, s) {
          super();
          this.c = e;
          this.f = i;
          this.g = s;
          this.a = this.D(new $());
          this.onDidChangeConfiguration = this.a.event;
          this.b = ft.createEmptyModel(this.g);
        }
        async initialize() {
          this.g.trace("PolicyConfiguration#initialize");
          this.m(await this.h(this.c.configurationModel.keys), false);
          this.D(this.f.onDidChange(e => this.j(e)));
          this.D(this.c.onDidChangeConfiguration(async ({
            properties: e
          }) => this.m(await this.h(e), true)));
          return this.b;
        }
        async h(e) {
          this.g.trace("PolicyConfiguration#updatePolicyDefinitions", e);
          const i = {};
          const s = [];
          const r = Gt.as(Ai.Configuration).getConfigurationProperties();
          for (const n of e) {
            const o = r[n];
            if (!o) {
              s.push(n);
              continue;
            }
            if (o.policy) {
              if (o.type !== "string" && o.type !== "number" && o.type !== "array" && o.type !== "object") {
                this.g.warn(`Policy ${o.policy.name} has unsupported type ${o.type}`);
                continue;
              }
              s.push(n);
              i[o.policy.name] = {
                type: o.type === "number" ? "number" : "string"
              };
            }
          }
          if (!sp(i)) {
            await this.f.updatePolicyDefinitions(i);
          }
          return s;
        }
        j(e) {
          this.g.trace("PolicyConfiguration#onDidChangePolicies", e);
          const i = Gt.as(Ai.Configuration).getPolicyConfigurations();
          const s = $t(e.map(r => i.get(r)));
          this.m(s, true);
        }
        m(e, i) {
          this.g.trace("PolicyConfiguration#update", e);
          const s = Gt.as(Ai.Configuration).getConfigurationProperties();
          const r = [];
          const n = this.b.isEmpty();
          for (const o of e) {
            const a = s[o];
            const c = a?.policy?.name;
            if (c) {
              let l = this.f.getPolicyValue(c);
              if (wt(l) && a.type !== "string") {
                try {
                  l = this.n(l);
                } catch (u) {
                  this.g.error(`Error parsing policy value ${c}:`, Vi(u));
                  continue;
                }
              }
              if (n ? l !== undefined : !Os(this.b.getValue(o), l)) {
                r.push([o, l]);
              }
            } else if (this.b.getValue(o) !== undefined) {
              r.push([o, undefined]);
            }
          }
          if (r.length) {
            this.g.trace("PolicyConfiguration#changed", r);
            const o = this.b;
            this.b = ft.createEmptyModel(this.g);
            for (const a of o.keys) {
              this.b.setValue(a, o.getValue(a));
            }
            for (const [a, c] of r) {
              if (c === undefined) {
                this.b.removeValue(a);
              } else {
                this.b.setValue(a, c);
              }
            }
            if (i) {
              this.a.fire(this.b);
            }
          }
        }
        n(e) {
          let i = {};
          let s = null;
          let r = [];
          const n = [];
          const o = [];
          function a(l) {
            if (Array.isArray(r)) {
              r.push(l);
            } else if (s !== null) {
              if (r[s] !== undefined) {
                throw new Error(`Duplicate property found: ${s}`);
              }
              r[s] = l;
            }
          }
          if (e) {
            hh(e, {
              onObjectBegin: () => {
                const l = {};
                a(l);
                n.push(r);
                r = l;
                s = null;
              },
              onObjectProperty: l => {
                s = l;
              },
              onObjectEnd: () => {
                r = n.pop();
              },
              onArrayBegin: () => {
                const l = [];
                a(l);
                n.push(r);
                r = l;
                s = null;
              },
              onArrayEnd: () => {
                r = n.pop();
              },
              onLiteralValue: a,
              onError: (l, u, d) => {
                o.push({
                  error: l,
                  offset: u,
                  length: d
                });
              }
            });
            i = r[0] || {};
          }
          if (o.length > 0) {
            throw new Error(o.map(l => Vi(l.error)).join(`
  `));
          }
          return i;
        }
      };
      Qd = __decorate([__param(1, Pn), __param(2, V)], Qd);
    }
  });
  var W8;
  var T8;
  var XL = g({
    "out-build/vs/platform/configuration/common/configurationService.js"() {
      "use strict";
  
      zt();
      ce();
      Ze();
      B();
      rr();
      l5();
      M();
      $i();
      us();
      H();
      nt();
      Ke();
      M8();
      Xr();
      YL();
      Ls();
      W8 = class extends T {
        constructor(t, e, i, s) {
          super();
          this.m = t;
          this.n = s;
          this.h = this.D(new $());
          this.onDidChangeConfiguration = this.h.event;
          this.b = this.D(new F8(s));
          this.c = i instanceof Ug ? new N8() : this.D(new Qd(this.b, i, s));
          this.f = this.D(new R8(this.m, {}, tt, e, s));
          this.a = new Xd(this.b.configurationModel, this.c.configurationModel, ft.createEmptyModel(s), ft.createEmptyModel(s), ft.createEmptyModel(s), ft.createEmptyModel(s), new Ht(), ft.createEmptyModel(s), new Ht(), s);
          this.j = new T8(t, e, this);
          this.g = this.D(new os(() => this.reloadConfiguration(), 50));
          this.D(this.b.onDidChangeConfiguration(({
            defaults: r,
            properties: n
          }) => this.r(r, n)));
          this.D(this.c.onDidChangeConfiguration(r => this.s(r)));
          this.D(this.f.onDidChange(() => this.g.schedule()));
        }
        async initialize() {
          const [t, e, i] = await Promise.all([this.b.initialize(), this.c.initialize(), this.f.loadConfiguration()]);
          this.a = new Xd(t, e, ft.createEmptyModel(this.n), i, ft.createEmptyModel(this.n), ft.createEmptyModel(this.n), new Ht(), ft.createEmptyModel(this.n), new Ht(), this.n);
        }
        getConfigurationData() {
          return this.a.toData();
        }
        getValue(t, e) {
          const i = typeof t == "string" ? t : undefined;
          const s = hp(t) ? t : hp(e) ? e : {};
          return this.a.getValue(i, s, undefined);
        }
        async updateValue(t, e, i, s, r) {
          const n = bE(i) ? i : hp(i) ? {
            resource: i.resource,
            overrideIdentifiers: i.overrideIdentifier ? [i.overrideIdentifier] : undefined
          } : undefined;
          const o = n ? s : i;
          if (o !== undefined && o !== 3 && o !== 2) {
            throw new Error(`Unable to write ${t} to target ${o}.`);
          }
          if (n?.overrideIdentifiers) {
            n.overrideIdentifiers = ss(n.overrideIdentifiers);
            n.overrideIdentifiers = n.overrideIdentifiers.length ? n.overrideIdentifiers : undefined;
          }
          const a = this.inspect(t, {
            resource: n?.resource,
            overrideIdentifier: n?.overrideIdentifiers ? n.overrideIdentifiers[0] : undefined
          });
          if (a.policyValue !== undefined) {
            throw new Error(`Unable to write ${t} because it is configured in system policy.`);
          }
          if (Os(e, a.defaultValue)) {
            e = undefined;
          }
          if (n?.overrideIdentifiers?.length && n.overrideIdentifiers.length > 1) {
            const l = n.overrideIdentifiers.sort();
            const u = this.a.localUserConfiguration.overrides.find(d => xa([...d.identifiers].sort(), l));
            if (u) {
              n.overrideIdentifiers = u.identifiers;
            }
          }
          const c = n?.overrideIdentifiers?.length ? [IE(n.overrideIdentifiers), t] : [t];
          await this.j.write(c, e);
          await this.reloadConfiguration();
        }
        inspect(t, e = {}) {
          return this.a.inspect(t, e, undefined);
        }
        keys() {
          return this.a.keys(undefined);
        }
        async reloadConfiguration() {
          const t = await this.f.loadConfiguration();
          this.q(t);
        }
        q(t) {
          const e = this.a.toData();
          const i = this.a.compareAndUpdateLocalUserConfiguration(t);
          this.t(i, e, 2);
        }
        r(t, e) {
          const i = this.a.toData();
          const s = this.a.compareAndUpdateDefaultConfiguration(t, e);
          this.t(s, i, 7);
        }
        s(t) {
          const e = this.a.toData();
          const i = this.a.compareAndUpdatePolicyConfiguration(t);
          this.t(i, e, 7);
        }
        t(t, e, i) {
          const s = new L8(t, {
            data: e
          }, this.a, undefined, this.n);
          s.source = i;
          this.h.fire(s);
        }
      };
      T8 = class {
        constructor(t, e, i) {
          this.b = t;
          this.c = e;
          this.d = i;
          this.a = new eo();
        }
        write(t, e) {
          return this.a.queue(() => this.e(t, e));
        }
        async e(t, e) {
          let i;
          try {
            i = (await this.c.readFile(this.b)).value.toString();
          } catch (n) {
            if (n.fileOperationResult === 1) {
              i = "{}";
            } else {
              throw n;
            }
          }
          const s = [];
          gn(i, s, {
            allowTrailingComma: true,
            allowEmptyContent: true
          });
          if (s.length > 0) {
            throw new Error("Unable to write into the settings file. Please open the file to correct errors/warnings in the file and try again.");
          }
          const r = this.f(i, t, e);
          i = MD(i, r);
          await this.c.writeFile(this.b, z.fromString(i));
        }
        f(t, e, i) {
          const {
            tabSize: s,
            insertSpaces: r,
            eol: n
          } = this.h;
          if (!e.length) {
            const o = JSON.stringify(i, null, r ? " ".repeat(s) : "\t");
            return [{
              content: o,
              length: o.length,
              offset: 0
            }];
          }
          return LD(t, e, i, {
            tabSize: s,
            insertSpaces: r,
            eol: n
          });
        }
        get h() {
          if (!this.g) {
            let t = Wi === 3 || Wi === 2 ? `
  ` : `\r
  `;
            const e = this.d.getValue("files.eol", {
              overrideIdentifier: "jsonc"
            });
            if (e && typeof e == "string" && e !== "auto") {
              t = e;
            }
            this.g = {
              eol: t,
              insertSpaces: !!this.d.getValue("editor.insertSpaces", {
                overrideIdentifier: "jsonc"
              }),
              tabSize: this.d.getValue("editor.tabSize", {
                overrideIdentifier: "jsonc"
              })
            };
          }
          return this.g;
        }
      };
    }
  });
  import * as QL from "fs";
  import * as ki from "os";
  async function Xm(t, e) {
    const i = `${t}::${e.join(":")}`;
    const s = e0.get(i);
    if (s) {
      return s;
    }
    const r = [{
      tag: "grunt.js",
      filePattern: /^gruntfile\.js$/i
    }, {
      tag: "gulp.js",
      filePattern: /^gulpfile\.js$/i
    }, {
      tag: "tsconfig.json",
      filePattern: /^tsconfig\.json$/i
    }, {
      tag: "package.json",
      filePattern: /^package\.json$/i
    }, {
      tag: "jsconfig.json",
      filePattern: /^jsconfig\.json$/i
    }, {
      tag: "tslint.json",
      filePattern: /^tslint\.json$/i
    }, {
      tag: "eslint.json",
      filePattern: /^eslint\.json$/i
    }, {
      tag: "tasks.json",
      filePattern: /^tasks\.json$/i
    }, {
      tag: "launch.json",
      filePattern: /^launch\.json$/i
    }, {
      tag: "settings.json",
      filePattern: /^settings\.json$/i
    }, {
      tag: "webpack.config.js",
      filePattern: /^webpack\.config\.js$/i
    }, {
      tag: "project.json",
      filePattern: /^project\.json$/i
    }, {
      tag: "makefile",
      filePattern: /^makefile$/i
    }, {
      tag: "sln",
      filePattern: /^.+\.sln$/i
    }, {
      tag: "csproj",
      filePattern: /^.+\.csproj$/i
    }, {
      tag: "cmake",
      filePattern: /^.+\.cmake$/i
    }, {
      tag: "github-actions",
      filePattern: /^.+\.ya?ml$/i,
      relativePathPattern: /^\.github(?:\/|\\)workflows$/i
    }, {
      tag: "devcontainer.json",
      filePattern: /^devcontainer\.json$/i
    }, {
      tag: "dockerfile",
      filePattern: /^(dockerfile|docker\-compose\.ya?ml)$/i
    }, {
      tag: "cursorrules",
      filePattern: /^\.cursorrules$/i
    }];
    const n = new Map();
    const o = new Map();
    const a = 20000;
    function c(u, d, f, p) {
      const w = d.substring(u.length + 1);
      return Tt.withAsyncBody(async m => {
        let y;
        p.readdirCount++;
        try {
          y = await ee.readdir(d, {
            withFileTypes: true
          });
        } catch {
          m();
          return;
        }
        if (p.count >= a) {
          p.count += y.length;
          p.maxReached = true;
          m();
          return;
        }
        let b = y.length;
        if (b === 0) {
          m();
          return;
        }
        let k = y;
        if (p.count + y.length > a) {
          p.maxReached = true;
          b = a - p.count;
          k = y.slice(0, b);
        }
        p.count += y.length;
        for (const A of k) {
          if (A.isDirectory()) {
            if (!f.includes(A.name)) {
              await c(u, F(d, A.name), f, p);
            }
            if (--b === 0) {
              m();
              return;
            }
          } else {
            const C = A.name.lastIndexOf(".");
            if (C >= 0) {
              const _ = A.name.substring(C + 1);
              if (_) {
                n.set(_, (n.get(_) ?? 0) + 1);
              }
            }
            for (const _ of r) {
              if (_.relativePathPattern?.test(w) !== false && _.filePattern.test(A.name)) {
                o.set(_.tag, (o.get(_.tag) ?? 0) + 1);
              }
            }
            if (--b === 0) {
              m();
              return;
            }
          }
        }
      });
    }
    const l = Tt.withAsyncBody(async u => {
      const d = {
        count: 0,
        maxReached: false,
        readdirCount: 0
      };
      const f = new Jr(true);
      await c(t, t, e, d);
      const p = await tM(t);
      u({
        configFiles: Qm(o),
        fileTypes: Qm(n),
        fileCount: d.count,
        maxFilesReached: d.maxReached,
        launchConfigFiles: p,
        totalScanTime: f.elapsed(),
        totalReaddirCount: d.readdirCount
      });
    });
    e0.set(i, l);
    return l;
  }
  function Qm(t) {
    return Array.from(t.entries(), ([e, i]) => ({
      name: e,
      count: i
    })).sort((e, i) => i.count - e.count);
  }
  function eM() {
    const t = {
      os: `${ki.type()} ${ki.arch()} ${ki.release()}`,
      memory: `${(ki.totalmem() / cn.GB).toFixed(2)}GB (${(ki.freemem() / cn.GB).toFixed(2)}GB free)`,
      vmHint: `${Math.round(Oh.value() * 100)}%`
    };
    const e = ki.cpus();
    if (e && e.length > 0) {
      t.cpus = `${e[0].model} (${e.length} x ${e[0].speed})`;
    }
    return t;
  }
  async function tM(t) {
    try {
      const e = new Map();
      const i = F(t, ".vscode", "launch.json");
      const s = await QL.promises.readFile(i);
      const r = [];
      const n = gn(s.toString(), r);
      if (r.length) {
        console.log(`Unable to parse ${i}`);
        return [];
      }
      if (Po(n) === "object" && n.configurations) {
        for (const o of n.configurations) {
          const a = o.type;
          if (a) {
            if (e.has(a)) {
              e.set(a, e.get(a) + 1);
            } else {
              e.set(a, 1);
            }
          }
        }
      }
      return Qm(e);
    } catch {
      return [];
    }
  }
  var e0;
  var ef;
  var iM = g({
    "out-build/vs/platform/diagnostics/node/diagnosticsService.js"() {
      "use strict";
  
      ce();
      rr();
      Ie();
      we();
      H();
      Kn();
      se();
      _c();
      _t();
      b2();
      K1();
      He();
      ht();
      xt();
      e0 = new Map();
      ef = class {
        constructor(e, i) {
          this.c = e;
          this.d = i;
        }
        f(e) {
          const i = [];
          i.push(`OS Version:       ${e.os}`);
          i.push(`CPUs:             ${e.cpus}`);
          i.push(`Memory (System):  ${e.memory}`);
          i.push(`VM:               ${e.vmHint}`);
          return i.join(`
  `);
        }
        g(e) {
          const i = [];
          i.push(`Version:          ${this.d.nameShort} ${this.d.version} (${this.d.commit || "Commit unknown"}, ${this.d.date || "Date unknown"})`);
          i.push(`OS Version:       ${ki.type()} ${ki.arch()} ${ki.release()}`);
          const s = ki.cpus();
          if (s && s.length > 0) {
            i.push(`CPUs:             ${s[0].model} (${s.length} x ${s[0].speed})`);
          }
          i.push(`Memory (System):  ${(ki.totalmem() / cn.GB).toFixed(2)}GB (${(ki.freemem() / cn.GB).toFixed(2)}GB free)`);
          if (!j) {
            i.push(`Load (avg):       ${ki.loadavg().map(r => Math.round(r)).join(", ")}`);
          }
          i.push(`VM:               ${Math.round(Oh.value() * 100)}%`);
          i.push(`Screen Reader:    ${e.screenReader ? "yes" : "no"}`);
          i.push(`Process Argv:     ${e.mainArguments.join(" ")}`);
          i.push(`GPU Status:       ${this.j(e.gpuFeatureStatus)}`);
          return i.join(`
  `);
        }
        async getPerformanceInfo(e, i) {
          return Promise.all([Pg(e.mainPID), this.k(e)]).then(async s => {
            let [r, n] = s;
            let o = this.m(e, r);
            i.forEach(a => {
              if (G1(a)) {
                o += `
  ${a.errorMessage}`;
                n += `
  ${a.errorMessage}`;
              } else {
                o += `
  
  Remote: ${a.hostName}`;
                if (a.processes) {
                  o += `
  ${this.m(e, a.processes)}`;
                }
                if (a.workspaceMetadata) {
                  n += `
  |  Remote: ${a.hostName}`;
                  for (const c of Object.keys(a.workspaceMetadata)) {
                    const l = a.workspaceMetadata[c];
                    let u = `${l.fileCount} files`;
                    if (l.maxFilesReached) {
                      u = `more than ${u}`;
                    }
                    n += `|    Folder (${c}): ${u}`;
                    n += this.h(l);
                  }
                }
              }
            });
            return {
              processInfo: o,
              workspaceInfo: n
            };
          });
        }
        async getSystemInfo(e, i) {
          const {
            memory: s,
            vmHint: r,
            os: n,
            cpus: o
          } = eM();
          const a = {
            os: n,
            memory: s,
            cpus: o,
            vmHint: r,
            processArgs: `${e.mainArguments.join(" ")}`,
            gpuStatus: e.gpuFeatureStatus,
            screenReader: `${e.screenReader ? "yes" : "no"}`,
            remoteData: i
          };
          if (!j) {
            a.load = `${ki.loadavg().map(c => Math.round(c)).join(", ")}`;
          }
          if (Se) {
            a.linuxEnv = {
              desktopSession: process.env.DESKTOP_SESSION,
              xdgSessionDesktop: process.env.XDG_SESSION_DESKTOP,
              xdgCurrentDesktop: process.env.XDG_CURRENT_DESKTOP,
              xdgSessionType: process.env.XDG_SESSION_TYPE
            };
          }
          return Promise.resolve(a);
        }
        async getDiagnostics(e, i) {
          const s = [];
          return Pg(e.mainPID).then(async r => {
            s.push("");
            s.push(this.g(e));
            s.push("");
            s.push(this.m(e, r));
            if (e.windows.some(n => n.folderURIs && n.folderURIs.length > 0 && !n.remoteAuthority)) {
              s.push("");
              s.push("Workspace Stats: ");
              s.push(await this.k(e));
            }
            i.forEach(n => {
              if (G1(n)) {
                s.push(`
  ${n.errorMessage}`);
              } else {
                s.push(`
  
  `);
                s.push(`Remote:           ${n.hostName}`);
                s.push(this.f(n.machineInfo));
                if (n.processes) {
                  s.push(this.m(e, n.processes));
                }
                if (n.workspaceMetadata) {
                  for (const o of Object.keys(n.workspaceMetadata)) {
                    const a = n.workspaceMetadata[o];
                    let c = `${a.fileCount} files`;
                    if (a.maxFilesReached) {
                      c = `more than ${c}`;
                    }
                    s.push(`Folder (${o}): ${c}`);
                    s.push(this.h(a));
                  }
                }
              }
            });
            s.push("");
            s.push("");
            return s.join(`
  `);
          });
        }
        h(e) {
          const i = [];
          let r = 0;
          const n = (l, u) => {
            const d = ` ${l}(${u})`;
            if (r + d.length > 60) {
              i.push(o);
              o = "|                 ";
              r = o.length;
            } else {
              r += d.length;
            }
            o += d;
          };
          let o = "|      File types:";
          const a = 10;
          const c = e.fileTypes.length > a ? a : e.fileTypes.length;
          for (let l = 0; l < c; l++) {
            const u = e.fileTypes[l];
            n(u.name, u.count);
          }
          i.push(o);
          if (e.configFiles.length >= 0) {
            o = "|      Conf files:";
            r = 0;
            e.configFiles.forEach(l => {
              n(l.name, l.count);
            });
            i.push(o);
          }
          if (e.launchConfigFiles.length > 0) {
            let l = "|      Launch Configs:";
            e.launchConfigFiles.forEach(u => {
              const d = u.count > 1 ? ` ${u.name}(${u.count})` : ` ${u.name}`;
              l += d;
            });
            i.push(l);
          }
          return i.join(`
  `);
        }
        j(e) {
          const i = Math.max(...Object.keys(e).map(s => s.length));
          return Object.keys(e).map(s => `${s}:  ${" ".repeat(i - s.length)}  ${e[s]}`).join(`
                    `);
        }
        k(e) {
          const i = [];
          const s = [];
          e.windows.forEach(r => {
            if (r.folderURIs.length !== 0 && !r.remoteAuthority) {
              i.push(`|  Window (${r.title})`);
              r.folderURIs.forEach(n => {
                const o = P.revive(n);
                if (o.scheme === R.file) {
                  const a = o.fsPath;
                  s.push(Xm(a, ["node_modules", ".git"]).then(c => {
                    let l = `${c.fileCount} files`;
                    if (c.maxFilesReached) {
                      l = `more than ${l}`;
                    }
                    i.push(`|    Folder (${Ue(a)}): ${l}`);
                    i.push(this.h(c));
                  }).catch(c => {
                    i.push(`|      Error: Unable to collect workspace stats for folder ${a} (${c.toString()})`);
                  }));
                } else {
                  i.push(`|    Folder (${o.toString()}): Workspace stats not available.`);
                }
              });
            }
          });
          return Promise.all(s).then(r => i.join(`
  `)).catch(r => `Unable to collect workspace stats: ${r}`);
        }
        m(e, i) {
          const s = new Map();
          e.windows.forEach(n => s.set(n.pid, `window [${n.id}] (${n.title})`));
          e.pidToNames.forEach(({
            pid: n,
            name: o
          }) => s.set(n, o));
          const r = [];
          r.push("CPU %\tMem MB\t   PID\tProcess");
          if (i) {
            this.n(e.mainPID, s, r, i, 0);
          }
          return r.join(`
  `);
        }
        n(e, i, s, r, n) {
          const o = n === 0;
          let a;
          if (o) {
            a = r.pid === e ? `${this.d.applicationName} main` : "remote agent";
          } else if (i.has(r.pid)) {
            a = i.get(r.pid);
          } else {
            a = `${"  ".repeat(n)} ${r.name}`;
          }
          const c = process.platform === "win32" ? r.mem : ki.totalmem() * (r.mem / 100);
          s.push(`${r.load.toFixed(0).padStart(5, " ")}	${(c / cn.MB).toFixed(0).padStart(6, " ")}	${r.pid.toFixed(0).padStart(6, " ")}	${a}`);
          if (Array.isArray(r.children)) {
            r.children.forEach(l => this.n(e, i, s, l, n + 1));
          }
        }
        async getWorkspaceFileExtensions(e) {
          const i = new Set();
          for (const {
            uri: s
          } of e.folders) {
            const r = P.revive(s);
            if (r.scheme !== R.file) {
              continue;
            }
            const n = r.fsPath;
            try {
              (await Xm(n, ["node_modules", ".git"])).fileTypes.forEach(a => i.add(a.name));
            } catch {}
          }
          return {
            extensions: [...i]
          };
        }
        async reportWorkspaceStats(e) {
          for (const {
            uri: i
          } of e.folders) {
            const s = P.revive(i);
            if (s.scheme !== R.file) {
              continue;
            }
            const r = s.fsPath;
            try {
              const n = await Xm(r, ["node_modules", ".git"]);
              this.c.publicLog2("workspace.stats", {
                "workspace.id": e.telemetryId,
                rendererSessionId: e.rendererSessionId
              });
              n.fileTypes.forEach(o => {
                this.c.publicLog2("workspace.stats.file", {
                  rendererSessionId: e.rendererSessionId,
                  type: o.name,
                  count: o.count
                });
              });
              n.launchConfigFiles.forEach(o => {
                this.c.publicLog2("workspace.stats.launchConfigFile", {
                  rendererSessionId: e.rendererSessionId,
                  type: o.name,
                  count: o.count
                });
              });
              n.configFiles.forEach(o => {
                this.c.publicLog2("workspace.stats.configFiles", {
                  rendererSessionId: e.rendererSessionId,
                  type: o.name,
                  count: o.count
                });
              });
              this.c.publicLog2("workspace.stats.metadata", {
                duration: n.totalScanTime,
                reachedLimit: n.maxFilesReached,
                fileCount: n.fileCount,
                readdirCount: n.totalReaddirCount
              });
            } catch {}
          }
        }
      };
      ef = __decorate([__param(0, Ot), __param(1, Ve)], ef);
    }
  });
  import { writeFileSync as sM } from "fs";
  import { tmpdir as rM } from "os";
  function nM(t) {
    const e = qa(rM());
    try {
      sM(e, "");
      if (t) {
        console.log(`Marker file for --wait created: ${e}`);
      }
      return e;
    } catch (i) {
      if (t) {
        console.error(`Failed to create marker file for --wait: ${i}`);
      }
      return;
    }
  }
  var oM = g({
    "out-build/vs/platform/environment/node/wait.js"() {
      "use strict";
  
      gi();
    }
  });
  function aM(t) {
    return (t.scheme === "file" || t.scheme === "vscode-remote") && t.path.endsWith(".mdc");
  }
  var j8;
  var cM = g({
    "out-build/vs/base/common/mdc.js"() {
      "use strict";
  
      Ie();
      j8 = `---
  description:
  globs:
  alwaysApply: false
  ---
  `;
    }
  });
  var t0;
  var tf;
  var lM = g({
    "out-build/vs/platform/files/common/fileService.js"() {
      "use strict";
  
      zt();
      ce();
      Ze();
      At();
      B();
      er();
      Bl();
      M();
      go();
      Ie();
      Hs();
      nt();
      Ka();
      be();
      He();
      t2();
      X();
      $e();
      cM();
      tf = class extends T {
        static {
          t0 = this;
        }
        constructor(e) {
          super();
          this.b = e;
          this.a = 262144;
          this.c = this.D(new $());
          this.onDidChangeFileSystemProviderRegistrations = this.c.event;
          this.f = this.D(new $());
          this.onWillActivateFileSystemProvider = this.f.event;
          this.g = this.D(new $());
          this.onDidChangeFileSystemProviderCapabilities = this.g.event;
          this.h = new Map();
          this.q = this.D(new $());
          this.onDidRunOperation = this.q.event;
          this.X = this.D(new $());
          this.Y = this.D(new $());
          this.onDidFilesChange = this.Y.event;
          this.Z = this.D(new $());
          this.onDidWatchError = this.Z.event;
          this.$ = new Map();
          this.cb = this.D(new Cp());
        }
        registerProvider(e, i) {
          if (this.h.has(e)) {
            throw new Error(`A filesystem provider for the scheme '${e}' is already registered.`);
          }
          Ne(`code/registerFilesystem/${e}`);
          const s = new De();
          this.h.set(e, i);
          this.c.fire({
            added: true,
            scheme: e,
            provider: i
          });
          s.add(i.onDidChangeFile(r => {
            const n = new Fy(r, !this.S(i));
            this.X.fire(n);
            if (!n.hasCorrelation()) {
              this.Y.fire(n);
            }
          }));
          if (typeof i.onDidWatchError == "function") {
            s.add(i.onDidWatchError(r => this.Z.fire(new Error(r))));
          }
          s.add(i.onDidChangeCapabilities(() => this.g.fire({
            provider: i,
            scheme: e
          })));
          return xe(() => {
            this.c.fire({
              added: false,
              scheme: e,
              provider: i
            });
            this.h.delete(e);
            Et(s);
          });
        }
        getProvider(e) {
          return this.h.get(e);
        }
        async activateProvider(e) {
          const i = [];
          this.f.fire({
            scheme: e,
            join(s) {
              i.push(s);
            }
          });
          if (!this.h.has(e)) {
            await Tt.settled(i);
          }
        }
        async canHandleResource(e) {
          await this.activateProvider(e.scheme);
          return this.hasProvider(e);
        }
        hasProvider(e) {
          return this.h.has(e.scheme);
        }
        hasCapability(e, i) {
          const s = this.h.get(e.scheme);
          return !!s && !!(s.capabilities & i);
        }
        listCapabilities() {
          return Vr.map(this.h, ([e, i]) => ({
            scheme: e,
            capabilities: i.capabilities
          }));
        }
        async j(e) {
          if (!Nv(e)) {
            throw new si(v(1920, null, this.sb(e)), 8);
          }
          await this.activateProvider(e.scheme);
          const i = this.h.get(e.scheme);
          if (!i) {
            const s = new Vs();
            s.message = v(1921, null, e.toString());
            throw s;
          }
          return i;
        }
        async m(e) {
          const i = await this.j(e);
          if ($r(i) || Xi(i) || h1(i)) {
            return i;
          }
          throw new Error(`Filesystem provider for scheme '${e.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`);
        }
        async n(e) {
          const i = await this.j(e);
          if ($r(i) || Xi(i)) {
            return i;
          }
          throw new Error(`Filesystem provider for scheme '${e.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`);
        }
        async resolve(e, i) {
          try {
            return await this.r(e, i);
          } catch (s) {
            throw Ou(s) === oe.FileNotFound ? new si(v(1922, null, this.sb(e)), 1) : on(s);
          }
        }
        async r(e, i) {
          const s = await this.j(e);
          const r = this.S(s);
          const n = i?.resolveTo;
          const o = i?.resolveSingleChildDescendants;
          const a = i?.resolveMetadata;
          const c = await s.stat(e);
          let l;
          return this.s(s, e, c, undefined, !!a, (u, d) => {
            if (!l) {
              l = Pr.forUris(() => !r);
              l.set(e, true);
              if (n) {
                l.fill(true, n);
              }
            }
            if (l.get(u.resource) || l.findSuperstr(u.resource.with({
              query: null,
              fragment: null
            }))) {
              return true;
            } else if (u.isDirectory && o) {
              return d === 1;
            } else {
              return false;
            }
          });
        }
        async s(e, i, s, r, n, o) {
          const {
            providerExtUri: a
          } = this.R(e);
          const c = {
            resource: i,
            name: a.basename(i),
            isFile: (s.type & Rt.File) !== 0,
            isDirectory: (s.type & Rt.Directory) !== 0,
            isSymbolicLink: (s.type & Rt.SymbolicLink) !== 0,
            mtime: s.mtime,
            ctime: s.ctime,
            size: s.size,
            readonly: !!((s.permissions ?? 0) & wo.Readonly) || !!(e.capabilities & 2048),
            locked: !!((s.permissions ?? 0) & wo.Locked),
            etag: _y({
              mtime: s.mtime,
              size: s.size
            }),
            children: undefined
          };
          if (c.isDirectory && o(c, r)) {
            try {
              const l = await e.readdir(i);
              const u = await Tt.settled(l.map(async ([d, f]) => {
                try {
                  const p = a.joinPath(i, d);
                  const w = n ? await e.stat(p) : {
                    type: f
                  };
                  return await this.s(e, p, w, l.length, n, o);
                } catch (p) {
                  this.b.trace(p);
                  return null;
                }
              }));
              c.children = $t(u);
            } catch (l) {
              this.b.trace(l);
              c.children = [];
            }
            return c;
          }
          return c;
        }
        async resolveAll(e) {
          return Tt.settled(e.map(async i => {
            try {
              return {
                stat: await this.r(i.resource, i.options),
                success: true
              };
            } catch (s) {
              this.b.trace(s);
              return {
                stat: undefined,
                success: false
              };
            }
          }));
        }
        async stat(e) {
          const i = await this.j(e);
          const s = await i.stat(e);
          return this.s(i, e, s, undefined, true, () => false);
        }
        async exists(e) {
          const i = await this.j(e);
          try {
            return !!(await i.stat(e));
          } catch {
            return false;
          }
        }
        async canCreateFile(e, i) {
          try {
            await this.t(e, i);
          } catch (s) {
            return s;
          }
          return true;
        }
        async t(e, i) {
          if (!i?.overwrite && (await this.exists(e))) {
            throw new si(v(1923, null, this.sb(e)), 3, i);
          }
        }
        async createFile(e, i = z.fromString(""), s) {
          if (aM(e) && i.toString().trim() === "") {
            i = z.fromString(j8);
          }
          await this.t(e, s);
          const r = await this.writeFile(e, i);
          this.q.fire(new an(e, 0, r));
          return r;
        }
        async writeFile(e, i, s) {
          const r = this.qb(await this.n(e), e);
          const {
            providerExtUri: n
          } = this.R(r);
          let o = s;
          if (Cy(r) && !o?.atomic) {
            const a = r.enforceAtomicWriteFile?.(e);
            if (a) {
              o = {
                ...s,
                atomic: a
              };
            }
          }
          try {
            if (!(await this.u(r, e, o))) {
              await this.U(r, n.dirname(e));
            }
            let c;
            if (Xi(r) && !(i instanceof z)) {
              if (cu(i)) {
                const l = await Ik(i, 3);
                if (l.ended) {
                  c = z.concat(l.buffer);
                } else {
                  c = l;
                }
              } else {
                c = $k(i, l => z.concat(l), 3);
              }
            } else {
              c = i;
            }
            if (!$r(r) || Xi(r) && c instanceof z || Xi(r) && Cy(r) && o?.atomic) {
              await this.hb(r, e, o, c);
            } else {
              await this.db(r, e, o, c instanceof z ? Wk(c) : c);
            }
            this.q.fire(new an(e, 4));
          } catch (a) {
            throw new si(v(1924, null, this.sb(e), on(a).toString()), $s(a), o);
          }
          return this.resolve(e, {
            resolveMetadata: true
          });
        }
        async u(e, i, s) {
          const r = !!s?.unlock;
          if (r && !(e.capabilities & 8192)) {
            throw new Error(v(1925, null, this.sb(i)));
          }
          if (s?.atomic) {
            if (!(e.capabilities & 32768)) {
              throw new Error(v(1926, null, this.sb(i)));
            }
            if (!(e.capabilities & 2)) {
              throw new Error(v(1927, null, this.sb(i)));
            }
            if (r) {
              throw new Error(v(1928, null, this.sb(i)));
            }
          }
          let o;
          try {
            o = await e.stat(i);
          } catch {
            return;
          }
          if (o.type & Rt.Directory) {
            throw new si(v(1929, null, this.sb(i)), 0, s);
          }
          this.rb(i, o);
          if (typeof s?.mtime == "number" && typeof s.etag == "string" && s.etag !== Wu && typeof o.mtime == "number" && typeof o.size == "number" && s.mtime < o.mtime && s.etag !== _y({
            mtime: s.mtime,
            size: o.size
          })) {
            throw new si(v(1930, null), 3, s);
          }
          return o;
        }
        async readFile(e, i, s) {
          const r = await this.m(e);
          if (i?.atomic) {
            return this.w(r, e, i, s);
          } else {
            return this.z(r, e, i, s);
          }
        }
        async w(e, i, s, r) {
          return new Promise((n, o) => {
            this.cb.queueFor(i, async () => {
              try {
                const a = await this.z(e, i, s, r);
                n(a);
              } catch (a) {
                o(a);
              }
            }, this.R(e).providerExtUri);
          });
        }
        async z(e, i, s, r) {
          const n = await this.C(e, i, {
            ...s,
            preferUnbuffered: true
          }, r);
          return {
            ...n,
            value: await Za(n.value)
          };
        }
        async readFileStream(e, i, s) {
          const r = await this.m(e);
          return this.C(r, e, i, s);
        }
        async C(e, i, s, r) {
          const n = new ns(r);
          let o = s;
          if (d1(e) && e.enforceAtomicReadFile?.(i)) {
            o = {
              ...s,
              atomic: true
            };
          }
          const a = this.J(i, o).then(l => l, l => {
            n.dispose(true);
            throw l;
          });
          let c;
          try {
            if (typeof o?.etag == "string" && o.etag !== Wu) {
              await a;
            }
            if (o?.atomic && d1(e) || !$r(e) && !h1(e) || Xi(e) && o?.preferUnbuffered) {
              c = this.I(e, i, o);
            } else if (h1(e)) {
              c = this.G(e, i, n.token, o);
            } else {
              c = this.H(e, i, n.token, o);
            }
            c.on("end", () => n.dispose());
            c.on("error", () => n.dispose());
            return {
              ...(await a),
              value: c
            };
          } catch (l) {
            if (c) {
              await ab(c);
            }
            throw this.F(l, i, o);
          }
        }
        F(e, i, s) {
          const r = v(1931, null, this.sb(i), on(e).toString());
          if (e instanceof Fu) {
            return new Fu(r, e.stat, s);
          } else if (e instanceof Mu) {
            return new Mu(r, e.fileOperationResult, e.size, e.options);
          } else {
            return new si(r, $s(e), s);
          }
        }
        G(e, i, s, r = Object.create(null)) {
          const n = e.readFileStream(i, r, s);
          return cb(n, {
            data: o => o instanceof z ? o : z.wrap(o),
            error: o => this.F(o, i, r)
          }, o => z.concat(o));
        }
        H(e, i, s, r = Object.create(null)) {
          const n = Uk();
          e2(e, i, n, o => o, {
            ...r,
            bufferSize: this.a,
            errorTransformer: o => this.F(o, i, r)
          }, s);
          return n;
        }
        I(e, i, s) {
          const r = lu(n => z.concat(n));
          (async () => {
            try {
              let n;
              if (s?.atomic && d1(e)) {
                n = await e.readFile(i, {
                  atomic: true
                });
              } else {
                n = await e.readFile(i);
              }
              if (typeof s?.position == "number") {
                n = n.slice(s.position);
              }
              if (typeof s?.length == "number") {
                n = n.slice(0, s.length);
              }
              this.L(i, n.byteLength, s);
              r.end(z.wrap(n));
            } catch (n) {
              r.error(n);
              r.end();
            }
          })();
          return r;
        }
        async J(e, i) {
          const s = await this.resolve(e, {
            resolveMetadata: true
          });
          if (s.isDirectory) {
            throw new si(v(1932, null, this.sb(e)), 0, i);
          }
          if (typeof i?.etag == "string" && i.etag !== Wu && i.etag === s.etag) {
            throw new Fu(v(1933, null), s, i);
          }
          this.L(e, s.size, i);
          return s;
        }
        L(e, i, s) {
          if (typeof s?.limits?.size == "number" && i > s.limits.size) {
            throw new Mu(v(1934, null, this.sb(e)), 7, i, s);
          }
        }
        async canMove(e, i, s) {
          return this.M(e, i, "move", s);
        }
        async canCopy(e, i, s) {
          return this.M(e, i, "copy", s);
        }
        async M(e, i, s, r) {
          if (e.toString() !== i.toString()) {
            try {
              const n = s === "move" ? this.qb(await this.n(e), e) : await this.m(e);
              const o = this.qb(await this.n(i), i);
              await this.Q(n, e, o, i, s, r);
            } catch (n) {
              return n;
            }
          }
          return true;
        }
        async move(e, i, s) {
          const r = this.qb(await this.n(e), e);
          const n = this.qb(await this.n(i), i);
          const o = await this.N(r, e, n, i, "move", !!s);
          const a = await this.resolve(i, {
            resolveMetadata: true
          });
          this.q.fire(new an(e, o === "move" ? 2 : 3, a));
          return a;
        }
        async copy(e, i, s) {
          const r = await this.m(e);
          const n = this.qb(await this.n(i), i);
          const o = await this.N(r, e, n, i, "copy", !!s);
          const a = await this.resolve(i, {
            resolveMetadata: true
          });
          this.q.fire(new an(e, o === "copy" ? 3 : 2, a));
          return a;
        }
        async N(e, i, s, r, n, o) {
          if (i.toString() === r.toString()) {
            return n;
          }
          const {
            exists: a,
            isSameResourceWithDifferentPathCase: c
          } = await this.Q(e, i, s, r, n, o);
          if (a && !c && o) {
            await this.del(r, {
              recursive: true
            });
          }
          await this.U(s, this.R(s).providerExtUri.dirname(r));
          if (n === "copy") {
            if (e === s && u1(e)) {
              await e.copy(i, r, {
                overwrite: o
              });
            } else {
              const l = await this.resolve(i);
              if (l.isDirectory) {
                await this.P(e, l, s, r);
              } else {
                await this.O(e, i, s, r);
              }
            }
            return n;
          } else if (e === s) {
            await e.rename(i, r, {
              overwrite: o
            });
            return n;
          } else {
            await this.N(e, i, s, r, "copy", o);
            await this.del(i, {
              recursive: true
            });
            return "copy";
          }
        }
        async O(e, i, s, r) {
          if ($r(e) && $r(s)) {
            return this.jb(e, i, s, r);
          }
          if ($r(e) && Xi(s)) {
            return this.pb(e, i, s, r);
          }
          if (Xi(e) && $r(s)) {
            return this.nb(e, i, s, r);
          }
          if (Xi(e) && Xi(s)) {
            return this.lb(e, i, s, r);
          }
        }
        async P(e, i, s, r) {
          await s.mkdir(r);
          if (Array.isArray(i.children)) {
            await Tt.settled(i.children.map(async n => {
              const o = this.R(s).providerExtUri.joinPath(r, n.name);
              if (n.isDirectory) {
                return this.P(e, await this.resolve(n.resource), s, o);
              } else {
                return this.O(e, n.resource, s, o);
              }
            }));
          }
        }
        async Q(e, i, s, r, n, o) {
          let a = false;
          if (e === s) {
            const {
              providerExtUri: l,
              isPathCaseSensitive: u
            } = this.R(e);
            if (!u) {
              a = l.isEqual(i, r);
            }
            if (a && n === "copy") {
              throw new Error(v(1935, null, this.sb(i), this.sb(r)));
            }
            if (!a && l.isEqualOrParent(r, i)) {
              throw new Error(v(1936, null, this.sb(i), this.sb(r)));
            }
          }
          const c = await this.exists(r);
          if (c && !a) {
            if (!o) {
              throw new si(v(1937, null, this.sb(i), this.sb(r)), 4);
            }
            if (e === s) {
              const {
                providerExtUri: l
              } = this.R(e);
              if (l.isEqualOrParent(i, r)) {
                throw new Error(v(1938, null, this.sb(i), this.sb(r)));
              }
            }
          }
          return {
            exists: c,
            isSameResourceWithDifferentPathCase: a
          };
        }
        R(e) {
          const i = this.S(e);
          return {
            providerExtUri: i ? ke : kp,
            isPathCaseSensitive: i
          };
        }
        S(e) {
          return !!(e.capabilities & 1024);
        }
        async createFolder(e) {
          const i = this.qb(await this.j(e), e);
          await this.U(i, e);
          const s = await this.resolve(e, {
            resolveMetadata: true
          });
          this.q.fire(new an(e, 0, s));
          return s;
        }
        async U(e, i) {
          const s = [];
          const {
            providerExtUri: r
          } = this.R(e);
          while (!r.isEqual(i, r.dirname(i))) {
            try {
              if (!((await e.stat(i)).type & Rt.Directory)) {
                throw new Error(v(1939, null, this.sb(i)));
              }
              break;
            } catch (n) {
              if (Ou(n) !== oe.FileNotFound) {
                throw n;
              }
              s.push(r.basename(i));
              i = r.dirname(i);
            }
          }
          for (let n = s.length - 1; n >= 0; n--) {
            i = r.joinPath(i, s[n]);
            try {
              await e.mkdir(i);
            } catch (o) {
              if (Ou(o) !== oe.FileExists) {
                throw o;
              }
            }
          }
        }
        async canDelete(e, i) {
          try {
            await this.W(e, i);
          } catch (s) {
            return s;
          }
          return true;
        }
        async W(e, i) {
          const s = this.qb(await this.j(e), e);
          const r = !!i?.useTrash;
          if (r && !(s.capabilities & 4096)) {
            throw new Error(v(1940, null, this.sb(e)));
          }
          const n = i?.atomic;
          if (n && !(s.capabilities & 65536)) {
            throw new Error(v(1941, null, this.sb(e)));
          }
          if (r && n) {
            throw new Error(v(1942, null, this.sb(e)));
          }
          let o;
          try {
            o = await s.stat(e);
          } catch {}
          if (o) {
            this.rb(e, o);
          } else {
            throw new si(v(1943, null, this.sb(e)), 1);
          }
          if (!i?.recursive) {
            const c = await this.resolve(e);
            if (c.isDirectory && Array.isArray(c.children) && c.children.length > 0) {
              throw new Error(v(1944, null, this.sb(e)));
            }
          }
          return s;
        }
        async del(e, i) {
          const s = await this.W(e, i);
          let r = i;
          if (_x(s) && !r?.atomic) {
            const c = s.enforceAtomicDelete?.(e);
            if (c) {
              r = {
                ...i,
                atomic: c
              };
            }
          }
          const n = !!r?.useTrash;
          const o = !!r?.recursive;
          const a = r?.atomic ?? false;
          await s.delete(e, {
            recursive: o,
            useTrash: n,
            atomic: a
          });
          this.q.fire(new an(e, 1));
        }
        async cloneFile(e, i) {
          const s = await this.j(e);
          const r = this.qb(await this.n(i), i);
          if (s !== r || !this.R(s).providerExtUri.isEqual(e, i)) {
            if (s === r && Ay(s)) {
              return s.cloneFile(e, i);
            } else {
              await this.U(r, this.R(r).providerExtUri.dirname(i));
              if (s === r && u1(s)) {
                return this.cb.queueFor(e, () => s.copy(e, i, {
                  overwrite: true
                }), this.R(s).providerExtUri);
              } else {
                return this.cb.queueFor(e, () => this.O(s, e, r, i), this.R(s).providerExtUri);
              }
            }
          }
        }
        static {
          this.ab = 0;
        }
        createWatcher(e, i) {
          return this.watch(e, {
            ...i,
            correlationId: t0.ab++
          });
        }
        watch(e, i = {
          recursive: false,
          excludes: []
        }) {
          const s = new De();
          let r = false;
          let n = () => {
            r = true;
          };
          s.add(xe(() => n()));
          (async () => {
            try {
              const a = await this.bb(e, i);
              if (r) {
                Et(a);
              } else {
                n = () => Et(a);
              }
            } catch (a) {
              this.b.error(a);
            }
          })();
          const o = i.correlationId;
          if (typeof o == "number") {
            const a = s.add(new $());
            s.add(this.X.event(l => {
              if (l.correlates(o)) {
                a.fire(l);
              }
            }));
            return {
              onDidChange: a.event,
              dispose: () => s.dispose()
            };
          }
          return s;
        }
        async bb(e, i) {
          const s = await this.j(e);
          const r = Ds([this.R(s).providerExtUri.getComparisonKey(e), i]);
          let n = this.$.get(r);
          if (!n) {
            n = {
              count: 0,
              disposable: s.watch(e, i)
            };
            this.$.set(r, n);
          }
          n.count += 1;
          return xe(() => {
            if (n) {
              n.count--;
              if (n.count === 0) {
                Et(n.disposable);
                this.$.delete(r);
              }
            }
          });
        }
        dispose() {
          super.dispose();
          for (const [, e] of this.$) {
            Et(e.disposable);
          }
          this.$.clear();
        }
        async db(e, i, s, r) {
          return this.cb.queueFor(i, async () => {
            const n = await e.open(i, {
              create: true,
              unlock: s?.unlock ?? false
            });
            try {
              if (cu(r) || Wp(r)) {
                await this.eb(e, n, r);
              } else {
                await this.fb(e, n, r);
              }
            } catch (o) {
              throw on(o);
            } finally {
              await e.close(n);
            }
          }, this.R(e).providerExtUri);
        }
        async eb(e, i, s) {
          let r = 0;
          let n;
          if (Wp(s)) {
            if (s.buffer.length > 0) {
              const o = z.concat(s.buffer);
              await this.gb(e, i, o, o.byteLength, r, 0);
              r += o.byteLength;
            }
            if (s.ended) {
              return;
            }
            n = s.stream;
          } else {
            n = s;
          }
          return new Promise((o, a) => {
            uu(n, {
              onData: async c => {
                n.pause();
                try {
                  await this.gb(e, i, c, c.byteLength, r, 0);
                } catch (l) {
                  return a(l);
                }
                r += c.byteLength;
                setTimeout(() => n.resume());
              },
              onError: c => a(c),
              onEnd: () => o()
            });
          });
        }
        async fb(e, i, s) {
          let r = 0;
          let n;
          while ((n = s.read()) !== null) {
            await this.gb(e, i, n, n.byteLength, r, 0);
            r += n.byteLength;
          }
        }
        async gb(e, i, s, r, n, o) {
          let a = 0;
          while (a < r) {
            const c = await e.write(i, n + a, s.buffer, o + a, r - a);
            a += c;
          }
        }
        async hb(e, i, s, r) {
          return this.cb.queueFor(i, () => this.ib(e, i, s, r), this.R(e).providerExtUri);
        }
        async ib(e, i, s, r) {
          let n;
          if (r instanceof z) {
            n = r;
          } else if (cu(r)) {
            n = await Za(r);
          } else if (Wp(r)) {
            n = await Tk(r);
          } else {
            n = Nk(r);
          }
          await e.writeFile(i, n.buffer, {
            create: true,
            overwrite: true,
            unlock: s?.unlock ?? false,
            atomic: s?.atomic ?? false
          });
        }
        async jb(e, i, s, r) {
          return this.cb.queueFor(r, () => this.kb(e, i, s, r), this.R(s).providerExtUri);
        }
        async kb(e, i, s, r) {
          let n;
          let o;
          try {
            n = await e.open(i, {
              create: false
            });
            o = await s.open(r, {
              create: true,
              unlock: false
            });
            const a = z.alloc(this.a);
            let c = 0;
            let l = 0;
            let u = 0;
            do {
              u = await e.read(n, c, a.buffer, l, a.byteLength - l);
              await this.gb(s, o, a, u, c, l);
              c += u;
              l += u;
              if (l === a.byteLength) {
                l = 0;
              }
            } while (u > 0);
          } catch (a) {
            throw on(a);
          } finally {
            await Tt.settled([typeof n == "number" ? e.close(n) : Promise.resolve(), typeof o == "number" ? s.close(o) : Promise.resolve()]);
          }
        }
        async lb(e, i, s, r) {
          return this.cb.queueFor(r, () => this.mb(e, i, s, r), this.R(s).providerExtUri);
        }
        async mb(e, i, s, r) {
          return s.writeFile(r, await e.readFile(i), {
            create: true,
            overwrite: true,
            unlock: false,
            atomic: false
          });
        }
        async nb(e, i, s, r) {
          return this.cb.queueFor(r, () => this.ob(e, i, s, r), this.R(s).providerExtUri);
        }
        async ob(e, i, s, r) {
          const n = await s.open(r, {
            create: true,
            unlock: false
          });
          try {
            const o = await e.readFile(i);
            await this.gb(s, n, z.wrap(o), o.byteLength, 0, 0);
          } catch (o) {
            throw on(o);
          } finally {
            await s.close(n);
          }
        }
        async pb(e, i, s, r) {
          const n = await Za(this.H(e, i, We.None));
          await this.hb(s, r, undefined, n);
        }
        qb(e, i) {
          if (e.capabilities & 2048) {
            throw new si(v(1945, null, this.sb(i)), 6);
          }
          return e;
        }
        rb(e, i) {
          if ((i.permissions ?? 0) & wo.Readonly) {
            throw new si(v(1946, null, this.sb(e)), 6);
          }
        }
        sb(e) {
          if (e.scheme === R.file) {
            return e.fsPath;
          } else {
            return e.toString(true);
          }
        }
      };
      tf = t0 = __decorate([__param(0, V)], tf);
    }
  });
  var U8;
  var i0;
  var uM = g({
    "out-build/vs/platform/instantiation/common/graph.js"() {
      "use strict";
  
      U8 = class {
        constructor(t, e) {
          this.key = t;
          this.data = e;
          this.incoming = new Map();
          this.outgoing = new Map();
        }
      };
      i0 = class {
        constructor(t) {
          this.b = t;
          this.a = new Map();
        }
        roots() {
          const t = [];
          for (const e of this.a.values()) {
            if (e.outgoing.size === 0) {
              t.push(e);
            }
          }
          return t;
        }
        insertEdge(t, e) {
          const i = this.lookupOrInsertNode(t);
          const s = this.lookupOrInsertNode(e);
          i.outgoing.set(s.key, s);
          s.incoming.set(i.key, i);
        }
        removeNode(t) {
          const e = this.b(t);
          this.a.delete(e);
          for (const i of this.a.values()) {
            i.outgoing.delete(e);
            i.incoming.delete(e);
          }
        }
        lookupOrInsertNode(t) {
          const e = this.b(t);
          let i = this.a.get(e);
          if (!i) {
            i = new U8(e, t);
            this.a.set(e, i);
          }
          return i;
        }
        lookup(t) {
          return this.a.get(this.b(t));
        }
        isEmpty() {
          return this.a.size === 0;
        }
        toString() {
          const t = [];
          for (const [e, i] of this.a) {
            t.push(`${e}
      (-> incoming)[${[...i.incoming.keys()].join(", ")}]
      (outgoing ->)[${[...i.outgoing.keys()].join(",")}]
  `);
          }
          return t.join(`
  `);
        }
        findCycleSlow() {
          for (const [t, e] of this.a) {
            const i = new Set([t]);
            const s = this.c(e, i);
            if (s) {
              return s;
            }
          }
        }
        c(t, e) {
          for (const [i, s] of t.outgoing) {
            if (e.has(i)) {
              return [...e, i].join(" -> ");
            }
            e.add(i);
            const r = this.c(s, e);
            if (r) {
              return r;
            }
            e.delete(i);
          }
        }
      };
    }
  });
  var B8;
  var s0;
  var q8;
  var z8;
  var sf;
  var hM = g({
    "out-build/vs/platform/instantiation/common/instantiationService.js"() {
      "use strict";
  
      ce();
      $e();
      M();
      Ah();
      uM();
      Y();
      xg();
      $w();
      B8 = false;
      s0 = class extends Error {
        constructor(t, e) {
          super("cyclic dependency between services");
          this.message = `REASON: ${e}
  ${t.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: 
  ${t.toString()}`}`;
        }
      };
      q8 = class D0 {
        constructor(e = new Ch(), i = false, s, r = B8) {
          this.i = e;
          this.j = i;
          this.k = s;
          this.l = r;
          this.f = false;
          this.g = new Set();
          this.h = new Set();
          this.t = new Set();
          this.i.set(Ss, this);
          this._globalGraph = r ? s?._globalGraph ?? new i0(n => n) : undefined;
        }
        dispose() {
          if (!this.f) {
            this.f = true;
            Et(this.h);
            this.h.clear();
            for (const e of this.g) {
              if (rE(e)) {
                e.dispose();
              }
            }
            this.g.clear();
          }
        }
        m() {
          if (this.f) {
            throw new Error("InstantiationService has been disposed");
          }
        }
        createChild(e, i) {
          this.m();
          const s = this;
          const r = new class extends D0 {
            dispose() {
              s.h.delete(r);
              super.dispose();
            }
          }(e, this.j, this, this.l);
          this.h.add(r);
          i?.add(r);
          return r;
        }
        invokeFunction(e, ...i) {
          this.m();
          const s = sf.traceInvocation(this.l, e);
          let r = false;
          try {
            return e({
              get: o => {
                if (r) {
                  throw uw("service accessor is only valid during the invocation of its target method");
                }
                const a = this.s(o, s);
                if (!a) {
                  throw new Error(`[invokeFunction] unknown service '${o}'`);
                }
                return a;
              }
            }, ...i);
          } finally {
            r = true;
            s.stop();
          }
        }
        createInstance(e, ...i) {
          this.m();
          let s;
          let r;
          if (e instanceof ue) {
            s = sf.traceCreation(this.l, e.ctor);
            r = this.o(e.ctor, e.staticArguments.concat(i), s);
          } else {
            s = sf.traceCreation(this.l, e);
            r = this.o(e, i, s);
          }
          s.stop();
          return r;
        }
        o(e, i = [], s) {
          const r = rs.getServiceDependencies(e).sort((a, c) => a.index - c.index);
          const n = [];
          for (const a of r) {
            const c = this.s(a.id, s);
            if (!c) {
              this.y(`[createInstance] ${e.name} depends on UNKNOWN service ${a.id}.`, false);
            }
            n.push(c);
          }
          const o = r.length > 0 ? r[0].index : i.length;
          if (i.length !== o) {
            console.trace(`[createInstance] First service dependency of ${e.name} at position ${o + 1} conflicts with ${i.length} static arguments`);
            const a = o - i.length;
            if (a > 0) {
              i = i.concat(new Array(a));
            } else {
              i = i.slice(0, o);
            }
          }
          return Reflect.construct(e, i.concat(n));
        }
        q(e, i) {
          if (this.i.get(e) instanceof ue) {
            this.i.set(e, i);
          } else if (this.k) {
            this.k.q(e, i);
          } else {
            throw new Error("illegalState - setting UNKNOWN service instance");
          }
        }
        r(e) {
          const i = this.i.get(e);
          if (!i && this.k) {
            return this.k.r(e);
          } else {
            return i;
          }
        }
        s(e, i) {
          if (this._globalGraph && this.c) {
            this._globalGraph.insertEdge(this.c, String(e));
          }
          const s = this.r(e);
          if (s instanceof ue) {
            return this.u(e, s, i.branch(e, true));
          } else {
            i.branch(e, false);
            return s;
          }
        }
        u(e, i, s) {
          if (this.t.has(e)) {
            throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);
          }
          this.t.add(e);
          try {
            return this.v(e, i, s);
          } finally {
            this.t.delete(e);
          }
        }
        v(e, i, s) {
          const r = new i0(c => c.id.toString());
          let n = 0;
          const o = [{
            id: e,
            desc: i,
            _trace: s
          }];
          const a = new Set();
          while (o.length) {
            const c = o.pop();
            if (!a.has(String(c.id))) {
              a.add(String(c.id));
              r.lookupOrInsertNode(c);
              if (n++ > 10000) {
                throw new s0(r, "cycle count more than 1000");
              }
              for (const l of rs.getServiceDependencies(c.desc.ctor)) {
                const u = this.r(l.id);
                if (!u) {
                  this.y(`[createInstance] ${e} depends on ${l.id} which is NOT registered.`, true);
                }
                this._globalGraph?.insertEdge(String(c.id), String(l.id));
                if (u instanceof ue) {
                  const d = {
                    id: l.id,
                    desc: u,
                    _trace: c._trace.branch(l.id, true)
                  };
                  r.insertEdge(c, d);
                  o.push(d);
                }
              }
            }
          }
          while (true) {
            const c = r.roots();
            if (c.length === 0) {
              if (!r.isEmpty()) {
                throw new s0(r, "no more roots but still nodes in the graph");
              }
              break;
            }
            for (const {
              data: l
            } of c) {
              if (this.r(l.id) instanceof ue) {
                const d = this.w(l.id, l.desc.ctor, l.desc.staticArguments, l.desc.supportsDelayedInstantiation, l._trace);
                this.q(l.id, d);
              }
              r.removeNode(l);
            }
          }
          return this.r(e);
        }
        w(e, i, s = [], r, n) {
          if (this.i.get(e) instanceof ue) {
            return this.x(e, i, s, r, n, this.g);
          }
          if (this.k) {
            return this.k.w(e, i, s, r, n);
          }
          throw new Error(`illegalState - creating UNKNOWN service instance ${i.name}`);
        }
        x(e, i, s = [], r, n, o) {
          if (r) {
            const a = new D0(undefined, this.j, this, this.l);
            a.c = String(e);
            const c = new Map();
            const l = new Vv(() => {
              const u = a.o(i, s, n);
              for (const [d, f] of c) {
                const p = u[d];
                if (typeof p == "function") {
                  for (const w of f) {
                    w.disposable = p.apply(u, w.listener);
                  }
                }
              }
              c.clear();
              o.add(u);
              return u;
            });
            return new Proxy(Object.create(null), {
              get(u, d) {
                if (!l.isInitialized && typeof d == "string" && (d.startsWith("onDid") || d.startsWith("onWill"))) {
                  let w = c.get(d);
                  if (!w) {
                    w = new Qf();
                    c.set(d, w);
                  }
                  return (y, b, k) => {
                    if (l.isInitialized) {
                      return l.value[d](y, b, k);
                    }
                    {
                      const A = {
                        listener: [y, b, k],
                        disposable: undefined
                      };
                      const C = w.push(A);
                      return xe(() => {
                        C();
                        A.disposable?.dispose();
                      });
                    }
                  };
                }
                if (d in u) {
                  return u[d];
                }
                const f = l.value;
                let p = f[d];
                if (typeof p == "function") {
                  p = p.bind(f);
                  u[d] = p;
                }
                return p;
              },
              set(u, d, f) {
                l.value[d] = f;
                return true;
              },
              getPrototypeOf(u) {
                return i.prototype;
              }
            });
          } else {
            const a = this.o(i, s, n);
            o.add(a);
            return a;
          }
        }
        y(e, i) {
          if (i) {
            console.warn(e);
          }
          if (this.j) {
            throw new Error(e);
          }
        }
      };
      (function (t) {
        t[t.None = 0] = "None";
        t[t.Creation = 1] = "Creation";
        t[t.Invocation = 2] = "Invocation";
        t[t.Branch = 3] = "Branch";
      })(z8 ||= {});
      sf = class Us {
        static {
          this.all = new Set();
        }
        static {
          this.c = new class extends Us {
            constructor() {
              super(0, null);
            }
            stop() {}
            branch() {
              return this;
            }
          }();
        }
        static traceInvocation(e, i) {
          if (e) {
            return new Us(2, i.name || new Error().stack.split(`
  `).slice(3, 4).join(`
  `));
          } else {
            return Us.c;
          }
        }
        static traceCreation(e, i) {
          if (e) {
            return new Us(1, i.name);
          } else {
            return Us.c;
          }
        }
        static {
          this.f = 0;
        }
        constructor(e, i) {
          this.type = e;
          this.name = i;
          this.g = Date.now();
          this.h = [];
        }
        branch(e, i) {
          const s = new Us(3, e.toString());
          this.h.push([e, i, s]);
          return s;
        }
        stop() {
          const e = Date.now() - this.g;
          Us.f += e;
          let i = false;
          function s(n, o) {
            const a = [];
            const c = new Array(n + 1).join("\t");
            for (const [l, u, d] of o.h) {
              if (u && d) {
                i = true;
                a.push(`${c}CREATES -> ${l}`);
                const f = s(n + 1, d);
                if (f) {
                  a.push(f);
                }
              } else {
                a.push(`${c}uses -> ${l}`);
              }
            }
            return a.join(`
  `);
          }
          const r = [`${this.type === 1 ? "CREATE" : "CALL"} ${this.name}`, `${s(1, this)}`, `DONE, took ${e.toFixed(2)}ms (grand total ${Us.f.toFixed(2)}ms)`];
          if (e > 2 || i) {
            Us.all.add(r.join(`
  `));
          }
        }
      };
    }
  });
  var H8;
  var dM = g({
    "out-build/vs/platform/log/common/bufferLog.js"() {
      "use strict";
  
      M();
      X();
      H8 = class extends c1 {
        constructor(t = rc) {
          super();
          this.n = [];
          this.q = undefined;
          this.r = this.D(new pr());
          this.setLevel(t);
        }
        set logger(t) {
          this.q = t;
          this.setLevel(t.getLevel());
          this.r.value = t.onDidChangeLogLevel(this.setLevel, this);
          for (const {
            level: e,
            message: i
          } of this.n) {
            a1(t, e, i);
          }
          this.n = [];
        }
        m(t, e) {
          if (this.q) {
            a1(this.q, t, e);
          } else if (this.getLevel() <= t) {
            this.n.push({
              level: t,
              message: e
            });
          }
        }
        dispose() {
          this.q?.dispose();
          super.dispose();
        }
        flush() {
          this.q?.flush();
        }
      };
    }
  });
  import { session as fM } from "electron";
  var rf;
  var pM = g({
    "out-build/vs/platform/protocol/electron-main/protocolMainService.js"() {
      "use strict";
  
      M();
      Ie();
      we();
      H();
      go();
      se();
      _i();
      as();
      Ri();
      X();
      _s();
      rf = class extends T {
        constructor(e, i, s) {
          super();
          this.c = e;
          this.f = s;
          this.a = Pr.forPaths(!Se);
          this.b = new Set([".svg", ".png", ".jpg", ".jpeg", ".gif", ".bmp", ".webp", ".mp4", ".otf", ".ttf"]);
          this.addValidFileRoot(e.appRoot);
          this.addValidFileRoot(e.extensionsPath);
          this.addValidFileRoot(i.defaultProfile.globalStorageHome.with({
            scheme: R.file
          }).fsPath);
          this.addValidFileRoot(e.workspaceStorageHome.with({
            scheme: R.file
          }).fsPath);
          this.g();
        }
        g() {
          const {
            defaultSession: e
          } = fM;
          e.protocol.registerFileProtocol(R.vscodeFileResource, (i, s) => this.j(i, s));
          e.protocol.interceptFileProtocol(R.file, (i, s) => this.h(i, s));
          this.D(xe(() => {
            e.protocol.unregisterProtocol(R.vscodeFileResource);
            e.protocol.uninterceptProtocol(R.file);
          }));
        }
        addValidFileRoot(e) {
          const i = pi(e);
          if (this.a.get(i)) {
            return T.None;
          } else {
            this.a.set(i, true);
            return xe(() => this.a.delete(i));
          }
        }
        h(e, i) {
          const s = P.parse(e.url);
          this.f.error(`Refused to load resource ${s.fsPath} from ${R.file}: protocol (original URL: ${e.url})`);
          return i({
            error: -3
          });
        }
        j(e, i) {
          const s = this.m(e);
          const r = Ue(s);
          let n;
          if (this.c.crossOriginIsolated) {
            if (r === "workbench.html" || r === "workbench-dev.html") {
              n = Ha.CoopAndCoep;
            } else {
              n = Ha.getHeadersFromQuery(e.url);
            }
          }
          if (!this.c.isBuilt) {
            n = {
              ...n,
              ...Ov
            };
          }
          if (r === "workbench.html" || r === "workbench-dev.html") {
            n = {
              ...n,
              ...Lv
            };
          }
          if (this.a.findSubstr(s)) {
            return i({
              path: s,
              headers: n
            });
          } else if (this.b.has(Kl(s).toLowerCase())) {
            return i({
              path: s,
              headers: n
            });
          } else {
            this.f.error(`${R.vscodeFileResource}: Refused to load resource ${s} from ${R.vscodeFileResource}: protocol (original URL: ${e.url})`);
            return i({
              error: -3
            });
          }
        }
        m(e) {
          const i = P.parse(e.url);
          const s = Ct.uriToFileUri(i);
          return pi(s.fsPath);
        }
        createIPCObjectUrl() {
          let e;
          const i = P.from({
            scheme: "vscode",
            path: ti()
          });
          const s = i.toString();
          const r = async () => e;
          it.handle(s, r);
          this.f.trace(`IPC Object URL: Registered new channel ${s}.`);
          return {
            resource: i,
            update: n => e = n,
            dispose: () => {
              this.f.trace(`IPC Object URL: Removed channel ${s}.`);
              it.removeHandler(s);
            }
          };
        }
      };
      rf = __decorate([__param(0, tr), __param(1, Cs), __param(2, V)], rf);
    }
  });
  function gM(t) {
    return !!t.forwardPort;
  }
  function mM(t) {
    if (t.scheme !== "http" && t.scheme !== "https") {
      return;
    }
    const e = /^(localhost|127\.0\.0\.1|0\.0\.0\.0):(\d+)$/.exec(t.authority);
    if (e) {
      return {
        address: e[1],
        port: +e[2]
      };
    }
  }
  function r0(t) {
    return of.indexOf(t) >= 0;
  }
  function gl(t) {
    return af.indexOf(t) >= 0;
  }
  function wM(t, e, i, s) {
    if (i === 1) {
      return false;
    }
    if (i === 2 && gl(e)) {
      const r = /(\d+)\.(\d+)\.(\d+)/g.exec(s);
      if (r?.length === 4 && parseInt(r[1]) >= 18) {
        return false;
      }
    }
    return t < 1024;
  }
  var V8;
  var vM;
  var G8;
  var nf;
  var J8;
  var of;
  var af;
  var cf;
  var K8 = g({
    "out-build/vs/platform/tunnel/common/tunnel.js"() {
      "use strict";
  
      B();
      M();
      se();
      Ke();
      Y();
      X();
      V8 = q("tunnelService");
      vM = q("sharedTunnelsService");
      (function (t) {
        t.Http = "http";
        t.Https = "https";
      })(G8 ||= {});
      (function (t) {
        t.ConstantPrivate = "constantPrivate";
        t.Private = "private";
        t.Public = "public";
      })(nf ||= {});
      (function (t) {
        t[t.Notify = 1] = "Notify";
        t[t.OpenBrowser = 2] = "OpenBrowser";
        t[t.OpenPreview = 3] = "OpenPreview";
        t[t.Silent = 4] = "Silent";
        t[t.Ignore = 5] = "Ignore";
        t[t.OpenBrowserOnce = 6] = "OpenBrowserOnce";
      })(J8 ||= {});
      of = ["localhost", "127.0.0.1", "0:0:0:0:0:0:0:1", "::1"];
      af = ["0.0.0.0", "0:0:0:0:0:0:0:0", "::"];
      cf = class extends T {
        constructor(e, i) {
          super();
          this.q = e;
          this.r = i;
          this.a = new $();
          this.onTunnelOpened = this.a.event;
          this.b = new $();
          this.onTunnelClosed = this.b.event;
          this.c = new $();
          this.onAddedTunnelProvider = this.c.event;
          this.f = new Map();
          this.h = false;
          this.j = true;
          this.m = [];
          this.n = new Set();
        }
        get hasTunnelProvider() {
          return !!this.g;
        }
        get s() {
          const e = this.r.getValue("remote.localPortHost");
          if (!e || e === "localhost") {
            return "127.0.0.1";
          } else {
            return "0.0.0.0";
          }
        }
        setTunnelProvider(e) {
          this.g = e;
          if (e) {
            this.c.fire();
            return {
              dispose: () => {
                this.g = undefined;
                this.h = false;
                this.m = [];
              }
            };
          } else {
            this.h = false;
            this.m = [];
            this.c.fire();
            return {
              dispose: () => {}
            };
          }
        }
        setTunnelFeatures(e) {
          this.h = e.elevation;
          this.m = e.privacyOptions;
          this.j = e.protocol;
        }
        get canChangeProtocol() {
          return this.j;
        }
        get canElevate() {
          return this.h;
        }
        get canChangePrivacy() {
          return this.m.length > 0;
        }
        get privacyOptions() {
          return this.m;
        }
        get tunnels() {
          return this.t();
        }
        async t() {
          const e = [];
          const i = Array.from(this.f.values());
          for (const s of i) {
            const r = Array.from(s.values());
            for (const n of r) {
              const o = await n.value;
              if (o && typeof o != "string") {
                e.push(o);
              }
            }
          }
          return e;
        }
        async dispose() {
          super.dispose();
          for (const e of this.f.values()) {
            for (const {
              value: i
            } of e.values()) {
              await i.then(s => typeof s != "string" ? s?.dispose() : undefined);
            }
            e.clear();
          }
          this.f.clear();
        }
        setEnvironmentTunnel(e, i, s, r, n) {
          this.y(e, i, Promise.resolve({
            tunnelRemoteHost: e,
            tunnelRemotePort: i,
            localAddress: s,
            privacy: r,
            protocol: n,
            dispose: () => Promise.resolve()
          }));
        }
        async getExistingTunnel(e, i) {
          if (gl(e) || r0(e)) {
            e = of[0];
          }
          const s = this.C(e, i);
          if (s) {
            ++s.refcount;
            return s.value;
          }
        }
        openTunnel(e, i, s, r, n, o = false, a, c) {
          this.q.trace(`ForwardedPorts: (TunnelService) openTunnel request for ${i}:${s} on local port ${n}.`);
          const l = this.g ?? e;
          if (!l) {
            return;
          }
          i ||= "localhost";
          r ||= this.s;
          if (this.g && this.n.has(s)) {
            this.q.debug("ForwardedPorts: (TunnelService) Another call to create a tunnel with the same address has occurred before the last one completed. This call will be ignored.");
            return;
          }
          const u = this.F(l, i, s, r, n, o, a, c);
          if (u) {
            return u.then(d => {
              if (d) {
                if (typeof d == "string") {
                  this.q.trace("ForwardedPorts: (TunnelService) The tunnel provider returned an error when creating the tunnel.");
                  this.z(i, s);
                  return d;
                }
              } else {
                this.q.trace("ForwardedPorts: (TunnelService) New tunnel is undefined.");
                this.z(i, s);
                return;
              }
              this.q.trace("ForwardedPorts: (TunnelService) New tunnel established.");
              const f = this.u(d);
              if (d.tunnelRemoteHost !== i || d.tunnelRemotePort !== s) {
                this.q.warn("ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch.");
              }
              if (a && d.privacy !== a) {
                this.q.warn("ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Privacy mismatch.");
              }
              this.a.fire(f);
              return f;
            });
          } else {
            this.q.trace("ForwardedPorts: (TunnelService) Tunnel was not created.");
            return u;
          }
        }
        u(e) {
          return {
            tunnelRemotePort: e.tunnelRemotePort,
            tunnelRemoteHost: e.tunnelRemoteHost,
            tunnelLocalPort: e.tunnelLocalPort,
            localAddress: e.localAddress,
            privacy: e.privacy,
            protocol: e.protocol,
            dispose: async () => {
              this.q.trace(`ForwardedPorts: (TunnelService) dispose request for ${e.tunnelRemoteHost}:${e.tunnelRemotePort} `);
              const i = this.f.get(e.tunnelRemoteHost);
              if (i) {
                const s = i.get(e.tunnelRemotePort);
                if (s) {
                  s.refcount--;
                  await this.w(e.tunnelRemoteHost, e.tunnelRemotePort, s);
                }
              }
            }
          };
        }
        async w(e, i, s) {
          if (s.refcount <= 0) {
            this.q.trace(`ForwardedPorts: (TunnelService) Tunnel is being disposed ${e}:${i}.`);
            const r = s.value.then(async n => {
              if (n && typeof n != "string") {
                await n.dispose(true);
                this.b.fire({
                  host: n.tunnelRemoteHost,
                  port: n.tunnelRemotePort
                });
              }
            });
            if (this.f.has(e)) {
              this.f.get(e).delete(i);
            }
            return r;
          }
        }
        async closeTunnel(e, i) {
          this.q.trace(`ForwardedPorts: (TunnelService) close request for ${e}:${i} `);
          const s = this.f.get(e);
          if (s && s.has(i)) {
            const r = s.get(i);
            r.refcount = 0;
            await this.w(e, i, r);
          }
        }
        y(e, i, s) {
          if (!this.f.has(e)) {
            this.f.set(e, new Map());
          }
          this.f.get(e).set(i, {
            refcount: 1,
            value: s
          });
        }
        async z(e, i) {
          const s = this.f.get(e);
          if (s) {
            const r = s.get(i);
            const n = r ? await r.value : undefined;
            if (!n || typeof n == "string") {
              s.delete(i);
            }
            if (s.size === 0) {
              this.f.delete(e);
            }
          }
        }
        C(e, i) {
          const s = [e];
          if (r0(e)) {
            s.push(...of);
            s.push(...af);
          } else if (gl(e)) {
            s.push(...af);
          }
          const r = s.map(n => this.f.get(n));
          for (const n of r) {
            const o = n?.get(i);
            if (o) {
              return o;
            }
          }
        }
        canTunnel(e) {
          return !!mM(e);
        }
        G(e, i, s, r, n, o, a) {
          this.q.trace(`ForwardedPorts: (TunnelService) Creating tunnel with provider ${i}:${s} on local port ${r}.`);
          const c = s;
          this.n.add(c);
          const l = r === undefined ? s : r;
          const u = {
            elevationRequired: n ? this.isPortPrivileged(l) : false
          };
          const d = {
            remoteAddress: {
              host: i,
              port: s
            },
            localAddressPort: r,
            privacy: o,
            public: o ? o !== nf.Private : undefined,
            protocol: a
          };
          const f = e.forwardPort(d, u);
          if (f) {
            this.y(i, s, f);
            f.finally(() => {
              this.q.trace("ForwardedPorts: (TunnelService) Tunnel created by provider.");
              this.n.delete(c);
            });
          } else {
            this.n.delete(c);
          }
          return f;
        }
      };
      cf = __decorate([__param(0, V), __param(1, Je)], cf);
    }
  });
  var bM;
  var Z8;
  var jr;
  var lf;
  var yM = g({
    "out-build/vs/platform/remote/common/remoteAuthorityResolver.js"() {
      "use strict";
  
      $e();
      Y();
      bM = q("remoteAuthorityResolverService");
      (function (t) {
        t[t.WebSocket = 0] = "WebSocket";
        t[t.Managed = 1] = "Managed";
      })(Z8 ||= {});
      (function (t) {
        t.Unknown = "Unknown";
        t.NotAvailable = "NotAvailable";
        t.TemporarilyNotAvailable = "TemporarilyNotAvailable";
        t.NoResolverFound = "NoResolverFound";
        t.InvalidAuthority = "InvalidAuthority";
      })(jr ||= {});
      lf = class Bn extends Vs {
        static isNotAvailable(e) {
          return e instanceof Bn && e._code === jr.NotAvailable;
        }
        static isTemporarilyNotAvailable(e) {
          return e instanceof Bn && e._code === jr.TemporarilyNotAvailable;
        }
        static isNoResolverFound(e) {
          return e instanceof Bn && e._code === jr.NoResolverFound;
        }
        static isInvalidAuthority(e) {
          return e instanceof Bn && e._code === jr.InvalidAuthority;
        }
        static isHandled(e) {
          return e instanceof Bn && e.isHandled;
        }
        constructor(e, i = jr.Unknown, s) {
          super(e);
          this._message = e;
          this._code = i;
          this._detail = s;
          this.isHandled = i === jr.NotAvailable && s === true;
          Object.setPrototypeOf(this, Bn.prototype);
        }
      };
    }
  });
  function n0(t) {
    switch (t) {
      case 1:
        return "Management";
      case 2:
        return "ExtensionHost";
      case 3:
        return "Tunnel";
    }
  }
  function Y8(t) {
    const e = new ns();
    setTimeout(() => e.cancel(), t);
    return e.token;
  }
  function SM(t, e) {
    if (t.isCancellationRequested || e.isCancellationRequested) {
      return We.Cancelled;
    }
    const i = new ns();
    t.onCancellationRequested(() => i.cancel());
    e.onCancellationRequested(() => i.cancel());
    return i.token;
  }
  function EM(t, e) {
    const i = new hf(e);
    i.registerDisposable(t.onControlMessage(s => {
      const r = JSON.parse(s.toString());
      const n = IM(r);
      if (n) {
        i.reject(n);
      } else {
        i.resolve(r);
      }
    }));
    return i.promise;
  }
  function kM(t, e, i, s, r, n, o, a) {
    const c = new hf(a);
    const l = Jr.create(false);
    t.info(`Creating a socket (${o})...`);
    Ne(`code/willCreateSocket/${n}`);
    e.connect(i, s, r, o).then(u => {
      if (c.didTimeout) {
        Ne(`code/didCreateSocketError/${n}`);
        t.info(`Creating a socket (${o}) finished after ${l.elapsed()} ms, but this is too late and has timed out already.`);
        u?.dispose();
      } else {
        Ne(`code/didCreateSocketOK/${n}`);
        t.info(`Creating a socket (${o}) was successful after ${l.elapsed()} ms.`);
        c.resolve(u);
      }
    }, u => {
      Ne(`code/didCreateSocketError/${n}`);
      t.info(`Creating a socket (${o}) returned an error after ${l.elapsed()} ms.`);
      t.error(u);
      c.reject(u);
    });
    return c.promise;
  }
  function o0(t, e) {
    const i = new hf(e);
    t.then(s => {
      if (!i.didTimeout) {
        i.resolve(s);
      }
    }, s => {
      if (!i.didTimeout) {
        i.reject(s);
      }
    });
    return i.promise;
  }
  async function xM(t, e, i, s) {
    const r = e3(t, e);
    t.logService.trace(`${r} 1/6. invoking socketFactory.connect().`);
    let n;
    try {
      n = await kM(t.logService, t.remoteSocketFactoryService, t.connectTo, Ep.getServerRootPath(), `reconnectionToken=${t.reconnectionToken}&reconnection=${t.reconnectionProtocol ? "true" : "false"}`, n0(e), `renderer-${n0(e)}-${t.reconnectionToken}`, s);
    } catch (u) {
      t.logService.error(`${r} socketFactory.connect() failed or timed out. Error:`);
      t.logService.error(u);
      throw u;
    }
    t.logService.trace(`${r} 2/6. socketFactory.connect() was successful.`);
    let o;
    let a;
    if (t.reconnectionProtocol) {
      t.reconnectionProtocol.beginAcceptReconnection(n, null);
      o = t.reconnectionProtocol;
      a = false;
    } else {
      o = new Ib({
        socket: n
      });
      a = true;
    }
    t.logService.trace(`${r} 3/6. sending AuthRequest control message.`);
    const c = await o0(t.signService.createNewMessage(ti()), s);
    const l = {
      type: "auth",
      auth: t.connectionToken || "00000000000000000000",
      data: c.data
    };
    o.sendControl(z.fromString(JSON.stringify(l)));
    try {
      const u = await EM(o, SM(s, Y8(10000)));
      if (u.type !== "sign" || typeof u.data != "string") {
        const w = new Error("Unexpected handshake message");
        w.code = "VSCODE_CONNECTION_ERROR";
        throw w;
      }
      t.logService.trace(`${r} 4/6. received SignRequest control message.`);
      if (!(await o0(t.signService.validate(c, u.signedData), s))) {
        const w = new Error("Refused to connect to unsupported server");
        w.code = "VSCODE_CONNECTION_ERROR";
        throw w;
      }
      const f = await o0(t.signService.sign(u.data), s);
      const p = {
        type: "connectionType",
        commit: t.commit,
        signedData: f,
        desiredConnectionType: e
      };
      if (i) {
        p.args = i;
      }
      t.logService.trace(`${r} 5/6. sending ConnectionTypeRequest control message.`);
      o.sendControl(z.fromString(JSON.stringify(p)));
      return {
        protocol: o,
        ownsProtocol: a
      };
    } catch (u) {
      if (u && u.code === "ETIMEDOUT") {
        t.logService.error(`${r} the handshake timed out. Error:`);
        t.logService.error(u);
      }
      if (u && u.code === "VSCODE_CONNECTION_ERROR") {
        t.logService.error(`${r} received error control message when negotiating connection. Error:`);
        t.logService.error(u);
      }
      if (a) {
        Q8(o);
      }
      throw u;
    }
  }
  async function DM(t, e, i) {
    const s = Date.now();
    const r = e3(t, 3);
    const {
      protocol: n
    } = await xM(t, 3, e, i);
    t.logService.trace(`${r} 6/6. handshake finished, connection is up and running after ${_M(s)}!`);
    return n;
  }
  async function X8(t, e, i) {
    const {
      connectTo: s,
      connectionToken: r
    } = await t.addressProvider.getAddress();
    return {
      commit: t.commit,
      quality: t.quality,
      connectTo: s,
      connectionToken: r,
      reconnectionToken: e,
      reconnectionProtocol: i,
      remoteSocketFactoryService: t.remoteSocketFactoryService,
      signService: t.signService,
      logService: t.logService
    };
  }
  async function PM(t, e, i) {
    const s = await X8(t, ti(), null);
    return await DM(s, {
      host: e,
      port: i
    }, We.None);
  }
  function $M(t) {
    return Qn(e => new Promise((i, s) => {
      const r = setTimeout(i, t * 1000);
      e.onCancellationRequested(() => {
        clearTimeout(r);
        i();
      });
    }));
  }
  function Q8(t) {
    try {
      t.acceptDisconnect();
      const e = t.getSocket();
      t.dispose();
      e.dispose();
    } catch (e) {
      Ft(e);
    }
  }
  function IM(t) {
    if (t && t.type === "error") {
      const e = new Error(`Connection error: ${t.reason}`);
      e.code = "VSCODE_CONNECTION_ERROR";
      return e;
    }
    return null;
  }
  function AM(t, e) {
    while (t.length < e) {
      t += " ";
    }
    return t;
  }
  function CM(t, e) {
    return `[remote-connection][${AM(n0(t), 13)}][${e.substr(0, 5)}\u2026]`;
  }
  function uf(t, e, i) {
    return `${CM(t, e)}[${i ? "reconnect" : "initial"}]`;
  }
  function e3(t, e) {
    return `${uf(e, t.reconnectionToken, !!t.reconnectionProtocol)}[${t.connectTo}]`;
  }
  function _M(t) {
    return `${Date.now() - t} ms`;
  }
  var t3;
  var i3;
  var hf;
  var s3;
  var r3;
  var n3;
  var o3;
  var a0;
  var a3;
  var RM;
  var OM = g({
    "out-build/vs/platform/remote/common/remoteAgentConnection.js"() {
      "use strict";
  
      ce();
      Ze();
      At();
      $e();
      B();
      M();
      Ie();
      Hs();
      Kn();
      _i();
      Ab();
      yM();
      Wg();
      t3 = 30000;
      (function (t) {
        t[t.Management = 1] = "Management";
        t[t.ExtensionHost = 2] = "ExtensionHost";
        t[t.Tunnel = 3] = "Tunnel";
      })(i3 ||= {});
      hf = class {
        get didTimeout() {
          return this.c === "timedout";
        }
        constructor(t) {
          this.c = "pending";
          this.d = new De();
          ({
            promise: this.promise,
            resolve: this.f,
            reject: this.g
          } = tk());
          if (t.isCancellationRequested) {
            this.h();
          } else {
            this.d.add(t.onCancellationRequested(() => this.h()));
          }
        }
        registerDisposable(t) {
          if (this.c === "pending") {
            this.d.add(t);
          } else {
            t.dispose();
          }
        }
        h() {
          if (this.c === "pending") {
            this.d.dispose();
            this.c = "timedout";
            this.g(this.i());
          }
        }
        i() {
          const t = new Error("Time limit reached");
          t.code = "ETIMEDOUT";
          t.syscall = "connect";
          return t;
        }
        resolve(t) {
          if (this.c === "pending") {
            this.d.dispose();
            this.c = "resolved";
            this.f(t);
          }
        }
        reject(t) {
          if (this.c === "pending") {
            this.d.dispose();
            this.c = "rejected";
            this.g(t);
          }
        }
      };
      (function (t) {
        t[t.ConnectionLost = 0] = "ConnectionLost";
        t[t.ReconnectionWait = 1] = "ReconnectionWait";
        t[t.ReconnectionRunning = 2] = "ReconnectionRunning";
        t[t.ReconnectionPermanentFailure = 3] = "ReconnectionPermanentFailure";
        t[t.ConnectionGain = 4] = "ConnectionGain";
      })(s3 ||= {});
      r3 = class {
        constructor(t, e) {
          this.reconnectionToken = t;
          this.millisSinceLastIncomingData = e;
          this.type = 0;
        }
      };
      n3 = class {
        constructor(t, e, i, s) {
          this.reconnectionToken = t;
          this.millisSinceLastIncomingData = e;
          this.durationSeconds = i;
          this.c = s;
          this.type = 1;
        }
        skipWait() {
          this.c.cancel();
        }
      };
      o3 = class {
        constructor(t, e, i) {
          this.reconnectionToken = t;
          this.millisSinceLastIncomingData = e;
          this.attempt = i;
          this.type = 2;
        }
      };
      a0 = class {
        constructor(t, e, i) {
          this.reconnectionToken = t;
          this.millisSinceLastIncomingData = e;
          this.attempt = i;
          this.type = 4;
        }
      };
      a3 = class {
        constructor(t, e, i, s) {
          this.reconnectionToken = t;
          this.millisSinceLastIncomingData = e;
          this.attempt = i;
          this.handled = s;
          this.type = 3;
        }
      };
      RM = class hr extends T {
        static triggerPermanentFailure(e, i, s) {
          this._permanentFailure = true;
          this.f = e;
          this.g = i;
          this.h = s;
          this.j.forEach(r => r.F(this.f, this.g, this.h));
        }
        static debugTriggerReconnection() {
          this.j.forEach(e => e.w());
        }
        static debugPauseSocketWriting() {
          this.j.forEach(e => e.G());
        }
        static {
          this._permanentFailure = false;
        }
        static {
          this.f = 0;
        }
        static {
          this.g = 0;
        }
        static {
          this.h = false;
        }
        static {
          this.j = [];
        }
        get n() {
          return this.c || hr._permanentFailure;
        }
        constructor(e, i, s, r, n) {
          super();
          this.s = e;
          this.t = i;
          this.reconnectionToken = s;
          this.protocol = r;
          this.u = n;
          this.m = this.D(new $());
          this.onDidStateChange = this.m.event;
          this.c = false;
          this.q = false;
          this.r = false;
          this.m.fire(new a0(this.reconnectionToken, 0, 0));
          this.D(r.onSocketClose(o => {
            const a = uf(this.s, this.reconnectionToken, true);
            if (o) {
              if (o.type === 0) {
                this.t.logService.info(`${a} received socket close event (hadError: ${o.hadError}).`);
                if (o.error) {
                  this.t.logService.error(o.error);
                }
              } else {
                this.t.logService.info(`${a} received socket close event (wasClean: ${o.wasClean}, code: ${o.code}, reason: ${o.reason}).`);
                if (o.event) {
                  this.t.logService.error(o.event);
                }
              }
            } else {
              this.t.logService.info(`${a} received socket close event.`);
            }
            this.w();
          }));
          this.D(r.onSocketTimeout(o => {
            const a = uf(this.s, this.reconnectionToken, true);
            this.t.logService.info(`${a} received socket timeout event (unacknowledgedMsgCount: ${o.unacknowledgedMsgCount}, timeSinceOldestUnacknowledgedMsg: ${o.timeSinceOldestUnacknowledgedMsg}, timeSinceLastReceivedSomeData: ${o.timeSinceLastReceivedSomeData}).`);
            this.w();
          }));
          hr.j.push(this);
          this.D(xe(() => {
            const o = hr.j.indexOf(this);
            if (o >= 0) {
              hr.j.splice(o, 1);
            }
          }));
          if (this.n) {
            this.F(hr.f, hr.g, hr.h);
          }
        }
        dispose() {
          super.dispose();
          this.r = true;
        }
        async w() {
          if (!this.q) {
            try {
              this.q = true;
              await this.z();
            } finally {
              this.q = false;
            }
          }
        }
        y() {
          const e = this.getRemoteAuthority();
          return !!e && Bh(e) !== undefined;
        }
        async z() {
          if (this.n || this.r) {
            return;
          }
          const e = uf(this.s, this.reconnectionToken, true);
          this.t.logService.info(`${e} starting reconnecting loop. You can get more information with the trace log level.`);
          this.m.fire(new r3(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData()));
          const i = [0, 5, 5, 10, 10, 10, 10, 10, 30];
          let s = -1;
          do {
            s++;
            const r = s < i.length ? i[s] : i[i.length - 1];
            try {
              if (r > 0) {
                const o = $M(r);
                this.m.fire(new n3(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), r, o));
                this.t.logService.info(`${e} waiting for ${r} seconds before reconnecting...`);
                try {
                  await o;
                } catch {}
              }
              if (this.n) {
                this.t.logService.error(`${e} permanent failure occurred while running the reconnecting loop.`);
                break;
              }
              this.m.fire(new o3(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), s + 1));
              this.t.logService.info(`${e} resolving connection...`);
              const n = await X8(this.t, this.reconnectionToken, this.protocol);
              this.t.logService.info(`${e} connecting to ${n.connectTo}...`);
              await this.H(n, Y8(t3));
              this.t.logService.info(`${e} reconnected!`);
              this.m.fire(new a0(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), s + 1));
              break;
            } catch (n) {
              const o = this.y();
              if (n.code === "VSCODE_CONNECTION_ERROR") {
                this.t.logService.error(`${e} A permanent error occurred in the reconnecting loop! Will give up now! Error:`);
                this.t.logService.error(n);
                if (o) {
                  this.t.logService.info(`${e} A permanent error occurred in the reconnecting loop! For background composer, we should ideally try to reconnect, but we're not doing that for now...`);
                }
                this.C(this.protocol.getMillisSinceLastIncomingData(), s + 1, false);
                break;
              }
              if (s > 360 && !o) {
                this.t.logService.error(`${e} An error occurred while reconnecting, but it will be treated as a permanent error because the reconnection grace time has expired! Will give up now! Error:`);
                this.t.logService.error(n);
                this.C(this.protocol.getMillisSinceLastIncomingData(), s + 1, false);
                break;
              }
              if (lf.isTemporarilyNotAvailable(n)) {
                this.t.logService.info(`${e} A temporarily not available error occurred while trying to reconnect, will try again...`);
                this.t.logService.trace(n);
                continue;
              }
              if ((n.code === "ETIMEDOUT" || n.code === "ENETUNREACH" || n.code === "ECONNREFUSED" || n.code === "ECONNRESET") && n.syscall === "connect") {
                this.t.logService.info(`${e} A network error occurred while trying to reconnect, will try again...`);
                this.t.logService.trace(n);
                continue;
              }
              if (Nl(n)) {
                this.t.logService.info(`${e} A promise cancelation error occurred while trying to reconnect, will try again...`);
                this.t.logService.trace(n);
                continue;
              }
              if (n instanceof lf) {
                this.t.logService.error(`${e} A RemoteAuthorityResolverError occurred while trying to reconnect. Will give up now! Error:`);
                this.t.logService.error(n);
                if (o) {
                  this.t.logService.info(`${e} A RemoteAuthorityResolverError occurred while trying to reconnect. For background composer, we should ideally try to reconnect, but we're not doing that for now...`);
                }
                this.C(this.protocol.getMillisSinceLastIncomingData(), s + 1, lf.isHandled(n));
                break;
              }
              this.t.logService.error(`${e} An unknown error occurred while trying to reconnect, since this is an unknown case, it will be treated as a permanent error! Will give up now! Error:`);
              this.t.logService.error(n);
              if (o) {
                if ("_code" in n && n._code === "TemporarilyNotAvailable" || "code" in n && n.code === "TemporarilyNotAvailable") {
                  this.t.logService.info(`${e} Temporarily not available error in background composer, will try again...`);
                  continue;
                }
                this.t.logService.info(`${e} An unknown error occurred while trying to reconnect. For background composer, we should ideally try to reconnect, but we're not doing that for now...`);
              }
              this.C(this.protocol.getMillisSinceLastIncomingData(), s + 1, false);
              break;
            }
          } while (!this.n && !this.r);
        }
        C(e, i, s) {
          if (this.u) {
            hr.triggerPermanentFailure(e, i, s);
          } else {
            this.F(e, i, s);
          }
        }
        F(e, i, s) {
          this.m.fire(new a3(this.reconnectionToken, e, i, s));
          Q8(this.protocol);
        }
        G() {
          this.protocol.pauseSocketWriting();
        }
      };
    }
  });
  var df;
  var LM = g({
    "out-build/vs/platform/remote/common/remoteSocketFactoryService.js"() {
      "use strict";
  
      M();
      Y();
      df = q("remoteSocketFactoryService");
    }
  });
  import * as MM from "net";
  import * as FM from "os";
  async function NM(t, e, i, s, r) {
    let n;
    for (let o = 3; o && (n?.dispose(), n = await new c3(t, e, i, s, r).waitForReady(), (!r || !Cg[r]) && !!Cg[n.tunnelLocalPort]); o--);
    return n;
  }
  var c3;
  var ff;
  var ml;
  var c0;
  var WM = g({
    "out-build/vs/platform/tunnel/node/tunnelService.js"() {
      "use strict";
  
      O2();
      Vp();
      ce();
      M();
      H();
      Ke();
      X();
      ht();
      OM();
      LM();
      Hg();
      K8();
      Ze();
      c3 = class extends T {
        constructor(t, e, i, s, r) {
          super();
          this.m = e;
          this.n = r;
          this.privacy = nf.Private;
          this.j = new Map();
          this.a = t;
          this.b = MM.createServer();
          this.c = new Ga();
          this.f = () => this.c.open();
          this.b.on("listening", this.f);
          this.g = n => this.q(n);
          this.b.on("connection", this.g);
          this.h = () => {};
          this.b.on("error", this.h);
          this.tunnelRemotePort = s;
          this.tunnelRemoteHost = i;
        }
        async dispose() {
          super.dispose();
          this.b.removeListener("listening", this.f);
          this.b.removeListener("connection", this.g);
          this.b.removeListener("error", this.h);
          this.b.close();
          Array.from(this.j.values()).forEach(e => {
            e();
          });
        }
        async waitForReady() {
          const t = this.n ?? this.tunnelRemotePort;
          const e = gl(this.m) ? "0.0.0.0" : "127.0.0.1";
          let i = await x$(t, 2, 1000, e);
          let s = null;
          this.b.listen(i, this.m);
          await this.c.wait();
          s = this.b.address();
          if (!s) {
            i = 0;
            this.b.listen(i, this.m);
            await this.c.wait();
            s = this.b.address();
          }
          this.tunnelLocalPort = s.port;
          this.localAddress = `${this.tunnelRemoteHost === "127.0.0.1" ? "127.0.0.1" : "localhost"}:${s.port}`;
          return this;
        }
        async q(t) {
          t.pause();
          const e = r0(this.tunnelRemoteHost) || gl(this.tunnelRemoteHost) ? "localhost" : this.tunnelRemoteHost;
          const i = await PM(this.a, e, this.tunnelRemotePort);
          const s = i.getSocket();
          const r = i.readEntireBuffer();
          i.dispose();
          if (r.byteLength > 0) {
            t.write(r.buffer);
          }
          t.on("end", () => {
            if (t.localAddress) {
              this.j.delete(t.localAddress);
            }
            s.end();
          });
          t.on("close", () => s.end());
          t.on("error", () => {
            if (t.localAddress) {
              this.j.delete(t.localAddress);
            }
            if (s instanceof Qa) {
              s.socket.destroy();
            } else {
              s.end();
            }
          });
          if (s instanceof Qa) {
            this.s(t, s);
          } else {
            this.r(t, s);
          }
          if (t.localAddress) {
            this.j.set(t.localAddress, () => {
              t.end();
              s.end();
            });
          }
        }
        r(t, e) {
          e.onClose(() => t.destroy());
          e.onEnd(() => t.end());
          e.onData(i => t.write(i.buffer));
          t.on("data", i => e.write(z.wrap(i)));
          t.resume();
        }
        s(t, e) {
          const i = e.socket;
          i.on("end", () => t.end());
          i.on("close", () => t.end());
          i.on("error", () => {
            t.destroy();
          });
          i.pipe(t);
          t.pipe(i);
        }
      };
      ff = class extends cf {
        constructor(e, i, s, r, n) {
          super(i, n);
          this.H = e;
          this.I = s;
          this.J = r;
        }
        isPortPrivileged(e) {
          return wM(e, this.s, Wi, FM.release());
        }
        F(e, i, s, r, n, o, a, c) {
          const l = this.C(i, s);
          if (l) {
            ++l.refcount;
            return l.value;
          }
          if (gM(e)) {
            return this.G(e, i, s, n, o, a, c);
          }
          {
            this.q.trace(`ForwardedPorts: (TunnelService) Creating tunnel without provider ${i}:${s} on local port ${n}.`);
            const u = {
              commit: this.J.commit,
              quality: this.J.quality,
              addressProvider: e,
              remoteSocketFactoryService: this.H,
              signService: this.I,
              logService: this.q,
              ipcLogger: null
            };
            const d = NM(u, r, i, s, n);
            this.q.trace("ForwardedPorts: (TunnelService) Tunnel created without provider.");
            this.y(i, s, d);
            return d;
          }
        }
      };
      ff = __decorate([__param(0, df), __param(1, V), __param(2, zo), __param(3, Ve), __param(4, Je)], ff);
      ml = class extends ff {
        constructor(e, i, s, r, n) {
          super(e, i, s, r, n);
        }
      };
      ml = __decorate([__param(0, df), __param(1, V), __param(2, zo), __param(3, Ve), __param(4, Je)], ml);
      c0 = class extends T {
        constructor(e, i, s, r, n) {
          super();
          this.b = e;
          this.c = i;
          this.f = s;
          this.g = r;
          this.h = n;
          this.a = new Map();
        }
        async openTunnel(e, i, s, r, n, o, a, c, l) {
          this.c.trace(`ForwardedPorts: (SharedTunnelService) openTunnel request for ${s}:${r} on local port ${o}.`);
          if (!this.a.has(e)) {
            const u = new ml(this.b, this.c, this.g, this.f, this.h);
            this.D(u);
            this.a.set(e, u);
            u.onTunnelClosed(async () => {
              if ((await u.tunnels).length === 0) {
                u.dispose();
                this.a.delete(e);
              }
            });
          }
          return this.a.get(e).openTunnel(i, s, r, n, o, a, c, l);
        }
      };
      c0 = __decorate([__param(0, df), __param(1, V), __param(2, Ve), __param(3, zo), __param(4, Je)], c0);
    }
  });
  import { parse as l3 } from "url";
  function TM(t, e) {
    if (t.protocol === "http:") {
      return e.HTTP_PROXY || e.http_proxy || null;
    } else {
      return t.protocol === "https:" && (e.HTTPS_PROXY || e.https_proxy || e.HTTP_PROXY || e.http_proxy) || null;
    }
  }
  async function jM(t, e, i = {}) {
    const s = l3(t);
    const r = i.proxyUrl || TM(s, e);
    if (!r) {
      return null;
    }
    const n = l3(r);
    if (!/^https?:$/.test(n.protocol || "")) {
      return null;
    }
    const o = {
      host: n.hostname || "",
      port: (n.port ? +n.port : 0) || (n.protocol === "https" ? 443 : 80),
      auth: n.auth,
      rejectUnauthorized: Tw(i.strictSSL) ? i.strictSSL : true
    };
    if (s.protocol === "http:") {
      const {
        default: a
      } = await import("http-proxy-agent");
      return new a.HttpProxyAgent(r, o);
    } else {
      const {
        default: a
      } = await import("https-proxy-agent");
      return new a.HttpsProxyAgent(r, o);
    }
  }
  var UM = g({
    "out-build/vs/platform/request/node/proxy.js"() {
      "use strict";
  
      _e();
    }
  });
  import { parse as u3 } from "url";
  import { createGunzip as BM } from "zlib";
  async function qM(t, e, i, s) {
    const r = await import("kerberos");
    const n = r.default || r;
    const o = new URL(t);
    const a = e || (process.platform === "win32" ? `HTTP/${o.hostname}` : `HTTP@${o.hostname}`);
    i.debug(`${s} Kerberos authentication lookup`, `proxyURL:${o}`, `spn:${a}`);
    return (await n.initializeClient(a)).step("");
  }
  async function zM(t) {
    return (u3(t.url).protocol === "https:" ? await import("https") : await import("http")).request;
  }
  async function l0(t, e) {
    return Tt.withAsyncBody(async (i, s) => {
      const r = u3(t.url);
      const n = t.getRawRequest ? t.getRawRequest(t) : await zM(t);
      const o = {
        hostname: r.hostname,
        port: r.port ? parseInt(r.port) : r.protocol === "https:" ? 443 : 80,
        protocol: r.protocol,
        path: r.path,
        method: t.type || "GET",
        headers: t.headers,
        agent: t.agent,
        rejectUnauthorized: Tw(t.strictSSL) ? t.strictSSL : true
      };
      if (t.user && t.password) {
        o.auth = t.user + ":" + t.password;
      }
      const a = n(o, c => {
        const l = Hl(t.followRedirects) ? t.followRedirects : 3;
        if (c.statusCode && c.statusCode >= 300 && c.statusCode < 400 && l > 0 && c.headers.location) {
          if (c.statusCode === 303) {
            l0({
              ...t,
              url: c.headers.location,
              type: "GET",
              followRedirects: l - 1
            }, e).then(i, s);
          } else {
            l0({
              ...t,
              url: c.headers.location,
              followRedirects: l - 1
            }, e).then(i, s);
          }
        } else {
          let u = c;
          if (!t.isChromiumNetwork && c.headers["content-encoding"] === "gzip") {
            u = c.pipe(BM());
          }
          i({
            res: c,
            stream: jk(u)
          });
        }
      });
      a.on("error", s);
      if (t.timeout) {
        a.setTimeout(t.timeout);
      }
      if (t.isChromiumNetwork) {
        a.removeHeader("Content-Length");
      }
      if (t.data && typeof t.data == "string") {
        a.write(t.data);
      }
      a.end();
      e.onCancellationRequested(() => {
        a.abort();
        s(new hi());
      });
    });
  }
  var pf;
  var HM = g({
    "out-build/vs/platform/request/node/requestService.js"() {
      "use strict";
  
      ce();
      Ze();
      $e();
      _e();
      Ke();
      Ri();
      cg();
      X();
      En();
      UM();
      pf = class extends N2 {
        constructor(e, i, s) {
          super(s);
          this.m = e;
          this.n = i;
          this.q();
          this.D(e.onDidChangeConfiguration(r => {
            if (r.affectsConfiguration("http")) {
              this.q();
            }
          }));
        }
        q() {
          const e = this.m.getValue("http");
          this.f = e?.proxy;
          this.g = !!e?.proxyStrictSSL;
          this.h = e?.proxyAuthorization;
        }
        async request(e, i) {
          const {
            f: s,
            g: r
          } = this;
          let n;
          try {
            n = await ag(this.m, this.b, this.n.args, process.env);
          } catch (c) {
            if (!this.j) {
              this.j = true;
              this.b.error("resolving shell environment failed", Vi(c));
            }
          }
          const o = {
            ...process.env,
            ...n
          };
          const a = e.agent ? e.agent : await jM(e.url || "", o, {
            proxyUrl: s,
            strictSSL: r
          });
          e.agent = a;
          e.strictSSL = r;
          if (this.h) {
            e.headers = {
              ...(e.headers || {}),
              "Proxy-Authorization": this.h
            };
          }
          return this.c(e, () => l0(e, i));
        }
        async resolveProxy(e) {}
        async lookupAuthorization(e) {}
        async lookupKerberosAuthorization(e) {
          try {
            const i = this.m.getValue("http.proxyKerberosServicePrincipal");
            return "Negotiate " + (await qM(e, i, this.b, "RequestService#lookupKerberosAuthorization"));
          } catch (i) {
            this.b.debug("RequestService#lookupKerberosAuthorization Kerberos authentication failed", i);
            return;
          }
        }
        async loadCertificates() {
          return (await import("@vscode/proxy-agent")).loadSystemCertificates({
            log: this.b
          });
        }
      };
      pf = __decorate([__param(0, Je), __param(1, tr), __param(2, V)], pf);
    }
  });
  import { net as VM } from "electron";
  function GM(t) {
    return VM.request;
  }
  var h3;
  var JM = g({
    "out-build/vs/platform/request/electron-utility/requestService.js"() {
      "use strict";
  
      HM();
      h3 = class extends pf {
        request(t, e) {
          return super.request({
            ...(t || {}),
            getRawRequest: GM,
            isChromiumNetwork: true
          }, e);
        }
      };
    }
  });
  var d3;
  var KM = g({
    "out-build/vs/platform/sign/common/abstractSignService.js"() {
      "use strict";
  
      d3 = class fS {
        constructor() {
          this.b = new Map();
        }
        static {
          this.a = 1;
        }
        async createNewMessage(e) {
          try {
            const i = await this.c();
            if (i) {
              const s = String(fS.a++);
              this.b.set(s, i);
              return {
                id: s,
                data: i.createNewMessage(e)
              };
            }
          } catch {}
          return {
            id: "",
            data: e
          };
        }
        async validate(e, i) {
          if (!e.id) {
            return true;
          }
          const s = this.b.get(e.id);
          if (!s) {
            return false;
          }
          this.b.delete(e.id);
          try {
            return s.validate(i) === "ok";
          } catch {
            return false;
          } finally {
            s.dispose?.();
          }
        }
        async sign(e) {
          try {
            return await this.d(e);
          } catch {}
          return e;
        }
      };
    }
  });
  var f3;
  var ZM = g({
    "out-build/vs/platform/sign/node/signService.js"() {
      "use strict";
  
      KM();
      f3 = class extends d3 {
        c() {
          return this.h().then(t => new t.validator());
        }
        d(t) {
          return this.h().then(e => new e.signer().sign(t));
        }
        async h() {
          const t = "vsda";
          const {
            default: e
          } = await import(t);
          return e;
        }
      };
    }
  });
  var gf;
  var YM = g({
    "out-build/vs/platform/policy/node/nativePolicyService.js"() {
      "use strict";
  
      Ls();
      ce();
      M();
      X();
      gf = class extends jg {
        constructor(e, i) {
          super();
          this.m = e;
          this.n = i;
          this.a = new Ap();
          this.b = this.D(new pr());
        }
        async j(e) {
          this.m.trace(`NativePolicyService#_updatePolicyDefinitions - Found ${Object.keys(e).length} policy definitions`);
          const {
            createWatcher: i
          } = await import("@vscode/policy-watcher");
          await this.a.queue(() => new Promise((s, r) => {
            try {
              this.b.value = i(this.n, e, n => {
                this.s(n);
                s();
              });
            } catch (n) {
              this.m.error("NativePolicyService#_updatePolicyDefinitions - Error creating watcher:", n);
              r(n);
            }
          }));
        }
        s(e) {
          this.m.trace(`NativePolicyService#_onDidPolicyChange - Updated policy values: ${JSON.stringify(e)}`);
          for (const i in e) {
            const s = e[i];
            if (s === undefined) {
              this.g.delete(i);
            } else {
              this.g.set(i, s);
            }
          }
          this.h.fire(Object.keys(e));
        }
      };
      gf = __decorate([__param(0, V)], gf);
    }
  });
  function XM(t, e) {
    const i = [];
    for (const s of new Set(Vr.concat(t.keys(), e.keys()))) {
      if (t.get(s) !== e.get(s)) {
        i.push(s);
      }
    }
    return i;
  }
  var mf;
  var QM = g({
    "out-build/vs/platform/policy/common/filePolicyService.js"() {
      "use strict";
  
      ce();
      B();
      Bl();
      _e();
      He();
      X();
      Ls();
      mf = class extends jg {
        constructor(e, i, s) {
          super();
          this.m = e;
          this.n = i;
          this.q = s;
          this.c = this.D(new Ys(500));
          const r = x.filter(i.onDidFilesChange, n => n.affects(e));
          this.D(i.watch(e));
          this.D(r(() => this.c.trigger(() => this.u())));
        }
        async j() {
          await this.u();
        }
        async t() {
          const e = new Map();
          try {
            const i = await this.n.readFile(this.m);
            const s = JSON.parse(i.value.toString());
            if (!Nt(s)) {
              throw new Error("Policy file isn't a JSON object");
            }
            for (const r of Object.keys(s)) {
              if (this.f[r]) {
                e.set(r, s[r]);
              }
            }
          } catch (i) {
            if (i.fileOperationResult !== 1) {
              this.q.error("[FilePolicyService] Failed to read policies", i);
            }
          }
          return e;
        }
        async u() {
          const e = await this.t();
          const i = XM(this.g, e);
          this.g = e;
          if (i.length > 0) {
            this.h.fire(i);
          }
        }
      };
      mf = __decorate([__param(1, at), __param(2, V)], mf);
    }
  });
  function eF(t, e, i) {
    if (!(e instanceof ue)) {
      e = new ue(e, [], !!i);
    }
    p3.push([t, e]);
  }
  var p3;
  var g3;
  var tF = g({
    "out-build/vs/platform/instantiation/common/extensions.js"() {
      "use strict";
  
      Ah();
      p3 = [];
      (function (t) {
        t[t.Eager = 0] = "Eager";
        t[t.Delayed = 1] = "Delayed";
      })(g3 ||= {});
    }
  });
  var m3;
  var wf;
  var la;
  var w3;
  var iF = g({
    "out-build/vs/base/common/skipList.js"() {
      "use strict";
  
      wf = class {
        constructor(t, e, i) {
          this.level = t;
          this.key = e;
          this.value = i;
          this.forward = [];
        }
      };
      la = undefined;
      w3 = class da {
        constructor(e, i = 65536) {
          this.comparator = e;
          this[m3] = "SkipList";
          this.d = 0;
          this.f = 0;
          this.c = Math.max(1, Math.log2(i) | 0);
          this.e = new wf(this.c, la, la);
        }
        get size() {
          return this.f;
        }
        clear() {
          this.e = new wf(this.c, la, la);
          this.f = 0;
        }
        has(e) {
          return !!da.g(this, e, this.comparator);
        }
        get(e) {
          return da.g(this, e, this.comparator)?.value;
        }
        set(e, i) {
          if (da.h(this, e, i, this.comparator)) {
            this.f += 1;
          }
          return this;
        }
        delete(e) {
          const i = da.k(this, e, this.comparator);
          if (i) {
            this.f -= 1;
          }
          return i;
        }
        forEach(e, i) {
          let s = this.e.forward[0];
          while (s) {
            e.call(i, s.value, s.key, this);
            s = s.forward[0];
          }
        }
        [(m3 = Symbol.toStringTag, Symbol.iterator)]() {
          return this.entries();
        }
        *entries() {
          let e = this.e.forward[0];
          while (e) {
            yield [e.key, e.value];
            e = e.forward[0];
          }
        }
        *keys() {
          let e = this.e.forward[0];
          while (e) {
            yield e.key;
            e = e.forward[0];
          }
        }
        *values() {
          let e = this.e.forward[0];
          while (e) {
            yield e.value;
            e = e.forward[0];
          }
        }
        toString() {
          let e = "[SkipList]:";
          let i = this.e.forward[0];
          while (i) {
            e += `node(${i.key}, ${i.value}, lvl:${i.level})`;
            i = i.forward[0];
          }
          return e;
        }
        static g(e, i, s) {
          let r = e.e;
          for (let n = e.d - 1; n >= 0; n--) {
            while (r.forward[n] && s(r.forward[n].key, i) < 0) {
              r = r.forward[n];
            }
          }
          r = r.forward[0];
          if (r && s(r.key, i) === 0) {
            return r;
          }
        }
        static h(e, i, s, r) {
          const n = [];
          let o = e.e;
          for (let a = e.d - 1; a >= 0; a--) {
            while (o.forward[a] && r(o.forward[a].key, i) < 0) {
              o = o.forward[a];
            }
            n[a] = o;
          }
          o = o.forward[0];
          if (o && r(o.key, i) === 0) {
            o.value = s;
            return false;
          }
          {
            const a = da.j(e);
            if (a > e.d) {
              for (let c = e.d; c < a; c++) {
                n[c] = e.e;
              }
              e.d = a;
            }
            o = new wf(a, i, s);
            for (let c = 0; c < a; c++) {
              o.forward[c] = n[c].forward[c];
              n[c].forward[c] = o;
            }
            return true;
          }
        }
        static j(e, i = 0.5) {
          let s = 1;
          while (Math.random() < i && s < e.c) {
            s += 1;
          }
          return s;
        }
        static k(e, i, s) {
          const r = [];
          let n = e.e;
          for (let o = e.d - 1; o >= 0; o--) {
            while (n.forward[o] && s(n.forward[o].key, i) < 0) {
              n = n.forward[o];
            }
            r[o] = n;
          }
          n = n.forward[0];
          if (!n || s(n.key, i) !== 0) {
            return false;
          }
          for (let o = 0; o < e.d && r[o].forward[o] === n; o++) {
            r[o].forward[o] = n.forward[o];
          }
          while (e.d > 0 && e.e.forward[e.d - 1] === la) {
            e.d -= 1;
          }
          return true;
        }
      };
    }
  });
  var u0;
  var wl;
  var sF = g({
    "out-build/vs/platform/uriIdentity/common/uriIdentityService.js"() {
      "use strict";
  
      As();
      tF();
      He();
      nt();
      iF();
      B();
      M();
      u0 = class P0 {
        static {
          this._clock = 0;
        }
        constructor(e) {
          this.uri = e;
          this.time = P0._clock++;
        }
        touch() {
          this.time = P0._clock++;
          return this;
        }
      };
      wl = class {
        constructor(e) {
          this.g = e;
          this.c = new De();
          this.f = 65536;
          const i = new Map();
          const s = r => {
            let n = i.get(r.scheme);
            if (n === undefined) {
              n = e.hasProvider(r) && !this.g.hasCapability(r, 1024);
              i.set(r.scheme, n);
            }
            return n;
          };
          this.c.add(x.any(e.onDidChangeFileSystemProviderRegistrations, e.onDidChangeFileSystemProviderCapabilities)(r => {
            i.delete(r.scheme);
          }));
          this.extUri = new Va(s);
          this.d = new w3((r, n) => this.extUri.compare(r, n, true), this.f);
        }
        dispose() {
          this.c.dispose();
          this.d.clear();
        }
        asCanonicalUri(e) {
          if (this.g.hasProvider(e)) {
            e = Pp(e);
          }
          const i = this.d.get(e);
          if (i) {
            return i.touch().uri.with({
              fragment: e.fragment
            });
          } else {
            this.d.set(e, new u0(e));
            this.h();
            return e;
          }
        }
        h() {
          if (this.d.size < this.f) {
            return;
          }
          const e = [...this.d.entries()].sort((s, r) => s[1].time < r[1].time ? 1 : s[1].time > r[1].time ? -1 : 0);
          u0._clock = 0;
          this.d.clear();
          const i = this.f * 0.5;
          for (let s = 0; s < i; s++) {
            this.d.set(e[s][0], e[s][1].touch());
          }
        }
      };
      wl = __decorate([__param(0, at)], wl);
      eF(yi, wl, 1);
    }
  });
  var v3;
  var rF = g({
    "out-build/vs/platform/log/common/logService.js"() {
      "use strict";
  
      M();
      X();
      v3 = class extends T {
        constructor(t, e = []) {
          super();
          this.a = new yy([t, ...e]);
          this.D(t.onDidChangeLogLevel(i => this.setLevel(i)));
        }
        get onDidChangeLogLevel() {
          return this.a.onDidChangeLogLevel;
        }
        setLevel(t) {
          this.a.setLevel(t);
        }
        getLevel() {
          return this.a.getLevel();
        }
        trace(t, ...e) {
          this.a.trace(t, ...e);
        }
        debug(t, ...e) {
          this.a.debug(t, ...e);
        }
        info(t, ...e) {
          this.a.info(t, ...e);
        }
        warn(t, ...e) {
          this.a.warn(t, ...e);
        }
        error(t, ...e) {
          this.a.error(t, ...e);
        }
        flush() {
          this.a.flush();
        }
      };
    }
  });
  var b3;
  var nF = g({
    "out-build/vs/platform/userData/common/fileUserDataProvider.js"() {
      "use strict";
  
      B();
      M();
      He();
      go();
      $i();
      b3 = class extends T {
        constructor(t, e, i, s, r, n) {
          super();
          this.f = t;
          this.g = e;
          this.h = i;
          this.j = s;
          this.m = r;
          this.n = n;
          this.capabilities = this.g.capabilities;
          this.onDidChangeCapabilities = this.g.onDidChangeCapabilities;
          this.a = this.D(new $());
          this.onDidChangeFile = this.a.event;
          this.b = Pr.forUris(() => !(this.capabilities & 1024));
          this.c = new Sw(o => this.m.extUri.getComparisonKey(this.s(o)));
          this.q();
          this.D(s.onDidChangeProfiles(() => this.q()));
          this.D(this.g.onDidChangeFile(o => this.r(o)));
        }
        q() {
          this.c.clear();
          for (const t of this.j.profiles) {
            this.c.add(t.settingsResource);
            this.c.add(t.keybindingsResource);
            this.c.add(t.tasksResource);
            this.c.add(t.extensionsResource);
          }
        }
        open(t, e) {
          return this.g.open(this.s(t), e);
        }
        close(t) {
          return this.g.close(t);
        }
        read(t, e, i, s, r) {
          return this.g.read(t, e, i, s, r);
        }
        write(t, e, i, s, r) {
          return this.g.write(t, e, i, s, r);
        }
        watch(t, e) {
          this.b.set(t, t);
          const i = this.g.watch(this.s(t), e);
          return xe(() => {
            this.b.delete(t);
            i.dispose();
          });
        }
        stat(t) {
          return this.g.stat(this.s(t));
        }
        mkdir(t) {
          return this.g.mkdir(this.s(t));
        }
        rename(t, e, i) {
          return this.g.rename(this.s(t), this.s(e), i);
        }
        readFile(t, e) {
          return this.g.readFile(this.s(t), e);
        }
        readFileStream(t, e, i) {
          return this.g.readFileStream(this.s(t), e, i);
        }
        readdir(t) {
          return this.g.readdir(this.s(t));
        }
        enforceAtomicReadFile(t) {
          return this.c.has(t);
        }
        writeFile(t, e, i) {
          return this.g.writeFile(this.s(t), e, i);
        }
        enforceAtomicWriteFile(t) {
          if (this.c.has(t)) {
            return {
              postfix: ".vsctmp"
            };
          } else {
            return false;
          }
        }
        delete(t, e) {
          return this.g.delete(this.s(t), e);
        }
        copy(t, e, i) {
          if (u1(this.g)) {
            return this.g.copy(this.s(t), this.s(e), i);
          }
          throw new Error("copy not supported");
        }
        cloneFile(t, e) {
          if (Ay(this.g)) {
            return this.g.cloneFile(this.s(t), this.s(e));
          }
          throw new Error("clone not supported");
        }
        r(t) {
          const e = [];
          for (const i of t) {
            if (i.resource.scheme !== this.f) {
              continue;
            }
            const s = this.t(i.resource);
            if (this.b.findSubstr(s)) {
              e.push({
                resource: s,
                type: i.type,
                cId: i.cId
              });
            }
          }
          if (e.length) {
            this.n.debug("User data changed");
            this.a.fire(e);
          }
        }
        s(t) {
          return t.with({
            scheme: this.f
          });
        }
        t(t) {
          return t.with({
            scheme: this.h
          });
        }
      };
    }
  });
  function oF() {
    return !qt().enabled;
  }
  function y3(t) {
    if (!oF() && !Nl(t) && !Vs.isErrorNoTelemetry(t)) {
      Mn().captureException(t);
    }
  }
  var aF = g({
    "out-build/vs/platform/tracing/common/tracing.js"() {
      "use strict";
  
      ce();
      $e();
      va();
      Hm();
      if (typeof Symbol.dispose != "symbol") {
        Object.defineProperty(Symbol, "dispose", {
          value: Symbol("Symbol.dispose")
        });
      }
      if (typeof Symbol.asyncDispose != "symbol") {
        Object.defineProperty(Symbol, "asyncDispose", {
          value: Symbol("Symbol.asyncDispose")
        });
      }
    }
  });
  var S3;
  var cF = g({
    "out-build/vs/platform/tracing/common/logger.js"() {
      "use strict";
  
      va();
      aF();
      S3 = class {
        constructor(t) {
          this.a = t;
          this.onDidChangeLogLevel = this.a.onDidChangeLogLevel;
        }
        getLevel() {
          return this.a.getLevel();
        }
        setLevel(t) {
          this.a.setLevel(t);
        }
        trace(t, ...e) {
          this.a.trace(t, ...e);
        }
        debug(t, ...e) {
          this.a.debug(t, ...e);
        }
        info(t, ...e) {
          this.a.info(t, ...e);
        }
        warn(t, ...e) {
          this.a.warn(t, ...e);
        }
        error(t, ...e) {
          this.a.error(t, ...e);
          if (!!qt().enabled && !(Math.random() >= qt().loggerSampleRate)) {
            if (t instanceof Error) {
              y3(t);
              return;
            }
            for (const i of e) {
              if (i instanceof Error) {
                y3(i);
                return;
              }
            }
          }
        }
        flush() {
          this.a.flush();
        }
        dispose() {
          this.a.dispose();
        }
      };
    }
  });
  var lF = {};
  import { app as uF, dialog as hF } from "electron";
  import { unlinkSync as dF, promises as E3 } from "fs";
  var k3;
  var x3;
  var fF = g({
    "out-build/vs/code/electron-main/main.js"() {
      "use strict";
  
      _E();
      se();
      zt();
      ce();
      en();
      $e();
      gi();
      B();
      Sr();
      Ie();
      we();
      Hs();
      H();
      ys();
      Wt();
      _t();
      xs();
      Vp();
      ZL();
      be();
      Ke();
      XL();
      iM();
      vt();
      kc();
      oM();
      He();
      lM();
      kg();
      Ah();
      hM();
      xg();
      ct();
      dM();
      X();
      gc();
      ht();
      Wh();
      pM();
      K8();
      WM();
      En();
      JM();
      Hg();
      ZM();
      Ti();
      $n();
      pc();
      un();
      Ls();
      YM();
      QM();
      M();
      As();
      sF();
      zc();
      rF();
      a5();
      P4();
      nF();
      wa();
      cF();
      k3 = class {
        main() {
          try {
            this.a();
          } catch (t) {
            console.error(t.message);
            uF.exit(1);
          }
        }
        async a() {
          lw(c => console.error(c));
          const [t, e, i, s, r, n, o, a] = this.b();
          try {
            try {
              await this.d(i, a, s, r, o);
            } catch (c) {
              this.g(i, o, c);
              throw c;
            }
            await t.invokeFunction(async c => {
              const l = c.get(V);
              const u = c.get(Te);
              const d = c.get(at);
              const f = c.get(sc);
              const p = await this.f(l, i, u, t, o, true);
              ee.writeFile(i.mainLockfile, String(process.pid)).catch(m => {
                l.warn(`app#startup(): Error writing main lockfile: ${m.stack}`);
              });
              const w = f.createLogger("main", {
                name: v(156, null)
              });
              n.logger = new S3(w);
              x.once(u.onWillShutdown)(m => {
                d.dispose();
                s.dispose();
                m.join("instanceLockfile", E3.unlink(i.mainLockfile).catch(() => {}));
              });
              return t.createInstance(Yd, p, e).startup();
            });
          } catch (c) {
            t.invokeFunction(this.j, c);
          }
        }
        b() {
          const t = new Ch();
          const e = new De();
          process.once("exit", () => e.dispose());
          const i = {
            _serviceBrand: undefined,
            ...ko
          };
          t.set(Ve, i);
          const s = new ir(this.k(), i);
          const r = this.c(s);
          t.set(ot, s);
          const n = new Y2($x(s), s.logsHome);
          t.set(qo, n);
          const o = new H8(n.getLogLevel());
          const a = e.add(new v3(o, [new by(n.getLogLevel())]));
          t.set(V, a);
          const c = new tf(a);
          t.set(at, c);
          const l = new Ih(a);
          c.registerProvider(R.file, l);
          const u = new wl(c);
          t.set(yi, u);
          const d = new C1(1, s, a, c);
          t.set(f1, d);
          t.set(Oi, d);
          const f = new Yu(d, u, s, c, a);
          t.set(Rs, f);
          c.registerProvider(R.vscodeUserData, new b3(R.file, l, R.vscodeUserData, f, u, a));
          const p = j && i.win32RegValueName ? e.add(new gf(a, i.win32RegValueName)) : s.policyFile ? e.add(new mf(s.policyFile, c, a)) : new Ug();
          t.set(Pn, p);
          const w = new W8(f.defaultProfile.settingsResource, c, p, a);
          t.set(Je, w);
          t.set(Te, new ue(Tu, undefined, false));
          t.set(Sn, new ue(h3, undefined, true));
          t.set(Eo, new ue(ih));
          t.set(zo, new ue(f3, undefined, false));
          t.set(V8, new ue(ml));
          t.set(Wc, new rf(s, f, a));
          return [new q8(t, true), r, s, w, d, o, i, f];
        }
        c(t) {
          const e = {
            VSCODE_IPC_HOOK: t.mainIPCHandle
          };
          ["VSCODE_NLS_CONFIG", "VSCODE_PORTABLE"].forEach(i => {
            const s = process.env[i];
            if (typeof s == "string") {
              e[i] = s;
            }
          });
          Object.assign(process.env, e);
          return e;
        }
        async d(t, e, i, s, r) {
          await Tt.settled([Promise.all([this.e(t.extensionsPath), t.codeCachePath, t.logsHome.with({
            scheme: R.file
          }).fsPath, e.defaultProfile.globalStorageHome.with({
            scheme: R.file
          }).fsPath, t.workspaceStorageHome.with({
            scheme: R.file
          }).fsPath, t.localHistoryHome.with({
            scheme: R.file
          }).fsPath, t.backupHome].map(n => n ? E3.mkdir(n, {
            recursive: true
          }) : undefined)), s.init(), i.initialize()]);
          e.init();
        }
        e(t) {
          if (j) {
            const e = B0(t);
            if (e) {
              ma(e);
            }
          }
          return t;
        }
        async f(t, e, i, s, r, n) {
          let o;
          try {
            Ne("code/willStartMainServer");
            o = await Xk(e.mainIPCHandle);
            Ne("code/didStartMainServer");
            x.once(i.onWillShutdown)(() => o.dispose());
          } catch (a) {
            if (a.code !== "EADDRINUSE") {
              this.g(e, r, a);
              throw a;
            }
            let c;
            try {
              c = await Qk(e.mainIPCHandle, "main");
            } catch (f) {
              if (!n || j || f.code !== "ECONNREFUSED") {
                if (f.code === "EPERM") {
                  this.h(v(157, null, r.nameShort), v(158, null), r);
                }
                throw f;
              }
              try {
                dF(e.mainIPCHandle);
              } catch (p) {
                t.warn("Could not delete obsolete instance handle", p);
                throw p;
              }
              return this.f(t, e, i, s, r, false);
            }
            if (e.extensionTestsLocationURI && !e.debugExtensionHost.break) {
              const f = `Running extension tests from the command line is currently only supported if no other instance of ${r.nameShort} is running.`;
              t.error(f);
              c.dispose();
              throw new Error(f);
            }
            let l;
            if (!e.args.wait && !e.args.status) {
              l = setTimeout(() => {
                this.h(v(159, null, r.nameShort), v(160, null), r);
              }, 10000);
            }
            const u = ze.toService(c.getChannel("launch"), {
              disableMarshalling: true
            });
            const d = ze.toService(c.getChannel("diagnostics"), {
              disableMarshalling: true
            });
            if (e.args.status) {
              return s.invokeFunction(async () => {
                const f = new ef(Hc, r);
                const p = await d.getMainDiagnostics();
                const w = await d.getRemoteDiagnostics({
                  includeProcesses: true,
                  includeWorkspaceMetadata: true
                });
                const m = await f.getDiagnostics(p, w);
                console.log(m);
                throw new Tl();
              });
            }
            if (j) {
              await this.i(u, t);
            }
            t.trace("Sending env to running instance...");
            await u.start(e.args, process.env);
            c.dispose();
            if (l) {
              clearTimeout(l);
            }
            throw new Tl("Sent env to running instance. Terminating...");
          }
          if (e.args.status) {
            console.log(v(161, null, r.nameShort));
            throw new Tl("Terminating...");
          }
          process.env.VSCODE_PID = String(process.pid);
          return o;
        }
        g(t, e, i) {
          if (i.code === "EACCES" || i.code === "EPERM") {
            const s = $t([t.userDataPath, t.extensionsPath, bu]).map(r => to(P.file(r), {
              os: Wi,
              tildify: t
            }));
            this.h(v(162, null), v(163, null, Ki(i), s.join(`
  `)), e);
          }
        }
        h(t, e, i) {
          hF.showMessageBoxSync(r5({
            type: "warning",
            buttons: [v(164, null)],
            message: t,
            detail: e
          }, i).options);
        }
        async i(t, e) {
          if (j) {
            const i = await t.getMainProcessId();
            e.trace("Sending some foreground love to the running instance:", i);
            try {
              (await import("windows-foreground-love")).allowSetForegroundWindow(i);
            } catch (s) {
              e.error(s);
            }
          }
        }
        j(t, e) {
          const i = t.get(V);
          const s = t.get(Te);
          let r = 0;
          if (e) {
            if (e.isExpected) {
              if (e.message) {
                i.trace(e.message);
              }
            } else {
              r = 1;
              if (e.stack) {
                i.error(e.stack);
              } else {
                i.error(`Startup error: ${e.toString()}`);
              }
            }
          }
          s.kill(r);
        }
        k() {
          const t = this.l(rP(process.argv));
          if (t.wait && !t.waitMarkerFilePath) {
            const e = nM(t.verbose);
            if (e) {
              nP(process.argv, "--waitMarkerFilePath", e);
              t.waitMarkerFilePath = e;
            }
          }
          return t;
        }
        l(t) {
          if (t["open-url"]) {
            t._urls = t._;
            t._ = [];
          }
          if (!t.remote) {
            const e = this.m(t._, t.goto);
            t._ = e;
          }
          return t;
        }
        m(t, e) {
          const i = bs();
          const s = t.map(o => {
            let a = String(o);
            let c;
            if (e) {
              c = iu(a);
              a = c.path;
            }
            a &&= this.n(i, a);
            const l = Ev(a, i);
            const u = Ue(l);
            if (u && !zE(u)) {
              return null;
            } else if (e && c) {
              c.path = l;
              return this.o(c);
            } else {
              return l;
            }
          });
          const r = j || N;
          const n = ss(s, o => o && r ? o.toLowerCase() : o || "");
          return $t(n);
        }
        n(t, e) {
          if (j) {
            e = Qr(e, "\"");
          }
          e = pv(pv(e, " "), "\t");
          if (j) {
            e = Gi(t, e);
            e = Qr(e, ".");
          }
          return e;
        }
        o(t) {
          const e = [t.path];
          if (typeof t.line == "number") {
            e.push(String(t.line));
          }
          if (typeof t.column == "number") {
            e.push(String(t.column));
          }
          return e.join(":");
        }
      };
      x3 = new k3();
      x3.main();
    }
  });
  import * as lr from "path";
  import * as Wn from "original-fs";
  import * as pF from "os";
  import { performance as gF } from "perf_hooks";
  import * as Qi from "path";
  import * as D3 from "fs";
  import { fileURLToPath as mF } from "url";
  import { createRequire as wF } from "node:module";
  var bj = wF(import.meta.url);
  var vF = Qi.dirname(mF(import.meta.url));
  Error.stackTraceLimit = 100;
  if (!process.env.VSCODE_HANDLES_SIGPIPE) {
    let t = false;
    process.on("SIGPIPE", () => {
      if (!t) {
        t = true;
        console.error(new Error("Unexpected SIGPIPE"));
      }
    });
  }
  function bF() {
    try {
      if (typeof process.env.VSCODE_CWD != "string") {
        process.env.VSCODE_CWD = process.cwd();
      }
      if (process.platform === "win32") {
        process.chdir(Qi.dirname(process.execPath));
      }
    } catch (t) {
      console.error(t);
    }
  }
  bF();
  function yF(t) {
    const e = Qi.dirname(vF);
    function i() {
      if (process.env.VSCODE_DEV) {
        return e;
      } else if (process.platform === "darwin") {
        return Qi.dirname(Qi.dirname(Qi.dirname(e)));
      } else {
        return Qi.dirname(Qi.dirname(e));
      }
    }
    function s() {
      if (process.env.VSCODE_PORTABLE) {
        return process.env.VSCODE_PORTABLE;
      }
      if (process.platform === "win32" || process.platform === "linux") {
        return Qi.join(i(), "data");
      }
      const c = t.portable || `${t.applicationName}-portable-data`;
      return Qi.join(Qi.dirname(i()), c);
    }
    const r = s();
    const n = !("target" in t) && D3.existsSync(r);
    const o = Qi.join(r, "tmp");
    const a = n && D3.existsSync(o);
    if (n) {
      process.env.VSCODE_PORTABLE = r;
    } else {
      delete process.env.VSCODE_PORTABLE;
    }
    if (a) {
      if (process.platform === "win32") {
        process.env.TMP = o;
        process.env.TEMP = o;
      } else {
        process.env.TMPDIR = o;
      }
    }
    return {
      portableDataPath: r,
      isPortable: n
    };
  }
  import * as SF from "path";
  import * as h0 from "fs";
  import { fileURLToPath as EF } from "url";
  import { createRequire as kF, register as xF } from "node:module";
  import { createRequire as DF } from "node:module";
  var P3 = DF(import.meta.url);
  var d0 = {
    BUILD_INSERT_PRODUCT_CONFIGURATION: "BUILD_INSERT_PRODUCT_CONFIGURATION"
  };
  if (d0.BUILD_INSERT_PRODUCT_CONFIGURATION) {
    d0 = P3("../product.json");
  }
  var f0 = {
    name: "Cursor",
    version: "0.50.5",
    distro: "034ea95a21e3eb734fd22bf565a1e2e80d62ea9b",
    author: {
      name: "Anysphere, Inc."
    },
    engines: {
      pnpm: "please-use-npm",
      yarn: "please-use-npm",
      node: ">= 20.11.0 < 21.0.0"
    },
    main: "./out/main.js",
    type: "module",
    private: true,
    scripts: {
      test: "echo Please run any of the test scripts from the scripts folder.",
      "test-browser": "npx playwright install && node test/unit/browser/index.js",
      "test-browser-amd": "npx playwright install && node test/unit/browser/index.amd.js",
      "test-browser-no-install": "node test/unit/browser/index.js",
      "test-browser-amd-no-install": "node test/unit/browser/index.amd.js",
      "test-node": "mocha test/unit/node/index.mjs --delay --ui=tdd --timeout=5000 --exit",
      "test-node-amd": "mocha test/unit/node/index.amd.js --delay --ui=tdd --timeout=5000 --exit",
      "test-extension": "vscode-test",
      preinstall: "node build/npm/preinstall.js",
      postinstall: "patch-package && node build/npm/postinstall.js",
      "ravi-build-linux-arm64": "cross-env VSCODE_MANGLE_DISABLE=true node --max-old-space-size=8192 ./node_modules/gulp/bin/gulp.js vscode-linux-arm64-min",
      "ravi-build-linux-arm64-deb": "cross-env VSCODE_MANGLE_DISABLE=true node --max-old-space-size=8192 ./node_modules/gulp/bin/gulp.js vscode-linux-arm64-prepare-deb && node --max-old-space-size=8192 ./node_modules/gulp/bin/gulp.js vscode-linux-arm64-build-deb",
      "ravi-build-linux-x64": "cross-env VSCODE_MANGLE_DISABLE=true node --max-old-space-size=8192 ./node_modules/gulp/bin/gulp.js vscode-linux-x64-min",
      "ravi-build-linux-x64-deb": "cross-env VSCODE_MANGLE_DISABLE=true node --max-old-space-size=8192 ./node_modules/gulp/bin/gulp.js vscode-linux-x64-prepare-deb && node --max-old-space-size=8192 ./node_modules/gulp/bin/gulp.js vscode-linux-x64-build-deb",
      compile: "node --max-old-space-size=8192 ./node_modules/gulp/bin/gulp.js compile",
      "compile-extensions": "node --max-old-space-size=4095 ./node_modules/gulp/bin/gulp.js compile-extensions",
      "compile-retrieval": "node --max-old-space-size=4095 ./node_modules/gulp/bin/gulp.js compile-extension:cursor-retrieval",
      watch: "bash ./configure-product-json.sh products/product-debug.jsonc && cross-env VSCODE_DEV_CACHE=1 NODE_OPTIONS=--inspect-port=0 npm run watch-without-configuring-product-json",
      "watch-trace": "bash ./configure-product-json.sh products/product-debug.jsonc && cross-env VSCODE_DEV_CACHE=trace NODE_OPTIONS=--inspect-port=0 npm run watch-without-configuring-product-json",
      "watch-clean": "rm -rf out out-ts",
      "watch-nocache": "bash ./configure-product-json.sh products/product-debug.jsonc && cross-env NODE_OPTIONS=--inspect-port=0 npm run watch-without-configuring-product-json",
      "watch-esm": "bash ./configure-product-json.sh products/product-debug.jsonc && cross-env NODE_OPTIONS=--inspect-port=0 npm run watch-without-configuring-product-json-esm",
      "watch-nightly": "bash ./configure-product-json.sh products/product-nightly-todesktop.jsonc && cross-env VSCODE_DEV_CACHE=1 npm run watch-without-configuring-product-json",
      "watch-prod": "bash ./configure-product-json.sh products/product-prod-todesktop.jsonc && cross-env VSCODE_DEV_CACHE=1 npm run watch-without-configuring-product-json",
      "watch-prod-ssh": "bash ./configure-product-json.sh products/product-prod-sshfuzz.jsonc && cross-env VSCODE_DEV_CACHE=1 npm run watch-without-configuring-product-json",
      "watch-debug-ssh": "bash ./configure-product-json.sh products/product-debug-ssh.jsonc && cross-env VSCODE_DEV_CACHE=1 npm run watch-without-configuring-product-json",
      "watch-debug-ssh-swc": "bash ./configure-product-json.sh products/product-debug-ssh.jsonc && npm run watch-without-configuring-product-json-swc",
      "watch-prod-swc": "bash ./configure-product-json.sh products/product-prod-todesktop.jsonc && npm run watch-without-configuring-product-json-swc",
      "watch-swc": "echo 'watch-swc is banned for now because it is causing bugs that we are confusing with real bugs. it also dies more often.' && exit 1 && bash ./configure-product-json.sh products/product-debug.jsonc && npm run watch-without-configuring-product-json-swc",
      "sualeh:watch-swc": "bash ./configure-product-json.sh products/product-debug.jsonc && npm run watch-without-configuring-product-json-swc",
      "watch-windows": "cross-env VSCODE_DEV_CACHE=1 npm run buf:generate && cross-env VSCODE_DEV_CACHE=1 npm run compile-extensions && cross-env VSCODE_DEV_CACHE=1 npm-run-all -lp buf:generate watch-client watch-extensions watch-cpp-utils copy-cpp-utils watch-proto-windows",
      "watch-without-configuring-product-json": "(npm run buf:generate || echo 'failed to generate proto') && npm-run-all -lp watch-client watch-extensions watch-proto watch-rust watch-cpp-utils copy-cpp-utils watch-rcp-ts",
      "watch-without-configuring-product-json-esm": "(npm run buf:generate || echo 'failed to generate proto') && npm-run-all -lp watch-client-esm watch-extensions watch-proto watch-rust watch-cpp-utils copy-cpp-utils",
      "watch-without-configuring-product-json-swc": "(npm run buf:generate || echo 'failed to generate proto') && npm-run-all -lp watch-client-swc watch-extensions-swc watch-proto watch-rust watch-cpp-utils copy-cpp-utils",
      "watch-just-cursor-retrieval": "(npm run buf:generate || echo 'failed to generate proto') && npm-run-all -lp 'gulp watch-extension:cursor-retrieval' watch-proto",
      "watch-just-client": "(npm run buf:generate || echo 'failed to generate proto') && npm-run-all -lp 'gulp watch-just-client' watch-proto",
      "watch-proto": "nodemon --on-change-only --watch '../schema/**/*' --ext proto --exec 'bash ./scripts/buf-generate-with-error-handling.sh'",
      "watch-proto-windows": "nodemon --on-change-only --watch '../schema/**/*' --ext proto --exec 'npm run buf:generate'",
      "watch-cpp-utils": "nodemon --on-change-only --watch 'extensions/cursor-always-local/src/commands/cppUtils/**/*.ts' --ext ts --exec 'npm run copy-cpp-utils'",
      "copy-cpp-utils": "npm run copy-cpp-utils-to-renderer && npm run copy-cpp-utils-to-backend",
      "copy-cpp-utils-to-renderer": "node ../backend/server/scripts/copyCppUtils.js ./src/vs/base/common/cppUtils ./extensions/cursor-always-local/src/commands/cppUtils src/proto true",
      "copy-cpp-utils-to-backend": "node ../backend/server/scripts/copyCppUtils.js ../backend/server/src/cppUtils ./extensions/cursor-always-local/src/commands/cppUtils false true",
      "watch-rust": "cd extensions/cursor-retrieval && npm run watch:rust",
      watchd: "deemon npm run watch",
      "watch-webd": "deemon npm run watch-web",
      "kill-watchd": "deemon --kill npm run watch",
      "kill-watch-webd": "deemon --kill npm run watch-web",
      "restart-watchd": "deemon --restart npm run watch",
      "restart-watch-webd": "deemon --restart npm run watch-web",
      "watch-client": "node --max-old-space-size=8192 ./node_modules/gulp/bin/gulp.js watch-client",
      "watch-client-bun": "bun ./node_modules/gulp/bin/gulp.js watch-client",
      "watch-client-swc": "node --max-old-space-size=8192 ./node_modules/gulp/bin/gulp.js watch-client-swc",
      "watch-client-amd": "node --max-old-space-size=4095 ./node_modules/gulp/bin/gulp.js watch-client-amd",
      "watch-clientd": "deemon npm run watch-client",
      "kill-watch-clientd": "deemon --kill npm run watch-client",
      "watch-extensions": "node --max-old-space-size=8192 ./node_modules/gulp/bin/gulp.js watch-extensions watch-extension-media",
      "watch-extensions-bun": "bun ./node_modules/gulp/bin/gulp.js watch-extensions watch-extension-media",
      "watch-extensions-swc": "node --max-old-space-size=8192 -- ./node_modules/gulp/bin/gulp.js watch-extensions-swc watch-extension-media",
      "watch-extensionsd": "deemon npm run watch-extensions",
      "watch-rcp-ts": "cd cursor-rcp-ts && npm run watch",
      "kill-watch-extensionsd": "deemon --kill npm run watch-extensions",
      gulp: "node --max-old-space-size=10000 ./node_modules/gulp/bin/gulp.js",
      precommit: "node build/hygiene.js",
      electron: "node build/lib/electron",
      "7z": "7z",
      "update-grammars": "node build/npm/update-all-grammars.mjs",
      "update-localization-extension": "node build/npm/update-localization-extension.js",
      smoketest: "node build/lib/preLaunch.js && cd test/smoke && npm run compile && node test/index.js",
      "smoketest-no-compile": "cd test/smoke && node test/index.js",
      "download-builtin-extensions": "node build/lib/builtInExtensions.js",
      "download-builtin-extensions-cg": "node build/lib/builtInExtensionsCG.js",
      "monaco-compile-check": "tsc -p src/tsconfig.monaco.json --noEmit",
      "tsec-compile-check": "node --max-old-space-size=8192 node_modules/tsec/bin/tsec -p src/tsconfig.tsec.json",
      "tsec-compile-post-compile-ts": "npm run gulp precompile-tsx-only && node --max-old-space-size=8192 node_modules/tsec/bin/tsec -p out-ts2/tsconfig.tsec.json",
      "vscode-dts-compile-check": "tsc -p src/tsconfig.vscode-dts.json && tsc -p src/tsconfig.vscode-proposed-dts.json",
      "valid-layers-check": "node --max-old-space-size=4096 build/lib/layersChecker.js",
      "update-distro": "node build/npm/update-distro.mjs",
      web: "echo 'npm run web' is replaced by './scripts/code-server' or './scripts/code-web'",
      "compile-cli": "gulp compile-cli",
      "compile-web": "node ./node_modules/gulp/bin/gulp.js compile-web",
      "watch-web": "node --max-old-space-size=8192 ./node_modules/gulp/bin/gulp.js watch-web",
      "watch-cli": "node ./node_modules/gulp/bin/gulp.js watch-cli",
      eslint: "node build/eslint",
      stylelint: "node build/stylelint",
      "playwright-install": "npm exec playwright install",
      "compile-build": "node ./node_modules/gulp/bin/gulp.js compile-build",
      "compile-extensions-build": "node ./node_modules/gulp/bin/gulp.js compile-extensions-build",
      "minify-vscode": "node ./node_modules/gulp/bin/gulp.js minify-vscode",
      "minify-vscode-reh": "node ./node_modules/gulp/bin/gulp.js minify-vscode-reh",
      "minify-vscode-reh-web": "node ./node_modules/gulp/bin/gulp.js minify-vscode-reh-web",
      hygiene: "node ./node_modules/gulp/bin/gulp.js hygiene",
      "core-ci": "node ./node_modules/gulp/bin/gulp.js core-ci",
      "core-ci-pr": "node ./node_modules/gulp/bin/gulp.js core-ci-pr",
      "extensions-ci": "node ./node_modules/gulp/bin/gulp.js extensions-ci",
      "extensions-ci-pr": "node ./node_modules/gulp/bin/gulp.js extensions-ci-pr",
      perf: "node scripts/code-perf.js",
      "webview-generate-csp-hash": "npx github:apaatsio/csp-hash-from-html csp-hash ./src/vs/workbench/contrib/webview/browser/pre/index.html",
      "buf:onlygenerate": "buf generate ../schema && buf generate ../anyrun/proto",
      "buf:generate:schema": "buf generate ../schema && buf generate ../anyrun/proto",
      "buf:generate:vscode": "npm run buf:generate:schema && npm run buf:cleanpaths",
      "buf:generate:retrieval": "cd extensions/cursor-retrieval && npm run buf:generate",
      "buf:generate:experiments": "cd extensions/cursor-experiments && npm run buf:generate",
      "buf:generate:always-local": "cd extensions/cursor-always-local && npm run buf:generate",
      "buf:generate:browser": "cd extensions/cursor-browser && npm run buf:generate",
      "buf:generate:shadow-workspace": "cd extensions/cursor-shadow-workspace && npm run buf:generate",
      "buf:generate:deeplink": "cd extensions/cursor-deeplink && npm run buf:generate",
      "buf:generate": "npm-run-all -lp buf:generate:vscode buf:generate:retrieval buf:generate:experiments buf:generate:always-local buf:generate:browser buf:generate:shadow-workspace buf:generate:deeplink",
      "buf:cleanpaths": "node build/lib/cleanpaths.js src/proto",
      "update-build-ts-version": "npm install typescript@next && tsc -p ./build/tsconfig.build.json"
    },
    dependencies: {
      "@anysphere/file-service": "^0.0.0-b344d630",
      "@connectrpc/connect": "^1.6.1",
      "@connectrpc/connect-node": "^1.5.0",
      "@electron/asar": "^3.2.3",
      "@microsoft/1ds-core-js": "^3.2.13",
      "@microsoft/1ds-post-js": "^3.2.13",
      "@parcel/watcher": "2.5.0",
      "@sentry/electron": "5.7.0",
      "@sentry/node": "8.35.0",
      "@todesktop/runtime": "^1.6.1",
      "@types/semver": "^7.5.8",
      "@vscode/deviceid": "^0.1.1",
      "@vscode/iconv-lite-umd": "0.7.0",
      "@vscode/policy-watcher": "^1.1.8",
      "@vscode/proxy-agent": "^0.27.0",
      "@vscode/ripgrep": "^1.15.10",
      "@vscode/spdlog": "^0.15.1",
      "@vscode/sqlite3": "5.1.8-vscode",
      "@vscode/sudo-prompt": "9.3.1",
      "@vscode/tree-sitter-wasm": "^0.0.4",
      "@vscode/vscode-languagedetection": "1.0.21",
      "@vscode/windows-mutex": "^0.5.0",
      "@vscode/windows-process-tree": "^0.6.0",
      "@vscode/windows-registry": "^1.1.0",
      "@xterm/addon-clipboard": "^0.2.0-beta.53",
      "@xterm/addon-image": "^0.9.0-beta.70",
      "@xterm/addon-ligatures": "^0.10.0-beta.70",
      "@xterm/addon-search": "^0.16.0-beta.70",
      "@xterm/addon-serialize": "^0.14.0-beta.70",
      "@xterm/addon-unicode11": "^0.9.0-beta.70",
      "@xterm/addon-webgl": "^0.19.0-beta.70",
      "@xterm/headless": "^5.6.0-beta.70",
      "@xterm/xterm": "^5.6.0-beta.70",
      archiver: "^7.0.1",
      "fast-jwt": "^6.0.1",
      "http-proxy-agent": "^7.0.0",
      "https-proxy-agent": "^7.0.2",
      jschardet: "3.1.4",
      kerberos: "2.1.1",
      minimist: "^1.2.6",
      multiformats: "^13.3.1",
      "native-is-elevated": "0.7.0",
      "native-keymap": "^3.3.5",
      "native-watchdog": "^1.4.1",
      "node-fetch": "2.7.0",
      "node-pty": "1.1.0-beta22",
      open: "^8.4.2",
      "tas-client-umd": "0.2.0",
      "v8-inspect-profiler": "^0.1.1",
      "vscode-oniguruma": "1.7.0",
      "vscode-regexpp": "^3.1.0",
      "vscode-textmate": "9.1.0",
      yauzl: "^3.0.0",
      yazl: "^2.4.3"
    },
    devDependencies: {
      "@babel/plugin-proposal-decorators": "^7.21.0",
      "@babel/plugin-proposal-explicit-resource-management": "^7.25.9",
      "@babel/plugin-syntax-decorators": "^7.21.0",
      "@babel/plugin-syntax-explicit-resource-management": "^7.25.9",
      "@babel/plugin-syntax-jsx": "^7.18.6",
      "@babel/plugin-syntax-typescript": "^7.20.0",
      "@bufbuild/buf": "^1.47.2",
      "@bufbuild/protoc-gen-connect-web": "^0.11.0",
      "@bufbuild/protoc-gen-es": "^1.10.0",
      "@bufbuild/protoplugin": "^2.2.5",
      "@playwright/test": "^1.46.1",
      "@sentry/cli": "^2.39.1",
      "@solid-devtools/overlay": "^0.33.0",
      "@stylistic/eslint-plugin-ts": "^2.8.0",
      "@swc/core": "^1.3.85",
      "@types/archiver": "^6.0.3",
      "@types/cookie": "^0.3.3",
      "@types/debug": "^4.1.5",
      "@types/eslint": "^9.6.1",
      "@types/gulp-svgmin": "^1.2.1",
      "@types/http-proxy-agent": "^2.0.1",
      "@types/kerberos": "^1.1.2",
      "@types/minimist": "^1.2.1",
      "@types/mocha": "^9.1.1",
      "@types/node": "20.x",
      "@types/sinon": "^10.0.2",
      "@types/sinon-test": "^2.4.2",
      "@types/tmp": "^0.2.3",
      "@types/trusted-types": "^1.0.6",
      "@types/vscode-notebook-renderer": "^1.72.0",
      "@types/webpack": "^5.28.5",
      "@types/wicg-file-system-access": "^2020.9.6",
      "@types/windows-foreground-love": "^0.3.0",
      "@types/winreg": "^1.2.30",
      "@types/yauzl": "^2.10.0",
      "@types/yazl": "^2.4.2",
      "@typescript-eslint/typescript-estree": "^8.19.0",
      "@typescript-eslint/utils": "^8.8.0",
      "@vscode/gulp-electron": "^1.36.0",
      "@vscode/l10n-dev": "0.0.35",
      "@vscode/telemetry-extractor": "^1.10.2",
      "@vscode/test-cli": "^0.0.6",
      "@vscode/test-electron": "^2.4.0",
      "@vscode/test-web": "^0.0.62",
      "@vscode/v8-heap-parser": "^0.1.0",
      "@vscode/vscode-perf": "^0.0.19",
      "@webgpu/types": "^0.1.44",
      "ansi-colors": "^3.2.3",
      asar: "^3.0.3",
      autoprefixer: "^10.4.20",
      "babel-plugin-parameter-decorator": "^1.0.16",
      "babel-preset-solid": "^1.7.4",
      "chokidar-cli": "^3.0.0",
      "chromium-pickle-js": "^0.2.0",
      cookie: "^0.7.2",
      "copy-webpack-plugin": "^11.0.0",
      "cross-env": "^7.0.3",
      "css-loader": "^6.9.1",
      cssnano: "^6.0.3",
      debounce: "^1.0.0",
      deemon: "^1.8.0",
      electron: "34.3.4",
      eslint: "^9.17.0",
      "eslint-config-prettier": "^6.15.0",
      "eslint-formatter-compact": "^8.40.0",
      "eslint-plugin-header": "3.1.1",
      "eslint-plugin-import": "^2.31.0",
      "eslint-plugin-jsdoc": "^50.3.1",
      "eslint-plugin-local": "^6.0.0",
      "eslint-plugin-no-null": "^1.0.2",
      "eslint-plugin-no-only-tests": "^2.6.0",
      "eslint-plugin-prefer-arrow": "^1.2.2",
      "eslint-plugin-prettier": "^3.1.2",
      "eslint-plugin-react": "^7.37.3",
      "eslint-plugin-react-hooks": "^5.1.0",
      "eslint-plugin-solid": "^0.14.5",
      "eslint-plugin-unused-imports": "^4.1.4",
      "event-stream": "3.3.4",
      "fancy-log": "^1.3.3",
      "fast-glob": "^3.3.2",
      "file-loader": "^6.2.0",
      glob: "^5.0.13",
      gulp: "^4.0.0",
      "gulp-azure-storage": "^0.12.1",
      "gulp-bom": "^3.0.0",
      "gulp-buffer": "0.0.2",
      "gulp-clone": "^2.0.1",
      "gulp-concat": "^2.6.1",
      "gulp-filter": "^5.1.0",
      "gulp-flatmap": "^1.0.2",
      "gulp-gunzip": "^1.0.0",
      "gulp-gzip": "^1.4.2",
      "gulp-json-editor": "^2.5.0",
      "gulp-plumber": "^1.2.0",
      "gulp-rename": "^1.2.0",
      "gulp-replace": "^1.1.4",
      "gulp-sourcemaps": "^3.0.0",
      "gulp-svgmin": "^4.1.0",
      "gulp-untar": "^0.0.7",
      "gulp-vinyl-zip": "^2.1.2",
      "http-server": "^14.1.1",
      innosetup: "6.0.5",
      "istanbul-lib-coverage": "^3.2.0",
      "istanbul-lib-instrument": "^6.0.1",
      "istanbul-lib-report": "^3.0.0",
      "istanbul-lib-source-maps": "^4.0.1",
      "istanbul-reports": "^3.1.5",
      "lazy.js": "^0.4.2",
      "merge-options": "^1.0.1",
      mime: "^1.4.1",
      minimatch: "^3.0.4",
      minimist: "^1.2.6",
      mocha: "^10.2.0",
      "mocha-junit-reporter": "^2.2.1",
      "mocha-multi-reporters": "^1.5.1",
      nodemon: "^2.0.22",
      "npm-run-all": "^4.1.5",
      opn: "^6.0.0",
      "os-browserify": "^0.3.0",
      "p-all": "^1.0.0",
      "patch-package": "^8.0.0",
      "path-browserify": "^1.0.1",
      postcss: "^8.4.33",
      "postcss-nesting": "^12.0.2",
      prettier: "^3.3.3",
      pump: "^1.0.1",
      rcedit: "^1.1.0",
      rimraf: "^2.2.8",
      sinon: "^12.0.1",
      "sinon-test": "^3.1.3",
      "solid-devtools": "^0.33.0",
      "solid-refresh": "^0.7.5",
      "source-map": "0.6.1",
      "source-map-support": "^0.3.2",
      "strip-json-comments-cli": "^3.0.0",
      "style-loader": "^3.3.2",
      tailwindcss: "^3.4.17",
      "ts-loader": "^9.5.1",
      "ts-node": "^10.9.1",
      tsec: "0.2.7",
      tslib: "^2.6.3",
      typescript: "5.8.0-dev.20241202",
      "typescript-eslint": "^8.8.0",
      util: "^0.12.4",
      vite: "^6.0.7",
      webpack: "^5.94.0",
      "webpack-cli": "^5.1.4",
      "webpack-stream": "^7.0.0",
      xml2js: "^0.5.0",
      yaserver: "^0.4.0"
    },
    overrides: {
      "typescript-eslint": {
        typescript: "$typescript"
      },
      "@typescript-eslint/typescript-estree": {
        typescript: "$typescript"
      },
      "@typescript-eslint/utils": {
        typescript: "$typescript"
      },
      tsec: {
        typescript: "$typescript"
      },
      "eslint-config-airbnb": {
        eslint: "$eslint"
      },
      "ts-node": {
        typescript: "$typescript"
      },
      "eslint-plugin-solid": {
        typescript: "$typescript"
      },
      "node-gyp-build": "4.8.4",
      diff: "^5.2.0",
      "@parcel/watcher": "2.5.0",
      "kerberos@2.1.1": {
        "node-addon-api": "7.1.0"
      },
      "@parcel/watcher@2.5.0": {
        "node-addon-api": "7.1.0"
      }
    },
    repository: {
      type: "git",
      url: "https://github.com/microsoft/vscode.git"
    },
    bugs: {
      url: "https://github.com/microsoft/vscode/issues"
    },
    optionalDependencies: {
      "@vscode/windows-ca-certs": "^0.3.3",
      "windows-foreground-love": "0.5.0"
    }
  };
  if (f0.BUILD_INSERT_PACKAGE_CONFIGURATION) {
    f0 = P3("../package.json");
  }
  var li = d0;
  var PF = f0;
  Hs();
  var $F = kF(import.meta.url);
  var IF = SF.dirname(EF(import.meta.url));
  if (process.env.ELECTRON_RUN_AS_NODE || process.versions.electron) {
    xF(`data:text/javascript;base64,${Buffer.from(`
      export async function resolve(specifier, context, nextResolve) {
          if (specifier === 'fs') {
              return {
                  format: 'builtin',
                  shortCircuit: true,
                  url: 'node:original-fs'
              };
          }
  
          // Defer to the next hook in the chain, which would be the
          // Node.js default resolve if this is the last user-specified loader.
          return nextResolve(specifier, context);
      }`).toString("base64")}`, import.meta.url);
  }
  globalThis._VSCODE_PRODUCT_JSON = {
    ...li
  };
  if (process.env.VSCODE_DEV) {
    try {
      const t = $F("../product.overrides.json");
      globalThis._VSCODE_PRODUCT_JSON = Object.assign(globalThis._VSCODE_PRODUCT_JSON, t);
    } catch {}
  }
  globalThis._VSCODE_PACKAGE_JSON = {
    ...PF
  };
  globalThis._VSCODE_FILE_ROOT = IF;
  var p0 = undefined;
  function AF() {
    p0 ||= CF();
    return p0;
  }
  async function CF() {
    Ne("code/willLoadNls");
    let t;
    let e;
    if (process.env.VSCODE_NLS_CONFIG) {
      try {
        t = JSON.parse(process.env.VSCODE_NLS_CONFIG);
        if (t?.languagePack?.messagesFile) {
          e = t.languagePack.messagesFile;
        } else if (t?.defaultMessagesFile) {
          e = t.defaultMessagesFile;
        }
        globalThis._VSCODE_NLS_LANGUAGE = t?.resolvedLanguage;
      } catch (i) {
        console.error(`Error reading VSCODE_NLS_CONFIG from environment: ${i}`);
      }
    }
    if (!process.env.VSCODE_DEV && !!e) {
      try {
        globalThis._VSCODE_NLS_MESSAGES = JSON.parse((await h0.promises.readFile(e)).toString());
      } catch (i) {
        console.error(`Error reading NLS messages file ${e}: ${i}`);
        if (t?.languagePack?.corruptMarkerFile) {
          try {
            await h0.promises.writeFile(t.languagePack.corruptMarkerFile, "corrupted");
          } catch (s) {
            console.error(`Error writing corrupted NLS marker file: ${s}`);
          }
        }
        if (t?.defaultMessagesFile && t.defaultMessagesFile !== e) {
          try {
            globalThis._VSCODE_NLS_MESSAGES = JSON.parse((await h0.promises.readFile(t.defaultMessagesFile)).toString());
          } catch (s) {
            console.error(`Error reading default NLS messages file ${t.defaultMessagesFile}: ${s}`);
          }
        }
      }
      Ne("code/didLoadNls");
      return t;
    }
  }
  async function _F() {
    await AF();
  }
  var RF = R0(O0(), 1);
  import { fileURLToPath as OF } from "url";
  import { app as Ae, protocol as LF, crashReporter as MF, Menu as FF, contentTracing as NF } from "electron";
  import { networkInterfaces as WF } from "os";
  import { createHash as TF, randomUUID as jF } from "crypto";
  import "node-fetch";
  var UF = new Set(["00:00:00:00:00:00", "ff:ff:ff:ff:ff:ff", "ac:de:48:00:11:22"]);
  function BF(t) {
    const e = t.replace(/\-/g, ":").toLowerCase();
    return !UF.has(e);
  }
  function qF() {
    const t = WF();
    for (const e in t) {
      const i = t[e];
      if (i) {
        for (const {
          mac: s
        } of i) {
          if (BF(s)) {
            return s;
          }
        }
      }
    }
    throw new Error("Unable to retrieve mac address (unexpected format)");
  }
  function zF(t) {
    try {
      const e = qF();
      return TF("sha256").update(e, "utf8").digest("hex");
    } catch (e) {
      t(e);
      return jF();
    }
  }
  F0();
  j0();
  Hs();
  Hs();
  import * as Ws from "path";
  import * as Ts from "fs";
  async function $3({
    userLocale: t,
    osLocale: e,
    userDataPath: i,
    commit: s,
    nlsMetadataPath: r
  }) {
    Ne("code/willGenerateNls");
    if (process.env.VSCODE_DEV || t === "pseudo" || t.startsWith("en") || !s || !i) {
      return vl(t, e, r);
    }
    try {
      const n = await HF(i);
      if (!n) {
        return vl(t, e, r);
      }
      const o = VF(n, t);
      if (!o) {
        return vl(t, e, r);
      }
      const a = n[o];
      const c = a?.translations?.vscode;
      if (!a || typeof a.hash != "string" || !a.translations || typeof c != "string" || !(await g0(c))) {
        return vl(t, e, r);
      }
      const l = `${a.hash}.${o}`;
      const u = Ws.join(i, "clp", l);
      const d = Ws.join(u, s);
      const f = Ws.join(d, "nls.messages.json");
      const p = Ws.join(u, "tcf.json");
      const w = Ws.join(u, "corrupted.info");
      if (await g0(w)) {
        await Ts.promises.rm(u, {
          recursive: true,
          force: true,
          maxRetries: 3
        });
      }
      const m = {
        userLocale: t,
        osLocale: e,
        resolvedLanguage: o,
        defaultMessagesFile: Ws.join(r, "nls.messages.json"),
        languagePack: {
          translationsConfigFile: p,
          messagesFile: f,
          corruptMarkerFile: w
        },
        locale: t,
        availableLanguages: {
          "*": o
        },
        _languagePackId: l,
        _languagePackSupport: true,
        _translationsConfigFile: p,
        _cacheRoot: u,
        _resolvedLanguagePackCoreLocation: d,
        _corruptedFile: w
      };
      if (await g0(d)) {
        GF(d).catch(() => {});
        Ne("code/didGenerateNls");
        return m;
      }
      const [, y, b, k] = await Promise.all([Ts.promises.mkdir(d, {
        recursive: true
      }), JSON.parse(await Ts.promises.readFile(Ws.join(r, "nls.keys.json"), "utf-8")), JSON.parse(await Ts.promises.readFile(Ws.join(r, "nls.messages.json"), "utf-8")), JSON.parse(await Ts.promises.readFile(c, "utf-8"))]);
      const A = [];
      let C = 0;
      for (const [_, Z] of y) {
        const ie = k.contents[_];
        for (const me of Z) {
          A.push(ie?.[me] || b[C]);
          C++;
        }
      }
      await Promise.all([Ts.promises.writeFile(f, JSON.stringify(A), "utf-8"), Ts.promises.writeFile(p, JSON.stringify(a.translations), "utf-8")]);
      Ne("code/didGenerateNls");
      return m;
    } catch (n) {
      console.error("Generating translation files failed.", n);
    }
    return vl(t, e, r);
  }
  async function HF(t) {
    const e = Ws.join(t, "languagepacks.json");
    try {
      return JSON.parse(await Ts.promises.readFile(e, "utf-8"));
    } catch {
      return;
    }
  }
  function VF(t, e) {
    try {
      while (e) {
        if (t[e]) {
          return e;
        }
        const i = e.lastIndexOf("-");
        if (i > 0) {
          e = e.substring(0, i);
        } else {
          return;
        }
      }
    } catch (i) {
      console.error("Resolving language pack configuration failed.", i);
    }
  }
  function vl(t, e, i) {
    Ne("code/didGenerateNls");
    return {
      userLocale: t,
      osLocale: e,
      resolvedLanguage: "en",
      defaultMessagesFile: Ws.join(i, "nls.messages.json"),
      locale: t,
      availableLanguages: {}
    };
  }
  async function g0(t) {
    try {
      await Ts.promises.access(t);
      return true;
    } catch {
      return false;
    }
  }
  function GF(t) {
    const e = new Date();
    return Ts.promises.utimes(t, e, e);
  }
  wa();
  import { createRequire as JF } from "module";
  va();
  import * as Ni from "@sentry/electron/main";
  import KF from "electron";
  function ZF() {
    try {
      Ni.init({
        ...MS(),
        environment: KF.app.isPackaged ? globalThis._VSCODE_PRODUCT_JSON.applicationName : "development",
        integrations: [Ni.sentryMinidumpIntegration(), Ni.electronContextIntegration(), Ni.normalizePathsIntegration(), Ni.additionalContextIntegration(), Ni.inboundFiltersIntegration(), Ni.functionToStringIntegration(), Ni.linkedErrorsIntegration(), Ni.dedupeIntegration(), Ni.nodeContextIntegration({
          cloudResource: false
        }), Ni.mainProcessSessionIntegration({
          sendOnCreate: true
        })],
        beforeSend: t => {
          Ni.startSpan({
            name: "error-span",
            attributes: {
              "error.message": t.message,
              "error.trace_id": t.contexts?.trace?.trace_id,
              "error.event_id": t.event_id
            }
          }, () => {});
          return t;
        }
      });
      qt().sentry = Ni;
      process.env.CURSOR_TRACE_ID = Ni.getCurrentScope().getPropagationContext().traceId;
    } catch (t) {
      console.error("Failed to initialize tracing in main process", t);
    }
  }
  ZF();
  var _j = JF(import.meta.url);
  var m0 = lr.dirname(OF(import.meta.url));
  Ne("code/didStartMain");
  Ne("code/willLoadMainBundle", {
    startTime: Math.floor(gF.timeOrigin)
  });
  Ne("code/didLoadMainBundle");
  var I3 = yF(li);
  var Rj = zF(console.error);
  var Oj = li.dataFolderName ?? ".cursor";
  var Bi = rN();
  var vf = XF(Bi);
  if (Bi.sandbox && !Bi["disable-chromium-sandbox"] && !vf["disable-chromium-sandbox"]) {
    Ae.enableSandbox();
  } else if (Ae.commandLine.hasSwitch("no-sandbox") && !Ae.commandLine.hasSwitch("disable-gpu-sandbox")) {
    Ae.commandLine.appendSwitch("disable-gpu-sandbox");
  } else {
    Ae.commandLine.appendSwitch("no-sandbox");
    Ae.commandLine.appendSwitch("disable-gpu-sandbox");
  }
  Ae.commandLine.appendSwitch("force-gpu-mem-available-mb", "1024");
  var ua = W0(Bi, li.nameShort ?? "code-oss-dev");
  if (process.platform === "win32") {
    const t = B0(ua);
    if (t) {
      ma(t);
    }
  }
  Ae.setPath("userData", ua);
  var A3 = oN();
  FF.setApplicationMenu(null);
  Ne("code/willStartCrashReporter");
  if (Bi["crash-reporter-directory"] || vf["enable-crash-reporter"] && !Bi["disable-crash-reporter"]) {
    iN();
  }
  Ne("code/didStartCrashReporter");
  if (I3 && I3.isPortable) {
    Ae.setAppLogsPath(lr.join(ua, "logs"));
  }
  LF.registerSchemesAsPrivileged([{
    scheme: "vscode-webview",
    privileges: {
      standard: true,
      secure: true,
      supportFetchAPI: true,
      corsEnabled: true,
      allowServiceWorkers: true,
      codeCache: true
    }
  }, {
    scheme: "vscode-file",
    privileges: {
      secure: true,
      standard: true,
      supportFetchAPI: true,
      corsEnabled: true,
      codeCache: true
    }
  }]);
  nN();
  var w0 = undefined;
  var v0 = _3((Ae.getPreferredSystemLanguages()?.[0] ?? "en").toLowerCase());
  var bl = lN(vf);
  if (bl) {
    w0 = $3({
      userLocale: bl,
      osLocale: v0,
      commit: li.commit,
      userDataPath: ua,
      nlsMetadataPath: m0
    });
  }
  if (process.platform === "win32" || process.platform === "linux") {
    const t = !bl || bl === "qps-ploc" ? "en" : bl;
    Ae.commandLine.appendSwitch("lang", t);
  }
  Ae.once("ready", function () {
    if (Bi.trace) {
      let t;
      if (Bi["trace-memory-infra"]) {
        const e = Bi["trace-category-filter"]?.split(",") || [];
        e.push("disabled-by-default-memory-infra", "disabled-by-default-memory-infra.v8.code_stats");
        t = {
          included_categories: e,
          excluded_categories: ["*"],
          memory_dump_config: {
            allowed_dump_modes: ["light", "detailed"],
            triggers: [{
              type: "periodic_interval",
              mode: "detailed",
              min_time_between_dumps_ms: 10000
            }, {
              type: "periodic_interval",
              mode: "light",
              min_time_between_dumps_ms: 1000
            }]
          }
        };
      } else {
        t = {
          categoryFilter: Bi["trace-category-filter"] || "*",
          traceOptions: Bi["trace-options"] || "record-until-full,enable-sampling"
        };
      }
      NF.startRecording(t).finally(() => C3());
    } else {
      C3();
    }
  });
  async function C3() {
    Ne("code/mainAppReady");
    try {
      const [, t] = await Promise.all([aN(A3), cN()]);
      await YF(A3, t);
    } catch (t) {
      console.error(t);
    }
  }
  async function YF(t, e) {
    process.env.VSCODE_NLS_CONFIG = JSON.stringify(e);
    process.env.VSCODE_CODE_CACHE_PATH = t || "";
    await _F();
    await Promise.resolve().then(() => {
      fF();
      return lF;
    });
    Ne("code/didRunMainBundle");
  }
  function XF(t) {
    const e = ["disable-hardware-acceleration", "force-color-profile", "disable-lcd-text", "proxy-bypass-list"];
    if (process.platform === "linux") {
      e.push("force-renderer-accessibility");
      e.push("password-store");
    }
    const i = ["enable-proposed-api", "log-level", "use-inmemory-secretstorage"];
    const s = QF();
    Object.keys(s).forEach(c => {
      const l = s[c];
      if (e.indexOf(c) !== -1) {
        if (l === true || l === "true") {
          if (c === "disable-hardware-acceleration") {
            Ae.disableHardwareAcceleration();
          } else {
            Ae.commandLine.appendSwitch(c);
          }
        } else if (typeof l == "string" && l) {
          if (c === "password-store") {
            let u = l;
            if (l === "gnome" || l === "gnome-keyring") {
              u = "gnome-libsecret";
            }
            Ae.commandLine.appendSwitch(c, u);
          } else {
            Ae.commandLine.appendSwitch(c, l);
          }
        }
      } else if (i.indexOf(c) !== -1) {
        switch (c) {
          case "enable-proposed-api":
            if (Array.isArray(l)) {
              l.forEach(u => u && typeof u == "string" && process.argv.push("--enable-proposed-api", u));
            } else {
              console.error("Unexpected value for `enable-proposed-api` in argv.json. Expected array of extension ids.");
            }
            break;
          case "log-level":
            if (typeof l == "string") {
              process.argv.push("--log", l);
            } else if (Array.isArray(l)) {
              for (const u of l) {
                process.argv.push("--log", u);
              }
            }
            break;
          case "use-inmemory-secretstorage":
            if (l) {
              process.argv.push("--use-inmemory-secretstorage");
            }
            break;
        }
      }
    });
    const r = `DocumentPolicyIncludeJSCallStacksInCrashReports, ${Ae.commandLine.getSwitchValue("enable-features")}`;
    Ae.commandLine.appendSwitch("enable-features", r);
    const n = `CalculateNativeWinOcclusion,PlzDedicatedWorker,${Ae.commandLine.getSwitchValue("disable-features")}`;
    Ae.commandLine.appendSwitch("disable-features", n);
    const o = `FontMatchingCTMigration,StandardizedBrowserZoom,${Ae.commandLine.getSwitchValue("disable-blink-features")}`;
    Ae.commandLine.appendSwitch("disable-blink-features", o);
    const a = sN(t);
    if (a) {
      Ae.commandLine.appendSwitch("js-flags", a);
    }
    Ae.commandLine.appendSwitch("xdg-portal-required-version", "4");
    return s;
  }
  function QF() {
    const t = tN();
    let e;
    try {
      e = L0(Wn.readFileSync(t).toString());
    } catch (i) {
      if (i && i.code === "ENOENT") {
        eN(t);
      } else {
        console.warn(`Unable to read argv.json configuration file in ${t}, falling back to defaults (${i})`);
      }
    }
    e ||= {};
    return e;
  }
  function eN(t) {
    try {
      const e = lr.dirname(t);
      if (!Wn.existsSync(e)) {
        Wn.mkdirSync(e);
      }
      const i = ["// This configuration file allows you to pass permanent command line arguments to VS Code.", "// Only a subset of arguments is currently supported to reduce the likelihood of breaking", "// the installation.", "//", "// PLEASE DO NOT CHANGE WITHOUT UNDERSTANDING THE IMPACT", "//", "// NOTE: Changing this file requires a restart of VS Code.", "{", "\t// Use software rendering instead of hardware accelerated rendering.", "\t// This can help in cases where you see rendering issues in VS Code.", "\t// \"disable-hardware-acceleration\": true", "}"];
      Wn.writeFileSync(t, i.join(`
  `));
    } catch (e) {
      console.error(`Unable to create argv.json configuration file in ${t}, falling back to defaults (${e})`);
    }
  }
  function tN() {
    const t = process.env.VSCODE_PORTABLE;
    if (t) {
      return lr.join(t, "argv.json");
    }
    let e = li.dataFolderName;
    if (process.env.VSCODE_DEV) {
      e = `${e}-dev`;
    }
    return lr.join(pF.homedir(), e, "argv.json");
  }
  function iN() {
    let t = Bi["crash-reporter-directory"];
    let e = "";
    if (t) {
      t = lr.normalize(t);
      if (!lr.isAbsolute(t)) {
        console.error(`The path '${t}' specified for --crash-reporter-directory must be absolute.`);
        Ae.exit(1);
      }
      if (!Wn.existsSync(t)) {
        try {
          Wn.mkdirSync(t, {
            recursive: true
          });
        } catch {
          console.error(`The path '${t}' specified for --crash-reporter-directory does not seem to exist or cannot be created.`);
          Ae.exit(1);
        }
      }
      console.log(`Found --crash-reporter-directory argument. Setting crashDumps directory to be '${t}'`);
      Ae.setPath("crashDumps", t);
    } else {
      const r = li.appCenter;
      if (r) {
        const n = process.platform === "win32";
        const o = process.platform === "linux";
        const a = process.platform === "darwin";
        const c = vf["crash-reporter-id"];
        if (c && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(c)) {
          if (n) {
            switch (process.arch) {
              case "x64":
                e = r["win32-x64"];
                break;
              case "arm64":
                e = r["win32-arm64"];
                break;
            }
          } else if (a) {
            if (li.darwinUniversalAssetId) {
              e = r["darwin-universal"];
            } else {
              switch (process.arch) {
                case "x64":
                  e = r.darwin;
                  break;
                case "arm64":
                  e = r["darwin-arm64"];
                  break;
              }
            }
          } else if (o) {
            e = r["linux-x64"];
          }
          e = e.concat("&uid=", c, "&iid=", c, "&sid=", c);
          const u = process.argv;
          const d = u.indexOf("--");
          if (d === -1) {
            u.push("--crash-reporter-id", c);
          } else {
            u.splice(d, 0, "--crash-reporter-id", c);
          }
        }
      }
    }
    const i = (li.crashReporter ? li.crashReporter.productName : undefined) || li.nameShort;
    const s = (li.crashReporter ? li.crashReporter.companyName : undefined) || "Anysphere";
    MF.start({
      companyName: s,
      productName: process.env.VSCODE_DEV ? `${i} Dev` : i,
      submitURL: e,
      uploadToServer: false,
      ignoreSystemCrashHandler: false,
      extra: {
        platform: process.platform
      },
      compress: true
    });
  }
  function sN(t) {
    const e = [];
    if (t["js-flags"]) {
      e.push(t["js-flags"]);
    }
    if (e.length > 0) {
      return e.join(" ");
    } else {
      return null;
    }
  }
  function rN() {
    return (0, RF.default)(process.argv, {
      string: ["user-data-dir", "locale", "js-flags", "crash-reporter-directory"],
      boolean: ["disable-chromium-sandbox"],
      default: {
        sandbox: true
      },
      alias: {
        "no-sandbox": "sandbox"
      }
    });
  }
  function nN() {
    const t = [];
    globalThis.macOpenFiles = t;
    Ae.on("open-file", function (s, r) {
      t.push(r);
    });
    const e = [];
    const i = function (s, r) {
      s.preventDefault();
      e.push(r);
    };
    Ae.on("will-finish-launching", function () {
      if (process.platform === "darwin" && process.env.VSCODE_DEV) {
        const s = li.urlProtocol;
        if (s) {
          if (!Ae.isDefaultProtocolClient(s) && !Ae.setAsDefaultProtocolClient(s, process.execPath, [])) {
            console.error(`Failed to register '${s}' protocol handler.`);
          }
        } else {
          console.warn("No urlProtocol found in product configuration for development registration.");
        }
      }
      Ae.on("open-url", i);
    });
    globalThis.getOpenUrls = function () {
      Ae.removeListener("open-url", i);
      return e;
    };
  }
  function oN() {
    if (process.argv.indexOf("--no-cached-data") > 0 || process.env.VSCODE_DEV) {
      return;
    }
    const t = li.commit;
    if (t) {
      return lr.join(ua, "CachedData", t);
    }
  }
  async function aN(t) {
    if (typeof t == "string") {
      try {
        await Wn.promises.mkdir(t, {
          recursive: true
        });
        return t;
      } catch {}
    }
  }
  function _3(t) {
    if (t.startsWith("zh")) {
      const e = t.split("-")[1];
      if (["hans", "cn", "sg", "my"].includes(e)) {
        return "zh-cn";
      } else {
        return "zh-tw";
      }
    }
    return t;
  }
  async function cN() {
    const t = w0 ? await w0 : undefined;
    if (t) {
      return t;
    }
    let e = Ae.getLocale();
    if (e) {
      e = _3(e.toLowerCase());
      return $3({
        userLocale: e,
        osLocale: v0,
        commit: li.commit,
        userDataPath: ua,
        nlsMetadataPath: m0
      });
    } else {
      return {
        userLocale: "en",
        osLocale: v0,
        resolvedLanguage: "en",
        defaultMessagesFile: lr.join(m0, "nls.messages.json"),
        locale: "en",
        availableLanguages: {}
      };
    }
  }
  function lN(t) {
    const e = Bi.locale;
    if (e) {
      return e.toLowerCase();
    } else if (typeof t?.locale == "string") {
      return t.locale.toLowerCase();
    } else {
      return undefined;
    }
  }
  
  //# sourceMappingURL=https://cursor-sourcemaps.s3.amazonaws.com/sourcemaps/96e5b01ca25f8fbd4c4c10bc69b15f6228c80770/core/main.js.map
  
  //# debugId=61209153-73c8-5a0b-b208-7e2f4a87ff8d